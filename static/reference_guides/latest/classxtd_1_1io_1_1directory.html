<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::io::directory Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classxtd_1_1io_1_1directory.html">directory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classxtd_1_1io_1_1directory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::io::directory Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">﹡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__io.html">io</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::io::directory:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1io_1_1directory.png" usemap="#xtd::io::directory_map" alt=""/>
  <map id="xtd::io::directory_map" name="xtd::io::directory_map">
<area href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted)." alt="xtd::static_object" shape="rect" coords="0,0,104,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Exposes static methods for creating, moving, and enumerating through directories and subdirectories. This class cannot be inherited. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_class" href="classxtd_1_1io_1_1directory.html">directory</a> <a class="code hl_define" href="group__keywords.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div>
<div class="ttc" id="aclassxtd_1_1io_1_1directory_html"><div class="ttname"><a href="classxtd_1_1io_1_1directory.html">xtd::io::directory</a></div><div class="ttdoc">Exposes static methods for creating, moving, and enumerating through directories and subdirectories....</div><div class="ttdef"><b>Definition</b> directory.hpp:101</div></div>
<div class="ttc" id="agroup__keywords_html_ga28796443ec37b938df7072c79595e3f6"><div class="ttname"><a href="group__keywords.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div><div class="ttdeci">#define static_</div><div class="ttdoc">This keyword is use to represent a static object. A static object can't be instantiated (constructors...</div><div class="ttdef"><b>Definition</b> static.hpp:37</div></div>
<div class="ttc" id="agroup__keywords_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.hpp:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted).">xtd::static_object</a> → <a class="el" href="classxtd_1_1io_1_1directory.html" title="Exposes static methods for creating, moving, and enumerating through directories and subdirectories....">xtd::io::directory</a> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/io/directory&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1io.html" title="The xtd::io namespace contains types that allow reading and writing to files and data streams,...">xtd::io</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example shows how to retrieve all the text files from a directory and move them to a new directory. After the files are moved, they no longer exist in the original directory. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1io.html">xtd::io</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>program {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() {</div>
<div class="line">    <span class="keywordtype">string</span> source_directory = R<span class="stringliteral">&quot;(C:\current)&quot;;</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keywordtype">string</span> archive_directory = R<span class="stringliteral">&quot;(C:\archive)&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">      <span class="keyword">auto</span> txt_files = directory::enumerate_files(source_directory, <span class="stringliteral">&quot;*.txt&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">string</span> current_file : txt_files) {</div>
<div class="line">        <span class="keywordtype">string</span> file_name = current_file.substring(source_directory.<a class="code hl_function" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853">size</a>() + 1);</div>
<div class="line">        directory::move(current_file, path::combine(archive_directory, file_name));</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code hl_class" href="classxtd_1_1exception.html">exception</a>&amp; e) {</div>
<div class="line">      console::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.message());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(program::main);</div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_aa6e7750375addd424e2684f5f7f88853"><div class="ttname"><a href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853">xtd::basic_string::size</a></div><div class="ttdeci">size_type size() const noexcept</div><div class="ttdoc">Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).</div><div class="ttdef"><b>Definition</b> basic_string.hpp:926</div></div>
<div class="ttc" id="aclassxtd_1_1exception_html"><div class="ttname"><a href="classxtd_1_1exception.html">xtd::exception</a></div><div class="ttdoc">Defines the base class for predefined exceptions in the xtd namespace.</div><div class="ttdef"><b>Definition</b> exception.hpp:28</div></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.hpp:175</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">xtd::console_key::e</a></div><div class="ttdeci">@ e</div><div class="ttdoc">The E key.</div></div>
<div class="ttc" id="anamespacextd_1_1io_html"><div class="ttname"><a href="namespacextd_1_1io.html">xtd::io</a></div><div class="ttdoc">The xtd::io namespace contains types that allow reading and writing to files and data streams,...</div><div class="ttdef"><b>Definition</b> binary_reader.hpp:17</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.hpp:10</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to move a directory and all its files to a new directory. The original directory no longer exists after it has been moved. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1io.html">xtd::io</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>program {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() {</div>
<div class="line">    <span class="keywordtype">string</span> source_directory = R<span class="stringliteral">&quot;(C:\source)&quot;;</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keywordtype">string</span> destination_directory = R<span class="stringliteral">&quot;(C:\destination)&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">      directory::move(source_directory, destination_directory);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1exception.html">exception</a>&amp; e) {</div>
<div class="line">      console::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.message());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(program::main);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use the <a class="el" href="classxtd_1_1io_1_1directory.html" title="Exposes static methods for creating, moving, and enumerating through directories and subdirectories....">xtd::io::directory</a> class for typical operations such as copying, moving, renaming, creating, and deleting directories.<ul>
<li>To create a directory, use one of the <a class="el" href="classxtd_1_1io_1_1directory.html#ac39037a0f9d5f824b232b80b6aab0dee" title="Creates all directories and subdirectories in the specified path unless they already exist.">xtd::io::directory::create_directory</a> methods.</li>
<li>To delete a directory, use one of the <a class="el" href="classxtd_1_1io_1_1directory.html#aa1debb18595ae6a7e9bacad2e11ed2aa" title="Deletes an empty directory from a specified path.">xtd::io::directory::remove</a> methods.</li>
<li>To get or set the current directory for an app, use the <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a> or <a class="el" href="classxtd_1_1io_1_1directory.html#a32acf95abeed88b7e903dd8124c746d1" title="Sets the application&#39;s current working directory to the specified directory.">xtd::io::directory::set_current_directory</a> method.</li>
<li>To manipulate date/time information related to the creation, access, and writing of a directory, use methods such as <a class="el" href="classxtd_1_1io_1_1directory.html#abaa8151fdfb08cc9f3f1d2a9600b4f8b" title="Sets the date and time the specified file or directory was last accessed.">xtd::io::directory::set_last_access_time</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#acc3a24ea0a3c5dab772871f424ae1db8" title="Sets the creation date and time for the specified file or directory.">xtd::io::directory::set_creation_time</a>. </li>
</ul>
</dd>
<dd>
The static methods of the <a class="el" href="classxtd_1_1io_1_1directory.html" title="Exposes static methods for creating, moving, and enumerating through directories and subdirectories....">xtd::io::directory</a> class perform security checks on all methods. If you are going to reuse an object several times, consider using the corresponding instance method of <a class="el" href="classxtd_1_1io_1_1directory__info.html" title="Exposes instance methods for creating, moving, and enumerating through directories and subdirectories...">xtd::io::directory_info</a> instead, because the security check will not always be necessary. </dd>
<dd>
If you are performing only one directory-related action, it might be more efficient to use a static <a class="el" href="classxtd_1_1io_1_1directory.html" title="Exposes static methods for creating, moving, and enumerating through directories and subdirectories....">xtd::io::directory</a> method rather than a corresponding <a class="el" href="classxtd_1_1io_1_1directory__info.html" title="Exposes instance methods for creating, moving, and enumerating through directories and subdirectories...">xtd::io::directory_info</a> instance method. Most <a class="el" href="classxtd_1_1io_1_1directory.html" title="Exposes static methods for creating, moving, and enumerating through directories and subdirectories....">xtd::io::directory</a> methods require the path to the directory that you are manipulating. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In members that accept a string path parameter, that path must be well-formed or an exception is raised. For example, if a path is fully qualified but begins with a space (" c:\temp"), the path string isn't trimmed, so the path is considered malformed and an exception is raised. In addition, a path or a combination of paths cannot be fully qualified twice. For example, "c:\temp c:\windows" also raises an exception. Ensure that your paths are well-formed when using methods that accept a path string. For more information see <a class="el" href="classxtd_1_1io_1_1path.html" title="Performs operations on std::basic_string instances that contain file or directory path information....">xtd::io::path</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In members that accept a path, the path can refer to a file or a directory. You can use a full path, a relative path, or a Universal Naming Convention (UNC) path for a server and share name. For example, all the following are acceptable paths:<ul>
<li>"c:\\MyDir".</li>
<li>"MyDir\\MySubdir".</li>
<li>"\\\\MyServer\\MyShare". </li>
</ul>
</dd>
<dd>
By default, full read/write access to new directories is granted to all users. However, the app must have the correct security to access existing directories. </dd>
<dd>
To demand permissions for a directory and all its subdirectories, end the path string with the directory separator character. (For example, "C:\Temp\" grants access to C:\Temp\ and all its subdirectories.) To demand permissions only for a specific directory, end the path string with a period. (For example, "C:\Temp." grants access only to C:\Temp\, not to its subdirectories.)
@remarks In members that accept a search_pattern parameter, the search string can be any combination of literal characters and two wildcard characters; * and ?. This parameter does not recognize regular expressions. For more information, see the xtd::io::directory::enumerate_directories(string, string) method or any other method that uses the search_pattern parameter.
@remarks For a list of common I/O tasks, see &lt;a href="<a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks</a>" &gt;Common I/O Tasks&lt;/a&gt;.
@remarks xtd::io::directory and xtd::io::directory_info are not supported for use in Windows Store apps. For information about how to access files and folders in Windows Store apps, see &lt;a href="<a href="https://msdn.microsoft.com/library/windows/apps/hh758319.aspx">https://msdn.microsoft.com/library/windows/apps/hh758319.aspx</a>" &gt;Accessing data and files (Windows Store apps). </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory_1_1directory__iterator.html">directory_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent directory iterator used by <a class="el" href="classxtd_1_1io_1_1directory.html" title="Exposes static methods for creating, moving, and enumerating through directories and subdirectories....">xtd::io::directory</a>.  <a href="classxtd_1_1io_1_1directory_1_1directory__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory_1_1file__iterator.html">file_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent file iterator used by <a class="el" href="classxtd_1_1io_1_1directory.html" title="Exposes static methods for creating, moving, and enumerating through directories and subdirectories....">xtd::io::directory</a>.  <a href="classxtd_1_1io_1_1directory_1_1file__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory_1_1file__system__entry__iterator.html">file_system_entry_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent file system iterator used by <a class="el" href="classxtd_1_1io_1_1directory.html" title="Exposes static methods for creating, moving, and enumerating through directories and subdirectories....">xtd::io::directory</a>.  <a href="classxtd_1_1io_1_1directory_1_1file__system__entry__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:ac39037a0f9d5f824b232b80b6aab0dee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1io_1_1directory__info.html">xtd::io::directory_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#ac39037a0f9d5f824b232b80b6aab0dee">create_directory</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:ac39037a0f9d5f824b232b80b6aab0dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all directories and subdirectories in the specified path unless they already exist.  <br /></td></tr>
<tr class="separator:ac39037a0f9d5f824b232b80b6aab0dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b598e7712edce585ab1593696806113"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1io_1_1directory_1_1directory__iterator.html">xtd::io::directory::directory_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a8b598e7712edce585ab1593696806113">enumerate_directories</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a8b598e7712edce585ab1593696806113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerable collection of directory full names in a specified path.  <br /></td></tr>
<tr class="separator:a8b598e7712edce585ab1593696806113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf03de3ebe7a146eae9355de13ddd453"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1io_1_1directory_1_1directory__iterator.html">xtd::io::directory::directory_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#acf03de3ebe7a146eae9355de13ddd453">enumerate_directories</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;search_pattern)</td></tr>
<tr class="memdesc:acf03de3ebe7a146eae9355de13ddd453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerable collection of directory full names that match a search pattern in a specified path.  <br /></td></tr>
<tr class="separator:acf03de3ebe7a146eae9355de13ddd453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fc22b50dbb33fe9fc338b4726713f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1io_1_1directory_1_1file__iterator.html">xtd::io::directory::file_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6">enumerate_files</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a33fc22b50dbb33fe9fc338b4726713f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerable collection of full file names in a specified path.  <br /></td></tr>
<tr class="separator:a33fc22b50dbb33fe9fc338b4726713f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ece16ab1b6f27ef820948bf4b37933"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1io_1_1directory_1_1file__iterator.html">xtd::io::directory::file_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a72ece16ab1b6f27ef820948bf4b37933">enumerate_files</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;search_pattern)</td></tr>
<tr class="memdesc:a72ece16ab1b6f27ef820948bf4b37933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerable collection of full file names that match a search pattern in a specified path.  <br /></td></tr>
<tr class="separator:a72ece16ab1b6f27ef820948bf4b37933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264974521f7c5f01c4081be2298c4bdd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1io_1_1directory_1_1file__system__entry__iterator.html">xtd::io::directory::file_system_entry_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a264974521f7c5f01c4081be2298c4bdd">enumerate_file_system_entries</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a264974521f7c5f01c4081be2298c4bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerable collection of file names and directory names in a specified path.  <br /></td></tr>
<tr class="separator:a264974521f7c5f01c4081be2298c4bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bac6521ab2460cb633afe965818d55"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1io_1_1directory_1_1file__system__entry__iterator.html">xtd::io::directory::file_system_entry_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a32bac6521ab2460cb633afe965818d55">enumerate_file_system_entries</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;search_pattern)</td></tr>
<tr class="memdesc:a32bac6521ab2460cb633afe965818d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerable collection of file names and directory names that match a search pattern in a specified path.  <br /></td></tr>
<tr class="separator:a32bac6521ab2460cb633afe965818d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f80efcc4bb75c7f03c1faa7fc50cc5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a02f80efcc4bb75c7f03c1faa7fc50cc5">exists</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a02f80efcc4bb75c7f03c1faa7fc50cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given path refers to an existing directory on disk.  <br /></td></tr>
<tr class="separator:a02f80efcc4bb75c7f03c1faa7fc50cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebf822c311055165d1e8da104a0b1c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a1ebf822c311055165d1e8da104a0b1c3">get_creation_time</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a1ebf822c311055165d1e8da104a0b1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the creation date and time of a directory.  <br /></td></tr>
<tr class="separator:a1ebf822c311055165d1e8da104a0b1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8fa39de0bab437d77a5ce7d336ca29"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29">get_current_directory</a> ()</td></tr>
<tr class="memdesc:aeb8fa39de0bab437d77a5ce7d336ca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current working directory of the application.  <br /></td></tr>
<tr class="separator:aeb8fa39de0bab437d77a5ce7d336ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af402ff2500b5e7523017f98ae4e205"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a2af402ff2500b5e7523017f98ae4e205">get_directories</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a2af402ff2500b5e7523017f98ae4e205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of subdirectories (including their paths) in the specified directory.  <br /></td></tr>
<tr class="separator:a2af402ff2500b5e7523017f98ae4e205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf672e0e312e7a9c67b70ce9d8c9c9d"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a8bf672e0e312e7a9c67b70ce9d8c9c9d">get_directories</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;search_pattern)</td></tr>
<tr class="memdesc:a8bf672e0e312e7a9c67b70ce9d8c9c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of subdirectories (including their paths) that match the specified search pattern in the specified directory.  <br /></td></tr>
<tr class="separator:a8bf672e0e312e7a9c67b70ce9d8c9c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af605efd518ef94a7d53696a94041ec0d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#af605efd518ef94a7d53696a94041ec0d">get_directory_root</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:af605efd518ef94a7d53696a94041ec0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the volume information, root information, or both for the specified path.  <br /></td></tr>
<tr class="separator:af605efd518ef94a7d53696a94041ec0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707f349017d49cdca0c9c6281627f677"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a707f349017d49cdca0c9c6281627f677">get_files</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a707f349017d49cdca0c9c6281627f677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of files (including their paths) in the specified directory.  <br /></td></tr>
<tr class="separator:a707f349017d49cdca0c9c6281627f677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d237770f4a4c5743a364407aff3a4d8"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a4d237770f4a4c5743a364407aff3a4d8">get_files</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;search_pattern)</td></tr>
<tr class="memdesc:a4d237770f4a4c5743a364407aff3a4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of files (including their paths) that match the specified search pattern in the specified directory.  <br /></td></tr>
<tr class="separator:a4d237770f4a4c5743a364407aff3a4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d90fb5d18e8cc5c3615b5a957a1e11"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#af5d90fb5d18e8cc5c3615b5a957a1e11">get_file_system_entries</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:af5d90fb5d18e8cc5c3615b5a957a1e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of all files and subdirectories in a specified path.  <br /></td></tr>
<tr class="separator:af5d90fb5d18e8cc5c3615b5a957a1e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03c0ddb13ec02df33ac72cfc8e9a3dc"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#ac03c0ddb13ec02df33ac72cfc8e9a3dc">get_file_system_entries</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;search_pattern)</td></tr>
<tr class="memdesc:ac03c0ddb13ec02df33ac72cfc8e9a3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of file names and directory names that match a search pattern in a specified path.  <br /></td></tr>
<tr class="separator:ac03c0ddb13ec02df33ac72cfc8e9a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d37a413694688edc644f804a8abc97"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#ac8d37a413694688edc644f804a8abc97">get_last_access_time</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:ac8d37a413694688edc644f804a8abc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the date and time the specified file or directory was last accessed.  <br /></td></tr>
<tr class="separator:ac8d37a413694688edc644f804a8abc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e03e7ff8acb5ed57f7eaca2a1e9101"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a83e03e7ff8acb5ed57f7eaca2a1e9101">get_last_write_time</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a83e03e7ff8acb5ed57f7eaca2a1e9101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the date and time the specified file or directory was last written to.  <br /></td></tr>
<tr class="separator:a83e03e7ff8acb5ed57f7eaca2a1e9101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b4d5ece70ed823e1e446c1fa354b0b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a32b4d5ece70ed823e1e446c1fa354b0b">get_logical_drives</a> ()</td></tr>
<tr class="memdesc:a32b4d5ece70ed823e1e446c1fa354b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the names of the logical drives on this computer in the form "&lt;drive letter&gt;:\".  <br /></td></tr>
<tr class="separator:a32b4d5ece70ed823e1e446c1fa354b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975bf854f1b7074ada1e44ea76df2e26"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1io_1_1directory__info.html">xtd::io::directory_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a975bf854f1b7074ada1e44ea76df2e26">get_parent</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a975bf854f1b7074ada1e44ea76df2e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the parent directory of the specified path, including both absolute and relative paths.  <br /></td></tr>
<tr class="separator:a975bf854f1b7074ada1e44ea76df2e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2477344c40b4205106b287cd7d5e41"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__xtd__core.html#gac1ad31e82b8a9af93776488ad7c14843">xtd::io::file_permissions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#abf2477344c40b4205106b287cd7d5e41">get_permissions</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:abf2477344c40b4205106b287cd7d5e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="group__xtd__core.html#gac1ad31e82b8a9af93776488ad7c14843" title="Provides permissions for files and directories.">xtd::io::file_permissions</a> of the directory on the path.  <br /></td></tr>
<tr class="separator:abf2477344c40b4205106b287cd7d5e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a78c760fbcf159d5b2848bf17d3c23b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a4a78c760fbcf159d5b2848bf17d3c23b">move</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;source_dir_name, const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;dest_dir_name)</td></tr>
<tr class="memdesc:a4a78c760fbcf159d5b2848bf17d3c23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a file or a directory and its contents to a new location.  <br /></td></tr>
<tr class="separator:a4a78c760fbcf159d5b2848bf17d3c23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1debb18595ae6a7e9bacad2e11ed2aa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#aa1debb18595ae6a7e9bacad2e11ed2aa">remove</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:aa1debb18595ae6a7e9bacad2e11ed2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an empty directory from a specified path.  <br /></td></tr>
<tr class="separator:aa1debb18595ae6a7e9bacad2e11ed2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6667f648412ab11caf1090dec64f33f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#af6667f648412ab11caf1090dec64f33f">remove</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, bool recursive)</td></tr>
<tr class="memdesc:af6667f648412ab11caf1090dec64f33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the specified directory and, if indicated, any subdirectories and files in the directory.  <br /></td></tr>
<tr class="separator:af6667f648412ab11caf1090dec64f33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3a24ea0a3c5dab772871f424ae1db8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#acc3a24ea0a3c5dab772871f424ae1db8">set_creation_time</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, const <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a> &amp;creation_time)</td></tr>
<tr class="memdesc:acc3a24ea0a3c5dab772871f424ae1db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the creation date and time for the specified file or directory.  <br /></td></tr>
<tr class="separator:acc3a24ea0a3c5dab772871f424ae1db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd56f9ec1d322bc46ef7374acbbfa53"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#adfd56f9ec1d322bc46ef7374acbbfa53">set_creation_time</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, time_t creation_time)</td></tr>
<tr class="memdesc:adfd56f9ec1d322bc46ef7374acbbfa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the creation date and time for the specified file or directory.  <br /></td></tr>
<tr class="separator:adfd56f9ec1d322bc46ef7374acbbfa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32acf95abeed88b7e903dd8124c746d1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a32acf95abeed88b7e903dd8124c746d1">set_current_directory</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>)</td></tr>
<tr class="memdesc:a32acf95abeed88b7e903dd8124c746d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application's current working directory to the specified directory.  <br /></td></tr>
<tr class="separator:a32acf95abeed88b7e903dd8124c746d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa8151fdfb08cc9f3f1d2a9600b4f8b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#abaa8151fdfb08cc9f3f1d2a9600b4f8b">set_last_access_time</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, const <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a> &amp;last_access_time)</td></tr>
<tr class="memdesc:abaa8151fdfb08cc9f3f1d2a9600b4f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the date and time the specified file or directory was last accessed.  <br /></td></tr>
<tr class="separator:abaa8151fdfb08cc9f3f1d2a9600b4f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12896e015a6745b3984a2b5cd7cab619"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a12896e015a6745b3984a2b5cd7cab619">set_last_write_time</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, const <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a> &amp;last_write_time)</td></tr>
<tr class="memdesc:a12896e015a6745b3984a2b5cd7cab619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the date and time a directory was last written to.  <br /></td></tr>
<tr class="separator:a12896e015a6745b3984a2b5cd7cab619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfcdc8ab011f53d8c6ec39aced25a1c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1io_1_1directory.html#a7dfcdc8ab011f53d8c6ec39aced25a1c">set_permissions</a> (const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;<a class="el" href="classxtd_1_1io_1_1path.html">path</a>, <a class="el" href="group__xtd__core.html#gac1ad31e82b8a9af93776488ad7c14843">xtd::io::file_permissions</a> permissions)</td></tr>
<tr class="memdesc:a7dfcdc8ab011f53d8c6ec39aced25a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified <a class="el" href="group__xtd__core.html#gac1ad31e82b8a9af93776488ad7c14843" title="Provides permissions for files and directories.">xtd::io::file_permissions</a> of the directory on the specified path.  <br /></td></tr>
<tr class="separator:a7dfcdc8ab011f53d8c6ec39aced25a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac39037a0f9d5f824b232b80b6aab0dee" name="ac39037a0f9d5f824b232b80b6aab0dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39037a0f9d5f824b232b80b6aab0dee">&#9670;&#160;</a></span>create_directory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1io_1_1directory__info.html">xtd::io::directory_info</a> xtd::io::directory::create_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates all directories and subdirectories in the specified path unless they already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The directory to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the directory at the specified path. This object is returned regardless of whether a directory at the specified path already exists. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example creates and deletes the specified directory:
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    // Specify the directories you want to manipulate.
    directory_info di("c:\MyDir");
    try {
      // Determine whether the directory exists.
      if (di.exists()) {
        // Indicate that the directory already exists.
        console::write_line("That path exists already.");
        return;
      }

      // Try to create the directory.
      di.create();
      console::write_line("The directory was created successfully.");

      // Delete the directory.
      di.remove();
      console::write_line("The directory was deleted successfully.");
    }
    catch (const exception&amp; e) {
      console::write_line("The process failed: {0}", e.to_string());
    }
  }
};

startup_(program::main);
@endicode 
@par Examples
To create the directory C:\Users\User1\Public\Html when the current directory is C:\Users\User1, use any of the following calls to ensure that the backslash is interpreted properly:
@icode{cpp} 
directory::create_directory("Public\Html");
directory::create_directory("\Users\User1\Public\Html");
directory::create_directory("c:\Users\User1\Public\Html");  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Any and all directories specified in path are created, unless they already exist or unless some part of path is invalid. If the directory already exists, this method does not create a new directory, but it returns a DirectoryInfo object for the existing directory. </dd>
<dd>
The path parameter specifies a directory path, not a file path. </dd>
<dd>
Trailing spaces are removed from the end of the path parameter before creating the directory. </dd>
<dd>
Creating a directory with only the colon character (:) is not supported, and will cause a <a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">not_supported_exception</a> to be thrown. </dd>
<dd>
On Unix systems, use a forward slash (/) as path separator. </dd></dl>

</div>
</div>
<a id="a8b598e7712edce585ab1593696806113" name="a8b598e7712edce585ab1593696806113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b598e7712edce585ab1593696806113">&#9670;&#160;</a></span>enumerate_directories() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1io_1_1directory_1_1directory__iterator.html">xtd::io::directory::directory_iterator</a> xtd::io::directory::enumerate_directories </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerable collection of directory full names in a specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1io_1_1directory_1_1directory__iterator.html" title="Represent directory iterator used by xtd::io::directory.">xtd::io::directory::directory_iterator</a> of the full names (including paths) for the directories in the directory specified by path. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par rExample
The following example enumerates the top-level directories in a specified path.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::collections::generic;
using namespace xtd::io;

class program {
public:
  static auto main() {
    try {
      // Set a variable to the My Documents path.
      string doc_path = environment::get_folder_path(environment::special_folder::my_documents);

      list&lt;string&gt; dirs(begin(directory::enumerate_directories(doc_path)), end(directory::enumerate_directories(doc_path)));

      for (auto dir : dirs) {
        console::write_line("{}", dir.substring(dir.last_index_of(path::directory_separator_char()) + 1));
      }
      console::write_line("{} directories found.", dirs.size()); } catch (const <a class="el" href="classxtd_1_1unauthorized__access__exception.html" title="The exception that is thrown when the operating system denies access because of an I/O error or a spe...">unauthorized_access_exception</a>&amp; ex) { <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>(ex.message()); } catch (const <a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">path_too_long_exception</a>&amp; ex) { <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>(ex.message()); } } };</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_(program::main)</a>;  </p><dl class="section remark"><dt>Remarks</dt><dd>You can specify relative or absolute path information in the path parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a> method. The returned directory names are prefixed with the value you provided in the path parameter. For example, if you provide a relative path in the path parameter, the returned directory names will contain a relative path. </dd>
<dd>
The <a class="el" href="classxtd_1_1io_1_1directory.html#a8b598e7712edce585ab1593696806113" title="Returns an enumerable collection of directory full names in a specified path.">xtd::io::directory::enumerate_directories</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#a2af402ff2500b5e7523017f98ae4e205" title="Returns the names of subdirectories (including their paths) in the specified directory.">xtd::io::directory::get_directories</a> methods differ as follows: When you use <a class="el" href="classxtd_1_1io_1_1directory.html#a8b598e7712edce585ab1593696806113" title="Returns an enumerable collection of directory full names in a specified path.">xtd::io::directory::enumerate_directories</a>, you can start enumerating the collection of names before the whole collection is returned; when you use <a class="el" href="classxtd_1_1io_1_1directory.html#a2af402ff2500b5e7523017f98ae4e205" title="Returns the names of subdirectories (including their paths) in the specified directory.">xtd::io::directory::get_directories</a>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <a class="el" href="classxtd_1_1io_1_1directory.html#a8b598e7712edce585ab1593696806113" title="Returns an enumerable collection of directory full names in a specified path.">xtd::io::directory::enumerate_directories</a> can be more efficient. </dd></dl>

</div>
</div>
<a id="acf03de3ebe7a146eae9355de13ddd453" name="acf03de3ebe7a146eae9355de13ddd453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf03de3ebe7a146eae9355de13ddd453">&#9670;&#160;</a></span>enumerate_directories() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1io_1_1directory_1_1directory__iterator.html">xtd::io::directory::directory_iterator</a> xtd::io::directory::enumerate_directories </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>search_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerable collection of directory full names that match a search pattern in a specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
    <tr><td class="paramname">search_pattern</td><td>The search string to match against the names of directories in path. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1io_1_1directory_1_1directory__iterator.html" title="Represent directory iterator used by xtd::io::directory.">xtd::io::directory::directory_iterator</a> of the full names (including paths) for the directories in the directory specified by path and that match the specified search pattern. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par rExample
The following example enumerates the top-level directories in a specified path that match a specified search pattern.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::collections::generic;
using namespace xtd::io;

class program {
public:
  static auto main() {
    try {
      string dir_path = R"(\archives\2009\reports)";

      // Create a List collection.
      auto dirs = list&lt;string&gt;(begin(directory::enumerate_directories(dir_path, "dv_*")), end(directory::enumerate_directories(dir_path, "dv_*")));

      // Show results.
      for (auto dir : dirs) {
        // Remove path information from string.
        console::write_line("{0}", dir.substring(dir.last_index_of("\") + 1));
      }
      console::write_line("{0} directories found.", dirs.size());
    } catch (const unauthorized_access_exception&amp; ex) {
      console::write_line(ex.message());
    } catch (const path_too_long_exception&amp; ex) {
      console::write_line(ex.message());
    }
  }
};

startup_(program::main);
@endicode 
@remarks search_pattern can be a combination of literal and wildcard characters, but it doesn't support regular expressions. The following wildcard specifiers are permitted in search_pattern.
&lt;table class="markdownTable"&gt;
  &lt;tr class="markdownTableHead"&gt;    &lt;th class="markdownTableHeadNone"&gt; Wildcard specifier   </td></tr>
  </table>
  </dd>
</dl>
<p>Matches    </p>
<p>* (asterisk)   </p>
<p>Zero or more characters in that position.    </p>
<p>? (question mark)   </p>
<p>Zero or one character in that position.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>Characters other than the wildcard are literal characters. For example, the search_pattern string "*t" searches for all names in path ending with the letter "t". The search_pattern string "s*" searches for all names in path beginning with the letter "s". </dd>
<dd>
search_pattern cannot end in two periods ("..") or contain two periods ("..") followed by <a class="el" href="classxtd_1_1io_1_1path.html#a152dd1295da22520de63ad7fffb63946" title="Provides a platform-specific character used to separate directory levels in a path string that reflec...">xtd::io::path::directory_separator_char</a> or <a class="el" href="classxtd_1_1io_1_1path.html#a319adad45ffab4fe137d9543196fd974" title="Provides a platform-specific alternate character used to separate directory levels in a path string t...">xtd::io::path::alt_directory_separator_char</a>, nor can it contain any invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </dd>
<dd>
You can specify relative or absolute path information in the path parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a> method. The returned directory names are prefixed with the value you provided in the path parameter. For example, if you provide a relative path in the path parameter, the returned directory names will contain a relative path. </dd>
<dd>
The <a class="el" href="classxtd_1_1io_1_1directory.html#a8b598e7712edce585ab1593696806113" title="Returns an enumerable collection of directory full names in a specified path.">xtd::io::directory::enumerate_directories</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#a2af402ff2500b5e7523017f98ae4e205" title="Returns the names of subdirectories (including their paths) in the specified directory.">xtd::io::directory::get_directories</a> methods differ as follows: When you use xtd::io::directory::xtd::io::directory::enumerate_directories, you can start enumerating the collection of names before the whole collection is returned; when you use <a class="el" href="classxtd_1_1io_1_1directory.html#a2af402ff2500b5e7523017f98ae4e205" title="Returns the names of subdirectories (including their paths) in the specified directory.">xtd::io::directory::get_directories</a>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <a class="el" href="classxtd_1_1io_1_1directory.html#a8b598e7712edce585ab1593696806113" title="Returns an enumerable collection of directory full names in a specified path.">xtd::io::directory::enumerate_directories</a> can be more efficient. </dd></dl>

</div>
</div>
<a id="a33fc22b50dbb33fe9fc338b4726713f6" name="a33fc22b50dbb33fe9fc338b4726713f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fc22b50dbb33fe9fc338b4726713f6">&#9670;&#160;</a></span>enumerate_files() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1io_1_1directory_1_1file__iterator.html">xtd::io::directory::file_iterator</a> xtd::io::directory::enumerate_files </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerable collection of full file names in a specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1io_1_1directory_1_1directory__iterator.html" title="Represent directory iterator used by xtd::io::directory.">xtd::io::directory::directory_iterator</a> of the full names (including paths) for the files in the directory specified by path. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example shows how to retrieve all the text files from a directory and move them to a new directory. After the files are moved, they no longer exist in the original directory.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    string source_directory = R"(C:\current)";
    string archive_directory = R"(C:\archive)";</td></tr>
  </table>
  </dd>
</dl>
<p>try { auto txt_files = directory::enumerate_files(source_directory);</p>
<p>for (string current_file : txt_files) { string file_name = current_file.substring(source_directory.size() + 1); directory::move(current_file, path::combine(archive_directory, file_name)); } } catch (exception&amp; e) { <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>(e.message()); } } };</p>
<p><a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_(program::main)</a>;  </p><dl class="section remark"><dt>Remarks</dt><dd>You can specify relative path information with the path parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a> method. </dd>
<dd>
The <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#a707f349017d49cdca0c9c6281627f677" title="Returns the names of files (including their paths) in the specified directory.">xtd::io::directory::get_files</a> methods differ as follows: When you use <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a>, you can start enumerating the collection of names before the whole collection is returned. When you use <a class="el" href="classxtd_1_1io_1_1directory.html#a707f349017d49cdca0c9c6281627f677" title="Returns the names of files (including their paths) in the specified directory.">xtd::io::directory::get_files</a>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a> can be more efficient. </dd></dl>

</div>
</div>
<a id="a72ece16ab1b6f27ef820948bf4b37933" name="a72ece16ab1b6f27ef820948bf4b37933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ece16ab1b6f27ef820948bf4b37933">&#9670;&#160;</a></span>enumerate_files() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1io_1_1directory_1_1file__iterator.html">xtd::io::directory::file_iterator</a> xtd::io::directory::enumerate_files </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>search_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerable collection of full file names that match a search pattern in a specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
    <tr><td class="paramname">search_pattern</td><td>The search string to match against the names of files in path. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1io_1_1directory_1_1directory__iterator.html" title="Represent directory iterator used by xtd::io::directory.">xtd::io::directory::directory_iterator</a> of the full names (including paths) for the files in the directory specified by path and that match the specified search pattern. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example shows how to retrieve all the text files from a directory and move them to a new directory. After the files are moved, they no longer exist in the original directory.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    string source_directory = R"(C:\current)";
    string archive_directory = R"(C:\archive)";

    try {
      auto txt_files = directory::enumerate_files(source_directory, "*.txt");

      for (string current_file : txt_files) {
        string file_name = current_file.substring(source_directory.size() + 1);
        directory::move(current_file, path::combine(archive_directory, file_name));
      }
    } catch (exception&amp; e) {
      console::write_line(e.message());
    }
  }
};

startup_(program::main);
@endicode 
@remarks search_pattern can be a combination of literal and wildcard characters, but it doesn't support regular expressions. The following wildcard specifiers are permitted in searchPattern.
&lt;table class="markdownTable"&gt;
  &lt;tr class="markdownTableHead"&gt;    &lt;th class="markdownTableHeadNone"&gt; Wildcard specifier   </td></tr>
  </table>
  </dd>
</dl>
<p>Matches    </p>
<p>* (asterisk)   </p>
<p>Zero or more characters in that position.    </p>
<p>? (question mark)   </p>
<p>Zero or one character in that position.   </p>
<p>Characters other than the wildcard are literal characters. For example, the search_pattern string "*t" searches for all names in path ending with the letter "t". The search_attern string "s*" searches for all names in path beginning with the letter "s". </p><dl class="section remark"><dt>Remarks</dt><dd>search_pattern cannot end in two periods ("..") or contain two periods ("..") followed by <a class="el" href="classxtd_1_1io_1_1path.html#a152dd1295da22520de63ad7fffb63946" title="Provides a platform-specific character used to separate directory levels in a path string that reflec...">xtd::io::path::directory_separator_char</a> or xtd::ioo::path::alt_directory_separator_char, nor can it contain any invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </dd>
<dd>
You can specify relative path information with the path parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a> method. </dd>
<dd>
The <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#a707f349017d49cdca0c9c6281627f677" title="Returns the names of files (including their paths) in the specified directory.">xtd::io::directory::get_files</a> methods differ as follows: When you use <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a>, you can start enumerating the collection of names before the whole collection is returned; when you use <a class="el" href="classxtd_1_1io_1_1directory.html#a707f349017d49cdca0c9c6281627f677" title="Returns the names of files (including their paths) in the specified directory.">xtd::io::directory::get_files</a>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a> can be more efficient. </dd></dl>

</div>
</div>
<a id="a264974521f7c5f01c4081be2298c4bdd" name="a264974521f7c5f01c4081be2298c4bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264974521f7c5f01c4081be2298c4bdd">&#9670;&#160;</a></span>enumerate_file_system_entries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1io_1_1directory_1_1file__system__entry__iterator.html">xtd::io::directory::file_system_entry_iterator</a> xtd::io::directory::enumerate_file_system_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerable collection of file names and directory names in a specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1io_1_1directory_1_1file__system__entry__iterator.html" title="Represent file system iterator used by xtd::io::directory.">xtd::io::directory::file_system_entry_iterator</a> of file-system entries in the directory specified by path. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>You can specify relative path information with the path parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a> method. </dd>
<dd>
The <a class="el" href="classxtd_1_1io_1_1directory.html#a264974521f7c5f01c4081be2298c4bdd" title="Returns an enumerable collection of file names and directory names in a specified path.">xtd::io::directory::enumerate_file_system_entries</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#af5d90fb5d18e8cc5c3615b5a957a1e11" title="Returns the names of all files and subdirectories in a specified path.">xtd::io::directory::get_file_system_entries</a> methods differ as follows: When you use <a class="el" href="classxtd_1_1io_1_1directory.html#a264974521f7c5f01c4081be2298c4bdd" title="Returns an enumerable collection of file names and directory names in a specified path.">xtd::io::directory::enumerate_file_system_entries</a>, you can start enumerating the collection of entries before the whole collection is returned; when you use <a class="el" href="classxtd_1_1io_1_1directory.html#af5d90fb5d18e8cc5c3615b5a957a1e11" title="Returns the names of all files and subdirectories in a specified path.">xtd::io::directory::get_file_system_entries</a>, you must wait for the whole array of entries to be returned before you can access the array. Therefore, when you are working with many files and directories, xtd::io::directory::enumerate_files_system_entires can be more efficient. </dd></dl>

</div>
</div>
<a id="a32bac6521ab2460cb633afe965818d55" name="a32bac6521ab2460cb633afe965818d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bac6521ab2460cb633afe965818d55">&#9670;&#160;</a></span>enumerate_file_system_entries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1io_1_1directory_1_1file__system__entry__iterator.html">xtd::io::directory::file_system_entry_iterator</a> xtd::io::directory::enumerate_file_system_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>search_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerable collection of file names and directory names that match a search pattern in a specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
    <tr><td class="paramname">serach_pattern</td><td>The search string to match against the names of file-system entries in path. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1io_1_1directory_1_1file__system__entry__iterator.html" title="Represent file system iterator used by xtd::io::directory.">xtd::io::directory::file_system_entry_iterator</a> of file-system entries in the directory specified by path and that match the specified search pattern. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@remarks search_pattern can be a combination of literal and wildcard characters, but it doesn't support regular expressions. The following wildcard specifiers are permitted in searchPattern.
&lt;table class="markdownTable"&gt;
  &lt;tr class="markdownTableHead"&gt;    &lt;th class="markdownTableHeadNone"&gt; Wildcard specifier   </td></tr>
  </table>
  </dd>
</dl>
<p>Matches    </p>
<p>* (asterisk)   </p>
<p>Zero or more characters in that position.    </p>
<p>? (question mark)   </p>
<p>Zero or one character in that position.   </p>
<p>Characters other than the wildcard are literal characters. For example, the search_pattern string "*t" searches for all names in path ending with the letter "t". The search_attern string "s*" searches for all names in path beginning with the letter "s". </p><dl class="section remark"><dt>Remarks</dt><dd>search_pattern cannot end in two periods ("..") or contain two periods ("..") followed by <a class="el" href="classxtd_1_1io_1_1path.html#a152dd1295da22520de63ad7fffb63946" title="Provides a platform-specific character used to separate directory levels in a path string that reflec...">xtd::io::path::directory_separator_char</a> or xtd::ioo::path::alt_directory_separator_char, nor can it contain any invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </dd>
<dd>
You can specify relative path information with the path parameter. Relative path information is interpreted as relative to the current working directory, which you can determine by using the <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a> method. </dd>
<dd>
The <a class="el" href="classxtd_1_1io_1_1directory.html#a264974521f7c5f01c4081be2298c4bdd" title="Returns an enumerable collection of file names and directory names in a specified path.">xtd::io::directory::enumerate_file_system_entries</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#af5d90fb5d18e8cc5c3615b5a957a1e11" title="Returns the names of all files and subdirectories in a specified path.">xtd::io::directory::get_file_system_entries</a> methods differ as follows: When you use <a class="el" href="classxtd_1_1io_1_1directory.html#a264974521f7c5f01c4081be2298c4bdd" title="Returns an enumerable collection of file names and directory names in a specified path.">xtd::io::directory::enumerate_file_system_entries</a>, you can start enumerating the collection of entries before the whole collection is returned; when you use <a class="el" href="classxtd_1_1io_1_1directory.html#af5d90fb5d18e8cc5c3615b5a957a1e11" title="Returns the names of all files and subdirectories in a specified path.">xtd::io::directory::get_file_system_entries</a>, you must wait for the whole array of entries to be returned before you can access the array. Therefore, when you are working with many files and directories, <a class="el" href="classxtd_1_1io_1_1directory.html#a264974521f7c5f01c4081be2298c4bdd" title="Returns an enumerable collection of file names and directory names in a specified path.">xtd::io::directory::enumerate_file_system_entries</a> can be more efficient. </dd></dl>

</div>
</div>
<a id="a02f80efcc4bb75c7f03c1faa7fc50cc5" name="a02f80efcc4bb75c7f03c1faa7fc50cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f80efcc4bb75c7f03c1faa7fc50cc5">&#9670;&#160;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::io::directory::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given path refers to an existing directory on disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if path refers to an existing directory; <code>false</code> if the directory does not exist or an error occurs when trying to determine if the specified directory exists. </dd></dl>
<dl class="section user"><dt>rExample</dt><dd>The following example takes an array of file or directory names on the command line, determines what kind of name it is, and processes it appropriately. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1io.html">xtd::io</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>program {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main(<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1array.html">argument_collection</a>&amp; args) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">string</span> <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a> : args) {</div>
<div class="line">      <span class="keywordflow">if</span> (file::exists(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>)) {</div>
<div class="line">        <span class="comment">// This path is a file</span></div>
<div class="line">        process_file(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(directory::exists(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>)) {</div>
<div class="line">        <span class="comment">// This path is a directory</span></div>
<div class="line">        process_directory(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;{0} is not a valid file or directory.&quot;</span>, <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Process all files in the directory passed in, recurse on any directories</span></div>
<div class="line">  <span class="comment">// that are found, and process the files they contain.</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> process_directory(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; target_directory) {</div>
<div class="line">    <span class="comment">// Process the list of files found in the directory.</span></div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;string&gt;</a> file_entries = directory::get_files(target_directory);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">string</span> file_name : file_entries)</div>
<div class="line">      process_file(file_name);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Recurse into subdirectories of this directory.</span></div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;string&gt;</a> subdirectory_entries = directory::get_directories(target_directory);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">string</span> subdirectory : subdirectory_entries)</div>
<div class="line">      process_directory(subdirectory);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Insert logic for processing found files here.</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> process_file(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>) {</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Processed file &#39;{0}&#39;.&quot;</span>, <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(program::main);</div>
<div class="ttc" id="aclassxtd_1_1array_html"><div class="ttname"><a href="classxtd_1_1array.html">xtd::array</a></div><div class="ttdoc">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...</div><div class="ttdef"><b>Definition</b> array.hpp:59</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1list_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a></div><div class="ttdoc">Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...</div><div class="ttdef"><b>Definition</b> list.hpp:80</div></div>
<div class="ttc" id="aclassxtd_1_1io_1_1path_html"><div class="ttname"><a href="classxtd_1_1io_1_1path.html">xtd::io::path</a></div><div class="ttdoc">Performs operations on std::basic_string instances that contain file or directory path information....</div><div class="ttdef"><b>Definition</b> path.hpp:36</div></div>
<div class="ttc" id="anamespacextd_1_1collections_1_1generic_html"><div class="ttname"><a href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a></div><div class="ttdoc">The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...</div><div class="ttdef"><b>Definition</b> comparer.hpp:16</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. </dd>
<dd>
Trailing spaces are removed from the end of the path parameter before checking whether the directory exists. </dd>
<dd>
The path parameter is not case-sensitive. </dd>
<dd>
If you do not have at a minimum read-only permission to the directory, the Exists method will return <code>false</code>. </dd>
<dd>
The <a class="el" href="classxtd_1_1io_1_1directory.html#a02f80efcc4bb75c7f03c1faa7fc50cc5" title="Determines whether the given path refers to an existing directory on disk.">xtd::io::directory::exists</a> method returns <code>false</code> if any error occurs while trying to determine if the specified file exists. This can occur in situations that raise exceptions such as passing a file name with invalid characters or too many characters, a failing or missing disk, or if the caller does not have permission to read the file. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="test_forms_8cpp-example.html#a42">test_forms.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1ebf822c311055165d1e8da104a0b1c3" name="a1ebf822c311055165d1e8da104a0b1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebf822c311055165d1e8da104a0b1c3">&#9670;&#160;</a></span>get_creation_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a> xtd::io::directory::get_creation_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the creation date and time of a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A xtd::date::time class that is set to the creation date and time for the specified directory. This value is expressed in local time. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples

@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;
The following example gets the creation time of the specified directory.
class program {
public:
  static auto main() {
    try {
      // Get the creation time of a well-known directory.
      date_time dt = directory::get_creation_time(environment::current_directory());
      ///
      // Give feedback to the user.
      if (date_time::now().subtract(dt).total_days() &gt; 364) {
        console::write_line("This directory is over a year old.");
      } else if (date_time::now().subtract(dt).total_days() &gt; 30) {
        console::write_line("This directory is over a month old.");
      } else if (date_time::now().subtract(dt).total_days() &lt;= 1) {
        console::write_line("This directory is less than a day old.");
      } else {
        console::write_line("This directory was created on {0}", dt);
      }
    } catch (const exception&amp; e) {
      console::write_line("The process failed: {0}", e.to_string()); } } };</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_(program::main)</a>;  </p>

</div>
</div>
<a id="aeb8fa39de0bab437d77a5ce7d336ca29" name="aeb8fa39de0bab437d77a5ce7d336ca29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8fa39de0bab437d77a5ce7d336ca29">&#9670;&#160;</a></span>get_current_directory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> xtd::io::directory::get_current_directory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current working directory of the application. </p>
<dl class="section return"><dt>Returns</dt><dd>A string that contains the absolute path of the current working directory, and does not end with a backslash (). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1unauthorized__access__exception.html" title="The exception that is thrown when the operating system denies access because of an I/O error or a spe...">xtd::unauthorized_access_exception</a></td><td>The caller does not have the required permission. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The operating system does not have current directory functionality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to use the <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a> method. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1io.html">xtd::io</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>program {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="comment">// Get the current directory.</span></div>
<div class="line">      <span class="keywordtype">string</span> <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a> = directory::get_current_directory();</div>
<div class="line">      <span class="keywordtype">string</span> target = R<span class="stringliteral">&quot;(c:\temp)&quot;;</span></div>
<div class="line"><span class="stringliteral">      console::write_line(</span><span class="stringliteral">&quot;The current directory is {0}&quot;</span>, <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      <span class="keywordflow">if</span> (!directory::exists(target)) {</div>
<div class="line">        directory::create_directory(target);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Change the current directory.</span></div>
<div class="line">      environment::current_directory(target);</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>.equals(directory::get_current_directory())) {</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;You are in the temp directory.&quot;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;You are not in the temp directory.&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1exception.html">exception</a>&amp; e) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The process failed: {0}&quot;</span>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.to_string());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(program::main);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The current directory is distinct from the original directory, which is the one from which the process was started. </dd>
<dd>
For a list of common I/O tasks, see <a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">Common I/O Tasks</a>. </dd></dl>

</div>
</div>
<a id="a2af402ff2500b5e7523017f98ae4e205" name="a2af402ff2500b5e7523017f98ae4e205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af402ff2500b5e7523017f98ae4e205">&#9670;&#160;</a></span>get_directories() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt; xtd::io::directory::get_directories </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the names of subdirectories (including their paths) in the specified directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of the full names (including paths) of subdirectories in the specified path, or an empty array if no directories are found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example takes an array of file or directory names on the command line, determines what kind of name it is, and processes it appropriately.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::collections::generic;
using namespace xtd::io;

class program {
public:
  static auto main(const argument_collection&amp; args) {
    for (string path : args) {
      if (file::exists(path)) {
        // This path is a file
        process_file(path);
      } else if(directory::exists(path)) {
        // This path is a directory
        process_directory(path);
      } else {
        console::write_line("{0} is not a valid file or directory.", path);
      }
    }
  }

  // Process all files in the directory passed in, recurse on any directories
  // that are found, and process the files they contain.
  static void process_directory(const string&amp; target_directory) {
    // Process the list of files found in the directory.
    std::vector&lt;string&gt; file_entries = directory::get_files(target_directory);
    for (string file_name : file_entries)
      process_file(file_name);

    // Recurse into subdirectories of this directory.
    std::vector&lt;string&gt; subdirectory_entries = directory::get_directories(target_directory);
    for (string subdirectory : subdirectory_entries)
      process_directory(subdirectory);
  }

  // Insert logic for processing found files here.
  static void process_file(const string&amp; path) {
    console::write_line("Processed file '{0}'.", path);
  }
};

startup_(program::main);
@endicode 
@remarks This method is identical to xtd::io::directory::get_directories(string, string) with the asterisk (*) specified as the search pattern, so it returns all subdirectories.
@remarks The xtd::io::directory::enumerate_directories and xtd::io::directory::get_directories methods differ as follows: When you use xtd::io::directory::enumerate_directories, you can start enumerating the collection of names before the whole collection is returned; when you use xtd::io::directory::get_directories, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, xtd::io::directory::enumerate_directories can be more efficient.
@remarks The path parameter can specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see xtd::io::directory::get_current_directory.
@remarks The names returned by this method are prefixed with the directory information provided in path.
@remarks The path parameter is not case-sensitive.
@remarks For a list of common I/O tasks, see &lt;a href="<a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks</a>" &gt;Common I/O Tasks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bf672e0e312e7a9c67b70ce9d8c9c9d" name="a8bf672e0e312e7a9c67b70ce9d8c9c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf672e0e312e7a9c67b70ce9d8c9c9d">&#9670;&#160;</a></span>get_directories() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt; xtd::io::directory::get_directories </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>search_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the names of subdirectories (including their paths) that match the specified search pattern in the specified directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
    <tr><td class="paramname">search_pattern</td><td>The search string to match against the names of subdirectories in path. This parameter can contain a combination of valid literal and wildcard characters, but it doesn't support regular expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of the full names (including paths) of the subdirectories that match the search pattern in the specified directory, or an empty array if no directories are found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples

@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::collections::generic;
using namespace xtd::io;

class program {
public:
  static auto main() {
    try {
      // Only get subdirectories that begin with the letter "p."
      list&lt;string&gt; dirs = directory::get_directories(R"(c:\)", "p*");
      console::write_line("The number of directories starting with p is {0}.", dirs.size());
      for (string dir : dirs) {
        console::write_line(dir);
      }
    } catch (const exception&amp; e) {
      console::write_line("The process failed: {0}", e.to_string());
    }
  }
};

startup_(program::main);
@endicode 
@remarks This method returns all subdirectories directly under the specified directory that match the specified search pattern. If the specified directory has no subdirectories, or no subdirectories match the search_pattern parameter, this method returns an empty array. Only the top directory is searched.
@remarks search_pattern can be a combination of literal and wildcard characters, but it doesn't support regular expressions. The following wildcard specifiers are permitted in search_pattern.
&lt;table class="markdownTable"&gt;
  &lt;tr class="markdownTableHead"&gt;    &lt;th class="markdownTableHeadNone"&gt; Wildcard specifier   </td></tr>
  </table>
  </dd>
</dl>
<p>Matches    </p>
<p>* (asterisk)   </p>
<p>Zero or more characters in that position.    </p>
<p>? (question mark)   </p>
<p>Zero or one character in that position.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>Characters other than the wildcard are literal characters. For example, the search_attern string "*t" searches for all names in path ending with the letter "t". The search_pattern string "s*" searches for all names in path beginning with the letter "s". </dd>
<dd>
search_pattern cannot end in two periods ("..") or contain two periods ("..") followed by <a class="el" href="classxtd_1_1io_1_1path.html#a152dd1295da22520de63ad7fffb63946" title="Provides a platform-specific character used to separate directory levels in a path string that reflec...">xtd::io::path::directory_separator_char</a> or <a class="el" href="classxtd_1_1io_1_1path.html#a319adad45ffab4fe137d9543196fd974" title="Provides a platform-specific alternate character used to separate directory levels in a path string t...">xtd::io::path::alt_directory_separator_char</a>, nor can it contain any invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </dd>
<dd>
The path parameter can specify relative or absolute path information, and is not case-sensitive. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a>. </dd>
<dd>
The <a class="el" href="classxtd_1_1io_1_1directory.html#a8b598e7712edce585ab1593696806113" title="Returns an enumerable collection of directory full names in a specified path.">xtd::io::directory::enumerate_directories</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#a2af402ff2500b5e7523017f98ae4e205" title="Returns the names of subdirectories (including their paths) in the specified directory.">xtd::io::directory::get_directories</a> methods differ as follows: When you use <a class="el" href="classxtd_1_1io_1_1directory.html#a8b598e7712edce585ab1593696806113" title="Returns an enumerable collection of directory full names in a specified path.">xtd::io::directory::enumerate_directories</a>, you can start enumerating the collection of names before the whole collection is returned; when you use <a class="el" href="classxtd_1_1io_1_1directory.html#a2af402ff2500b5e7523017f98ae4e205" title="Returns the names of subdirectories (including their paths) in the specified directory.">xtd::io::directory::get_directories</a>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <a class="el" href="classxtd_1_1io_1_1directory.html#a8b598e7712edce585ab1593696806113" title="Returns an enumerable collection of directory full names in a specified path.">xtd::io::directory::enumerate_directories</a> can be more efficient. </dd>
<dd>
For a list of common I/O tasks, see <a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">Common I/O Tasks</a>. </dd></dl>

</div>
</div>
<a id="af605efd518ef94a7d53696a94041ec0d" name="af605efd518ef94a7d53696a94041ec0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af605efd518ef94a7d53696a94041ec0d">&#9670;&#160;</a></span>get_directory_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> xtd::io::directory::get_directory_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the volume information, root information, or both for the specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of a file or directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that contains the volume information, root information, or both for the specified path. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example illustrates how to set the current directory and display the directory root.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    // Create string for a directory. This value should be an existing directory
    // or the sample will throw a DirectoryNotFoundException.
    string dir = R"(C:\test)";
    try {
      //Set the current directory.
      directory::set_current_directory(dir);
    } catch (const directory_not_found_exception&amp; e) {
      console::write_line("The specified directory does not exist. {0}", e);
    }
    // Print to console the results.
    console::write_line("Root directory: {0}", directory::get_directory_root(dir));
    console::write_line("Current directory: {0}", directory::get_current_directory());
  }
};

startup_(program::main);
@endicode 
@remarks This method obtains the fully qualified path name of path, as returned by xtd::io::path::get_full_path, and returns root directory information. The specified path is not required to exist.
@remarks The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see xtd::io::directory::get_current_directory.
@remarks The path parameter is not case-sensitive.
@remarks For a list of common I/O tasks, see &lt;a href="<a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks</a>" &gt;Common I/O Tasks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a707f349017d49cdca0c9c6281627f677" name="a707f349017d49cdca0c9c6281627f677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707f349017d49cdca0c9c6281627f677">&#9670;&#160;</a></span>get_files() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt; xtd::io::directory::get_files </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the names of files (including their paths) in the specified directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of the full names (including paths) for the files in the specified directory, or an empty array if no files are found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example demonstrates how to use the GetFiles method to return file names from a user-specified location. The example is configured to catch all errors common to this method.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::collections::generic;
using namespace xtd::io;

class program {
public:
  static auto main(const argument_collection&amp; args) {
    for (string path : args) {
      if (file::exists(path)) {
        // This path is a file
        process_file(path);
      } else if(directory::exists(path)) {
        // This path is a directory
        process_directory(path);
      } else {
        console::write_line("{0} is not a valid file or directory.", path);
      }
    }
  }

  // Process all files in the directory passed in, recurse on any directories
  // that are found, and process the files they contain.
  static void process_directory(const string&amp; target_directory) {
    // Process the list of files found in the directory.
    std::vector&lt;string&gt; file_entries = directory::get_files(target_directory);
    for (string file_name : file_entries)
      process_file(file_name);

    // Recurse into subdirectories of this directory.
    std::vector&lt;string&gt; subdirectory_entries = directory::get_directories(target_directory);
    for (string subdirectory : subdirectory_entries)
      process_directory(subdirectory);
  }

  // Insert logic for processing found files here.
  static void process_file(const string&amp; path) {
    console::write_line("Processed file '{0}'.", path);
  }
};

startup_(program::main);
@endicode 
@remarks The xtd::io::directory::enumerate_files and xtd::io::directory::get_files methods differ as follows: When you use xtd::io::directory::enumerate_files, you can start enumerating the collection of names before the whole collection is returned; when you use xtd::io::directory::get_files, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, xtd::io::directory::enumerate_files can be more efficient.
@remarks The returned file names are appended to the supplied path parameter.
@remarks This method is identical to xtd::io::directory::get_files(string, string) with the asterisk (*) specified as the search pattern.
@remarks The path parameter can specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see xtd::io::directory::get_current_directory.
@remarks The order of the returned file names is not guaranteed; use the std:::sort method if a specific sort order is required.
@remarks The path parameter is not case-sensitive.
@remarks For a list of common I/O tasks, see &lt;a href="<a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks</a>" &gt;Common I/O Tasks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d237770f4a4c5743a364407aff3a4d8" name="a4d237770f4a4c5743a364407aff3a4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d237770f4a4c5743a364407aff3a4d8">&#9670;&#160;</a></span>get_files() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt; xtd::io::directory::get_files </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>search_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the names of files (including their paths) that match the specified search pattern in the specified directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
    <tr><td class="paramname">search_pattern</td><td>The search string to match against the names of files in path. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of the full names (including paths) for the files in the specified directory that match the specified search pattern, or an empty array if no files are found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example counts the number of files that begin with the specified letter.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::collections::generic;
using namespace xtd::io;

class program {
public:
  static auto main() {
    try {
      // Only get files that begin with the letter "c".
      list&lt;string&gt; dirs = directory::get_files(R"(c:", "c*)"); <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>("The number of files starting with c is {0}.", dirs.size()); for (string dir : dirs) { console::write_line(dir); } } catch (const exception&amp; e) { <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>("The process failed: {0}", e.to_string()); } } };</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_(program::main)</a>;  </p><dl class="section remark"><dt>Remarks</dt><dd>The returned file names are appended to the supplied path parameter and the order of the returned file names is not guaranteed; use the std::sort method if a specific sort order is required. </dd>
<dd>
search_pattern can be a combination of literal and wildcard characters, but it doesn't support regular expressions. The following wildcard specifiers are permitted in search_pattern. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Wildcard specifier   </th><th class="markdownTableHeadNone">Matches    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">* (asterisk)   </td><td class="markdownTableBodyNone">Zero or more characters in that position.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">? (question mark)   </td><td class="markdownTableBodyNone">Zero or one character in that position.   </td></tr>
</table>
</dd>
<dd>
Characters other than the wildcard are literal characters. For example, the search_pattern string "*t" searches for all names in path ending with the letter "t". The search_pattern string "s*" searches for all names in path beginning with the letter "s". </dd>
<dd>
search_pattern cannot end in two periods ("..") or contain two periods ("..") followed by <a class="el" href="classxtd_1_1io_1_1path.html#a152dd1295da22520de63ad7fffb63946" title="Provides a platform-specific character used to separate directory levels in a path string that reflec...">xtd::io::path::directory_separator_char</a> or <a class="el" href="classxtd_1_1io_1_1path.html#a319adad45ffab4fe137d9543196fd974" title="Provides a platform-specific alternate character used to separate directory levels in a path string t...">xtd::io::path::alt_directory_separator_char</a>, nor can it contain any invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When you use the asterisk wildcard character in a search_pattern such as "*.txt", the number of characters in the specified extension affects the search as follows:<ul>
<li>If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, "*.xls" returns both "book.xls" and "book.xlsx".</li>
<li>In all other cases, the method returns files that exactly match the specified extension. For example, "*.ai" returns "file.ai" but not "file.aif". <br  />
When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, "file1.txt" and "file1.txtother", in a directory, a search pattern of "file?.txt" returns just the first file, whereas a search pattern of "file*.txt" returns both files. </li>
</ul>
</dd>
<dd>
Because this method checks against file names with both the 8.3 file name format and the long file name format, a search pattern similar to "*1*.txt" may return unexpected file names. For example, using a search pattern of "*1*.txt" returns "longfilename.txt" because the equivalent 8.3 file name format is "LONGFI~1.TXT". </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#a707f349017d49cdca0c9c6281627f677" title="Returns the names of files (including their paths) in the specified directory.">xtd::io::directory::get_files</a> methods differ as follows: When you use <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a>, you can start enumerating the collection of names before the whole collection is returned; when you use <a class="el" href="classxtd_1_1io_1_1directory.html#a707f349017d49cdca0c9c6281627f677" title="Returns the names of files (including their paths) in the specified directory.">xtd::io::directory::get_files</a>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a> can be more efficient. </dd>
<dd>
The path parameter can specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a>. </dd>
<dd>
The path parameter is not case-sensitive. </dd>
<dd>
For a list of common I/O tasks, see <a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">Common I/O Tasks</a>. </dd></dl>

</div>
</div>
<a id="af5d90fb5d18e8cc5c3615b5a957a1e11" name="af5d90fb5d18e8cc5c3615b5a957a1e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d90fb5d18e8cc5c3615b5a957a1e11">&#9670;&#160;</a></span>get_file_system_entries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt; xtd::io::directory::get_file_system_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the names of all files and subdirectories in a specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of the names of files and subdirectories in the specified directory, or an empty array if no files or subdirectories are found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example uses the xtd::io::directory::get_file_system_entries method to fill an array of strings with the names of all files and subdirectories in a user-specified location and prints each string in the array to the console. The example is configured to catch all errors common to this method.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::collections::generic;

class program {
public:
  static auto main() {
    program snippets;

    string path = io::directory::get_current_directory();
    string filter = "*.exe";

    snippets.print_file_system_entries(path);
    snippets.print_file_system_entries(path, filter);
    snippets.get_logical_drives();
    snippets.get_parent(path);
    snippets.move("C:\proof", "C:\Temp");
  }

  void print_file_system_entries(const string&amp; path) {
    try {
      // Obtain the file system entries in the directory path.
      list&lt;string&gt; directory_entries = io::directory::get_file_system_entries(path);

   for (xtd::string str : directory_entries) {
        console::write_line(str);
      }
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    } catch (const io::directory_not_found_exception&amp;) {
      console::write_line("The path encapsulated in the directory object does not exist.");
    }
  }

  void print_file_system_entries(string path, string pattern) {
    try {
      // Obtain the file system entries in the directory path that match the pattern.
      list&lt;string&gt; directory_entries = io::directory::get_file_system_entries(path, pattern);

      for (string str : directory_entries) {
        console::write_line(str);
      }
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    } catch (const io::directory_not_found_exception&amp;) {
      console::write_line("The path encapsulated in the directory object does not exist.");
    }
  }

  // Print out all logical drives on the system.
  void get_logical_drives() {
    try {
      list&lt;string&gt; drives = io::directory::get_logical_drives();

      for (string str : drives) {
        console::write_line(str);
      }
    } catch (const io::io_exception&amp;) {
      console::write_line("An I/O error occurs.");
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    }
  }

  void get_parent(const string&amp; path) {
    try {
      io::directory_info directory_info = io::directory::get_parent(path);

      console::write_line(directory_info.full_name());
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    }
  }

  void move(const string&amp; source_path, const string&amp; destination_path) {
    try {
      io::directory::move(source_path, destination_path);
      console::write_line("The directory move is complete.");
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    } catch (const io::io_exception&amp;) {
      console::write_line("An attempt was made to move a directory to a different volume, or dest_dir_name already exists.");
    }
  }
};

startup_(program::main);
@endicode 
@remarks The order of the returned file and directory names is not guaranteed; use the std::sort method if a specific sort order is required.
@remarks The xtd::io::directory::enumerate_fileSystem_entries and xtd::io::directory::get_file_system_entries methods differ as follows: When you use xtd::io::directory::enumerate_file_system_entries, you can start enumerating the collection of entries before the whole collection is returned; when you use xtd::io::directory::get_file_system_entries, you must wait for the whole array of entries to be returned before you can access the array. Therefore, when you are working with many files and directories, xtd::io::directory::enumerate_file_system_enties can be more efficient.
@remarks This method is identical to xtd::io::directory::get_file_system_entries with the asterisk (*) specified as the search pattern.
@remarks The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see xtd::io::directory::get_current_directory.
@remarks The path parameter is not case-sensitive.
@remarks For a list of common I/O tasks, see &lt;a href="<a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks</a>" &gt;Common I/O Tasks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac03c0ddb13ec02df33ac72cfc8e9a3dc" name="ac03c0ddb13ec02df33ac72cfc8e9a3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03c0ddb13ec02df33ac72cfc8e9a3dc">&#9670;&#160;</a></span>get_file_system_entries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt; xtd::io::directory::get_file_system_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>search_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of file names and directory names that match a search pattern in a specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the directory to search. This string is not case-sensitive. </td></tr>
    <tr><td class="paramname">serach_pattern</td><td>The search string to match against the names of file and directories in path. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of file names and directory names that match the specified search criteria, or an empty array if no files or directories are found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example uses the xtd::io::directory::get_file_system_entries method to fill an array of strings with the names of all files matching a user-specified filter in a specific location and prints each string in the array to the console. The example is configured to catch all errors common to this method.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::collections::generic;

class program {
public:
  static auto main() {
    program snippets;

    string path = io::directory::get_current_directory();
    string filter = "*.exe";

    snippets.print_file_system_entries(path);
    snippets.print_file_system_entries(path, filter);
    snippets.get_logical_drives();
    snippets.get_parent(path);
    snippets.move("C:\proof", "C:\Temp");
  }

  void print_file_system_entries(const string&amp; path) {
    try {
      // Obtain the file system entries in the directory path.
      list&lt;string&gt; directory_entries = io::directory::get_file_system_entries(path);

   for (xtd::string str : directory_entries) {
        console::write_line(str);
      }
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    } catch (const io::directory_not_found_exception&amp;) {
      console::write_line("The path encapsulated in the directory object does not exist.");
    }
  }

  void print_file_system_entries(string path, string pattern) {
    try {
      // Obtain the file system entries in the directory path that match the pattern.
      list&lt;string&gt; directory_entries = io::directory::get_file_system_entries(path, pattern);

      for (string str : directory_entries) {
        console::write_line(str);
      }
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    } catch (const io::directory_not_found_exception&amp;) {
      console::write_line("The path encapsulated in the directory object does not exist.");
    }
  }

  // Print out all logical drives on the system.
  void get_logical_drives() {
    try {
      list&lt;string&gt; drives = io::directory::get_logical_drives();

      for (string str : drives) {
        console::write_line(str);
      }
    } catch (const io::io_exception&amp;) {
      console::write_line("An I/O error occurs.");
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    }
  }

  void get_parent(const string&amp; path) {
    try {
      io::directory_info directory_info = io::directory::get_parent(path);

      console::write_line(directory_info.full_name());
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    }
  }

  void move(const string&amp; source_path, const string&amp; destination_path) {
    try {
      io::directory::move(source_path, destination_path);
      console::write_line("The directory move is complete.");
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    } catch (const io::io_exception&amp;) {
      console::write_line("An attempt was made to move a directory to a different volume, or dest_dir_name already exists.");
    }
  }
};

startup_(program::main);
@endicode 
@remarks The returned file names are appended to the supplied path parameter and the order of the returned file names is not guaranteed; use the std::sort method if a specific sort order is required.
@remarks search_pattern can be a combination of literal and wildcard characters, but it doesn't support regular expressions. The following wildcard specifiers are permitted in search_pattern.
&lt;table class="markdownTable"&gt;
  &lt;tr class="markdownTableHead"&gt;    &lt;th class="markdownTableHeadNone"&gt; Wildcard specifier   </td></tr>
  </table>
  </dd>
</dl>
<p>Matches    </p>
<p>* (asterisk)   </p>
<p>Zero or more characters in that position.    </p>
<p>? (question mark)   </p>
<p>Zero or one character in that position.   </p>
<dl class="section remark"><dt>Remarks</dt><dd>Characters other than the wildcard are literal characters. For example, the search_pattern string "*t" searches for all names in path ending with the letter "t". The search_pattern string "s*" searches for all names in path beginning with the letter "s". </dd>
<dd>
search_pattern cannot end in two periods ("..") or contain two periods ("..") followed by <a class="el" href="classxtd_1_1io_1_1path.html#a152dd1295da22520de63ad7fffb63946" title="Provides a platform-specific character used to separate directory levels in a path string that reflec...">xtd::io::path::directory_separator_char</a> or <a class="el" href="classxtd_1_1io_1_1path.html#a319adad45ffab4fe137d9543196fd974" title="Provides a platform-specific alternate character used to separate directory levels in a path string t...">xtd::io::path::alt_directory_separator_char</a>, nor can it contain any invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When you use the asterisk wildcard character in a search_pattern such as "*.txt", the number of characters in the specified extension affects the search as follows:<ul>
<li>If the specified extension is exactly three characters long, the method returns files with extensions that begin with the specified extension. For example, "*.xls" returns both "book.xls" and "book.xlsx".</li>
<li>In all other cases, the method returns files that exactly match the specified extension. For example, "*.ai" returns "file.ai" but not "file.aif". <br  />
When you use the question mark wildcard character, this method returns only files that match the specified file extension. For example, given two files, "file1.txt" and "file1.txtother", in a directory, a search pattern of "file?.txt" returns just the first file, whereas a search pattern of "file*.txt" returns both files. </li>
</ul>
</dd>
<dd>
Because this method checks against file names with both the 8.3 file name format and the long file name format, a search pattern similar to "*1*.txt" may return unexpected file names. For example, using a search pattern of "*1*.txt" returns "longfilename.txt" because the equivalent 8.3 file name format is "LONGFI~1.TXT". </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a> and <a class="el" href="classxtd_1_1io_1_1directory.html#a707f349017d49cdca0c9c6281627f677" title="Returns the names of files (including their paths) in the specified directory.">xtd::io::directory::get_files</a> methods differ as follows: When you use <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a>, you can start enumerating the collection of names before the whole collection is returned; when you use <a class="el" href="classxtd_1_1io_1_1directory.html#a707f349017d49cdca0c9c6281627f677" title="Returns the names of files (including their paths) in the specified directory.">xtd::io::directory::get_files</a>, you must wait for the whole array of names to be returned before you can access the array. Therefore, when you are working with many files and directories, <a class="el" href="classxtd_1_1io_1_1directory.html#a33fc22b50dbb33fe9fc338b4726713f6" title="Returns an enumerable collection of full file names in a specified path.">xtd::io::directory::enumerate_files</a> can be more efficient. </dd>
<dd>
The path parameter can specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a>. </dd>
<dd>
The path parameter is not case-sensitive. </dd>
<dd>
For a list of common I/O tasks, see <a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">Common I/O Tasks</a>. </dd></dl>

</div>
</div>
<a id="ac8d37a413694688edc644f804a8abc97" name="ac8d37a413694688edc644f804a8abc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d37a413694688edc644f804a8abc97">&#9670;&#160;</a></span>get_last_access_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a> xtd::io::directory::get_last_access_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the date and time the specified file or directory was last accessed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file or directory for which to obtain access date and time information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1date__time.html" title="Represents an instant in time, typically expressed as a date and time of day.">xtd::date_time</a> class that is set to the date and time the specified file or directory was last accessed. This value is expressed in local time. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example demonstrates how to use GetLastAccessTime.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    try {
      string path = R"(c:\MyDir)";
      if (!directory::exists(path)) {
        directory::create_directory(path);
      }
      directory::set_last_access_time(path, {1985, 5, 4});

      // Get the creation time of a well-known directory.
      date_time dt = directory::get_last_access_time(path);
      console::write_line("The last access time for this directory was {0}", dt);

      // Update the last access time.
      directory::set_last_access_time(path, date_time::now());
      dt = directory::get_last_access_time(path);
      console::write_line("The last access time for this directory was {0}", dt);
    }

    catch (const exception&amp; e) {
      console::write_line("The process failed: {0}", e.to_string());
    }
  }
};

startup_(program::main);
@endicode 
@note This method may return an inaccurate value, because it uses native functions whose values may not be continuously updated by the operating system.
@remarks This method is identical to xtd::io::file::get_last_access_time.
@remarks If the directory described in the path parameter does not exist, this method returns 12:00 midnight, January 1, 1601 A.D. (C.E.) Coordinated Universal Time (UTC), adjusted to local time.
@remarks The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see xtd::io::directory::get_current_directory.
@remarks The path parameter is not case-sensitive.
@remarks For a list of common I/O tasks, see &lt;a href="<a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks</a>" &gt;Common I/O Tasks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83e03e7ff8acb5ed57f7eaca2a1e9101" name="a83e03e7ff8acb5ed57f7eaca2a1e9101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e03e7ff8acb5ed57f7eaca2a1e9101">&#9670;&#160;</a></span>get_last_write_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a> xtd::io::directory::get_last_write_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the date and time the specified file or directory was last written to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file or directory for which to obtain modification date and time information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1date__time.html" title="Represents an instant in time, typically expressed as a date and time of day.">xtd::date_time</a> class that is set to the date and time the specified file or directory was last written to. This value is expressed in local time. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example demonstrates how to use xtd::io::directory::get_last_write_time.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    try {
      string path = R"(c:\MyDir)";
      if (!directory::exists(path)) {
        directory::create_directory(path);
      }
      directory::set_last_write_time(path, {1985, 5, 4});

      // Get the creation time of a well-known directory.
      date_time dt = directory::get_last_write_time(path);
      console::write_line("The last write time for this directory was {0}", dt);

      // Update the last write time.
      directory::set_last_write_time(path, date_time::now());
      dt = directory::get_last_write_time(path);
      console::write_line("The last write time for this directory was {0}", dt);
    }

    catch (const exception&amp; e) {
      console::write_line("The process failed: {0}", e.to_string());
    }
  }
};

startup_(program::main);
@endicode 
@note This method may return an inaccurate value, because it uses native functions whose values may not be continuously updated by the operating system.
@remarks If the directory described in the path parameter does not exist, this method returns 12:00 midnight, January 1, 1601 A.D. (C.E.) Coordinated Universal Time (UTC), adjusted to local time.
@remarks The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see xtd::io::directory::get_current_directory.
@remarks The path parameter is not case-sensitive.
@remarks For a list of common I/O tasks, see &lt;a href="<a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks</a>" &gt;Common I/O Tasks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32b4d5ece70ed823e1e446c1fa354b0b" name="a32b4d5ece70ed823e1e446c1fa354b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b4d5ece70ed823e1e446c1fa354b0b">&#9670;&#160;</a></span>get_logical_drives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &gt; xtd::io::directory::get_logical_drives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the names of the logical drives on this computer in the form "&lt;drive letter&gt;:\". </p>
<dl class="section return"><dt>Returns</dt><dd>The logical drives on this computer. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>An I/O error occurred (for example, a disk error). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1unauthorized__access__exception.html" title="The exception that is thrown when the operating system denies access because of an I/O error or a spe...">xtd::unauthorized_access_exception</a></td><td>The caller does not have the required permission. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example uses the <a class="el" href="classxtd_1_1io_1_1directory.html#a32b4d5ece70ed823e1e446c1fa354b0b" title="Retrieves the names of the logical drives on this computer in the form &quot;&lt;drive letter&gt;:\&quot;.">xtd::io::directory::get_logical_drives</a> method to assign the name of each drive on the calling computer to an array of strings. Each member of this string array is then printed to the console. The example is configured to catch all errors common to this method. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>program {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() {</div>
<div class="line">    program snippets;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">string</span> <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a> = io::directory::get_current_directory();</div>
<div class="line">    <span class="keywordtype">string</span> filter = <span class="stringliteral">&quot;*.exe&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    snippets.print_file_system_entries(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">    snippets.print_file_system_entries(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>, filter);</div>
<div class="line">    snippets.get_logical_drives();</div>
<div class="line">    snippets.get_parent(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">    snippets.move(<span class="stringliteral">&quot;C:\\proof&quot;</span>, <span class="stringliteral">&quot;C:\\Temp&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> print_file_system_entries(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="comment">// Obtain the file system entries in the directory path.</span></div>
<div class="line">      <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;string&gt;</a> directory_entries = io::directory::get_file_system_entries(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">for</span> (<a class="code hl_class" href="classxtd_1_1basic__string.html">xtd::string</a> str : directory_entries) {</div>
<div class="line">        console::write_line(str);</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1security_1_1security__exception.html">security::security_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The caller does not have the required permission.&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1argument__exception.html">argument_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;path is an empty string, contains only white spaces, or contains invalid characters.&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1io_1_1directory__not__found__exception.html">io::directory_not_found_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The path encapsulated in the directory object does not exist.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> print_file_system_entries(<span class="keywordtype">string</span> path, <span class="keywordtype">string</span> pattern) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="comment">// Obtain the file system entries in the directory path that match the pattern.</span></div>
<div class="line">      <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;string&gt;</a> directory_entries = io::directory::get_file_system_entries(path, pattern);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">string</span> str : directory_entries) {</div>
<div class="line">        console::write_line(str);</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1security_1_1security__exception.html">security::security_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The caller does not have the required permission.&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1argument__exception.html">argument_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;path is an empty string, contains only white spaces, or contains invalid characters.&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1io_1_1directory__not__found__exception.html">io::directory_not_found_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The path encapsulated in the directory object does not exist.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print out all logical drives on the system.</span></div>
<div class="line">  <span class="keywordtype">void</span> get_logical_drives() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;string&gt;</a> drives = io::directory::get_logical_drives();</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">string</span> str : drives) {</div>
<div class="line">        console::write_line(str);</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1io_1_1io__exception.html">io::io_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;An I/O error occurs.&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1security_1_1security__exception.html">security::security_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The caller does not have the required permission.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> get_parent(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; path) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <a class="code hl_class" href="classxtd_1_1io_1_1directory__info.html">io::directory_info</a> directory_info = io::directory::get_parent(path);</div>
<div class="line"> </div>
<div class="line">      console::write_line(directory_info.<a class="code hl_function" href="classxtd_1_1io_1_1file__system__info.html#a4fb28d3aa102d283c21a9ac5dc2710b5">full_name</a>());</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1argument__exception.html">argument_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;path is an empty string, contains only white spaces, or contains invalid characters.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> move(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; source_path, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; destination_path) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      io::directory::move(source_path, destination_path);</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The directory move is complete.&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1security_1_1security__exception.html">security::security_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The caller does not have the required permission.&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1argument__exception.html">argument_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;path is an empty string, contains only white spaces, or contains invalid characters.&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1io_1_1io__exception.html">io::io_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;An attempt was made to move a directory to a different volume, or dest_dir_name already exists.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(program::main);</div>
<div class="ttc" id="aclassxtd_1_1argument__exception_html"><div class="ttname"><a href="classxtd_1_1argument__exception.html">xtd::argument_exception</a></div><div class="ttdoc">The exception that is thrown when one of the arguments provided to a method is not valid.</div><div class="ttdef"><b>Definition</b> argument_exception.hpp:24</div></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html"><div class="ttname"><a href="classxtd_1_1basic__string.html">xtd::basic_string</a></div><div class="ttdoc">Represents text as a sequence of character units.</div><div class="ttdef"><b>Definition</b> basic_string.hpp:71</div></div>
<div class="ttc" id="aclassxtd_1_1io_1_1directory__info_html"><div class="ttname"><a href="classxtd_1_1io_1_1directory__info.html">xtd::io::directory_info</a></div><div class="ttdoc">Exposes instance methods for creating, moving, and enumerating through directories and subdirectories...</div><div class="ttdef"><b>Definition</b> directory_info.hpp:129</div></div>
<div class="ttc" id="aclassxtd_1_1io_1_1directory__not__found__exception_html"><div class="ttname"><a href="classxtd_1_1io_1_1directory__not__found__exception.html">xtd::io::directory_not_found_exception</a></div><div class="ttdoc">The exception that is thrown when part of a file or directory cannot be found.</div><div class="ttdef"><b>Definition</b> directory_not_found_exception.hpp:29</div></div>
<div class="ttc" id="aclassxtd_1_1io_1_1file__system__info_html_a4fb28d3aa102d283c21a9ac5dc2710b5"><div class="ttname"><a href="classxtd_1_1io_1_1file__system__info.html#a4fb28d3aa102d283c21a9ac5dc2710b5">xtd::io::file_system_info::full_name</a></div><div class="ttdeci">xtd::string full_name() const</div><div class="ttdoc">Gets the full path of the directory or file.</div></div>
<div class="ttc" id="aclassxtd_1_1io_1_1io__exception_html"><div class="ttname"><a href="classxtd_1_1io_1_1io__exception.html">xtd::io::io_exception</a></div><div class="ttdoc">The exception that is thrown when an I/O error occurs.</div><div class="ttdef"><b>Definition</b> io_exception.hpp:29</div></div>
<div class="ttc" id="aclassxtd_1_1security_1_1security__exception_html"><div class="ttname"><a href="classxtd_1_1security_1_1security__exception.html">xtd::security::security_exception</a></div><div class="ttdoc">The exception that is thrown when an I/O error occurs.</div><div class="ttdef"><b>Definition</b> security_exception.hpp:25</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1io_1_1directory.html#a32b4d5ece70ed823e1e446c1fa354b0b" title="Retrieves the names of the logical drives on this computer in the form &quot;&lt;drive letter&gt;:\&quot;.">xtd::io::directory::get_logical_drives</a> returns all of the accessible drives on a particular machine, including the floppy drive and any optical drives. </dd>
<dd>
For a list of common I/O tasks, see <a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">Common I/O Tasks</a>. </dd></dl>

</div>
</div>
<a id="a975bf854f1b7074ada1e44ea76df2e26" name="a975bf854f1b7074ada1e44ea76df2e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975bf854f1b7074ada1e44ea76df2e26">&#9670;&#160;</a></span>get_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1io_1_1directory__info.html">xtd::io::directory_info</a> xtd::io::directory::get_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the parent directory of the specified path, including both absolute and relative paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path for which to retrieve the parent directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parent directory, or <a class="el" href="classxtd_1_1io_1_1directory__info.html#ae6cb2a7637a4c3c96980e01ec3d5b654" title="Represents the uninitialized xtd::io::directory_info object. This field is constant.">xtd::io::directory_info::empty</a> if path is the root directory, including the root of a UNC server or share name. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example demonstrates how to use the xtd::io::directory::get_parent method to retrieve the parent directory of a user-specified location, "path". The value returned by the xtd::io::directory::get_parent method is then printed to the console. The example is configured to catch all errors common to this method.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::collections::generic;

class program {
public:
  static auto main() {
    program snippets;

    string path = io::directory::get_current_directory();
    string filter = "*.exe";

    snippets.print_file_system_entries(path);
    snippets.print_file_system_entries(path, filter);
    snippets.get_logical_drives();
    snippets.get_parent(path);
    snippets.move("C:\proof", "C:\Temp");
  }

  void print_file_system_entries(const string&amp; path) {
    try {
      // Obtain the file system entries in the directory path.
      list&lt;string&gt; directory_entries = io::directory::get_file_system_entries(path);

   for (xtd::string str : directory_entries) {
        console::write_line(str);
      }
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    } catch (const io::directory_not_found_exception&amp;) {
      console::write_line("The path encapsulated in the directory object does not exist.");
    }
  }

  void print_file_system_entries(string path, string pattern) {
    try {
      // Obtain the file system entries in the directory path that match the pattern.
      list&lt;string&gt; directory_entries = io::directory::get_file_system_entries(path, pattern);

      for (string str : directory_entries) {
        console::write_line(str);
      }
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    } catch (const io::directory_not_found_exception&amp;) {
      console::write_line("The path encapsulated in the directory object does not exist.");
    }
  }

  // Print out all logical drives on the system.
  void get_logical_drives() {
    try {
      list&lt;string&gt; drives = io::directory::get_logical_drives();

      for (string str : drives) {
        console::write_line(str);
      }
    } catch (const io::io_exception&amp;) {
      console::write_line("An I/O error occurs.");
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    }
  }

  void get_parent(const string&amp; path) {
    try {
      io::directory_info directory_info = io::directory::get_parent(path);

      console::write_line(directory_info.full_name());
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    }
  }

  void move(const string&amp; source_path, const string&amp; destination_path) {
    try {
      io::directory::move(source_path, destination_path);
      console::write_line("The directory move is complete.");
    } catch (const security::security_exception&amp;) {
      console::write_line("The caller does not have the required permission.");
    } catch (const argument_exception&amp;) {
      console::write_line("path is an empty string, contains only white spaces, or contains invalid characters.");
    } catch (const io::io_exception&amp;) {
      console::write_line("An attempt was made to move a directory to a different volume, or dest_dir_name already exists.");
    }
  }
};

startup_(program::main);
@endicode 
@remarks The path parameter can specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see xtd::io::directory::get_current_directory.
@remarks Trailing spaces are removed from the end of the path parameter before getting the directory.
@remarks The string returned by this method consists of all characters in the path up to, but not including, the last xtd::io::path::directory_separator_char or alt_directory_separator_char. For example, passing the path "C:\Directory\SubDirectory\test.txt" to xtd::io::directory::get_parent returns "C:\Directory\SubDirectory". Passing "C:\Directory\SubDirectory" returns "C:\Directory". However, passing "C:\Directory\SubDirectory" returns "C:\Directory\SubDirectory", because the ending directory separator is after "SubDirectory". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The path parameter is not case-sensitive. </dd>
<dd>
For a list of common I/O tasks, see <a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">Common I/O Tasks</a>. </dd></dl>

</div>
</div>
<a id="abf2477344c40b4205106b287cd7d5e41" name="abf2477344c40b4205106b287cd7d5e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2477344c40b4205106b287cd7d5e41">&#9670;&#160;</a></span>get_permissions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__xtd__core.html#gac1ad31e82b8a9af93776488ad7c14843">xtd::io::file_permissions</a> xtd::io::directory::get_permissions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="group__xtd__core.html#gac1ad31e82b8a9af93776488ad7c14843" title="Provides permissions for files and directories.">xtd::io::file_permissions</a> of the directory on the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__xtd__core.html#gac1ad31e82b8a9af93776488ad7c14843" title="Provides permissions for files and directories.">xtd::io::file_permissions</a> of the directory on the path. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>if directory src does not exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a78c760fbcf159d5b2848bf17d3c23b" name="a4a78c760fbcf159d5b2848bf17d3c23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a78c760fbcf159d5b2848bf17d3c23b">&#9670;&#160;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::io::directory::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>source_dir_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>dest_dir_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves a file or a directory and its contents to a new location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_dir_name</td><td>The path of the file or directory to move. </td></tr>
    <tr><td class="paramname">dest_dir_name</td><td>The path to the new location for source_dir_name. If source_dir_name is a file, then dest_dir_name must also be a file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>An attempt was made to move a directory to a different volume.<br  />
-or-<br  />
dest_dir_name already exists. See the Note in the Remarks section.<br  />
-or-<br  />
The source_dir_name and dest_dir_name parameters refer to the same file or directory.<br  />
-or-<br  />
The directory or a file within it is being used by another process. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>source_dir_name or dest_dir_name is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters with the xtd::path::io::get_invalid_path_chars() method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The path specified by sourceDirName is invalid (for example, it is on an unmapped drive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to move a directory and all its files to a new directory. The original directory no longer exists after it has been moved. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1io.html">xtd::io</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>program {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() {</div>
<div class="line">    <span class="keywordtype">string</span> source_directory = R<span class="stringliteral">&quot;(C:\source)&quot;;</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keywordtype">string</span> destination_directory = R<span class="stringliteral">&quot;(C:\destination)&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">      directory::move(source_directory, destination_directory);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1exception.html">exception</a>&amp; e) {</div>
<div class="line">      console::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.message());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(program::main);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method creates a new directory with the name specified by destDirName and moves the contents of sourceDirName to the newly created destination directory. If you try to move a directory to a directory that already exists, an IOException will occur. For example, an exception will occur if you try to move c:\mydir to c:, and c:already exists. Alternatively, you could specify "c:\\public\\mydir" as the destDirName parameter, provided that "mydir" does not exist under "c:\\public", or specify a new directory name such as "c:\\newdir". </dd>
<dd>
The sourceDirName and destDirName arguments are permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see GetCurrentDirectory. </dd>
<dd>
Trailing spaces are removed from the end of the path parameters before moving the directory. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classxtd_1_1io_1_1directory.html#a4a78c760fbcf159d5b2848bf17d3c23b" title="Moves a file or a directory and its contents to a new location.">xtd::io::directory::move</a> method throws an <a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a> in all platforms when the dest_dir_name already exists. </dd></dl>

</div>
</div>
<a id="aa1debb18595ae6a7e9bacad2e11ed2aa" name="aa1debb18595ae6a7e9bacad2e11ed2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1debb18595ae6a7e9bacad2e11ed2aa">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::io::directory::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes an empty directory from a specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The name of the empty directory to remove. This directory must be writable and empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>A file with the same name and location specified by path exists.<br  />
-or-<br  />
The directory is the application's current working directory.<br  />
-or-<br  />
The directory specified by path is not empty.<br  />
-or-<br  />
The directory is read-only or contains a read-only file.<br  />
-or-<br  />
The directory is being used by another process. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Exaample
The following example shows how to create a new directory and subdirectory, and then delete only the subdirectory.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    string sub_path = R"(C:\NewDirectory\NewSubDirectory)";

    try {
      directory::create_directory(sub_path);
      directory::remove(sub_path);

      bool directory_exists = directory::exists(R"(C:\NewDirectory)");
      bool sub_directory_exists = directory::exists(sub_path);

      console::write_line("top-level directory exists: {0}", directory_exists);
      console::write_line("sub-directory exists: {0}", sub_directory_exists);
    } catch (const exception&amp; e) {
      console::write_line("The process failed: {0}", e.message()); } } };</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_(program::main)</a>;  </p><dl class="section remark"><dt>Remarks</dt><dd>This method behaves identically to xtd::io::dirctory::remove(const xtd::string&amp;, bool) with <code>false</code> specified for the second parameter. </dd>
<dd>
The path parameter may specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see GetCurrentDirectory. </dd>
<dd>
Trailing spaces are removed from the end of the path parameter before deleting the directory. </dd>
<dd>
This method throws an IOException if the directory specified in the path parameter contains files or subdirectories. </dd>
<dd>
The path parameter is not case-sensitive. </dd>
<dd>
In some cases, if you have the specified directory open in File Explorer, the Delete method may not be able to delete it. </dd></dl>

</div>
</div>
<a id="af6667f648412ab11caf1090dec64f33f" name="af6667f648412ab11caf1090dec64f33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6667f648412ab11caf1090dec64f33f">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::io::directory::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the specified directory and, if indicated, any subdirectories and files in the directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The name of the directory to remove. </td></tr>
    <tr><td class="paramname">recursive</td><td><code>true</code> to remove directories, subdirectories, and files in path; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>A file with the same name and location specified by path exists.<br  />
-or-<br  />
The directory is the application's current working directory.<br  />
-or-<br  />
The directory specified by path is not empty.<br  />
-or-<br  />
The directory is read-only or contains a read-only file.<br  />
-or-<br  />
The directory is being used by another process. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples
The following example shows how to create a new directory, subdirectory, and file in the subdirectory, and then recursively delete all the new items.
@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    string top_path = R"(C:\NewDirectory)";
    string sub_path = R"(C:\NewDirectory\NewSubDirectory)";

    try {
      directory::create_directory(sub_path);

      block_scope_(stream_writer writer(sub_path + R"(\example.txt)")) {
        writer.write_line("content added");
      }

      directory::remove(top_path, true);

      bool directory_exists = directory::exists(top_path);

      console::write_line("top-level directory exists: {0}", directory_exists);
    } catch (const exception&amp; e) {
      console::write_line("The process failed: {0}", e.message()); } } };</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_(program::main)</a>;  </p><dl class="section remark"><dt>Remarks</dt><dd>The path parameter may specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a>. </dd>
<dd>
Trailing spaces are removed from the end of the path parameter before deleting the directory. </dd>
<dd>
The path parameter is not case-sensitive. </dd>
<dd>
If the recursive parameter is <code>true</code>, the user must have write permission for the current directory as well as for all subdirectories. </dd>
<dd>
The behavior of this method differs slightly when deleting a directory that contains a reparse point, such as a symbolic link or a mount point. If the reparse point is a directory, such as a mount point, it is unmounted and the mount point is deleted. This method does not recurse through the reparse point. If the reparse point is a symbolic link to a file, the reparse point is deleted and not the target of the symbolic link. </dd>
<dd>
In some cases, if you have the specified directory open in File Explorer, the <a class="el" href="classxtd_1_1io_1_1directory.html#aa1debb18595ae6a7e9bacad2e11ed2aa" title="Deletes an empty directory from a specified path.">xtd::io::directory::remove</a> method may not be able to delete it. </dd></dl>

</div>
</div>
<a id="acc3a24ea0a3c5dab772871f424ae1db8" name="acc3a24ea0a3c5dab772871f424ae1db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3a24ea0a3c5dab772871f424ae1db8">&#9670;&#160;</a></span>set_creation_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::io::directory::set_creation_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a> &amp;&#160;</td>
          <td class="paramname"><em>creation_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the creation date and time for the specified file or directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file or directory for which to set the creation date and time information. </td></tr>
    <tr><td class="paramname">creation_time</td><td>The date and time the file or directory was last written to. This value is expressed in local time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples

@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    // Set the directory.
    string n = R"(C:\test\newdir)";

    //Create the directory.
    try {
      directory::create_directory(n);
    } catch (const io_exception&amp; e) {
      console::write_line(e);
    }

    //Set the creation and last access times to a variable DateTime value.
    directory::set_creation_time(n, {2002, 1, 3});
    directory::set_last_access_time(n, {2002, 1, 3});

    // Print to console the results.
    console::write_line("Creation Date: {0}", directory::get_creation_time(n));
    console::write_line("Last write time: {0}", directory::get_last_write_time(n));
    console::write_line("Last access time: {0}", directory::get_last_access_time(n));

    //Set the last write time to a different value.
    directory::set_last_write_time(n, {1999, 1, 1});
    console::write_line("Changed last write time: {0}", directory::get_last_write_time(n)); } };</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_(program::main)</a>;</p>
<p>// Obviously, since this sample deals with dates and times, the output will vary // depending on when you run the executable. Here is one example of the output: //Creation Date: 1/3/2002 12:00:00 AM //Last write time: 12/31/1998 4:00:00 PM //Last access time: 1/2/2002 4:00:00 PM //Changed last write time: 1/1/1999 12:00:00 AM  </p><dl class="section remark"><dt>Remarks</dt><dd>The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a>. </dd>
<dd>
The path parameter is not case-sensitive. </dd></dl>

</div>
</div>
<a id="adfd56f9ec1d322bc46ef7374acbbfa53" name="adfd56f9ec1d322bc46ef7374acbbfa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd56f9ec1d322bc46ef7374acbbfa53">&#9670;&#160;</a></span>set_creation_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::io::directory::set_creation_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>creation_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the creation date and time for the specified file or directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file or directory for which to set the creation date and time information. </td></tr>
    <tr><td class="paramname">creation_time</td><td>The date and time the file or directory was last written to. This value is expressed in local time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, file name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@par Examples

@icode{cpp} 
#include &lt;xtd/xtd&gt;

using namespace xtd;
using namespace xtd::io;

class program {
public:
  static auto main() {
    // Set the directory.
    string n = R"(C:\test\newdir)";

    //Create the directory.
    try {
      directory::create_directory(n);
    } catch (const io_exception&amp; e) {
      console::write_line(e);
    }

    //Set the creation and last access times to a variable DateTime value.
    directory::set_creation_time(n, {2002, 1, 3});
    directory::set_last_access_time(n, {2002, 1, 3});

    // Print to console the results.
    console::write_line("Creation Date: {0}", directory::get_creation_time(n));
    console::write_line("Last write time: {0}", directory::get_last_write_time(n));
    console::write_line("Last access time: {0}", directory::get_last_access_time(n));

    //Set the last write time to a different value.
    directory::set_last_write_time(n, {1999, 1, 1});
    console::write_line("Changed last write time: {0}", directory::get_last_write_time(n)); } };</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_(program::main)</a>;</p>
<p>// Obviously, since this sample deals with dates and times, the output will vary // depending on when you run the executable. Here is one example of the output: //Creation Date: 1/3/2002 12:00:00 AM //Last write time: 12/31/1998 4:00:00 PM //Last access time: 1/2/2002 4:00:00 PM //Changed last write time: 1/1/1999 12:00:00 AM  </p><dl class="section remark"><dt>Remarks</dt><dd>The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a>. </dd>
<dd>
The path parameter is not case-sensitive. </dd></dl>

</div>
</div>
<a id="a32acf95abeed88b7e903dd8124c746d1" name="a32acf95abeed88b7e903dd8124c746d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32acf95abeed88b7e903dd8124c746d1">&#9670;&#160;</a></span>set_current_directory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::io::directory::set_current_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the application's current working directory to the specified directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to which the current working directory is set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>Attempted to set to an empty string (""). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>An I/O error occurred. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>Attempted to set a local path that cannot be found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1security_1_1security__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::security::security_exception</a></td><td>The caller does not have the appropriate permission. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example illustrates how to set the current directory and display the directory root. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1io.html">xtd::io</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>program {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() {</div>
<div class="line">    <span class="comment">// Create string for a directory. This value should be an existing directory</span></div>
<div class="line">    <span class="comment">// or the sample will throw a DirectoryNotFoundException.</span></div>
<div class="line">    <span class="keywordtype">string</span> dir = R<span class="stringliteral">&quot;(C:\test)&quot;;</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">      <span class="comment">//Set the current directory.</span></div>
<div class="line">      directory::set_current_directory(dir);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1io_1_1directory__not__found__exception.html">directory_not_found_exception</a>&amp; e) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The specified directory does not exist. {0}&quot;</span>, e);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Print to console the results.</span></div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Root directory: {0}&quot;</span>, directory::get_directory_root(dir));</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Current directory: {0}&quot;</span>, directory::get_current_directory());</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(program::main);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>When the application terminates, the working directory is restored to its original location (the directory where the process was started). </dd>
<dd>
The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a>. </dd>
<dd>
Trailing spaces are removed from the end of the path parameter before setting the directory. </dd>
<dd>
The path parameter is not case-sensitive. </dd>
<dd>
If you are setting the directory to a drive with removable media (for example, "E:" for a USB flash drive), you can determine whether the drive is ready by using the IsReady property.When the application terminates, the working directory is restored to its original location (the directory where the process was started). </dd>
<dd>
The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see GetCurrentDirectory. </dd>
<dd>
Trailing spaces are removed from the end of the path parameter before setting the directory. </dd>
<dd>
The path parameter is not case-sensitive. </dd>
<dd>
If you are setting the directory to a drive with removable media (for example, "E:" for a USB flash drive), you can determine whether the drive is ready by using the xtd::io::drive::is_ready property. </dd></dl>

</div>
</div>
<a id="abaa8151fdfb08cc9f3f1d2a9600b4f8b" name="abaa8151fdfb08cc9f3f1d2a9600b4f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa8151fdfb08cc9f3f1d2a9600b4f8b">&#9670;&#160;</a></span>set_last_access_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::io::directory::set_last_access_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a> &amp;&#160;</td>
          <td class="paramname"><em>last_access_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the date and time the specified file or directory was last accessed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file or directory for which to set the access date and time information. </td></tr>
    <tr><td class="paramname">last_access_time</td><td>An object that contains the value to set for the access date and time of path. This value is expressed in local time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>Attempted to set to an empty string (""). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>An I/O error occurred. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>Attempted to set a local path that cannot be found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1security_1_1security__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::security::security_exception</a></td><td>The caller does not have the appropriate permission. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to use xtd::directory::set_last_access_time. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1io.html">xtd::io</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>program {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="keywordtype">string</span> <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a> = R<span class="stringliteral">&quot;(c:\MyDir)&quot;;</span></div>
<div class="line"><span class="stringliteral">      </span><span class="keywordflow">if</span> (!directory::exists(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>)) {</div>
<div class="line">        directory::create_directory(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      }</div>
<div class="line">      directory::set_last_access_time(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>, {1985, 5, 4});</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the creation time of a well-known directory.</span></div>
<div class="line">      sdate_time dt = directory::get_last_access_time(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The last access time for this directory was {0}&quot;</span>, dt);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Update the last access time.</span></div>
<div class="line">      directory::set_last_access_time(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>, date_time::now());</div>
<div class="line">      dt = directory::get_last_access_time(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The last access time for this directory was {0}&quot;</span>, dt);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1exception.html">exception</a>&amp; e) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The process failed: {0}&quot;</span>, e.to_string());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(program::main);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a>. </dd>
<dd>
The path parameter is not case-sensitive. </dd>
<dd>
For a list of common I/O tasks, see <a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">Common I/O Tasks</a>. </dd></dl>

</div>
</div>
<a id="a12896e015a6745b3984a2b5cd7cab619" name="a12896e015a6745b3984a2b5cd7cab619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12896e015a6745b3984a2b5cd7cab619">&#9670;&#160;</a></span>set_last_write_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::io::directory::set_last_write_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1date__time.html">xtd::date_time</a> &amp;&#160;</td>
          <td class="paramname"><em>last_write_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the date and time a directory was last written to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the directory. </td></tr>
    <tr><td class="paramname">last_write_time</td><td>The date and time the directory was last written to. This value is expressed in local time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>Attempted to set to an empty string (""). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>An I/O error occurred. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>Attempted to set a local path that cannot be found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1security_1_1security__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::security::security_exception</a></td><td>The caller does not have the appropriate permission. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates how to use xtd::io::set_last_write_time. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1io.html">xtd::io</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>program {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="keywordtype">string</span> <a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a> = R<span class="stringliteral">&quot;(c:\MyDir)&quot;;</span></div>
<div class="line"><span class="stringliteral">      </span><span class="keywordflow">if</span> (!directory::exists(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>)) {</div>
<div class="line">        directory::create_directory(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      }</div>
<div class="line">      directory::set_last_write_time(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>, {1985, 5, 4});</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the creation time of a well-known directory.</span></div>
<div class="line">      <a class="code hl_class" href="classxtd_1_1date__time.html">date_time</a> dt = directory::get_last_write_time(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The last write time for this directory was {0}&quot;</span>, dt);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Update the last write time.</span></div>
<div class="line">      directory::set_last_write_time(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>, date_time::now());</div>
<div class="line">      tp = directory::get_last_write_time(<a class="code hl_class" href="classxtd_1_1io_1_1path.html">path</a>);</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The last write time for this directory was {0}&quot;</span>, dt);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1exception.html">exception</a>&amp; e) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;The process failed: {0}&quot;</span>, e.to_string());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(program::main);</div>
<div class="ttc" id="aclassxtd_1_1date__time_html"><div class="ttname"><a href="classxtd_1_1date__time.html">xtd::date_time</a></div><div class="ttdoc">Represents an instant in time, typically expressed as a date and time of day.</div><div class="ttdef"><b>Definition</b> date_time.hpp:85</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see <a class="el" href="classxtd_1_1io_1_1directory.html#aeb8fa39de0bab437d77a5ce7d336ca29" title="Gets the current working directory of the application.">xtd::io::directory::get_current_directory</a>. </dd>
<dd>
The path parameter is not case-sensitive. </dd>
<dd>
For a list of common I/O tasks, see <a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">Common I/O Tasks</a>. </dd></dl>

</div>
</div>
<a id="a7dfcdc8ab011f53d8c6ec39aced25a1c" name="a7dfcdc8ab011f53d8c6ec39aced25a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfcdc8ab011f53d8c6ec39aced25a1c">&#9670;&#160;</a></span>set_permissions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::io::directory::set_permissions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#gac1ad31e82b8a9af93776488ad7c14843">xtd::io::file_permissions</a>&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the specified <a class="el" href="group__xtd__core.html#gac1ad31e82b8a9af93776488ad7c14843" title="Provides permissions for files and directories.">xtd::io::file_permissions</a> of the directory on the specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the directory. </td></tr>
    <tr><td class="paramname">attributes</td><td>A bitwise combination of the enumeration values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>The directory specified by path is a file. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>path is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the <a class="el" href="classxtd_1_1io_1_1path.html#a2af675f6c167a25a44572be9c3ff4430" title="Gets an array containing the characters that are not allowed in path names.">xtd::io::path::get_invalid_path_chars</a> method. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The specified path, directory name, or both exceed the system-defined maximum length. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a></td><td>The specified path is invalid (for example, it is on an unmapped drive). </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>path contains a colon character (:) that is not part of a drive label ("C:\").
@remarks The path parameter is permitted to specify relative or absolute path information. Relative path information is interpreted as relative to the current working directory. To obtain the current working directory, see xtd::io::directory::get_current_directory.
@remarks For a list of common I/O tasks, see &lt;a href="<a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks">https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Common%20I%3AO%20tasks</a>" &gt;Common I/O Tasks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/io/<a class="el" href="directory_8hpp_source.html">directory.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 6 2025 22:52:46 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
