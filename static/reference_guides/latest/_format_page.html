<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: Format</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Format</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Contains formatting converting documentation.</p>
<h1><a class="anchor" id="FormattingType"></a>
Formatting Types</h1>
<p>Formatting is the process of converting an instance of a class, structure, or enumeration value to its string representation, often so that the resulting string can be displayed to users or deserialized to restore the original data type. This conversion can pose a number of challenges:</p>
<ul>
<li>The way that values are stored internally does not necessarily reflect the way that users want to view them. For example, a telephone number might be stored in the form 8009999999, which is not user-friendly. It should instead be displayed as 800-999-9999. See the CustomFormatStringsSection section for an example that formats a number in this way.</li>
<li>Sometimes the conversion of an object to its string representation is not intuitive. For example, it is not clear how the string representation of a Temperature object or a Person object should appear. For an example that formats a Temperature object in a variety of ways, see the StandardFormatStringsSection section.</li>
<li>Values often require culture-sensitive formatting. For example, in an application that uses numbers to reflect monetary values, numeric strings should include the current culture’s currency symbol, group separator (which, in most cultures, is the thousands separator), and decimal symbol.</li>
<li>An application may have to display the same value in different ways. For example, an application may represent an enumeration member by displaying a string representation of its name or by displaying its underlying value. For an example that formats a member of the day_of_week enumeration in different ways, see the StandardFormatStringsSection section.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Formatting converts the value of a type into a string representation. Parsing is the inverse of formatting. A parsing operation creates an instance of a data type from its string representation.</dd></dl>
<p>xtd provides rich formatting support that enables developers to address these requirements.</p>
<p>This overview contains the following sections:</p><ul>
<li><a class="el" href="#FormattingSection">Formatting</a></li>
<li>DefaultFormattingUsingOperatorShiftLeftSection</li>
<li>OverridingShiftLeftoperatorMethodSection</li>
<li>ToStringMethodAndFormatStringsSection<ul>
<li>StandardFormatStringsSection</li>
<li>CustomFormatStringsSection</li>
<li>FormatStringsAndTypesSection</li>
</ul>
</li>
<li>CultureSensitiveFormattingSection<ul>
<li>CultureSensitiveFormattingOfNumericValuesSection</li>
<li>CultureSensitiveFormattingOfDateAndTimeValuesSection</li>
</ul>
</li>
<li>CultureSensitiveFormattingSection</li>
<li><a class="el" href="#CompositeFormattingSection">Composite Formatting</a></li>
<li>CustomFormattingSection</li>
<li>RelatedTopicsSection</li>
<li>ReferenceSection</li>
</ul>
<h2><a class="anchor" id="FormattingSection"></a>
Formatting</h2>
<p>The basic mechanism for formatting is the default implementation of the operator &lt;&lt; object method, which is discussed in the DefaultFormattingUsingOperatorShiftLeftSection section later in this topic. xtd.Strings provides several ways to modify and extend its default formatting support. These include the following:</p><ul>
<li>Overriding the operator &lt;&lt; object method to define a custom string representation of an object’s value. For more information, see the OverridingShiftLeftoperatorMethodSection section later in this topic.</li>
<li>Defining format specifiers that enable the string representation of an object’s value to take multiple forms. For example, the "X" format specifier in the following statement converts an integer to the string representation of a hexadecimal value.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> integer_value = 60312;</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(<a class="code hl_function" href="namespacextd.html#a2ed47ae86e395ccbe84ab1857c78c4e0">xtd::to_string</a>(integer_value, <span class="stringliteral">&quot;X&quot;</span>));   <span class="comment">// Displays EB98.</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="anamespacextd_html_a2ed47ae86e395ccbe84ab1857c78c4e0"><div class="ttname"><a href="namespacextd.html#a2ed47ae86e395ccbe84ab1857c78c4e0">xtd::to_string</a></div><div class="ttdeci">string to_string() const noexcept override</div><div class="ttdoc">Returns the string representation of this xtd::read_only_span &lt;type_t&gt; object.</div><div class="ttdef"><b>Definition</b> read_only_span.hpp:375</div></div>
</div><!-- fragment --><p>For more information about format specifiers, see the ToStringMethodAndFormatStringsSection section.</p>
<ul>
<li>Using format providers to take advantage of the formatting conventions of a specific culture. For example, the following statement displays a currency value by using the formatting conventions of the en-US culture.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> cost = 1632.54;</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(<a class="code hl_function" href="namespacextd.html#a2ed47ae86e395ccbe84ab1857c78c4e0">xtd::to_string</a>(cost, <span class="stringliteral">&quot;C&quot;</span>, std::locale(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>)));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// $1,632.54</span></div>
</div><!-- fragment --><p>For more information about formatting with format providers, see the CultureSensitiveFormattingSection section.</p>
<ul>
<li>Using composite formatting to embed the string representation of a value in a larger string. For more information, see the <a class="el" href="#CompositeFormattingSection">Composite Formatting</a> section.</li>
</ul>
<p>The following sections examine these methods for converting an object to its string representation.</p>
<h1><a class="anchor" id="CompositeFormattingSection"></a>
Composite Formatting</h1>
<p>The composite formatting feature takes a list of objects and a composite format string as input. A composite format string consists of fixed text intermixed with indexed placeholders, called format items, that correspond to the objects in the list. The formatting operation yields a result string that consists of the original fixed text intermixed with the string representation of the objects in the list.</p>
<p>The composite formatting feature is supported by methods such as the following:</p><ul>
<li>xtd::string::format, which returns a formatted result string (xtd library).</li>
<li>Some overloads of the console::write_line method, which display a formatted result string to the console (xtd.core library).</li>
<li><a class="el" href="classxtd_1_1diagnostics_1_1debug.html#a2656cc128804128258ecad60ecf1cbd1" title="Writes a line terminator to the trace listeners in the listeners collection.">xtd::diagnostics::debug::write_line</a> method, which outputs a formatted message to trace listeners (xtd.core library).</li>
<li>The <a class="el" href="classxtd_1_1diagnostics_1_1trace.html#a62bb0ba1047d848268378be8ee54747f" title="Writes an error message to the trace listeners in the Listeners collection using the specified messag...">xtd::diagnostics::trace::trace_error</a>, <a class="el" href="classxtd_1_1diagnostics_1_1trace.html#a75140c992dcc637f048c470877a064bb" title="Writes an informational message to the trace listeners in the listeners collection using the specifie...">xtd::diagnostics::trace::trace_information</a>, and <a class="el" href="classxtd_1_1diagnostics_1_1trace.html#a9a68c5b743f292aaa9e8dbff9a55eed8" title="Writes a warning message to the trace listeners in the listeners collection using the specified messa...">xtd::diagnostics::trace::trace_warning</a> methods, which output formatted messages to trace listeners (xtd.core library).</li>
</ul>
<h2><a class="anchor" id="CompositeFormatStringSection"></a>
Composite Format String</h2>
<p>A composite format string and object list are used as arguments of methods that support the composite formatting feature. A composite format string consists of zero or more runs of fixed text intermixed with one or more format items. The fixed text is any string that you choose, and each format item corresponds to an object or boxed structure in the list. The composite formatting feature returns a new result string where each format item is replaced by the string representation of the corresponding object in the list.</p>
<p>Consider the following Format code fragment.</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> name = <span class="stringliteral">&quot;Fred&quot;</span>;</div>
<div class="line">xtd::string::format(<span class="stringliteral">&quot;Name = {0}, age = {1:D3}&quot;</span>, name, 42);</div>
</div><!-- fragment --><p>The fixed text is "Name = " and ", age = ". The format items are "{0}", whose index is 0, which corresponds to the object name, and "{1:D3}", whose index is 1, which corresponds to the integer 42.</p>
<h2><a class="anchor" id="FormatItemSyntaxSection"></a>
Format Item Syntax</h2>
<p>Each format item takes the following form and consists of the following components:</p>
<h3>{[<b>index</b>][<b>,alignment</b>][<b>:format_string</b>]}</h3>
<p>The matching braces ("{" and "}") are required.</p>
<h3><a class="anchor" id="IndexComponentSection"></a>
Index Component</h3>
<p>The optional index component, also called a parameter specifier, is a number starting from 0 that identifies a corresponding item in the list of objects. That is, the format item whose parameter specifier is 0 formats the first object in the list, the format item whose parameter specifier is 1 formats the second object in the list, and so on. The following example includes four parameter specifiers, numbered zero through three, to represent prime numbers less than ten:</p>
<div class="fragment"><div class="line">std::string primes;</div>
<div class="line">primes = xtd::string::format(<span class="stringliteral">&quot;Prime numbers less than 10: {0}, {1}, {2}, {3}&quot;</span>, 2, 3, 5, 7 );</div>
<div class="line">std::cout &lt;&lt; primes &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Prime numbers less than 10: 2, 3, 5, 7</span></div>
</div><!-- fragment --><p>Multiple format items can refer to the same element in the list of objects by specifying the same parameter specifier. For example, you can format the same numeric value in hexadecimal, scientific, and number format by specifying a composite format string such as : "0x{0:X} {0:E} {0:N}", as the following example shows.</p>
<div class="fragment"><div class="line">std::string multiple = xtd::string::format(<span class="stringliteral">&quot;0x{0:X} {0:E} {0:N}&quot;</span>, std::numeric_limits&lt;long long&gt;::max());</div>
<div class="line">std::cout &lt;&lt; multiple &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0x7FFFFFFFFFFFFFFF 9.223372E+18 9,223,372,036,854,775,807.00</span></div>
</div><!-- fragment --><p>Each format item can refer to any object in the list. For example, if there are three objects, you can format the second, first, and third object by specifying a composite format string like this: "{1} {0} {2}". An object that is not referenced by a format item is ignored. A std::argument_error is thrown at runtime if a parameter specifier designates an item outside the bounds of the list of objects.</p>
<p>If the index component is not specified, it will be automatically generated in the order of the argument list.</p>
<p>The following example shows format without specified index:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; xtd::string::format(<span class="stringliteral">&quot;{} {} {:F2}&quot;</span>, 1, <span class="stringliteral">&quot;two&quot;</span>, 3.0) &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1 two 3.00</span></div>
</div><!-- fragment --><h3><a class="anchor" id="AlignmentComponentSection"></a>
Alignment Component</h3>
<p>The optional alignment component is a signed integer indicating the preferred formatted field width. If the value of alignment is less than the length of the formatted string, alignment is ignored and the length of the formatted string is used as the field width. The formatted data in the field is right-aligned if alignment is positive and left-aligned if alignment is negative. If padding is necessary, white space is used. The comma is required if alignment is specified.</p>
<p>The following example defines two arrays, one containing the names of employees and the other containing the hours they worked over a two-week period. The composite format string left-aligns the names in a 20-character field, and right-aligns their hours in a 5-character field. Note that the "N1" standard format string is also used to format the hours with one fractional digit.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">xtd::array</a> names = {<span class="stringliteral">&quot;Adam&quot;</span>, <span class="stringliteral">&quot;Bridgette&quot;</span>, <span class="stringliteral">&quot;Carla&quot;</span>, <span class="stringliteral">&quot;Daniel&quot;</span>, <span class="stringliteral">&quot;Ebenezer&quot;</span>, <span class="stringliteral">&quot;Francine&quot;</span>, <span class="stringliteral">&quot;George&quot;</span>};</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">xtd::array</a> hours = {40.0, 6.667, 40.39, 82.0, 40.333, 80.0, 16.75};</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_variable" href="classxtd_1_1console.html#a923837ac84baf01726703e0474ca4888">xtd::console::out</a> &lt;&lt; xtd::string::format(<span class="stringliteral">&quot;{0,-20} {1,5}\n&quot;</span>, <span class="stringliteral">&quot;Name&quot;</span>, <span class="stringliteral">&quot;Hours&quot;</span>) &lt;&lt; <a class="code hl_function" href="classxtd_1_1environment.html#a19a9aa87ee20eb3789058621ed161c4e">xtd::environment::new_line</a>;</div>
<div class="line">  <span class="keywordflow">for</span> (<a class="code hl_typedef" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> ctr = 0; ctr &lt; names.<a class="code hl_function" href="classxtd_1_1basic__array.html#af2ad3488e28e4140835dece83723e7eb">size</a>(); ctr++)</div>
<div class="line">    <a class="code hl_variable" href="classxtd_1_1console.html#a923837ac84baf01726703e0474ca4888">xtd::console::out</a> &lt;&lt; xtd::string::format(<span class="stringliteral">&quot;{0,-20} {1,5:N1}&quot;</span>, names[ctr], hours[ctr]) &lt;&lt; <a class="code hl_function" href="classxtd_1_1environment.html#a19a9aa87ee20eb3789058621ed161c4e">xtd::environment::new_line</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Name                 Hours</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Adam                  40.0</span></div>
<div class="line"><span class="comment">// Bridgette              6.7</span></div>
<div class="line"><span class="comment">// Carla                 40.4</span></div>
<div class="line"><span class="comment">// Daniel                82.0</span></div>
<div class="line"><span class="comment">// Ebenezer              40.3</span></div>
<div class="line"><span class="comment">// Francine              80.0</span></div>
<div class="line"><span class="comment">// George                16.8</span></div>
<div class="ttc" id="aclassxtd_1_1array_html"><div class="ttname"><a href="classxtd_1_1array.html">xtd::array</a></div><div class="ttdoc">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...</div><div class="ttdef"><b>Definition</b> array.hpp:61</div></div>
<div class="ttc" id="aclassxtd_1_1basic__array_html_af2ad3488e28e4140835dece83723e7eb"><div class="ttname"><a href="classxtd_1_1basic__array.html#af2ad3488e28e4140835dece83723e7eb">xtd::basic_array::size</a></div><div class="ttdeci">virtual size_type size() const noexcept</div><div class="ttdoc">Returns the number of elements in the container, i.e. std::distance(xtd::array::begin(),...</div><div class="ttdef"><b>Definition</b> basic_array.hpp:229</div></div>
<div class="ttc" id="aclassxtd_1_1console_html_a923837ac84baf01726703e0474ca4888"><div class="ttname"><a href="classxtd_1_1console.html#a923837ac84baf01726703e0474ca4888">xtd::console::out</a></div><div class="ttdeci">static std::ostream out</div><div class="ttdoc">Gets the standard output stream. A std::basic_ostream&lt;char_t&gt; that represents the standard output str...</div><div class="ttdef"><b>Definition</b> console.hpp:52</div></div>
<div class="ttc" id="aclassxtd_1_1environment_html_a19a9aa87ee20eb3789058621ed161c4e"><div class="ttname"><a href="classxtd_1_1environment.html#a19a9aa87ee20eb3789058621ed161c4e">xtd::environment::new_line</a></div><div class="ttdeci">static xtd::string new_line() noexcept</div><div class="ttdoc">Gets the newline string defined for this environment.</div></div>
<div class="ttc" id="agroup__types_html_ga221e5b824352c9046d353e4659af5b87"><div class="ttname"><a href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">Represents a size of any object in bytes.</div><div class="ttdef"><b>Definition</b> size.hpp:23</div></div>
</div><!-- fragment --><h3><a class="anchor" id="FormatStringComponentSection"></a>
Format String Component</h3>
<p>The optional formatString component is a format string that is appropriate for the type of object being formatted. Specify a numeric format string if the corresponding object is a numeric value, or an enumeration format string if the corresponding object is an enumeration value. If formatString is not specified, the general ("G") format specifier for a numeric or enumeration type is used. The colon is required if formatString is specified.</p>
<p>The following table lists types or categories of types that support a predefined set of format strings, and provides links to the topics that list the supported format strings. Note that string formatting is an extensible mechanism that makes it possible to define new format strings for all existing types as well as to define a set of format strings supported by an application-defined type. For more information, see CustomFormatSection.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"> Type or Type category   </th><th class="markdownTableHeadNone">See    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Boolean type (bool)   </td><td class="markdownTableBodyNone">BooleanFormatSection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Date and time type (std::chrono::time_point, std::time_t)   </td><td class="markdownTableBodyNone">DateTimeFormatSection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Duration type (std::chrono::duration)   </td><td class="markdownTableBodyNone">DurationFormatSection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Enumeration types (all enum or enum class types)   </td><td class="markdownTableBodyNone">EnumerationFormatSection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Numeric types (char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long, float, double and long double)   </td><td class="markdownTableBodyNone"><a class="el" href="#NumericFormatSection">Numeric format</a>   </td></tr>
</table>
<h3><a class="anchor" id="EscapingBracesSubsucsection"></a>
Escaping Braces</h3>
<p>Opening and closing braces are interpreted as starting and ending a format item. Consequently, you must use an escape sequence to display a literal opening brace or closing brace. Specify two opening braces ("{{") in the fixed text to display one opening brace ("{"), or two closing braces ("}}") to display one closing brace ("}"). Braces in a format item are interpreted sequentially in the order they are encountered. Interpreting nested braces is not supported.</p>
<p>The way escaped braces are interpreted can lead to unexpected results. For example, consider the format item "{{{0:D}}}", which is intended to display an opening brace, a numeric value formatted as a decimal number, and a closing brace. However, the format item is actually interpreted in the following manner:</p>
<ol type="1">
<li>The first two opening braces ("{{") are escaped and yield one opening brace.</li>
<li>The next three characters ("{0:") are interpreted as the start of a format item.</li>
<li>The next character ("D") would be interpreted as the Decimal standard numeric format specifier, but the next two escaped braces ("}}") yield a single brace. Because the resulting string ("D}") is not a standard numeric format specifier, the resulting string is interpreted as a custom format string that means display the literal string "D}".</li>
<li>The last brace ("}") is interpreted as the end of the format item.</li>
<li>he final result that is displayed is the literal string, "{D}". The numeric value that was to be formatted is not displayed.</li>
</ol>
<p>One way to write your code to avoid misinterpreting escaped braces and format items is to format the braces and format item separately. That is, in the first format operation display a literal opening brace, in the next operation display the result of the format item, then in the final operation display a literal closing brace. The following example illustrates this approach.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> value = 6324;</div>
<div class="line">std::string output = xtd::string::format(<span class="stringliteral">&quot;{0}{1:D}{2}&quot;</span>, <span class="stringliteral">&quot;{&quot;</span>, value, <span class="stringliteral">&quot;}&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; output &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// The example displays the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// {6324}</span></div>
</div><!-- fragment --><h2><a class="anchor" id="CodeExamplesSection"></a>
Code Examples</h2>
<p>The following example shows one string created using composite formatting and another created using <a class="el" href="namespacextd.html#a2ed47ae86e395ccbe84ab1857c78c4e0" title="Returns the string representation of this xtd::read_only_span &lt;type_t&gt; object.">xtd::to_string</a> method. Both types of formatting produce equivalent results.</p>
<div class="fragment"><div class="line">std::string format_string1 = xtd::string::format(<span class="stringliteral">&quot;0:X4&quot;</span>, std::numeric_limits&lt;short&gt;::max());</div>
<div class="line">std::string format_string2 = xtd::to_ustring::format(std::numeric_limits&lt;short&gt;::max(), <span class="stringliteral">&quot;X4&quot;</span>);</div>
</div><!-- fragment --><p><a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">xtd::console::write_line</a> exposes the same functionality as xtd::string::format. The only difference between the two methods is that xtd::string::format returns its result as a string, while <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">xtd::console::write_line</a> writes the result to the output stream (std::cout) associated with the console object. The following example uses the <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">xtd::console::write_line</a> method to format the value of my_int to a currency value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_int = 100;</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(<span class="stringliteral">&quot;{0:C}&quot;</span>, my_int);</div>
<div class="line"><span class="comment">// The example displays the following output if en-US is the current culture:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// $100.00</span></div>
</div><!-- fragment --><p>The following example demonstrates formatting multiple objects, including formatting one object two different ways.</p>
<div class="fragment"><div class="line">std::string my_name = <span class="stringliteral">&quot;Fred&quot;</span>;</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(xtd::string::format(<span class="stringliteral">&quot;Name = {0}, hours = {1:hh}, minutes = {1:mm}&quot;</span>, myName, date_time::now()));</div>
<div class="line"><span class="comment">// Depending on the current time, the example displays output like the following:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Name = Fred, hours = 11, minutes = 30</span></div>
</div><!-- fragment --><p>The following example demonstrates the use of alignment in formatting. The arguments that are formatted are placed between vertical bar characters (|) to highlight the resulting alignment.</p>
<div class="fragment"><div class="line">std::string my_first_name = <span class="stringliteral">&quot;Fred&quot;</span>;</div>
<div class="line">std::string my_last_name = <span class="stringliteral">&quot;Opals&quot;</span>;</div>
<div class="line"><span class="keywordtype">int</span> myInt = 100;</div>
<div class="line">std::string format_first_name = xtd::string::format(<span class="stringliteral">&quot;First Name = |{0,10}|&quot;</span>, my_first_name);</div>
<div class="line">std::string format_last_name = xtd::string::format(<span class="stringliteral">&quot;Last Name = |{0,10}|&quot;</span>, my_last_name);</div>
<div class="line">std::string format_price = xtd::string::format(<span class="stringliteral">&quot;Price = |{0,10:C}|&quot;</span>, myInt);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(format_first_name);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(format_last_name);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(format_price);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>();</div>
<div class="line"> </div>
<div class="line">format_first_name = xtd::string::format(<span class="stringliteral">&quot;First Name = |{0,-10}|&quot;</span>, my_first_name);</div>
<div class="line">format_last_name = xtd::string::format(<span class="stringliteral">&quot;Last Name = |{0,-10}|&quot;</span>, my_last_name);</div>
<div class="line">format_price = xtd::string::format(<span class="stringliteral">&quot;Price = |{0,-10:C}|&quot;</span>, myInt);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(format_first_name);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(format_last_name);</div>
<div class="line"><a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a>(format_price);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The example displays the following output on a system whose current culture is en-US:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// First Name = |      Fred|</span></div>
<div class="line"><span class="comment">// Last Name = |     Opals|</span></div>
<div class="line"><span class="comment">// Price = |   $100.00|</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// First Name = |Fred      |</span></div>
<div class="line"><span class="comment">// Last Name = |Opals     |</span></div>
<div class="line"><span class="comment">// Price = |$100.00   |</span></div>
</div><!-- fragment --><h1><a class="anchor" id="NumericFormatSection"></a>
Numeric format</h1>
<p>Standard numeric format strings are used to format common numeric types. A standard numeric format string takes the form <b>Axx</b>, where:</p><ul>
<li><b>A</b> is a single alphabetic character called the format specifier.</li>
<li><b>xx</b> is an optional integer called the precision specifier. The precision specifier ranges from 0 to 99 and affects the number of digits in the result. Note that the precision specifier controls the number of digits in the string representation of a number. It does not round the number itself. To perform a rounding operation, use the std::ceil, std::floor, or std::round method. When precision specifier controls the number of fractional digits in the result string, the result string reflects a number that is rounded to a representable result nearest to the infinitely precise result.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The precision specifier determines the number of digits in the result string. To pad a result string with leading or trailing spaces, use the <a class="el" href="#CompositeFormattingSection">Composite Formatting</a> feature and define an alignment component in the format item. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 19 2025 18:04:30 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
