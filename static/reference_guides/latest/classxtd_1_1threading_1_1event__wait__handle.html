<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::event_wait_handle Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1threading_1_1event__wait__handle-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::event_wait_handle Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::event_wait_handle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1event__wait__handle.png" usemap="#xtd::threading::event_5Fwait_5Fhandle_map" alt=""/>
  <map id="xtd::threading::event_5Fwait_5Fhandle_map" name="xtd::threading::event_5Fwait_5Fhandle_map">
<area href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources." alt="xtd::threading::wait_handle" shape="rect" coords="0,112,232,136"/>
<area href="classxtd_1_1icomparable.html" alt="xtd::icomparable&lt; event_wait_handle &gt;" shape="rect" coords="242,112,474,136"/>
<area href="classxtd_1_1iequatable.html" alt="xtd::iequatable&lt; event_wait_handle &gt;" shape="rect" coords="484,112,716,136"/>
<area href="classxtd_1_1abstract__object.html" title="Represent an abstract class." alt="xtd::abstract_object" shape="rect" coords="0,56,232,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="242,56,474,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="484,56,716,80"/>
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,232,24"/>
<area href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a..." alt="xtd::threading::auto_reset_event" shape="rect" coords="121,224,353,248"/>
<area href="classxtd_1_1threading_1_1manual__reset__event.html" title="Represents a thread synchronization event that, when signaled, must be reset manually...." alt="xtd::threading::manual_reset_event" shape="rect" coords="363,224,595,248"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Represents a thread synchronization event. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a>, <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1icomparable.html">xtd::icomparable</a> &lt; xtd::threading::event_wait_handle &gt;, <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1iequatable.html">xtd::iequatable</a>&lt;xtd::threading::event_wait_handle&gt;</div>
<div class="ttc" id="aclassxtd_1_1icomparable_html"><div class="ttname"><a href="classxtd_1_1icomparable.html">xtd::icomparable</a></div><div class="ttdoc">Defines a generalized comparison method that a value type or class implements to create a type-specif...</div><div class="ttdef"><b>Definition</b> icomparable.h:17</div></div>
<div class="ttc" id="aclassxtd_1_1iequatable_html"><div class="ttname"><a href="classxtd_1_1iequatable.html">xtd::iequatable</a></div><div class="ttdoc">Defines a generalized method that a value type or class implements to create a type-specific method f...</div><div class="ttdef"><b>Definition</b> iequatable.h:18</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1event__wait__handle_html"><div class="ttname"><a href="classxtd_1_1threading_1_1event__wait__handle.html">xtd::threading::event_wait_handle</a></div><div class="ttdoc">Represents a thread synchronization event.</div><div class="ttdef"><b>Definition</b> event_wait_handle.h:35</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1wait__handle_html"><div class="ttname"><a href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></div><div class="ttdoc">Encapsulates operating system specific objects that wait for exclusive access to shared resources.</div><div class="ttdef"><b>Definition</b> wait_handle.h:48</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/event_wait_handle&gt;</span> </div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class allows threads to communicate with each other by signaling. Typically, one or more threads block on an <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> until an unblocked thread calls the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c" title="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">xtd::threading::event_wait_handle::set</a> method, releasing one or more of the blocked threads. A thread can signal an <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> and then block on it, by calling the static <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a01c82b06ca8a5d14aba5f1fb396c16f7" title="Signals one xtd::threading::wait_handle and waits on another.">xtd::threading::wait_handle::signal_and_wait</a> method. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class provides access to named system synchronization events. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The behavior of an <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> that has been signaled depends on its reset mode. An <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> created with the <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ad15df6f4bb58577e7078575bd2924794" title="When signaled, the xtd::threading::event_wait_handle resets automatically after releasing a single th...">xtd::threading::event_reset_mode::auto_reset</a> flag resets automatically when signaled, after releasing a single waiting thread. An <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> created with the <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ae24e926926861449731fb9418399a53d" title="When signaled, the xtd::threading::event_wait_handle releases all waiting threads and remains signale...">xtd::threading::event_reset_mode::manual_reset</a> flag remains signaled until its Reset method is called. </dd>
<dd>
Automatic reset events provide exclusive access to a resource. If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it. The event releases the thread and immediately resets, blocking subsequent threads. </dd>
<dd>
Manual reset events are like gates. When the event is not signaled, threads that wait on it will block. When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#afad8a8b6d18cec770c3688e02e2154da" title="Sets the state of the event to nonsignaled, causing threads to block.">xtd::threading::event_wait_handle::reset</a> method is called. Manual reset events are useful when one thread must complete an activity before other threads can proceed. </dd>
<dd>
<a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> objects can be used with the static xtd::threading::wait_handle::wWait_all and <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a> methods. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example uses the <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a01c82b06ca8a5d14aba5f1fb396c16f7" title="Signals one xtd::threading::wait_handle and waits on another.">xtd::threading::wait_handle::signal_and_wait(xtd::threading::wait_handle&amp;, xtd::threading::wait_handle&amp;)</a> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.<br  />
<br  />
 The example starts five threads and allows them to block on an <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> created with the <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ad15df6f4bb58577e7078575bd2924794" title="When signaled, the xtd::threading::event_wait_handle resets automatically after releasing a single th...">xtd::threading::event_reset_mode::auto_reset</a> flag, then releases one thread each time the user presses the Enter key. The example then queues another five threads and releases them all using an <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> created with the <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ae24e926926861449731fb9418399a53d" title="When signaled, the xtd::threading::event_wait_handle releases all waiting threads and remains signale...">xtd::threading::event_reset_mode::manual_reset</a> flag. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/event_wait_handle&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/interlocked&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/startup&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1threading.html">xtd::threading</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>example {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// The event_wait_handle used to demonstrate the difference</span></div>
<div class="line">  <span class="comment">// between auto_reset and manual_reset synchronization events.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code hl_class" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a> ewh;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// A counter to make sure all threads are started and</span></div>
<div class="line">  <span class="comment">// blocked before any are released. A Long is used to show</span></div>
<div class="line">  <span class="comment">// the use of the 64-bit Interlocked methods.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code hl_typedef" href="group__types.html#ga7ab879ebcae19d6021222f00537cfdce">int64</a> thread_count = 0;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// An auto_reset event that allows the main thread to block</span></div>
<div class="line">  <span class="comment">// until an exiting thread has decremented the count.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code hl_class" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a> clear_count {<span class="keyword">false</span>, event_reset_mode::auto_reset};</div>
<div class="line">  </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">    <span class="comment">// Create an auto_reset event_wait_handle.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    ewh = <a class="code hl_class" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a> {<span class="keyword">false</span>, event_reset_mode::auto_reset};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create and start five numbered threads. Use the</span></div>
<div class="line">    <span class="comment">// ParameterizedThreadStart delegate, so the thread</span></div>
<div class="line">    <span class="comment">// number can be passed as an argument to the Start</span></div>
<div class="line">    <span class="comment">// method.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> &lt;= 4; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>++) {</div>
<div class="line">      threads_[<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>] = <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a> {thread_proc};</div>
<div class="line">      threads_[i].<a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">start</a>(i);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait until all the threads have started and blocked.</span></div>
<div class="line">    <span class="comment">// When multiple threads use a 64-bit value on a 32-bit</span></div>
<div class="line">    <span class="comment">// system, you must access the value through the</span></div>
<div class="line">    <span class="comment">// Interlocked class to guarantee thread safety.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">while</span> (interlocked::read(thread_count) &lt; 5) {</div>
<div class="line">      thread::sleep(500);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Release one thread each time the user presses ENTER,</span></div>
<div class="line">    <span class="comment">// until all threads have been released.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">while</span> (interlocked::read(thread_count) &gt; 0) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;Press ENTER to release a waiting thread.&quot;</span>);</div>
<div class="line">      console::read_line();</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// SignalAndWait signals the event_wait_handle, which</span></div>
<div class="line">      <span class="comment">// releases exactly one thread before resetting,</span></div>
<div class="line">      <span class="comment">// because it was created with auto_reset mode.</span></div>
<div class="line">      <span class="comment">// SignalAndWait then blocks on clear_count, to</span></div>
<div class="line">      <span class="comment">// allow the signaled thread to decrement the count</span></div>
<div class="line">      <span class="comment">// before looping again.</span></div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      wait_handle::signal_and_wait(ewh, clear_count);</div>
<div class="line">    }</div>
<div class="line">    console::write_line();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create a manual_reset event_wait_handle.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    ewh = <a class="code hl_class" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a>(<span class="keyword">false</span>, event_reset_mode::manual_reset);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create and start five more numbered threads.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> i = 0; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> &lt;= 4; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>++) {</div>
<div class="line">      threads_[<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>] = <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a> {thread_proc};</div>
<div class="line">      threads_[<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>].<a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">start</a>(i);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait until all the threads have started and blocked.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">while</span> (interlocked::read(thread_count) &lt; 5) {</div>
<div class="line">      thread::sleep(500);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Because the event_wait_handle was created with</span></div>
<div class="line">    <span class="comment">// manual_reset mode, signaling it releases all the</span></div>
<div class="line">    <span class="comment">// waiting threads.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Press ENTER to release the waiting threads.&quot;</span>);</div>
<div class="line">    console::read_line();</div>
<div class="line">    ewh.<a class="code hl_function" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c">set</a>();</div>
<div class="line">    </div>
<div class="line">    thread::join_all(threads_);</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc(std::any data) {</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Thread {0} blocks.&quot;</span>, as&lt;int&gt;(data));</div>
<div class="line">    <span class="comment">// Increment the count of blocked threads.</span></div>
<div class="line">    interlocked::increment(thread_count);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait on the event_wait_handle.</span></div>
<div class="line">    ewh.<a class="code hl_function" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87">wait_one</a>();</div>
<div class="line">    </div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Thread {0} exits.&quot;</span>, as&lt;int&gt;(data));</div>
<div class="line">    <span class="comment">// Decrement the count of blocked threads.</span></div>
<div class="line">    interlocked::decrement(thread_count);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// After signaling ewh, the main thread blocks on</span></div>
<div class="line">    <span class="comment">// clear_count until the signaled thread has</span></div>
<div class="line">    <span class="comment">// decremented the count. Signal it now.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    clear_count.set();</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">inline</span> <span class="keyword">static</span> std::array&lt;thread, 5&gt; threads_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(example::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example produces output similar to the following:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Thread 2 blocks.</span></div>
<div class="line"><span class="comment">// Thread 4 blocks.</span></div>
<div class="line"><span class="comment">// Thread 0 blocks.</span></div>
<div class="line"><span class="comment">// Thread 1 blocks.</span></div>
<div class="line"><span class="comment">// Thread 3 blocks.</span></div>
<div class="line"><span class="comment">// Press ENTER to release a waiting thread.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Thread 4 exits.</span></div>
<div class="line"><span class="comment">// Press ENTER to release a waiting thread.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Thread 2 exits.</span></div>
<div class="line"><span class="comment">// Press ENTER to release a waiting thread.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Thread 0 exits.</span></div>
<div class="line"><span class="comment">// Press ENTER to release a waiting thread.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Thread 1 exits.</span></div>
<div class="line"><span class="comment">// Press ENTER to release a waiting thread.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Thread 3 exits.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Thread 0 blocks.</span></div>
<div class="line"><span class="comment">// Thread 1 blocks.</span></div>
<div class="line"><span class="comment">// Thread 3 blocks.</span></div>
<div class="line"><span class="comment">// Thread 2 blocks.</span></div>
<div class="line"><span class="comment">// Thread 4 blocks.</span></div>
<div class="line"><span class="comment">// Press ENTER to release the waiting threads.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Thread 2 exits.</span></div>
<div class="line"><span class="comment">// Thread 1 exits.</span></div>
<div class="line"><span class="comment">// Thread 4 exits.</span></div>
<div class="line"><span class="comment">// Thread 3 exits.</span></div>
<div class="line"><span class="comment">// Thread 0 exits.</span></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1event__wait__handle_html_a3254163aa012cb3dc8f99ff16c0c7d6c"><div class="ttname"><a href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c">xtd::threading::event_wait_handle::set</a></div><div class="ttdeci">bool set()</div><div class="ttdoc">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html">xtd::threading::thread</a></div><div class="ttdoc">Creates and controls a thread, sets its priority, and gets its status.</div><div class="ttdef"><b>Definition</b> thread.h:41</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html_a573cca51d21d56dcf79eaace281b74b0"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">xtd::threading::thread::start</a></div><div class="ttdeci">void start()</div><div class="ttdoc">Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1wait__handle_html_ab53dcefc6844ecf0d6d9967ac489ac87"><div class="ttname"><a href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87">xtd::threading::wait_handle::wait_one</a></div><div class="ttdeci">virtual bool wait_one()</div><div class="ttdoc">Blocks the current thread until the current xtd::threading::wait_handle receives a signal.</div></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.h:162</div></div>
<div class="ttc" id="agroup__types_html_ga7ab879ebcae19d6021222f00537cfdce"><div class="ttname"><a href="group__types.html#ga7ab879ebcae19d6021222f00537cfdce">xtd::int64</a></div><div class="ttdeci">int_least64_t int64</div><div class="ttdoc">Represents a 64-bit signed integer.</div><div class="ttdef"><b>Definition</b> types.h:140</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">xtd::console_key::i</a></div><div class="ttdeci">@ i</div><div class="ttdoc">The I key.</div></div>
<div class="ttc" id="anamespacextd_1_1threading_html"><div class="ttname"><a href="namespacextd_1_1threading.html">xtd::threading</a></div><div class="ttdoc">The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....</div><div class="ttdef"><b>Definition</b> abandoned_mutex_exception.h:10</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> system_report.h:17</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="event_wait_handle_8cpp-example.html#_a0">event_wait_handle.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors</h2></td></tr>
<tr class="memitem:a955143ff0600450c82aa495a98584569"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a955143ff0600450c82aa495a98584569">event_wait_handle</a> (bool initial_state)</td></tr>
<tr class="memdesc:a955143ff0600450c82aa495a98584569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled.  <br /></td></tr>
<tr class="separator:a955143ff0600450c82aa495a98584569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2291371a49ff3530aab2e4e57256cd52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a2291371a49ff3530aab2e4e57256cd52">event_wait_handle</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name)</td></tr>
<tr class="memdesc:a2291371a49ff3530aab2e4e57256cd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying the name.  <br /></td></tr>
<tr class="separator:a2291371a49ff3530aab2e4e57256cd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cba329aeeb58306fe62fde4068ce5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a20cba329aeeb58306fe62fde4068ce5d">event_wait_handle</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name, bool &amp;created_new)</td></tr>
<tr class="memdesc:a20cba329aeeb58306fe62fde4068ce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a bool variable whose value after the call indicates whether the named system event was created.  <br /></td></tr>
<tr class="separator:a20cba329aeeb58306fe62fde4068ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606abdc7f39d74fe6a541f8c333fac55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a606abdc7f39d74fe6a541f8c333fac55">event_wait_handle</a> (bool initial_state, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name)</td></tr>
<tr class="memdesc:a606abdc7f39d74fe6a541f8c333fac55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, and the name of a system synchronization event.  <br /></td></tr>
<tr class="separator:a606abdc7f39d74fe6a541f8c333fac55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3f634eba0b202bbd4766b6e1107863"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a7f3f634eba0b202bbd4766b6e1107863">event_wait_handle</a> (bool initial_state, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name, bool &amp;created_new)</td></tr>
<tr class="memdesc:a7f3f634eba0b202bbd4766b6e1107863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, the name of a system synchronization event, and a bool variable whose value after the call indicates whether the named system event was created.  <br /></td></tr>
<tr class="separator:a7f3f634eba0b202bbd4766b6e1107863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2cae6b22eca173f8c84769ea2a0424"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#afd2cae6b22eca173f8c84769ea2a0424">event_wait_handle</a> (bool initial_state, <a class="el" href="group__threading.html#ga0d88594f6d137d04a3d0aa7b102664b3">event_reset_mode</a> mode)</td></tr>
<tr class="memdesc:afd2cae6b22eca173f8c84769ea2a0424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.  <br /></td></tr>
<tr class="separator:afd2cae6b22eca173f8c84769ea2a0424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9de462db14bdf5a591acaaef6d6098f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#ae9de462db14bdf5a591acaaef6d6098f">event_wait_handle</a> (bool initial_state, <a class="el" href="group__threading.html#ga0d88594f6d137d04a3d0aa7b102664b3">event_reset_mode</a> mode, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name)</td></tr>
<tr class="memdesc:ae9de462db14bdf5a591acaaef6d6098f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.  <br /></td></tr>
<tr class="separator:ae9de462db14bdf5a591acaaef6d6098f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d33ea81f346c673cc0a1326524009d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a72d33ea81f346c673cc0a1326524009d">event_wait_handle</a> (bool initial_state, <a class="el" href="group__threading.html#ga0d88594f6d137d04a3d0aa7b102664b3">event_reset_mode</a> mode, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name, bool &amp;created_new)</td></tr>
<tr class="memdesc:a72d33ea81f346c673cc0a1326524009d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a bool variable whose value after the call indicates whether the named system event was created.  <br /></td></tr>
<tr class="separator:a72d33ea81f346c673cc0a1326524009d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Properties</h2></td></tr>
<tr class="memitem:a96d6a6e016d598ac4eab6916b1fe756c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a96d6a6e016d598ac4eab6916b1fe756c">handle</a> () const noexcept override</td></tr>
<tr class="memdesc:a96d6a6e016d598ac4eab6916b1fe756c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the native operating system handle.  <br /></td></tr>
<tr class="separator:a96d6a6e016d598ac4eab6916b1fe756c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9768d5b08aa592b96e4fb7880471b041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a9768d5b08aa592b96e4fb7880471b041">handle</a> (<a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a> value) override</td></tr>
<tr class="memdesc:a9768d5b08aa592b96e4fb7880471b041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the native operating system handle.  <br /></td></tr>
<tr class="separator:a9768d5b08aa592b96e4fb7880471b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods</h2></td></tr>
<tr class="memitem:a25cd50beb10d27e546af15506fa98465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a25cd50beb10d27e546af15506fa98465">close</a> () override</td></tr>
<tr class="memdesc:a25cd50beb10d27e546af15506fa98465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all resources held by the current <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>.  <br /></td></tr>
<tr class="separator:a25cd50beb10d27e546af15506fa98465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc2c05478fe39adf25ea9c51bcc194c"><td class="memItemLeft" align="right" valign="top"><a id="a5dc2c05478fe39adf25ea9c51bcc194c" name="a5dc2c05478fe39adf25ea9c51bcc194c"></a>
<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compare_to</b> (const <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a> &amp;value) const noexcept override</td></tr>
<tr class="separator:a5dc2c05478fe39adf25ea9c51bcc194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab054b607d74396eab935607793454d69"><td class="memItemLeft" align="right" valign="top"><a id="ab054b607d74396eab935607793454d69" name="ab054b607d74396eab935607793454d69"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a> &amp;value) const noexcept override</td></tr>
<tr class="separator:ab054b607d74396eab935607793454d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad8a8b6d18cec770c3688e02e2154da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#afad8a8b6d18cec770c3688e02e2154da">reset</a> ()</td></tr>
<tr class="memdesc:afad8a8b6d18cec770c3688e02e2154da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state of the event to nonsignaled, causing threads to block.  <br /></td></tr>
<tr class="separator:afad8a8b6d18cec770c3688e02e2154da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3254163aa012cb3dc8f99ff16c0c7d6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c">set</a> ()</td></tr>
<tr class="memdesc:a3254163aa012cb3dc8f99ff16c0c7d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.  <br /></td></tr>
<tr class="separator:a3254163aa012cb3dc8f99ff16c0c7d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ea49911ec81e86d193049aac25fd67"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a93ea49911ec81e86d193049aac25fd67">open_existing</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name)</td></tr>
<tr class="memdesc:a93ea49911ec81e86d193049aac25fd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the specified named synchronization event, if it already exists.  <br /></td></tr>
<tr class="separator:a93ea49911ec81e86d193049aac25fd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574bd9f733a6ba3317cf1859874f3335"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a574bd9f733a6ba3317cf1859874f3335">try_open_existing</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name, <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a> &amp;result) noexcept</td></tr>
<tr class="memdesc:a574bd9f733a6ba3317cf1859874f3335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.  <br /></td></tr>
<tr class="separator:a574bd9f733a6ba3317cf1859874f3335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Protected methods</h2></td></tr>
<tr class="memitem:aaa4488a58c5f9a3d9275edcef7db8506"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#aaa4488a58c5f9a3d9275edcef7db8506">signal</a> () override</td></tr>
<tr class="memdesc:aaa4488a58c5f9a3d9275edcef7db8506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases ownership of the specified <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">wait_handle</a> object.  <br /></td></tr>
<tr class="separator:aaa4488a58c5f9a3d9275edcef7db8506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307798f8a6772759c3bd9941bb7eab5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a307798f8a6772759c3bd9941bb7eab5d">wait</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout) override</td></tr>
<tr class="memdesc:a307798f8a6772759c3bd9941bb7eab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait ownership of the specified mutex object.  <br /></td></tr>
<tr class="separator:a307798f8a6772759c3bd9941bb7eab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classxtd_1_1threading_1_1wait__handle')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></td></tr>
<tr class="memitem:a1c98f88990d103ede2f1f9dcbed8956b inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a1c98f88990d103ede2f1f9dcbed8956b">invalid_handle</a></td></tr>
<tr class="memdesc:a1c98f88990d103ede2f1f9dcbed8956b inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an invalid native operating system handle. This field is read-only.  <br /></td></tr>
<tr class="separator:a1c98f88990d103ede2f1f9dcbed8956b inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cd044ea1e43ec86d62960d667ec67d inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a88cd044ea1e43ec86d62960d667ec67d">wait_timeout</a></td></tr>
<tr class="memdesc:a88cd044ea1e43ec86d62960d667ec67d inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a> operation timed out before any of the wait handles were signaled. This field is constant. @remrarks This field is one of the possible return values of <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a>.  <br /></td></tr>
<tr class="separator:a88cd044ea1e43ec86d62960d667ec67d inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1threading_1_1wait__handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1threading_1_1wait__handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></td></tr>
<tr class="memitem:a73af88726a64d8720c4075f540ff14da inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a73af88726a64d8720c4075f540ff14da">wait_handle</a> ()=default</td></tr>
<tr class="memdesc:a73af88726a64d8720c4075f540ff14da inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> class.  <br /></td></tr>
<tr class="separator:a73af88726a64d8720c4075f540ff14da inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53dcefc6844ecf0d6d9967ac489ac87 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87">wait_one</a> ()</td></tr>
<tr class="memdesc:ab53dcefc6844ecf0d6d9967ac489ac87 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until the current <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> receives a signal.  <br /></td></tr>
<tr class="separator:ab53dcefc6844ecf0d6d9967ac489ac87 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65749b3c963772bef5440b1c8faca6ea inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a65749b3c963772bef5440b1c8faca6ea">wait_one</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a65749b3c963772bef5440b1c8faca6ea inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until the current <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> receives a signal, using 32-bit signed integer to measure the time interval.  <br /></td></tr>
<tr class="separator:a65749b3c963772bef5440b1c8faca6ea inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffdfd0f2f35f6768cb78bded574aa01 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a6ffdfd0f2f35f6768cb78bded574aa01">wait_one</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a6ffdfd0f2f35f6768cb78bded574aa01 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until the current instance receives a signal, using a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> to measure the time interval.  <br /></td></tr>
<tr class="separator:a6ffdfd0f2f35f6768cb78bded574aa01 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#aa8027c211754118c30ccf7e52557fd7a">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af734e36ea583a842339d7c4444fb6d86">memberwise_clone</a> () const noexcept</td></tr>
<tr class="memdesc:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sxd::ustring that represents the current object.  <br /></td></tr>
<tr class="separator:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1icomparable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1icomparable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1icomparable.html">xtd::icomparable&lt; event_wait_handle &gt;</a></td></tr>
<tr class="memitem:a8e5ad6ed9d798584e8b9be5749d6faa5 inherit pub_methods_classxtd_1_1icomparable"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1icomparable.html#a8e5ad6ed9d798584e8b9be5749d6faa5">compare_to</a> (const event_wait_handle &amp;obj) const noexcept=0</td></tr>
<tr class="memdesc:a8e5ad6ed9d798584e8b9be5749d6faa5 inherit pub_methods_classxtd_1_1icomparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current instance with another object of the same type.  <br /></td></tr>
<tr class="separator:a8e5ad6ed9d798584e8b9be5749d6faa5 inherit pub_methods_classxtd_1_1icomparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1iequatable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1iequatable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1iequatable.html">xtd::iequatable&lt; event_wait_handle &gt;</a></td></tr>
<tr class="memitem:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a> (const event_wait_handle &amp;) const noexcept=0</td></tr>
<tr class="memdesc:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current object is equal to another object of the same type.  <br /></td></tr>
<tr class="separator:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1threading_1_1wait__handle')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></td></tr>
<tr class="memitem:a01c82b06ca8a5d14aba5f1fb396c16f7 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a01c82b06ca8a5d14aba5f1fb396c16f7">signal_and_wait</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_signal, <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_wait)</td></tr>
<tr class="memdesc:a01c82b06ca8a5d14aba5f1fb396c16f7 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals one <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> and waits on another.  <br /></td></tr>
<tr class="separator:a01c82b06ca8a5d14aba5f1fb396c16f7 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aebea15b640d53b04a97306515768d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a83aebea15b640d53b04a97306515768d">signal_and_wait</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_signal, <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_wait, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a83aebea15b640d53b04a97306515768d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals one <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> and waits on another, specifying a time-out interval as a 32-bit signed integer.  <br /></td></tr>
<tr class="separator:a83aebea15b640d53b04a97306515768d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2056ee81b21f23f6b0a7bd7f3bc232e8 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a2056ee81b21f23f6b0a7bd7f3bc232e8">signal_and_wait</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_signal, <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_wait, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a2056ee81b21f23f6b0a7bd7f3bc232e8 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals one <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> and waits on another, specifying a time-out interval as a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">time_span</a>.  <br /></td></tr>
<tr class="separator:a2056ee81b21f23f6b0a7bd7f3bc232e8 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217129669f17b6f14201dccd0405450c inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a217129669f17b6f14201dccd0405450c inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a217129669f17b6f14201dccd0405450c">wait_all</a> (const collection_t &amp;wait_handles)</td></tr>
<tr class="memdesc:a217129669f17b6f14201dccd0405450c inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the elements in the specified collection to receive a signal.  <br /></td></tr>
<tr class="separator:a217129669f17b6f14201dccd0405450c inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa977d4e62fe9fd5cc7c57cd4eb58f2 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a8aa977d4e62fe9fd5cc7c57cd4eb58f2 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a8aa977d4e62fe9fd5cc7c57cd4eb58f2">wait_all</a> (const collection_t &amp;wait_handles, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a8aa977d4e62fe9fd5cc7c57cd4eb58f2 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the elements in the specified collection to receive a signal, using an int32 value to measure the time interval.  <br /></td></tr>
<tr class="separator:a8aa977d4e62fe9fd5cc7c57cd4eb58f2 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda61f20a00dfc9a8b0f125edc9e8aa6 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:aeda61f20a00dfc9a8b0f125edc9e8aa6 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aeda61f20a00dfc9a8b0f125edc9e8aa6">wait_all</a> (const collection_t &amp;wait_handles, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:aeda61f20a00dfc9a8b0f125edc9e8aa6 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the elements in the specified collection to receive a signal, using a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> value to measure the time interval.  <br /></td></tr>
<tr class="separator:aeda61f20a00dfc9a8b0f125edc9e8aa6 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2a73d9052723690ff0e15a338cce35 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:aee2a73d9052723690ff0e15a338cce35 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35">wait_any</a> (const collection_t &amp;wait_handles)</td></tr>
<tr class="memdesc:aee2a73d9052723690ff0e15a338cce35 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for any of the elements in the specified collection to receive a signal.  <br /></td></tr>
<tr class="separator:aee2a73d9052723690ff0e15a338cce35 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1275f297e0dbddbf302edf0cd2a37d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a5b1275f297e0dbddbf302edf0cd2a37d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a5b1275f297e0dbddbf302edf0cd2a37d">wait_any</a> (const collection_t &amp;wait_handles, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a5b1275f297e0dbddbf302edf0cd2a37d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for any of the elements in the specified collection to receive a signal, using a 32-bit signed integer to measure the time interval.  <br /></td></tr>
<tr class="separator:a5b1275f297e0dbddbf302edf0cd2a37d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa704be64592eed6531ec3953bb9897e inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:afa704be64592eed6531ec3953bb9897e inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#afa704be64592eed6531ec3953bb9897e">wait_any</a> (const collection_t &amp;wait_handles, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:afa704be64592eed6531ec3953bb9897e inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for any of the elements in the specified collection to receive a signal, using a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> to measure the time interval.  <br /></td></tr>
<tr class="separator:afa704be64592eed6531ec3953bb9897e inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a75cb9ed56172fb088ca6697d5d836b13">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1ee13700465eead7934f450749b952d7">reference_equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classxtd_1_1threading_1_1wait__handle"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classxtd_1_1threading_1_1wait__handle')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></td></tr>
<tr class="inherit_header pro_methods_classxtd_1_1abstract__object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classxtd_1_1abstract__object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classxtd_1_1abstract__object.html">xtd::abstract_object</a></td></tr>
<tr class="memitem:ad7a701628e47b725c0bc15400085d714 inherit pro_methods_classxtd_1_1abstract__object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1abstract__object.html#ad7a701628e47b725c0bc15400085d714">abstract_object</a> ()=default</td></tr>
<tr class="memdesc:ad7a701628e47b725c0bc15400085d714 inherit pro_methods_classxtd_1_1abstract__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1abstract__object.html" title="Represent an abstract class.">xtd::abstract_object</a> class.  <br /></td></tr>
<tr class="separator:ad7a701628e47b725c0bc15400085d714 inherit pro_methods_classxtd_1_1abstract__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a955143ff0600450c82aa495a98584569" name="a955143ff0600450c82aa495a98584569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955143ff0600450c82aa495a98584569">&#9670;&#160;</a></span>event_wait_handle() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::event_wait_handle::event_wait_handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_state</td><td>true to set the initial state to signaled; false to set it to nonsignaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The mode is set to <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ad15df6f4bb58577e7078575bd2924794" title="When signaled, the xtd::threading::event_wait_handle resets automatically after releasing a single th...">xtd::threading::event_reset_mode::auto_reset</a> and the name is empty string (""). </dd></dl>

</div>
</div>
<a id="a2291371a49ff3530aab2e4e57256cd52" name="a2291371a49ff3530aab2e4e57256cd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2291371a49ff3530aab2e4e57256cd52">&#9670;&#160;</a></span>event_wait_handle() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::event_wait_handle::event_wait_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying the name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, null or an empty string. The name is case-sensitive. The backslash character () is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The initial state is false and the mode is set to <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ad15df6f4bb58577e7078575bd2924794" title="When signaled, the xtd::threading::event_wait_handle resets automatically after releasing a single th...">xtd::threading::event_reset_mode::auto_reset</a>. </dd></dl>

</div>
</div>
<a id="a20cba329aeeb58306fe62fde4068ce5d" name="a20cba329aeeb58306fe62fde4068ce5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cba329aeeb58306fe62fde4068ce5d">&#9670;&#160;</a></span>event_wait_handle() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::event_wait_handle::event_wait_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>created_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a bool variable whose value after the call indicates whether the named system event was created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, null or an empty string. The name is case-sensitive. The backslash character () is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name. </td></tr>
    <tr><td class="paramname">created_new</td><td>When this method returns, contains true if a local event was created (that is, if name is null or an empty string) or if the specified named system event was created; false if the specified named system event already existed. This parameter is passed uninitialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a606abdc7f39d74fe6a541f8c333fac55" name="a606abdc7f39d74fe6a541f8c333fac55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606abdc7f39d74fe6a541f8c333fac55">&#9670;&#160;</a></span>event_wait_handle() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::event_wait_handle::event_wait_handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, and the name of a system synchronization event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_state</td><td>true to set the initial state to signaled; false to set it to nonsignaled. </td></tr>
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, null or an empty string. The name is case-sensitive. The backslash character () is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f3f634eba0b202bbd4766b6e1107863" name="a7f3f634eba0b202bbd4766b6e1107863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3f634eba0b202bbd4766b6e1107863">&#9670;&#160;</a></span>event_wait_handle() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::event_wait_handle::event_wait_handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>created_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, the name of a system synchronization event, and a bool variable whose value after the call indicates whether the named system event was created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_state</td><td>true to set the initial state to signaled; false to set it to nonsignaled. </td></tr>
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, null or an empty string. The name is case-sensitive. The backslash character () is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name. </td></tr>
    <tr><td class="paramname">created_new</td><td>When this method returns, contains true if a local event was created (that is, if name is null or an empty string) or if the specified named system event was created; false if the specified named system event already existed. This parameter is passed uninitialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd2cae6b22eca173f8c84769ea2a0424" name="afd2cae6b22eca173f8c84769ea2a0424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2cae6b22eca173f8c84769ea2a0424">&#9670;&#160;</a></span>event_wait_handle() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::event_wait_handle::event_wait_handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading.html#ga0d88594f6d137d04a3d0aa7b102664b3">event_reset_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_state</td><td>true to set the initial state to signaled; false to set it to nonsignaled. </td></tr>
    <tr><td class="paramname">mode</td><td>One of the <a class="el" href="group__threading.html#ga0d88594f6d137d04a3d0aa7b102664b3" title="Indicates whether an xtd::threading::event_wait_handle is reset automatically or manually after recei...">xtd::threading::event_reset_mode</a> values that determines whether the event resets automatically or manually. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ae24e926926861449731fb9418399a53d" title="When signaled, the xtd::threading::event_wait_handle releases all waiting threads and remains signale...">xtd::threading::event_reset_mode::manual_reset</a> flag is specified for mode, threads that wait on the event will not block. If the initial state is signaled, and mode is <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ad15df6f4bb58577e7078575bd2924794" title="When signaled, the xtd::threading::event_wait_handle resets automatically after releasing a single th...">xtd::threading::event_reset_mode::auto_reset</a>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::argument_excpetion</td><td>The mode enum value was out of legal range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9de462db14bdf5a591acaaef6d6098f" name="ae9de462db14bdf5a591acaaef6d6098f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9de462db14bdf5a591acaaef6d6098f">&#9670;&#160;</a></span>event_wait_handle() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::event_wait_handle::event_wait_handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading.html#ga0d88594f6d137d04a3d0aa7b102664b3">event_reset_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_state</td><td>true to set the initial state to signaled; false to set it to nonsignaled. </td></tr>
    <tr><td class="paramname">mode</td><td>One of the <a class="el" href="group__threading.html#ga0d88594f6d137d04a3d0aa7b102664b3" title="Indicates whether an xtd::threading::event_wait_handle is reset automatically or manually after recei...">xtd::threading::event_reset_mode</a> values that determines whether the event resets automatically or manually. </td></tr>
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, null or an empty string. The name is case-sensitive. The backslash character () is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::argument_excpetion</td><td>The mode enum value was out of legal range. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>name is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes "Global\" and "Local" are case-sensitive.<br  />
-or-<br  />
There was some other error. The HResult property may provide more information. </td></tr>
    <tr><td class="paramname">xtd::io::path_to_long_exception</td><td>The name is too long. Length restrictions may depend on the operating system or configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The name may be prefixed with Global\ or Local\ to specify a namespace. When the Global namespace is specified, the synchronization object may be shared with any processes on the system. When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session. On Windows, a session is a login session, and services typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session. Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session. </dd>
<dd>
If a name is provided and a synchronization object of the requested type already exists in the namespace, the existing synchronization object is opened. If a synchronization object of a different type already exists in the namespace, a <a class="el" href="classxtd_1_1threading_1_1wait__handle__cannot__be__opened__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::wait_handle_cannot_be_opened_exception</a> is thrown. Otherwise, a new synchronization object is created. </dd>
<dd>
If a system event with the name specified for the name parameter already exists, the initialState parameter is ignored. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When using this constructor for named system events, specify false for initial_state. This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event. To determine whether a named event was created, use the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle(bool, xtd::threading::event_reset_mode, xtd::utring, bool)</a> constructor or the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle(bool, xtd::threading::event__reset_mode, xtd:string, bool)</a> constructor. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ae24e926926861449731fb9418399a53d" title="When signaled, the xtd::threading::event_wait_handle releases all waiting threads and remains signale...">xtd::threading::event_reset_mode::manual_reset</a> flag is specified for mode, threads that wait on the event will not block. If the initial state is signaled, and mode is <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ad15df6f4bb58577e7078575bd2924794" title="When signaled, the xtd::threading::event_wait_handle resets automatically after releasing a single th...">xtd::threading::event_reset_mode::auto_reset</a>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block. </dd></dl>

</div>
</div>
<a id="a72d33ea81f346c673cc0a1326524009d" name="a72d33ea81f346c673cc0a1326524009d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d33ea81f346c673cc0a1326524009d">&#9670;&#160;</a></span>event_wait_handle() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::event_wait_handle::event_wait_handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading.html#ga0d88594f6d137d04a3d0aa7b102664b3">event_reset_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>created_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a bool variable whose value after the call indicates whether the named system event was created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_state</td><td>true to set the initial state to signaled; false to set it to nonsignaled. </td></tr>
    <tr><td class="paramname">mode</td><td>One of the <a class="el" href="group__threading.html#ga0d88594f6d137d04a3d0aa7b102664b3" title="Indicates whether an xtd::threading::event_wait_handle is reset automatically or manually after recei...">xtd::threading::event_reset_mode</a> values that determines whether the event resets automatically or manually. </td></tr>
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, null or an empty string. The name is case-sensitive. The backslash character () is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name. </td></tr>
    <tr><td class="paramname">created_new</td><td>When this method returns, contains true if a local event was created (that is, if name is null or an empty string) or if the specified named system event was created; false if the specified named system event already existed. This parameter is passed uninitialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>name is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes "Global\" and "Local" are case-sensitive.<br  />
-or-<br  />
There was some other error. The HResult property may provide more information. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The name is too long. Length restrictions may depend on the operating system or configuration. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1wait__handle__cannot__be__opened__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::wait_handle_cannot_be_opened_exception</a></td><td>A synchronization object with the provided name cannot be created. A synchronization object of a different type might have the same name. @aexception <a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a> The mode enum value was out of legal range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The name may be prefixed with Global\ or Local\ to specify a namespace. When the Global namespace is specified, the synchronization object may be shared with any processes on the system. When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session. On Windows, a session is a login session, and services typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session. Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session </dd>
<dd>
If a name is provided and a synchronization object of the requested type already exists in the namespace, the existing synchronization object is opened. If a synchronization object of a different type already exists in the namespace, a WaitHandleCannotBeOpenedException is thrown. Otherwise, a new synchronization object is created. </dd>
<dd>
If a system event with the name specified for the name parameter already exists, the initialState parameter is ignored. After calling this constructor, use the value in the variable specified for the ref parameter (ByRef parameter in Visual Basic)createdNew to determine whether the named system event already existed or was created. </dd>
<dd>
If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ae24e926926861449731fb9418399a53d" title="When signaled, the xtd::threading::event_wait_handle releases all waiting threads and remains signale...">xtd::threading::event_reset_mode::manual_reset</a> flag is specified for mode, threads that wait on the event will not block. If the initial state is signaled, and mode is <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ad15df6f4bb58577e7078575bd2924794" title="When signaled, the xtd::threading::event_wait_handle resets automatically after releasing a single th...">xtd::threading::event_reset_mode::auto_reset</a>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a25cd50beb10d27e546af15506fa98465" name="a25cd50beb10d27e546af15506fa98465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cd50beb10d27e546af15506fa98465">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::event_wait_handle::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases all resources held by the current <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You to call this method in the destructor of the inherited class. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a177d4ddb89f80c3932de535af29e7c76">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<a id="a96d6a6e016d598ac4eab6916b1fe756c" name="a96d6a6e016d598ac4eab6916b1fe756c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d6a6e016d598ac4eab6916b1fe756c">&#9670;&#160;</a></span>handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a> xtd::threading::event_wait_handle::handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the native operating system handle. </p>
<dl class="section return"><dt>Returns</dt><dd>An intptr representing the native operating system handle. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ac6ea513628eed434543d706fb69c144c">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<a id="a9768d5b08aa592b96e4fb7880471b041" name="a9768d5b08aa592b96e4fb7880471b041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9768d5b08aa592b96e4fb7880471b041">&#9670;&#160;</a></span>handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::event_wait_handle::handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the native operating system handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An intptr representing the native operating system handle. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a1ae25cca055cc110953d333475ef5c3f">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<a id="a93ea49911ec81e86d193049aac25fd67" name="a93ea49911ec81e86d193049aac25fd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ea49911ec81e86d193049aac25fd67">&#9670;&#160;</a></span>open_existing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a> xtd::threading::event_wait_handle::open_existing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens the specified named synchronization event, if it already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character () is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the named system event. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1wait__handle__cannot__be__opened__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::wait_handle_cannot_be_opened_exception</a></td><td>A synchronization object with the provided name cannot be opened. It may not exist, or a synchronization object of a different type might have the same name. In some cases, this exception may be thrown for invalid names. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>name is an empty string. </td></tr>
    <tr><td class="paramname">xtd::io_io_exception</td><td>name is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes "Global\" and "Local" are case-sensitive.<br  />
-or-<br  />
There was some other error. The HResult property may provide more information. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The name is too long. Length restrictions may depend on the operating system or configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The name may be prefixed with Global\ or Local\ to specify a namespace. When the Global namespace is specified, the synchronization object may be shared with any processes on the system. When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session. On Windows, a session is a login session, and services typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session. Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session. </dd>
<dd>
If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened. If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, a <a class="el" href="classxtd_1_1threading_1_1wait__handle__cannot__be__opened__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::wait_handle_cannot_be_opened_exception</a> is thrown </dd>
<dd>
The <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a93ea49911ec81e86d193049aac25fd67" title="Opens the specified named synchronization event, if it already exists.">xtd::threading::event_wait_handle::open_existing</a> method tries to open the specified named system event. To create the system event when it does not already exist, use one of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> constructors that has a name parameter. </dd>
<dd>
Multiple calls to this method that use the same value for name do not necessarily return the same <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> object, even though the objects that are returned represent the same named system event. </dd></dl>

</div>
</div>
<a id="afad8a8b6d18cec770c3688e02e2154da" name="afad8a8b6d18cec770c3688e02e2154da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad8a8b6d18cec770c3688e02e2154da">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::event_wait_handle::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the state of the event to nonsignaled, causing threads to block. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeds; otherwise, false. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1object__closed__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::object_closed_exception</a></td><td>The <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a177d4ddb89f80c3932de535af29e7c76" title="Releases all resources held by the current xtd::threading::wait_handle.">xtd::threading::wait_handle::close()</a> method was previously called on this <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3254163aa012cb3dc8f99ff16c0c7d6c" name="a3254163aa012cb3dc8f99ff16c0c7d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3254163aa012cb3dc8f99ff16c0c7d6c">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::event_wait_handle::set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the state of the event to signaled, allowing one or more waiting threads to proceed. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeds; otherwise, false. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1object__closed__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::object_closed_exception</a></td><td>The <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a177d4ddb89f80c3932de535af29e7c76" title="Releases all resources held by the current xtd::threading::wait_handle.">xtd::threading::wait_handle::close()</a> method was previously called on this <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For an <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> with <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ad15df6f4bb58577e7078575bd2924794" title="When signaled, the xtd::threading::event_wait_handle resets automatically after releasing a single th...">xtd::threading::event_reset_mode::auto_reset</a> (including <a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a>:::auto_reset_event), the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c" title="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">xtd::threading::event_wait_handle::set</a> method releases a single thread. If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#afad8a8b6d18cec770c3688e02e2154da" title="Sets the state of the event to nonsignaled, causing threads to block.">xtd::threading::event_wait_handle::reset</a> method is called. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>There is no guarantee that every call to the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c" title="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">xtd::threading::auto_reset_event::set</a> method will release a thread. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It's as if the second call did not happen. Also, if <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c" title="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">xtd::threading::auto_reset_event::set</a> is called when there are no threads waiting and the <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> is already signaled, the call has no effect. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For an <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> with <a class="el" href="group__threading.html#gga0d88594f6d137d04a3d0aa7b102664b3ae24e926926861449731fb9418399a53d" title="When signaled, the xtd::threading::event_wait_handle releases all waiting threads and remains signale...">xtd::threading::event_reset_mode::manual_reset</a> (including <a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a>:::manual_reset_event), calling the Set method leaves the wait handle in a signaled state until its <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#afad8a8b6d18cec770c3688e02e2154da" title="Sets the state of the event to nonsignaled, causing threads to block.">xtd::threading::event_wait_handle::reset</a> method is called. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="event_wait_handle_8cpp-example.html#a3">event_wait_handle.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aaa4488a58c5f9a3d9275edcef7db8506" name="aaa4488a58c5f9a3d9275edcef7db8506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4488a58c5f9a3d9275edcef7db8506">&#9670;&#160;</a></span>signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::event_wait_handle::signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases ownership of the specified <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">wait_handle</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>true If the function succeeds, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Override this function for all derived object </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ae3323e1eb8bc5686e88c8eb54d93e2c8">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<a id="a574bd9f733a6ba3317cf1859874f3335" name="a574bd9f733a6ba3317cf1859874f3335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574bd9f733a6ba3317cf1859874f3335">&#9670;&#160;</a></span>try_open_existing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::event_wait_handle::try_open_existing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html">event_wait_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive. The backslash character () is reserved and may only be used to specify a namespace. For more information on namespaces, see the remarks section. There may be further restrictions on the name depending on the operating system. For example, on Unix-based operating systems, the name after excluding the namespace must be a valid file name. </td></tr>
    <tr><td class="paramname">result</td><td>When this method returns, contains a The <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> object that represents the named synchronization event if the call succeeded, or null if the call failed. This parameter is treated as uninitialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the named synchronization event was opened successfully; otherwise, false. In some cases, false may be returned for invalid names. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>name is an empty string. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>name is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes "Global\" and "Local" are case-sensitive. For some invalid names, the method may return false instead.<br  />
-or-<br  />
There was some other error. The HResult property may provide more information. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1path__too__long__exception.html" title="The exception that is thrown when a path or file name is longer than the system-defined maximum lengt...">xtd::io::path_too_long_exception</a></td><td>The name is too long. Length restrictions may depend on the operating system or configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The name may be prefixed with Global\ or Local\ to specify a namespace. When the Global namespace is specified, the synchronization object may be shared with any processes on the system. When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization object may be shared with processes in the same session. On Windows, a session is a login session, and services typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session. Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child relationship where they all run in the same session. </dd>
<dd>
If a synchronization object of the requested type exists in the namespace, the existing synchronization object is opened. If a synchronization object does not exist in the namespace, or a synchronization object of a different type exists in the namespace, false is returned. </dd>
<dd>
To create the system event when it does not already exist, use one of the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> constructors that has a name parameter. </dd>
<dd>
If you are uncertain whether a named synchronization event exists, use this method overload instead of the xtd::threading::event_xait_handle::open_existing(xtd::uttring) method overload, which throws an exception if the synchronization event does not exist. </dd>
<dd>
Multiple calls to this method that use the same value for name do not necessarily return the same <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html" title="Represents a thread synchronization event.">xtd::threading::event_wait_handle</a> object, even though the objects that are returned represent the same named system event. </dd></dl>

</div>
</div>
<a id="a307798f8a6772759c3bd9941bb7eab5d" name="a307798f8a6772759c3bd9941bb7eab5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307798f8a6772759c3bd9941bb7eab5d">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::event_wait_handle::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wait ownership of the specified mutex object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A valid handle to an open object. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait, or -1 to wait indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the current instance receives a signal; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If milliseconds_timeout is zero, the method does not block. It tests the state of the wait handle and returns immediately. </dd>
<dd>
Override this function for all derived object </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a9bb413f1c6bf14c9a514896f972dd35b">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="event__wait__handle_8h_source.html">event_wait_handle.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 27 2023 09:42:35 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
