<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::basic_string&lt; char_t, traits_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classxtd_1_1basic__string-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::basic_string&lt; char_t, traits_t, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__strings.html">strings</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::basic_string&lt; char_t, traits_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1basic__string.png" usemap="#xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,224,835,248"/>
<area href="classxtd_1_1icomparable.html" alt="xtd::icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;" shape="rect" coords="845,224,1680,248"/>
<area href="classxtd_1_1iequatable.html" alt="xtd::iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;" shape="rect" coords="2535,224,3370,248"/>
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" alt="xtd::collections::generic::ienumerable&lt; char_t &gt;" shape="rect" coords="4225,224,5060,248"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html" alt="xtd::collections::generic::extensions::enumerable&lt; ienumerable&lt; char_t &gt;, char_t &gt;" shape="rect" coords="5070,168,5905,192"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html" alt="xtd::collections::generic::extensions::enumerable_iterators&lt; char_t, xtd::collections::generic::ienumerable&lt; char_t &gt; &gt;" shape="rect" coords="5070,112,5905,136"/>
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable__abstract.html" title="Abstract object that represent ienumerable." alt="xtd::collections::generic::ienumerable_abstract" shape="rect" coords="5070,56,5905,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="5070,0,5905,24"/>
<area href="classxtd_1_1extensions_1_1equality__operators.html" alt="xtd::extensions::equality_operators&lt; basic_string&lt; char_t, traits_t, allocator_t &gt;, iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt; &gt;" shape="rect" coords="3380,168,4215,192"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="3380,112,4215,136"/>
<area href="classxtd_1_1extensions_1_1comparison__operators.html" alt="xtd::extensions::comparison_operators&lt; basic_string&lt; char_t, traits_t, allocator_t &gt;, icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt; &gt;" shape="rect" coords="1690,168,2525,192"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="1690,112,2525,136"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class char_t, class traits_t, class allocator_t&gt;<br />
class xtd::basic_string&lt; char_t, traits_t, allocator_t &gt;</div><p>Represents text as a sequence of character units. </p>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is a sequential collection of char that represent a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is the content of the sequential collection of <code>char_t</code>, and unlike <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char_t&gt;</a> that value is immutable (that is, it is read-only). </dd>
<dd>
If you want the same mutable <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> class, you can use <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char_t&gt; class. </dd>
<dd>
<a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char&gt;</a> and therefore offers the full (immutable) API of std::basic_string. </dd>
<dd>
Several aliases for common character types are provided: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;char&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#gad9519a3c079fca351ff0c97ccd3b012a" title="Represents text as a sequence of UTF-16 code units.">xtd::u16string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga30cd2dda34afc715ec10817ced72ac25" title="Represents text as a sequence of UTF-32 code units.">xtd::u32string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga2a1c504cef5a83ac0d4dec15817b0511" title="Represents text as a sequence of UTF-8 code units.">xtd::u8string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#gaef465eea9979bb0b1332b8bc46abe0ff" title="Represents text as a sequence of UTF-16 code unit on Windows or UTF-32 code unit on non-Windows syste...">xtd::wstring</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302" title="Represents a wide character.">xtd::wchar</a>&gt;   </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is a sequential collection of char that represent a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is the content of the sequential collection of <code>char_t</code>, and unlike <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char_t&gt;</a> that value is immutable (that is, it is read-only). </dd>
<dd>
If you want the same mutable <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> class, you can use <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char_t&gt; class. </dd>
<dd>
<a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char&gt;</a> and therefore offers the full (immutable) API of <a href="https://en.cppreference.com/w/cpp/string/basic_string">std::string</a>. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c9caea8081698b588cb6af9b6da8542" id="r_a6c9caea8081698b588cb6af9b6da8542"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c9caea8081698b588cb6af9b6da8542">is_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a6c9caea8081698b588cb6af9b6da8542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name Public Deprecated Methods.  <br /></td></tr>
<tr class="separator:a6c9caea8081698b588cb6af9b6da8542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2fbc3e59bb8d3c04f670a5d8ba4f12" id="r_a4d2fbc3e59bb8d3c04f670a5d8ba4f12"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a4d2fbc3e59bb8d3c04f670a5d8ba4f12">begin</a> () const -&gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a></td></tr>
<tr class="memdesc:a4d2fbc3e59bb8d3c04f670a5d8ba4f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:a4d2fbc3e59bb8d3c04f670a5d8ba4f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cdbd73b0ed69113e2515de4567df3e" id="r_a08cdbd73b0ed69113e2515de4567df3e"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a08cdbd73b0ed69113e2515de4567df3e">begin</a> () -&gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a6ff72a2ec99d0023552f723de3705c4d">iterator</a></td></tr>
<tr class="memdesc:a08cdbd73b0ed69113e2515de4567df3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:a08cdbd73b0ed69113e2515de4567df3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cdd8f12c81d860079f714dc3e663de" id="r_a78cdd8f12c81d860079f714dc3e663de"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a78cdd8f12c81d860079f714dc3e663de">cbegin</a> () const -&gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a></td></tr>
<tr class="memdesc:a78cdd8f12c81d860079f714dc3e663de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:a78cdd8f12c81d860079f714dc3e663de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda895757dc05aef6aeb09189eccc005" id="r_afda895757dc05aef6aeb09189eccc005"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#afda895757dc05aef6aeb09189eccc005">cend</a> () const -&gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a></td></tr>
<tr class="memdesc:afda895757dc05aef6aeb09189eccc005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:afda895757dc05aef6aeb09189eccc005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2560fb4c67389819997f5e5c71bee9e" id="r_af2560fb4c67389819997f5e5c71bee9e"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#af2560fb4c67389819997f5e5c71bee9e">end</a> () const -&gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a></td></tr>
<tr class="memdesc:af2560fb4c67389819997f5e5c71bee9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:af2560fb4c67389819997f5e5c71bee9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f0592bfc492405a455afc0578af42c" id="r_a65f0592bfc492405a455afc0578af42c"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a65f0592bfc492405a455afc0578af42c">end</a> () -&gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a6ff72a2ec99d0023552f723de3705c4d">iterator</a></td></tr>
<tr class="memdesc:a65f0592bfc492405a455afc0578af42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:a65f0592bfc492405a455afc0578af42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebcce5da7a657d84c60f5c1628537f7" id="r_a7ebcce5da7a657d84c60f5c1628537f7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a7ebcce5da7a657d84c60f5c1628537f7">aggregate</a> (const std::function&lt; char_t(const char_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const -&gt; char_t</td></tr>
<tr class="memdesc:a7ebcce5da7a657d84c60f5c1628537f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a7ebcce5da7a657d84c60f5c1628537f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6335443a047f8bd7d4b73b7f3e3e6869" id="r_a6335443a047f8bd7d4b73b7f3e3e6869"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a6335443a047f8bd7d4b73b7f3e3e6869">aggregate</a> (const char_t &amp;seed, const std::function&lt; char_t(const char_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const -&gt; char_t</td></tr>
<tr class="memdesc:a6335443a047f8bd7d4b73b7f3e3e6869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a6335443a047f8bd7d4b73b7f3e3e6869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8292c09b6991a75de60a694a1f5c55bf" id="r_a8292c09b6991a75de60a694a1f5c55bf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8292c09b6991a75de60a694a1f5c55bf">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const accumulate_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const -&gt; accumulate_t</td></tr>
<tr class="memdesc:a8292c09b6991a75de60a694a1f5c55bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a8292c09b6991a75de60a694a1f5c55bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf26a2790528a7818e883710ea67124" id="r_acbf26a2790528a7818e883710ea67124"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#acbf26a2790528a7818e883710ea67124">aggregate</a> (const char_t &amp;seed, const std::function&lt; char_t(const char_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; char_t(const char_t &amp;)&gt; &amp;result_selector) const -&gt; char_t</td></tr>
<tr class="memdesc:acbf26a2790528a7818e883710ea67124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:acbf26a2790528a7818e883710ea67124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5b20fc42ee48616d092ce43cad771b" id="r_acb5b20fc42ee48616d092ce43cad771b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#acb5b20fc42ee48616d092ce43cad771b">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const accumulate_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector) const -&gt; result_t</td></tr>
<tr class="memdesc:acb5b20fc42ee48616d092ce43cad771b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:acb5b20fc42ee48616d092ce43cad771b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c87271020284f4837a1c2bca5ba7b1a" id="r_a2c87271020284f4837a1c2bca5ba7b1a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2c87271020284f4837a1c2bca5ba7b1a">all</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const -&gt; bool</td></tr>
<tr class="memdesc:a2c87271020284f4837a1c2bca5ba7b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a2c87271020284f4837a1c2bca5ba7b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750d71902c133ab1140a4f3bc41c3129" id="r_a750d71902c133ab1140a4f3bc41c3129"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a750d71902c133ab1140a4f3bc41c3129">any</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a750d71902c133ab1140a4f3bc41c3129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a750d71902c133ab1140a4f3bc41c3129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0322f65a9d7574e8df67afe1e47dc7cb" id="r_a0322f65a9d7574e8df67afe1e47dc7cb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0322f65a9d7574e8df67afe1e47dc7cb">any</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const -&gt; bool</td></tr>
<tr class="memdesc:a0322f65a9d7574e8df67afe1e47dc7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a0322f65a9d7574e8df67afe1e47dc7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34c33a40d0180b2be5a5bfae2bda31e" id="r_ae34c33a40d0180b2be5a5bfae2bda31e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae34c33a40d0180b2be5a5bfae2bda31e">append</a> (const char_t &amp;element) const noexcept</td></tr>
<tr class="memdesc:ae34c33a40d0180b2be5a5bfae2bda31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:ae34c33a40d0180b2be5a5bfae2bda31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d20a7b596a0b4f468a80faaa8d0c93" id="r_ae9d20a7b596a0b4f468a80faaa8d0c93"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae9d20a7b596a0b4f468a80faaa8d0c93">as_enumerable</a> () const noexcept</td></tr>
<tr class="memdesc:ae9d20a7b596a0b4f468a80faaa8d0c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ae9d20a7b596a0b4f468a80faaa8d0c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5669f1a9bf9da6303aa9ff29197b4799" id="r_a5669f1a9bf9da6303aa9ff29197b4799"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5669f1a9bf9da6303aa9ff29197b4799">average</a> () const noexcept</td></tr>
<tr class="memdesc:a5669f1a9bf9da6303aa9ff29197b4799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of source_t values.  <br /></td></tr>
<tr class="separator:a5669f1a9bf9da6303aa9ff29197b4799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994683d04e77ec8464431ec8ac429a7c" id="r_a994683d04e77ec8464431ec8ac429a7c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a994683d04e77ec8464431ec8ac429a7c">cast</a> () const noexcept</td></tr>
<tr class="memdesc:a994683d04e77ec8464431ec8ac429a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> to the specified type.  <br /></td></tr>
<tr class="separator:a994683d04e77ec8464431ec8ac429a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992667d25a4fc7fd3383d9eafd716eca" id="r_a992667d25a4fc7fd3383d9eafd716eca"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a992667d25a4fc7fd3383d9eafd716eca">chunk</a> (size_t <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">size</a>) const</td></tr>
<tr class="memdesc:a992667d25a4fc7fd3383d9eafd716eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the elements of a sequence into chunks of size at most size.  <br /></td></tr>
<tr class="separator:a992667d25a4fc7fd3383d9eafd716eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc904cd780ff73da92d5d8f4e6c81468" id="r_afc904cd780ff73da92d5d8f4e6c81468"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afc904cd780ff73da92d5d8f4e6c81468">concat</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;second) const noexcept</td></tr>
<tr class="memdesc:afc904cd780ff73da92d5d8f4e6c81468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two sequences.  <br /></td></tr>
<tr class="separator:afc904cd780ff73da92d5d8f4e6c81468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb2e699be37d1850eed1d1df1e0f78e" id="r_a0eb2e699be37d1850eed1d1df1e0f78e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0eb2e699be37d1850eed1d1df1e0f78e">contains</a> (const char_t &amp;value) const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a0eb2e699be37d1850eed1d1df1e0f78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using the default equality comparer.  <br /></td></tr>
<tr class="separator:a0eb2e699be37d1850eed1d1df1e0f78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88904921d746c25c99d7935d1fb8f20d" id="r_a88904921d746c25c99d7935d1fb8f20d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a88904921d746c25c99d7935d1fb8f20d">contains</a> (const char_t &amp;value, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; char_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a88904921d746c25c99d7935d1fb8f20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using a specified equality comparer.  <br /></td></tr>
<tr class="separator:a88904921d746c25c99d7935d1fb8f20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eea430b375cd6362b5cc42416e1fd2" id="r_a05eea430b375cd6362b5cc42416e1fd2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a> () const noexcept -&gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td></tr>
<tr class="memdesc:a05eea430b375cd6362b5cc42416e1fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in current sequence.  <br /></td></tr>
<tr class="separator:a05eea430b375cd6362b5cc42416e1fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43314c0991ac465709e1c3f4aa4c1fad" id="r_a43314c0991ac465709e1c3f4aa4c1fad"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a43314c0991ac465709e1c3f4aa4c1fad">count</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const noexcept -&gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td></tr>
<tr class="memdesc:a43314c0991ac465709e1c3f4aa4c1fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number that represents how many elements in the specified sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a43314c0991ac465709e1c3f4aa4c1fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8409fc334c32734d57eeb058ac6dac12" id="r_a8409fc334c32734d57eeb058ac6dac12"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8409fc334c32734d57eeb058ac6dac12">count</a> (const char_t &amp;value) const noexcept -&gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td></tr>
<tr class="memdesc:a8409fc334c32734d57eeb058ac6dac12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with the specified value.  <br /></td></tr>
<tr class="separator:a8409fc334c32734d57eeb058ac6dac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4457cca131d9c0a6ffe086e8eb0f94" id="r_a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4e4457cca131d9c0a6ffe086e8eb0f94">count_by</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector) const noexcept</td></tr>
<tr class="memdesc:a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc573c1483ac2d7952eb75e8b114e49" id="r_acfc573c1483ac2d7952eb75e8b114e49"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#acfc573c1483ac2d7952eb75e8b114e49">count_by</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;key_comparer) const noexcept</td></tr>
<tr class="memdesc:acfc573c1483ac2d7952eb75e8b114e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:acfc573c1483ac2d7952eb75e8b114e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b55e90e328b05491b96d053b5d5fc0f" id="r_a6b55e90e328b05491b96d053b5d5fc0f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a6b55e90e328b05491b96d053b5d5fc0f">default_if_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a6b55e90e328b05491b96d053b5d5fc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a6b55e90e328b05491b96d053b5d5fc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adcbae38abdfd1ce51e6bb29ed2c3e3" id="r_a5adcbae38abdfd1ce51e6bb29ed2c3e3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5adcbae38abdfd1ce51e6bb29ed2c3e3">default_if_empty</a> (const char_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:a5adcbae38abdfd1ce51e6bb29ed2c3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the specified value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a5adcbae38abdfd1ce51e6bb29ed2c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed33cd2bdca30be4a7746d569a8367a7" id="r_aed33cd2bdca30be4a7746d569a8367a7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aed33cd2bdca30be4a7746d569a8367a7">distinct</a> () const noexcept</td></tr>
<tr class="memdesc:aed33cd2bdca30be4a7746d569a8367a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distinct elements from a sequence by using the default equality comparer to compare values.  <br /></td></tr>
<tr class="separator:aed33cd2bdca30be4a7746d569a8367a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4e42accb00e5e59a3262c6624dfc7c" id="r_abb4e42accb00e5e59a3262c6624dfc7c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#abb4e42accb00e5e59a3262c6624dfc7c">distinct</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; char_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept</td></tr>
<tr class="memdesc:abb4e42accb00e5e59a3262c6624dfc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distinct elements from a sequence by using a specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; to compare values.  <br /></td></tr>
<tr class="separator:abb4e42accb00e5e59a3262c6624dfc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e759b2fa491a2006eb244ce931ea4ee" id="r_a7e759b2fa491a2006eb244ce931ea4ee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a7e759b2fa491a2006eb244ce931ea4ee">first_or_default</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>, const char_t &amp;default_value) const noexcept -&gt; char_t</td></tr>
<tr class="memdesc:a7e759b2fa491a2006eb244ce931ea4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:a7e759b2fa491a2006eb244ce931ea4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dce81ad7c370279a7c87f5947904d8" id="r_a19dce81ad7c370279a7c87f5947904d8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a19dce81ad7c370279a7c87f5947904d8">first_or_default</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const noexcept -&gt; char_t</td></tr>
<tr class="memdesc:a19dce81ad7c370279a7c87f5947904d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a19dce81ad7c370279a7c87f5947904d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8433958437ae23f4272db71f201ddfee" id="r_a8433958437ae23f4272db71f201ddfee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8433958437ae23f4272db71f201ddfee">first_or_default</a> (const char_t default_value) const noexcept -&gt; char_t</td></tr>
<tr class="memdesc:a8433958437ae23f4272db71f201ddfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a8433958437ae23f4272db71f201ddfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15bac736758f4963624d6682a5c6d92" id="r_af15bac736758f4963624d6682a5c6d92"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#af15bac736758f4963624d6682a5c6d92">first_or_default</a> () const noexcept -&gt; char_t</td></tr>
<tr class="memdesc:af15bac736758f4963624d6682a5c6d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:af15bac736758f4963624d6682a5c6d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaaa233780cb312bb8702850041eb5b0" id="r_afaaa233780cb312bb8702850041eb5b0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afaaa233780cb312bb8702850041eb5b0">order</a> ()</td></tr>
<tr class="memdesc:afaaa233780cb312bb8702850041eb5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order.  <br /></td></tr>
<tr class="separator:afaaa233780cb312bb8702850041eb5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa298ffb7d50220c493a477064885743a" id="r_aa298ffb7d50220c493a477064885743a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aa298ffb7d50220c493a477064885743a">order</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1icomparer.html">xtd::collections::generic::icomparer</a>&lt; char_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>)</td></tr>
<tr class="memdesc:aa298ffb7d50220c493a477064885743a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order.  <br /></td></tr>
<tr class="separator:aa298ffb7d50220c493a477064885743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9472d2fb32abc451658a9a49b1850a" id="r_abd9472d2fb32abc451658a9a49b1850a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#abd9472d2fb32abc451658a9a49b1850a">order_by</a> (const std::function&lt; char_t(const char_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:abd9472d2fb32abc451658a9a49b1850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order according to a key.  <br /></td></tr>
<tr class="separator:abd9472d2fb32abc451658a9a49b1850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dd17c4172c503636ef8c0b1954415f" id="r_a22dd17c4172c503636ef8c0b1954415f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22dd17c4172c503636ef8c0b1954415f">order_by</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:a22dd17c4172c503636ef8c0b1954415f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order according to a key.  <br /></td></tr>
<tr class="separator:a22dd17c4172c503636ef8c0b1954415f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf1d21996e82ad730383c1c83f9d4f5" id="r_a5cf1d21996e82ad730383c1c83f9d4f5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5cf1d21996e82ad730383c1c83f9d4f5">order_by_descending</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:a5cf1d21996e82ad730383c1c83f9d4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in descending order according to a key.  <br /></td></tr>
<tr class="separator:a5cf1d21996e82ad730383c1c83f9d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab380ad6e3fcd5d1cad403eae4e5d9d56" id="r_ab380ad6e3fcd5d1cad403eae4e5d9d56"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ab380ad6e3fcd5d1cad403eae4e5d9d56">order_by_descending</a> (const std::function&lt; char_t(const char_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:ab380ad6e3fcd5d1cad403eae4e5d9d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in descending order according to a key.  <br /></td></tr>
<tr class="separator:ab380ad6e3fcd5d1cad403eae4e5d9d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf27a2adb67c1144bc20c98151c45639" id="r_adf27a2adb67c1144bc20c98151c45639"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#adf27a2adb67c1144bc20c98151c45639">select</a> (const std::function&lt; result_t(const char_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:adf27a2adb67c1144bc20c98151c45639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:adf27a2adb67c1144bc20c98151c45639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2388e79e9cf3b548edcbfd01c7fb606" id="r_ac2388e79e9cf3b548edcbfd01c7fb606"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ac2388e79e9cf3b548edcbfd01c7fb606">select</a> (const std::function&lt; char_t(const char_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:ac2388e79e9cf3b548edcbfd01c7fb606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:ac2388e79e9cf3b548edcbfd01c7fb606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72b6ac4c22f5ed599d5bcad4bcb8f51" id="r_ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae72b6ac4c22f5ed599d5bcad4bcb8f51">select</a> (const std::function&lt; result_t(const char_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057c689f8c51e80cbf49b14e8cad1b00" id="r_a057c689f8c51e80cbf49b14e8cad1b00"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a057c689f8c51e80cbf49b14e8cad1b00">select</a> (const std::function&lt; char_t(const char_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a057c689f8c51e80cbf49b14e8cad1b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a057c689f8c51e80cbf49b14e8cad1b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511949731079734f2aca9d08c3c69c27" id="r_a511949731079734f2aca9d08c3c69c27"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a511949731079734f2aca9d08c3c69c27">to_array</a> () const noexcept -&gt; <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; char_t &gt;</td></tr>
<tr class="memdesc:a511949731079734f2aca9d08c3c69c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a511949731079734f2aca9d08c3c69c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e00076ef778b67cf357e35560298ad" id="r_a32e00076ef778b67cf357e35560298ad"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a32e00076ef778b67cf357e35560298ad">to_list</a> () const noexcept -&gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a>&lt; char_t &gt;</td></tr>
<tr class="memdesc:a32e00076ef778b67cf357e35560298ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a32e00076ef778b67cf357e35560298ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb58e81e7cbc4401a227fa23918fd3c" id="r_accb58e81e7cbc4401a227fa23918fd3c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#accb58e81e7cbc4401a227fa23918fd3c">where</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:accb58e81e7cbc4401a227fa23918fd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:accb58e81e7cbc4401a227fa23918fd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cebfce505a8ba369e428df6c5935491" id="r_a2cebfce505a8ba369e428df6c5935491"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2cebfce505a8ba369e428df6c5935491">where</a> (const std::function&lt; bool(const char_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a2cebfce505a8ba369e428df6c5935491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a2cebfce505a8ba369e428df6c5935491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a69a97f1b420e640208ecd970b0d17f09" id="r_a69a97f1b420e640208ecd970b0d17f09"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a69a97f1b420e640208ecd970b0d17f09"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a69a97f1b420e640208ecd970b0d17f09">class_name</a> ()</td></tr>
<tr class="memdesc:a69a97f1b420e640208ecd970b0d17f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the object_t.  <br /></td></tr>
<tr class="separator:a69a97f1b420e640208ecd970b0d17f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da452ea8889d3c99e3ef0437d12b3a2" id="r_a0da452ea8889d3c99e3ef0437d12b3a2"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0da452ea8889d3c99e3ef0437d12b3a2">class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0695f721a034545f3ce21d8ac16944" id="r_a6a0695f721a034545f3ce21d8ac16944"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a0695f721a034545f3ce21d8ac16944">class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:a6a0695f721a034545f3ce21d8ac16944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a6a0695f721a034545f3ce21d8ac16944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac003a2b39a8e6160043f9d3a8681a178" id="r_ac003a2b39a8e6160043f9d3a8681a178"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac003a2b39a8e6160043f9d3a8681a178"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac003a2b39a8e6160043f9d3a8681a178">full_class_name</a> ()</td></tr>
<tr class="memdesc:ac003a2b39a8e6160043f9d3a8681a178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the objec_t, including the namespace of the objec_t.  <br /></td></tr>
<tr class="separator:ac003a2b39a8e6160043f9d3a8681a178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2dad45219c94eda3bd54742cc0a82a" id="r_acc2dad45219c94eda3bd54742cc0a82a"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:acc2dad45219c94eda3bd54742cc0a82a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acc2dad45219c94eda3bd54742cc0a82a">full_class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:acc2dad45219c94eda3bd54742cc0a82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:acc2dad45219c94eda3bd54742cc0a82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f42e3b00b7c27ffa63cc8e48dde6aa4" id="r_a3f42e3b00b7c27ffa63cc8e48dde6aa4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f42e3b00b7c27ffa63cc8e48dde6aa4">full_class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:a3f42e3b00b7c27ffa63cc8e48dde6aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:a3f42e3b00b7c27ffa63cc8e48dde6aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90e33edbf92dc99e369674abb843d63" id="r_aa90e33edbf92dc99e369674abb843d63"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#aa90e33edbf92dc99e369674abb843d63">to_const_iterator</a> (typename source_collection_t::const_iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept -&gt; typename target_collection_t::const_iterator</td></tr>
<tr class="memdesc:aa90e33edbf92dc99e369674abb843d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:aa90e33edbf92dc99e369674abb843d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68a5a25a0dc79b770d2cb5b6272b52a" id="r_ad68a5a25a0dc79b770d2cb5b6272b52a"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad68a5a25a0dc79b770d2cb5b6272b52a">to_const_iterator</a> (typename source_collection_t::const_iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept -&gt; typename target_collection_t::const_iterator</td></tr>
<tr class="memdesc:ad68a5a25a0dc79b770d2cb5b6272b52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:ad68a5a25a0dc79b770d2cb5b6272b52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647b6797f4d1a429c43db4d4125895ec" id="r_a647b6797f4d1a429c43db4d4125895ec"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a647b6797f4d1a429c43db4d4125895ec">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept -&gt; typename target_collection_t::const_iterator</td></tr>
<tr class="memdesc:a647b6797f4d1a429c43db4d4125895ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a647b6797f4d1a429c43db4d4125895ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4514f633426578cc3e17a1c67517c5" id="r_acd4514f633426578cc3e17a1c67517c5"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#acd4514f633426578cc3e17a1c67517c5">to_iterator</a> (typename source_collection_t::iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept -&gt; typename target_collection_t::iterator</td></tr>
<tr class="memdesc:acd4514f633426578cc3e17a1c67517c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:acd4514f633426578cc3e17a1c67517c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212ad047a8b8fa9461bb583add74a5e3" id="r_a212ad047a8b8fa9461bb583add74a5e3"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a212ad047a8b8fa9461bb583add74a5e3">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept -&gt; typename target_collection_t::const_iterator</td></tr>
<tr class="memdesc:a212ad047a8b8fa9461bb583add74a5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a212ad047a8b8fa9461bb583add74a5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add35fbf6a927d9328f634c79bd2e5d67" id="r_add35fbf6a927d9328f634c79bd2e5d67"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#add35fbf6a927d9328f634c79bd2e5d67">to_iterator</a> (typename source_collection_t::iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept -&gt; typename target_collection_t::iterator</td></tr>
<tr class="memdesc:add35fbf6a927d9328f634c79bd2e5d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:add35fbf6a927d9328f634c79bd2e5d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:af6f4efe678e6742104ad6b0ddb3fc2db" id="r_af6f4efe678e6742104ad6b0ddb3fc2db"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6f4efe678e6742104ad6b0ddb3fc2db">operator[]</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index) const</td></tr>
<tr class="memdesc:af6f4efe678e6742104ad6b0ddb3fc2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character at specified location index.  <br /></td></tr>
<tr class="separator:af6f4efe678e6742104ad6b0ddb3fc2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6775931e51f45aad56df1c249c578832" id="r_a6775931e51f45aad56df1c249c578832"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6775931e51f45aad56df1c249c578832">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:a6775931e51f45aad56df1c249c578832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a6775931e51f45aad56df1c249c578832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7fad567430f490e373f26b2d7dce9d" id="r_a8e7fad567430f490e373f26b2d7dce9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e7fad567430f490e373f26b2d7dce9d">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a8e7fad567430f490e373f26b2d7dce9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:a8e7fad567430f490e373f26b2d7dce9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c813a8edbc5272897079137ac03b1a2" id="r_a9c813a8edbc5272897079137ac03b1a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c813a8edbc5272897079137ac03b1a2">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a9c813a8edbc5272897079137ac03b1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:a9c813a8edbc5272897079137ac03b1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab02a07cc26e5c65be216bca381b38f" id="r_a1ab02a07cc26e5c65be216bca381b38f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ab02a07cc26e5c65be216bca381b38f">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a1ab02a07cc26e5c65be216bca381b38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:a1ab02a07cc26e5c65be216bca381b38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af878d5d6403d2336b18b4fe35bdd4182" id="r_af878d5d6403d2336b18b4fe35bdd4182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af878d5d6403d2336b18b4fe35bdd4182">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:af878d5d6403d2336b18b4fe35bdd4182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:af878d5d6403d2336b18b4fe35bdd4182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09eea471e56aea42786fa52c8126a3b" id="r_ae09eea471e56aea42786fa52c8126a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae09eea471e56aea42786fa52c8126a3b">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:ae09eea471e56aea42786fa52c8126a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:ae09eea471e56aea42786fa52c8126a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05124e1ea82616e66fc72599e5ba5914" id="r_a05124e1ea82616e66fc72599e5ba5914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05124e1ea82616e66fc72599e5ba5914">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a05124e1ea82616e66fc72599e5ba5914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:a05124e1ea82616e66fc72599e5ba5914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a91c59bacaef916f4aa1e62a4730ae6" id="r_a6a91c59bacaef916f4aa1e62a4730ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a91c59bacaef916f4aa1e62a4730ae6">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a6a91c59bacaef916f4aa1e62a4730ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:a6a91c59bacaef916f4aa1e62a4730ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca40ecd701f4cb13da77ee3e1d30587" id="r_a1ca40ecd701f4cb13da77ee3e1d30587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ca40ecd701f4cb13da77ee3e1d30587">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a1ca40ecd701f4cb13da77ee3e1d30587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:a1ca40ecd701f4cb13da77ee3e1d30587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee11528245223380dd77959002077fbe" id="r_aee11528245223380dd77959002077fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee11528245223380dd77959002077fbe">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:aee11528245223380dd77959002077fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:aee11528245223380dd77959002077fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac411bdfb98de0504a5c126ed67e954a1" id="r_ac411bdfb98de0504a5c126ed67e954a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac411bdfb98de0504a5c126ed67e954a1">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:ac411bdfb98de0504a5c126ed67e954a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:ac411bdfb98de0504a5c126ed67e954a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb658b3e0ec4abe277533ac512bc3ae1" id="r_abb658b3e0ec4abe277533ac512bc3ae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb658b3e0ec4abe277533ac512bc3ae1">operator=</a> (const std::basic_string&lt; char &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:abb658b3e0ec4abe277533ac512bc3ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:abb658b3e0ec4abe277533ac512bc3ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb8217139ce12832231bf9d40b19bfd" id="r_a2eb8217139ce12832231bf9d40b19bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eb8217139ce12832231bf9d40b19bfd">operator=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a2eb8217139ce12832231bf9d40b19bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a2eb8217139ce12832231bf9d40b19bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9e59b3bf597261e69cb3d3f051aadf" id="r_acc9e59b3bf597261e69cb3d3f051aadf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc9e59b3bf597261e69cb3d3f051aadf">operator=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:acc9e59b3bf597261e69cb3d3f051aadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:acc9e59b3bf597261e69cb3d3f051aadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0786502cf54544309a1abf38184a307" id="r_ad0786502cf54544309a1abf38184a307"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0786502cf54544309a1abf38184a307">operator=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:ad0786502cf54544309a1abf38184a307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:ad0786502cf54544309a1abf38184a307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e497c98372f90481ebd0e1bd21f315" id="r_ab3e497c98372f90481ebd0e1bd21f315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3e497c98372f90481ebd0e1bd21f315">operator=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:ab3e497c98372f90481ebd0e1bd21f315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:ab3e497c98372f90481ebd0e1bd21f315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0ea7a997d8fc99967e72b32c5fdd38" id="r_a5d0ea7a997d8fc99967e72b32c5fdd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d0ea7a997d8fc99967e72b32c5fdd38">operator=</a> (std::basic_string&lt; char &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a5d0ea7a997d8fc99967e72b32c5fdd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a5d0ea7a997d8fc99967e72b32c5fdd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a9907eb2556368b2c970ef1c55d304" id="r_a12a9907eb2556368b2c970ef1c55d304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12a9907eb2556368b2c970ef1c55d304">operator=</a> (std::basic_string&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a12a9907eb2556368b2c970ef1c55d304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a12a9907eb2556368b2c970ef1c55d304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2848f242d67f32fb93125d465593d" id="r_a21c2848f242d67f32fb93125d465593d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21c2848f242d67f32fb93125d465593d">operator=</a> (std::basic_string&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a21c2848f242d67f32fb93125d465593d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a21c2848f242d67f32fb93125d465593d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6fd1ff22ea00f8c10049954764abbc" id="r_aaf6fd1ff22ea00f8c10049954764abbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf6fd1ff22ea00f8c10049954764abbc">operator=</a> (std::basic_string&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:aaf6fd1ff22ea00f8c10049954764abbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:aaf6fd1ff22ea00f8c10049954764abbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9428692f29a5b0aeeaa868ec5be9f1" id="r_abd9428692f29a5b0aeeaa868ec5be9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd9428692f29a5b0aeeaa868ec5be9f1">operator=</a> (std::basic_string&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:abd9428692f29a5b0aeeaa868ec5be9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:abd9428692f29a5b0aeeaa868ec5be9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdeadc513f43dc2cf9ee771b5cccf65" id="r_abbdeadc513f43dc2cf9ee771b5cccf65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbdeadc513f43dc2cf9ee771b5cccf65">operator=</a> (const char *str)</td></tr>
<tr class="memdesc:abbdeadc513f43dc2cf9ee771b5cccf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:abbdeadc513f43dc2cf9ee771b5cccf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb13ea20a7630c0c25d59d22c407a25e" id="r_acb13ea20a7630c0c25d59d22c407a25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb13ea20a7630c0c25d59d22c407a25e">operator=</a> (const <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> *str)</td></tr>
<tr class="memdesc:acb13ea20a7630c0c25d59d22c407a25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:acb13ea20a7630c0c25d59d22c407a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9180140c3cb5474a4de317d1b81c99a" id="r_ae9180140c3cb5474a4de317d1b81c99a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9180140c3cb5474a4de317d1b81c99a">operator=</a> (const <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> *str)</td></tr>
<tr class="memdesc:ae9180140c3cb5474a4de317d1b81c99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:ae9180140c3cb5474a4de317d1b81c99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918e97c3c720478e2b1ff5cb8773de52" id="r_a918e97c3c720478e2b1ff5cb8773de52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a918e97c3c720478e2b1ff5cb8773de52">operator=</a> (const <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> *str)</td></tr>
<tr class="memdesc:a918e97c3c720478e2b1ff5cb8773de52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a918e97c3c720478e2b1ff5cb8773de52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa66ed4bee7575c0d6791f9d3c2e0b5" id="r_aeaa66ed4bee7575c0d6791f9d3c2e0b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaa66ed4bee7575c0d6791f9d3c2e0b5">operator=</a> (const <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> *str)</td></tr>
<tr class="memdesc:aeaa66ed4bee7575c0d6791f9d3c2e0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:aeaa66ed4bee7575c0d6791f9d3c2e0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22b7f387671fa95ea8462c297905b1f" id="r_ae22b7f387671fa95ea8462c297905b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae22b7f387671fa95ea8462c297905b1f">operator=</a> (char character)</td></tr>
<tr class="memdesc:ae22b7f387671fa95ea8462c297905b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:ae22b7f387671fa95ea8462c297905b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbfe5d2566ab0966a19775ea334b5b7" id="r_a4bbfe5d2566ab0966a19775ea334b5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bbfe5d2566ab0966a19775ea334b5b7">operator=</a> (<a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> character)</td></tr>
<tr class="memdesc:a4bbfe5d2566ab0966a19775ea334b5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:a4bbfe5d2566ab0966a19775ea334b5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20661ac7964f93e1cfbac62cec407934" id="r_a20661ac7964f93e1cfbac62cec407934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20661ac7964f93e1cfbac62cec407934">operator=</a> (<a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> character)</td></tr>
<tr class="memdesc:a20661ac7964f93e1cfbac62cec407934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:a20661ac7964f93e1cfbac62cec407934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068c674dbbe9cf949e8f6fe1d25903a6" id="r_a068c674dbbe9cf949e8f6fe1d25903a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a068c674dbbe9cf949e8f6fe1d25903a6">operator=</a> (<a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> character)</td></tr>
<tr class="memdesc:a068c674dbbe9cf949e8f6fe1d25903a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:a068c674dbbe9cf949e8f6fe1d25903a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78a2c22393147a7863d6612ea8ad596" id="r_af78a2c22393147a7863d6612ea8ad596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af78a2c22393147a7863d6612ea8ad596">operator=</a> (<a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> character)</td></tr>
<tr class="memdesc:af78a2c22393147a7863d6612ea8ad596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:af78a2c22393147a7863d6612ea8ad596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57338bbd9341a8316c97a0cb0b52a0b" id="r_aa57338bbd9341a8316c97a0cb0b52a0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa57338bbd9341a8316c97a0cb0b52a0b">operator=</a> (const std::initializer_list&lt; char &gt; &amp;il)</td></tr>
<tr class="memdesc:aa57338bbd9341a8316c97a0cb0b52a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:aa57338bbd9341a8316c97a0cb0b52a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ab06b38248888f8efed9bc86a970d6" id="r_aa1ab06b38248888f8efed9bc86a970d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1ab06b38248888f8efed9bc86a970d6">operator=</a> (const std::initializer_list&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:aa1ab06b38248888f8efed9bc86a970d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:aa1ab06b38248888f8efed9bc86a970d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52100794dde1bf6c481e50e94091916a" id="r_a52100794dde1bf6c481e50e94091916a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52100794dde1bf6c481e50e94091916a">operator=</a> (const std::initializer_list&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:a52100794dde1bf6c481e50e94091916a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:a52100794dde1bf6c481e50e94091916a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75927d980766139c7c20de14f1f8d13" id="r_aa75927d980766139c7c20de14f1f8d13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa75927d980766139c7c20de14f1f8d13">operator=</a> (const std::initializer_list&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:aa75927d980766139c7c20de14f1f8d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:aa75927d980766139c7c20de14f1f8d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed652c5e92066a11e47a0dd6cd647c90" id="r_aed652c5e92066a11e47a0dd6cd647c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed652c5e92066a11e47a0dd6cd647c90">operator=</a> (const std::initializer_list&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:aed652c5e92066a11e47a0dd6cd647c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:aed652c5e92066a11e47a0dd6cd647c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f96281407a61fd50345eb7e2b8f7ca" id="r_ab9f96281407a61fd50345eb7e2b8f7ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f96281407a61fd50345eb7e2b8f7ca">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str)</td></tr>
<tr class="memdesc:ab9f96281407a61fd50345eb7e2b8f7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ab9f96281407a61fd50345eb7e2b8f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e5dc85e2d471ae28f9957c4065248f" id="r_ad1e5dc85e2d471ae28f9957c4065248f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1e5dc85e2d471ae28f9957c4065248f">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:ad1e5dc85e2d471ae28f9957c4065248f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ad1e5dc85e2d471ae28f9957c4065248f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58d46ec7ebf00e9bb57d8844bfa684d" id="r_ab58d46ec7ebf00e9bb57d8844bfa684d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab58d46ec7ebf00e9bb57d8844bfa684d">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:ab58d46ec7ebf00e9bb57d8844bfa684d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ab58d46ec7ebf00e9bb57d8844bfa684d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fcc84e7cb9e168ed058dc58a3f4dfc" id="r_a99fcc84e7cb9e168ed058dc58a3f4dfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99fcc84e7cb9e168ed058dc58a3f4dfc">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:a99fcc84e7cb9e168ed058dc58a3f4dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a99fcc84e7cb9e168ed058dc58a3f4dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a84548f6b04aac050a32938bfe5e7c6" id="r_a1a84548f6b04aac050a32938bfe5e7c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a84548f6b04aac050a32938bfe5e7c6">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:a1a84548f6b04aac050a32938bfe5e7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a1a84548f6b04aac050a32938bfe5e7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21d4bbd734b2f65cf373c02a72e1ad" id="r_a6f21d4bbd734b2f65cf373c02a72e1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f21d4bbd734b2f65cf373c02a72e1ad">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:a6f21d4bbd734b2f65cf373c02a72e1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a6f21d4bbd734b2f65cf373c02a72e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb5b1ef0dcf242170da7be8c770b1a9" id="r_a4eb5b1ef0dcf242170da7be8c770b1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eb5b1ef0dcf242170da7be8c770b1a9">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:a4eb5b1ef0dcf242170da7be8c770b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a4eb5b1ef0dcf242170da7be8c770b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ad7d6ce3e3cfd9e32b049542eb8418" id="r_ad3ad7d6ce3e3cfd9e32b049542eb8418"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3ad7d6ce3e3cfd9e32b049542eb8418">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:ad3ad7d6ce3e3cfd9e32b049542eb8418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ad3ad7d6ce3e3cfd9e32b049542eb8418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8d99044981bb8b49c438dd552b15c0" id="r_a0e8d99044981bb8b49c438dd552b15c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e8d99044981bb8b49c438dd552b15c0">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:a0e8d99044981bb8b49c438dd552b15c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a0e8d99044981bb8b49c438dd552b15c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad891204bd0c088717a720bdf92f28212" id="r_ad891204bd0c088717a720bdf92f28212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad891204bd0c088717a720bdf92f28212">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:ad891204bd0c088717a720bdf92f28212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ad891204bd0c088717a720bdf92f28212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb3348705647e01e88be06aa3767894" id="r_a2fb3348705647e01e88be06aa3767894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fb3348705647e01e88be06aa3767894">operator+=</a> (const std::basic_string&lt; char &gt; &amp;str)</td></tr>
<tr class="memdesc:a2fb3348705647e01e88be06aa3767894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2fb3348705647e01e88be06aa3767894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9bab82c073016f8b31a4f9afdb7ce8" id="r_a2b9bab82c073016f8b31a4f9afdb7ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b9bab82c073016f8b31a4f9afdb7ce8">operator+=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:a2b9bab82c073016f8b31a4f9afdb7ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2b9bab82c073016f8b31a4f9afdb7ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea45b673c96bbe8fb31b5fcee7164a8" id="r_a9ea45b673c96bbe8fb31b5fcee7164a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ea45b673c96bbe8fb31b5fcee7164a8">operator+=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:a9ea45b673c96bbe8fb31b5fcee7164a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a9ea45b673c96bbe8fb31b5fcee7164a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf189ea3fea2ff21c6afd2b226a2921" id="r_accf189ea3fea2ff21c6afd2b226a2921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accf189ea3fea2ff21c6afd2b226a2921">operator+=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:accf189ea3fea2ff21c6afd2b226a2921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:accf189ea3fea2ff21c6afd2b226a2921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba271dd4828ec9c22972ce98ed71543" id="r_afba271dd4828ec9c22972ce98ed71543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afba271dd4828ec9c22972ce98ed71543">operator+=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:afba271dd4828ec9c22972ce98ed71543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:afba271dd4828ec9c22972ce98ed71543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2769a07751f2040b086f2e532741c682" id="r_a2769a07751f2040b086f2e532741c682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2769a07751f2040b086f2e532741c682">operator+=</a> (const char *str)</td></tr>
<tr class="memdesc:a2769a07751f2040b086f2e532741c682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2769a07751f2040b086f2e532741c682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af555dcf021c5c3ced7e1a8bfbe5bfa50" id="r_af555dcf021c5c3ced7e1a8bfbe5bfa50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af555dcf021c5c3ced7e1a8bfbe5bfa50">operator+=</a> (const <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> *str)</td></tr>
<tr class="memdesc:af555dcf021c5c3ced7e1a8bfbe5bfa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:af555dcf021c5c3ced7e1a8bfbe5bfa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a78449d887fa5d921f95856cd1487" id="r_a2c2a78449d887fa5d921f95856cd1487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c2a78449d887fa5d921f95856cd1487">operator+=</a> (const <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> *str)</td></tr>
<tr class="memdesc:a2c2a78449d887fa5d921f95856cd1487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2c2a78449d887fa5d921f95856cd1487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9529e5baf23784330b6045f2ef2ec37f" id="r_a9529e5baf23784330b6045f2ef2ec37f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9529e5baf23784330b6045f2ef2ec37f">operator+=</a> (const <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> *str)</td></tr>
<tr class="memdesc:a9529e5baf23784330b6045f2ef2ec37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a9529e5baf23784330b6045f2ef2ec37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec59e366d520219d67a6ee712e07f34" id="r_a0ec59e366d520219d67a6ee712e07f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec59e366d520219d67a6ee712e07f34">operator+=</a> (const <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> *str)</td></tr>
<tr class="memdesc:a0ec59e366d520219d67a6ee712e07f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a0ec59e366d520219d67a6ee712e07f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdc9356f22e6ff9139f4a81b93a6175" id="r_a2bdc9356f22e6ff9139f4a81b93a6175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bdc9356f22e6ff9139f4a81b93a6175">operator+=</a> (char ch)</td></tr>
<tr class="memdesc:a2bdc9356f22e6ff9139f4a81b93a6175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2bdc9356f22e6ff9139f4a81b93a6175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda811c544170f9951af6d7bac8ba707" id="r_acda811c544170f9951af6d7bac8ba707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acda811c544170f9951af6d7bac8ba707">operator+=</a> (<a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> ch)</td></tr>
<tr class="memdesc:acda811c544170f9951af6d7bac8ba707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:acda811c544170f9951af6d7bac8ba707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493fc8791204b6b8bde403fad729410" id="r_a7493fc8791204b6b8bde403fad729410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7493fc8791204b6b8bde403fad729410">operator+=</a> (<a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> ch)</td></tr>
<tr class="memdesc:a7493fc8791204b6b8bde403fad729410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a7493fc8791204b6b8bde403fad729410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfdd130d8ea5f20c20fe15bf794b572" id="r_a9bfdd130d8ea5f20c20fe15bf794b572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bfdd130d8ea5f20c20fe15bf794b572">operator+=</a> (<a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> ch)</td></tr>
<tr class="memdesc:a9bfdd130d8ea5f20c20fe15bf794b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a9bfdd130d8ea5f20c20fe15bf794b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c75ef362acb78e3f0072b8cbdf3e19" id="r_a29c75ef362acb78e3f0072b8cbdf3e19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29c75ef362acb78e3f0072b8cbdf3e19">operator+=</a> (<a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> ch)</td></tr>
<tr class="memdesc:a29c75ef362acb78e3f0072b8cbdf3e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a29c75ef362acb78e3f0072b8cbdf3e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Compares two character sequences. /</p>
<p>/</p>
<p>/ /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The other string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to str. / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(const basic_string &amp; str) const {return chars_.compare(str);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string &amp; str) const {return chars_.compare(pos1, count1, str);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. /</td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>. / * If <code>count1 &gt; <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a>). / * If <code>count2 &gt; str.length() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.length()</code>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string &amp; str, size_type pos2) const {return chars_.compare(pos1, count1, str, pos2);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. /</td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. /</td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>. / * If <code>count1 &gt; <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a>). / * If <code>count2 &gt; str.length() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.length()</code>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string &amp; str, size_type pos2, size_type count2) const {return chars_.compare(pos1, count1, str, pos2, count2);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(const_pointer s) const {return chars_.compare(s);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1$ , <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). @remarks A character sequence consisting of</code>count1<code>characters starting at</code>data1<code>is compared to a character sequence consisting of</code>count2<code>characters starting at</code>data2<code>as follows:<ul>
<li>First, calculate the number of characters to compare, as if by</li>
</ul>
</code>size_type rlen = std::min(count1, count2)<code>.<ul>
<li>Then compare the sequences by calling</li>
</ul>
</code>traits_t::compare(data1, data2, rlen)`. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>
</td></tr>
<tr class="memitem:a42f4de83225ec7eb81d9e34a6d3fd461" id="r_a42f4de83225ec7eb81d9e34a6d3fd461"><td class="memItemLeft" align="right" valign="top"><a id="a42f4de83225ec7eb81d9e34a6d3fd461" name="a42f4de83225ec7eb81d9e34a6d3fd461"></a>
<a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compare</b> (size_type pos1, size_type count1, const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="separator:a42f4de83225ec7eb81d9e34a6d3fd461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd1814acf74f3359393306249030536" id="r_a4cd1814acf74f3359393306249030536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cd1814acf74f3359393306249030536">compare</a> (size_type pos1, size_type count1, const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type count2) const</td></tr>
<tr class="memdesc:a4cd1814acf74f3359393306249030536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a4cd1814acf74f3359393306249030536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785e7ca9244c89a0fd0552a30dca0df6" id="r_a785e7ca9244c89a0fd0552a30dca0df6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a785e7ca9244c89a0fd0552a30dca0df6">compare_to</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;value) const</td></tr>
<tr class="memdesc:a785e7ca9244c89a0fd0552a30dca0df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this instance with a specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a>.  <br /></td></tr>
<tr class="separator:a785e7ca9244c89a0fd0552a30dca0df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56991bcdcf3648e12180abbda6d0e4a2" id="r_a56991bcdcf3648e12180abbda6d0e4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56991bcdcf3648e12180abbda6d0e4a2">compare_to</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a56991bcdcf3648e12180abbda6d0e4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this instance with a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.  <br /></td></tr>
<tr class="separator:a56991bcdcf3648e12180abbda6d0e4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850cd349d2e010f36c975a32b150a981" id="r_a850cd349d2e010f36c975a32b150a981"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a850cd349d2e010f36c975a32b150a981">contains</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a850cd349d2e010f36c975a32b150a981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified char occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a850cd349d2e010f36c975a32b150a981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fea739d2eea162481378cc3563e0e7" id="r_a46fea739d2eea162481378cc3563e0e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46fea739d2eea162481378cc3563e0e7">contains</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a46fea739d2eea162481378cc3563e0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified substring occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a46fea739d2eea162481378cc3563e0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa538684c095ac08578828af5eff7d48d" id="r_aa538684c095ac08578828af5eff7d48d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa538684c095ac08578828af5eff7d48d">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept override</td></tr>
<tr class="memdesc:aa538684c095ac08578828af5eff7d48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object, have the same value.  <br /></td></tr>
<tr class="separator:aa538684c095ac08578828af5eff7d48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1e61a72cf0017e83126ebd8d409079" id="r_acf1e61a72cf0017e83126ebd8d409079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf1e61a72cf0017e83126ebd8d409079">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:acf1e61a72cf0017e83126ebd8d409079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value.  <br /></td></tr>
<tr class="separator:acf1e61a72cf0017e83126ebd8d409079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe34c3ef80e295d524013594ab98e96f" id="r_abe34c3ef80e295d524013594ab98e96f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe34c3ef80e295d524013594ab98e96f">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:abe34c3ef80e295d524013594ab98e96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:abe34c3ef80e295d524013594ab98e96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a32b980ce33e6240fad1bdf860be32" id="r_a88a32b980ce33e6240fad1bdf860be32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a32b980ce33e6240fad1bdf860be32">ends_with</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a88a32b980ce33e6240fad1bdf860be32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character.  <br /></td></tr>
<tr class="separator:a88a32b980ce33e6240fad1bdf860be32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235800cab8022150e0242be1f70ccba5" id="r_a235800cab8022150e0242be1f70ccba5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a235800cab8022150e0242be1f70ccba5">ends_with</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:a235800cab8022150e0242be1f70ccba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a235800cab8022150e0242be1f70ccba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bb8f1452d6d3f0a504ed482aeff03d" id="r_ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9bb8f1452d6d3f0a504ed482aeff03d">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2260a3a56c452a4086de5c75d608f3" id="r_aad2260a3a56c452a4086de5c75d608f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad2260a3a56c452a4086de5c75d608f3">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:aad2260a3a56c452a4086de5c75d608f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:aad2260a3a56c452a4086de5c75d608f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d548b663eb6dc7b61394d0a5031a779" id="r_a0d548b663eb6dc7b61394d0a5031a779"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d548b663eb6dc7b61394d0a5031a779">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) const noexcept</td></tr>
<tr class="memdesc:a0d548b663eb6dc7b61394d0a5031a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option.  <br /></td></tr>
<tr class="separator:a0d548b663eb6dc7b61394d0a5031a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995fc327f844695b7d54bb8c9dcefd64" id="r_a995fc327f844695b7d54bb8c9dcefd64"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a995fc327f844695b7d54bb8c9dcefd64">find</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a995fc327f844695b7d54bb8c9dcefd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a995fc327f844695b7d54bb8c9dcefd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ef167753f97393efa4e8a04f645b1a" id="r_ae7ef167753f97393efa4e8a04f645b1a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7ef167753f97393efa4e8a04f645b1a">find</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:ae7ef167753f97393efa4e8a04f645b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:ae7ef167753f97393efa4e8a04f645b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa27496a7880e6ec15ed6af9f3ee63a9" id="r_afa27496a7880e6ec15ed6af9f3ee63a9"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa27496a7880e6ec15ed6af9f3ee63a9">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:afa27496a7880e6ec15ed6af9f3ee63a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:afa27496a7880e6ec15ed6af9f3ee63a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b84e810101f5722ea51155b57673c3a" id="r_a5b84e810101f5722ea51155b57673c3a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b84e810101f5722ea51155b57673c3a">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a5b84e810101f5722ea51155b57673c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a5b84e810101f5722ea51155b57673c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe01cbb72aa625955d5f91eaf20b4422" id="r_afe01cbb72aa625955d5f91eaf20b4422"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe01cbb72aa625955d5f91eaf20b4422">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:afe01cbb72aa625955d5f91eaf20b4422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:afe01cbb72aa625955d5f91eaf20b4422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e89be405fda67b0a224b7f5d19dbb74" id="r_a6e89be405fda67b0a224b7f5d19dbb74"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e89be405fda67b0a224b7f5d19dbb74">find</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> ch) const</td></tr>
<tr class="memdesc:a6e89be405fda67b0a224b7f5d19dbb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a6e89be405fda67b0a224b7f5d19dbb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada37711b3a6b2d96deb9937458eeed91" id="r_ada37711b3a6b2d96deb9937458eeed91"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada37711b3a6b2d96deb9937458eeed91">find</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> ch, size_type pos) const</td></tr>
<tr class="memdesc:ada37711b3a6b2d96deb9937458eeed91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:ada37711b3a6b2d96deb9937458eeed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190df4d0356f13ee707e02bf0ff69670" id="r_a190df4d0356f13ee707e02bf0ff69670"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a190df4d0356f13ee707e02bf0ff69670">find_first_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a190df4d0356f13ee707e02bf0ff69670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a190df4d0356f13ee707e02bf0ff69670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ad6cd829e5fb0e5ba7fd173fa52a4c" id="r_a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47ad6cd829e5fb0e5ba7fd173fa52a4c">find_first_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92834b04a7c65b7de003f742e78d8309" id="r_a92834b04a7c65b7de003f742e78d8309"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92834b04a7c65b7de003f742e78d8309">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:a92834b04a7c65b7de003f742e78d8309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a92834b04a7c65b7de003f742e78d8309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb30d4555ab0d49edac1d1f29748968d" id="r_acb30d4555ab0d49edac1d1f29748968d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb30d4555ab0d49edac1d1f29748968d">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:acb30d4555ab0d49edac1d1f29748968d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:acb30d4555ab0d49edac1d1f29748968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf3f78cb8fce98db32d6dea0dacb1fd" id="r_a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bf3f78cb8fce98db32d6dea0dacb1fd">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63f087262d302ffd91d44441141395f" id="r_aa63f087262d302ffd91d44441141395f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa63f087262d302ffd91d44441141395f">find_first_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:aa63f087262d302ffd91d44441141395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa63f087262d302ffd91d44441141395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0742e91a1bc6cc31486581993106d" id="r_aebf0742e91a1bc6cc31486581993106d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf0742e91a1bc6cc31486581993106d">find_first_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:aebf0742e91a1bc6cc31486581993106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aebf0742e91a1bc6cc31486581993106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44655a7fb2b16b0ac355f98efbe7f60a" id="r_a44655a7fb2b16b0ac355f98efbe7f60a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44655a7fb2b16b0ac355f98efbe7f60a">find_first_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a44655a7fb2b16b0ac355f98efbe7f60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a44655a7fb2b16b0ac355f98efbe7f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865854c0f1fc517a76019ef74357471c" id="r_a865854c0f1fc517a76019ef74357471c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a865854c0f1fc517a76019ef74357471c">find_first_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a865854c0f1fc517a76019ef74357471c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a865854c0f1fc517a76019ef74357471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ee3d277929b2e2822347bbef0799ec" id="r_aa7ee3d277929b2e2822347bbef0799ec"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7ee3d277929b2e2822347bbef0799ec">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:aa7ee3d277929b2e2822347bbef0799ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa7ee3d277929b2e2822347bbef0799ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68c7409e9483b7fb2ecb4119a1a49c3" id="r_aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa68c7409e9483b7fb2ecb4119a1a49c3">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394185c5018c818ca6e8c3cbf9048da1" id="r_a394185c5018c818ca6e8c3cbf9048da1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a394185c5018c818ca6e8c3cbf9048da1">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a394185c5018c818ca6e8c3cbf9048da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a394185c5018c818ca6e8c3cbf9048da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525f7ed777b11690436a4e545cbd4c52" id="r_a525f7ed777b11690436a4e545cbd4c52"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a525f7ed777b11690436a4e545cbd4c52">find_first_not_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:a525f7ed777b11690436a4e545cbd4c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a525f7ed777b11690436a4e545cbd4c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa337f7f098dc744c16c768824cdbf5de" id="r_aa337f7f098dc744c16c768824cdbf5de"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa337f7f098dc744c16c768824cdbf5de">find_first_not_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:aa337f7f098dc744c16c768824cdbf5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa337f7f098dc744c16c768824cdbf5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4b8376a5af873f844aa5de5a7f36f1" id="r_ada4b8376a5af873f844aa5de5a7f36f1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada4b8376a5af873f844aa5de5a7f36f1">find_last_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:ada4b8376a5af873f844aa5de5a7f36f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:ada4b8376a5af873f844aa5de5a7f36f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8812d25aeb365b83a6e13b22d3ea15" id="r_abe8812d25aeb365b83a6e13b22d3ea15"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe8812d25aeb365b83a6e13b22d3ea15">find_last_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:abe8812d25aeb365b83a6e13b22d3ea15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:abe8812d25aeb365b83a6e13b22d3ea15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae683ad85d132dc61069a39ab5ecfc892" id="r_ae683ad85d132dc61069a39ab5ecfc892"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae683ad85d132dc61069a39ab5ecfc892">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:ae683ad85d132dc61069a39ab5ecfc892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ae683ad85d132dc61069a39ab5ecfc892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9f9c97ebc85319e7bb0890747f95f0" id="r_a3b9f9c97ebc85319e7bb0890747f95f0"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b9f9c97ebc85319e7bb0890747f95f0">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a3b9f9c97ebc85319e7bb0890747f95f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a3b9f9c97ebc85319e7bb0890747f95f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43971d40fb8f9c14c8f2a8973fda5241" id="r_a43971d40fb8f9c14c8f2a8973fda5241"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43971d40fb8f9c14c8f2a8973fda5241">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a43971d40fb8f9c14c8f2a8973fda5241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a43971d40fb8f9c14c8f2a8973fda5241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f1e765d3c800b53ad278aeea40cbbb" id="r_ad3f1e765d3c800b53ad278aeea40cbbb"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3f1e765d3c800b53ad278aeea40cbbb">find_last_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:ad3f1e765d3c800b53ad278aeea40cbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ad3f1e765d3c800b53ad278aeea40cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2276b8461430eec909f87352134d92d8" id="r_a2276b8461430eec909f87352134d92d8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2276b8461430eec909f87352134d92d8">find_last_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:a2276b8461430eec909f87352134d92d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a2276b8461430eec909f87352134d92d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a0529754f7c547dd26d0e3df7d4d57" id="r_a85a0529754f7c547dd26d0e3df7d4d57"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a0529754f7c547dd26d0e3df7d4d57">find_last_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a85a0529754f7c547dd26d0e3df7d4d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a85a0529754f7c547dd26d0e3df7d4d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7be46eecca48686b7893fdcc22f1064" id="r_ae7be46eecca48686b7893fdcc22f1064"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7be46eecca48686b7893fdcc22f1064">find_last_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:ae7be46eecca48686b7893fdcc22f1064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ae7be46eecca48686b7893fdcc22f1064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db0de794b93c1d3daec32ee93ebb840" id="r_a0db0de794b93c1d3daec32ee93ebb840"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0db0de794b93c1d3daec32ee93ebb840">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:a0db0de794b93c1d3daec32ee93ebb840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a0db0de794b93c1d3daec32ee93ebb840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66" id="r_a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867ec6c6bbe8ded000aab89983f5b37" id="r_ad867ec6c6bbe8ded000aab89983f5b37"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad867ec6c6bbe8ded000aab89983f5b37">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:ad867ec6c6bbe8ded000aab89983f5b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ad867ec6c6bbe8ded000aab89983f5b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622aba17212244261f0a1dee4cf2a76c" id="r_a622aba17212244261f0a1dee4cf2a76c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a622aba17212244261f0a1dee4cf2a76c">find_last_not_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:a622aba17212244261f0a1dee4cf2a76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a622aba17212244261f0a1dee4cf2a76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb1e50a316279a814fbf6caa9a52512" id="r_a2bb1e50a316279a814fbf6caa9a52512"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bb1e50a316279a814fbf6caa9a52512">find_last_not_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:a2bb1e50a316279a814fbf6caa9a52512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a2bb1e50a316279a814fbf6caa9a52512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fea87ee51c2cc221b5018ff83de9b" id="r_a0f3fea87ee51c2cc221b5018ff83de9b"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f3fea87ee51c2cc221b5018ff83de9b">get_allocator</a> () const</td></tr>
<tr class="memdesc:a0f3fea87ee51c2cc221b5018ff83de9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the string.  <br /></td></tr>
<tr class="separator:a0f3fea87ee51c2cc221b5018ff83de9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f45ba04d07446618d604b99c22fbb3" id="r_a38f45ba04d07446618d604b99c22fbb3"><td class="memItemLeft" align="right" valign="top">virtual const base_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38f45ba04d07446618d604b99c22fbb3">get_base_type</a> () const noexcept</td></tr>
<tr class="memdesc:a38f45ba04d07446618d604b99c22fbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type.  <br /></td></tr>
<tr class="separator:a38f45ba04d07446618d604b99c22fbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8204b499a2a327ac2193814c5ba59be4" id="r_a8204b499a2a327ac2193814c5ba59be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8204b499a2a327ac2193814c5ba59be4">get_hash_code</a> () const noexcept override</td></tr>
<tr class="memdesc:a8204b499a2a327ac2193814c5ba59be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash code for this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a8204b499a2a327ac2193814c5ba59be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273eee6b3d879fdab255817b5406ff1b" id="r_a273eee6b3d879fdab255817b5406ff1b"><td class="memItemLeft" align="right" valign="top">enumerator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a273eee6b3d879fdab255817b5406ff1b">get_enumerator</a> () const noexcept override</td></tr>
<tr class="memdesc:a273eee6b3d879fdab255817b5406ff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that iterates through a collection.  <br /></td></tr>
<tr class="separator:a273eee6b3d879fdab255817b5406ff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e2b0b18ffae65666bfe665f10c8eee" id="r_aa2e2b0b18ffae65666bfe665f10c8eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2e2b0b18ffae65666bfe665f10c8eee">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:aa2e2b0b18ffae65666bfe665f10c8eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:aa2e2b0b18ffae65666bfe665f10c8eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cdbff9d2baf8ca5354e0361db8b8f1" id="r_ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8cdbff9d2baf8ca5354e0361db8b8f1">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9376bff15d7276c49c0ce4ea3bd744b0" id="r_a9376bff15d7276c49c0ce4ea3bd744b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9376bff15d7276c49c0ce4ea3bd744b0">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:a9376bff15d7276c49c0ce4ea3bd744b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a9376bff15d7276c49c0ce4ea3bd744b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cc9bdb3ebf738766cf0b8357d9f28d" id="r_a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03cc9bdb3ebf738766cf0b8357d9f28d">index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1241d527912da0524fe79c1885104986" id="r_a1241d527912da0524fe79c1885104986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1241d527912da0524fe79c1885104986">index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a1241d527912da0524fe79c1885104986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a1241d527912da0524fe79c1885104986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101dd613f8711c38c17443fbc8c29799" id="r_a101dd613f8711c38c17443fbc8c29799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a101dd613f8711c38c17443fbc8c29799">index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:a101dd613f8711c38c17443fbc8c29799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a101dd613f8711c38c17443fbc8c29799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c38c1845d60e7d08f8750bb181aa4d" id="r_a50c38c1845d60e7d08f8750bb181aa4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50c38c1845d60e7d08f8750bb181aa4d">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a50c38c1845d60e7d08f8750bb181aa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a50c38c1845d60e7d08f8750bb181aa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d7c6fb6ca5e05c6a464e8cb25c2e76" id="r_a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d7c6fb6ca5e05c6a464e8cb25c2e76">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac27b133bb5f4567decb3a19ff63a883" id="r_aac27b133bb5f4567decb3a19ff63a883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac27b133bb5f4567decb3a19ff63a883">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:aac27b133bb5f4567decb3a19ff63a883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:aac27b133bb5f4567decb3a19ff63a883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ce826afc61742ea2b759feb0987d9c" id="r_a48ce826afc61742ea2b759feb0987d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48ce826afc61742ea2b759feb0987d9c">insert</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const</td></tr>
<tr class="memdesc:a48ce826afc61742ea2b759feb0987d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a specified instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> at a specified index position in this instance.  <br /></td></tr>
<tr class="separator:a48ce826afc61742ea2b759feb0987d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc799a8cc31af232470d65cd88a1ca6a" id="r_acc799a8cc31af232470d65cd88a1ca6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc799a8cc31af232470d65cd88a1ca6a">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:acc799a8cc31af232470d65cd88a1ca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:acc799a8cc31af232470d65cd88a1ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a6db704899bd1263a714bf8363f6b" id="r_a3b7a6db704899bd1263a714bf8363f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b7a6db704899bd1263a714bf8363f6b">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a3b7a6db704899bd1263a714bf8363f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a3b7a6db704899bd1263a714bf8363f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb55029c7dfebcfb60989e102943e70" id="r_a4fb55029c7dfebcfb60989e102943e70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fb55029c7dfebcfb60989e102943e70">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:a4fb55029c7dfebcfb60989e102943e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a4fb55029c7dfebcfb60989e102943e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a1c153b902e5edf0b877652add0e43" id="r_a68a1c153b902e5edf0b877652add0e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68a1c153b902e5edf0b877652add0e43">last_index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a68a1c153b902e5edf0b877652add0e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this tring.  <br /></td></tr>
<tr class="separator:a68a1c153b902e5edf0b877652add0e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bdcec1f21421c38a7a80d8142ff7d5" id="r_af8bdcec1f21421c38a7a80d8142ff7d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bdcec1f21421c38a7a80d8142ff7d5">last_index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:af8bdcec1f21421c38a7a80d8142ff7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:af8bdcec1f21421c38a7a80d8142ff7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c63d72cfa3f91e2cf9f23881f68d9a6" id="r_a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c63d72cfa3f91e2cf9f23881f68d9a6">last_index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cef9de4c87f758793ab52f372999b98" id="r_a9cef9de4c87f758793ab52f372999b98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cef9de4c87f758793ab52f372999b98">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a9cef9de4c87f758793ab52f372999b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a9cef9de4c87f758793ab52f372999b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eee5a0186b0272dde1487fa3a76e31" id="r_ad9eee5a0186b0272dde1487fa3a76e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9eee5a0186b0272dde1487fa3a76e31">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:ad9eee5a0186b0272dde1487fa3a76e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ad9eee5a0186b0272dde1487fa3a76e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c41879b43a215e17a3b3f1d940352b" id="r_ac4c41879b43a215e17a3b3f1d940352b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4c41879b43a215e17a3b3f1d940352b">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:ac4c41879b43a215e17a3b3f1d940352b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ac4c41879b43a215e17a3b3f1d940352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0841b4ac447cc426dfc86857696a59d3" id="r_a0841b4ac447cc426dfc86857696a59d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0841b4ac447cc426dfc86857696a59d3">pad_left</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width) const noexcept</td></tr>
<tr class="memdesc:a0841b4ac447cc426dfc86857696a59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:a0841b4ac447cc426dfc86857696a59d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8d49dec1f34267194ae3d6023e5bca" id="r_acd8d49dec1f34267194ae3d6023e5bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd8d49dec1f34267194ae3d6023e5bca">pad_left</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width, <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a> padding_char) const noexcept</td></tr>
<tr class="memdesc:acd8d49dec1f34267194ae3d6023e5bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:acd8d49dec1f34267194ae3d6023e5bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37d71513cd7f2585290402bd45afb2" id="r_abe37d71513cd7f2585290402bd45afb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe37d71513cd7f2585290402bd45afb2">pad_right</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width) const noexcept</td></tr>
<tr class="memdesc:abe37d71513cd7f2585290402bd45afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:abe37d71513cd7f2585290402bd45afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948b86a1e0b7a58d6813048a74c4106" id="r_a7948b86a1e0b7a58d6813048a74c4106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7948b86a1e0b7a58d6813048a74c4106">pad_right</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width, <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a> padding_char) const noexcept</td></tr>
<tr class="memdesc:a7948b86a1e0b7a58d6813048a74c4106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:a7948b86a1e0b7a58d6813048a74c4106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856547e0780ad2ada0c0f614dc063df" id="r_a5856547e0780ad2ada0c0f614dc063df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5856547e0780ad2ada0c0f614dc063df">quoted</a> () const</td></tr>
<tr class="memdesc:a5856547e0780ad2ada0c0f614dc063df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>.  <br /></td></tr>
<tr class="separator:a5856547e0780ad2ada0c0f614dc063df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773214921b5ced5e4a8d4c25dd88891c" id="r_a773214921b5ced5e4a8d4c25dd88891c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a773214921b5ced5e4a8d4c25dd88891c">quoted</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> delimiter) const</td></tr>
<tr class="memdesc:a773214921b5ced5e4a8d4c25dd88891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter.  <br /></td></tr>
<tr class="separator:a773214921b5ced5e4a8d4c25dd88891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19de7bf5a27c141a306859535be853a" id="r_af19de7bf5a27c141a306859535be853a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af19de7bf5a27c141a306859535be853a">quoted</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> delimiter, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0ebc3c409070d07f1df0f2f4132509e">escape</a>) const</td></tr>
<tr class="memdesc:af19de7bf5a27c141a306859535be853a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape.  <br /></td></tr>
<tr class="separator:af19de7bf5a27c141a306859535be853a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb28698bda96ef32e834d79377523c7" id="r_a5fb28698bda96ef32e834d79377523c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb28698bda96ef32e834d79377523c7">remove</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a5fb28698bda96ef32e834d79377523c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a5fb28698bda96ef32e834d79377523c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f92a6d19c47147afc8eacf6f9c6b3" id="r_a678f92a6d19c47147afc8eacf6f9c6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a678f92a6d19c47147afc8eacf6f9c6b3">remove</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:a678f92a6d19c47147afc8eacf6f9c6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a678f92a6d19c47147afc8eacf6f9c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8e9d4ff2110bf9f24035babdc2a1ef" id="r_aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab8e9d4ff2110bf9f24035babdc2a1ef">replace</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> old_char, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> new_char) const noexcept</td></tr>
<tr class="memdesc:aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified char_t in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified char_t.  <br /></td></tr>
<tr class="separator:aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dba25995a5713a69ad528fc0dcf889" id="r_a80dba25995a5713a69ad528fc0dcf889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80dba25995a5713a69ad528fc0dcf889">replace</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;old_string, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;new_string) const noexcept</td></tr>
<tr class="memdesc:a80dba25995a5713a69ad528fc0dcf889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a80dba25995a5713a69ad528fc0dcf889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4f156b7f8196bcf93d922f5a0936d3" id="r_a2e4f156b7f8196bcf93d922f5a0936d3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e4f156b7f8196bcf93d922f5a0936d3">rfind</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a2e4f156b7f8196bcf93d922f5a0936d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code><a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a></code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a2e4f156b7f8196bcf93d922f5a0936d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58fe89ac239e9c5c32ed70df7c7c883" id="r_ad58fe89ac239e9c5c32ed70df7c7c883"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad58fe89ac239e9c5c32ed70df7c7c883">rfind</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:ad58fe89ac239e9c5c32ed70df7c7c883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:ad58fe89ac239e9c5c32ed70df7c7c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b86f1367a8a62bd5c9ec81730c6ff03" id="r_a2b86f1367a8a62bd5c9ec81730c6ff03"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b86f1367a8a62bd5c9ec81730c6ff03">rfind</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:a2b86f1367a8a62bd5c9ec81730c6ff03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a2b86f1367a8a62bd5c9ec81730c6ff03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5e3a4d7133856d265119fea8ec612f" id="r_a2c5e3a4d7133856d265119fea8ec612f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c5e3a4d7133856d265119fea8ec612f">rfind</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a2c5e3a4d7133856d265119fea8ec612f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code><a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a></code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a2c5e3a4d7133856d265119fea8ec612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7dc0272a38daae9fe92213bf3743f" id="r_afff7dc0272a38daae9fe92213bf3743f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff7dc0272a38daae9fe92213bf3743f">rfind</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:afff7dc0272a38daae9fe92213bf3743f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:afff7dc0272a38daae9fe92213bf3743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89758e3790f9444b86efcdb7b0ecbee2" id="r_a89758e3790f9444b86efcdb7b0ecbee2"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89758e3790f9444b86efcdb7b0ecbee2">rfind</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> ch) const</td></tr>
<tr class="memdesc:a89758e3790f9444b86efcdb7b0ecbee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code><a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a></code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a89758e3790f9444b86efcdb7b0ecbee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2a1c61ed2fd70d04090ff9e4ce3374" id="r_a6f2a1c61ed2fd70d04090ff9e4ce3374"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f2a1c61ed2fd70d04090ff9e4ce3374">rfind</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> ch, size_type pos) const</td></tr>
<tr class="memdesc:a6f2a1c61ed2fd70d04090ff9e4ce3374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a6f2a1c61ed2fd70d04090ff9e4ce3374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1344c6559dbf009f5ab4bebe64b6bb69" id="r_a1344c6559dbf009f5ab4bebe64b6bb69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1344c6559dbf009f5ab4bebe64b6bb69">split</a> () const noexcept</td></tr>
<tr class="memdesc:a1344c6559dbf009f5ab4bebe64b6bb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the default white-space characters. White-space characters are defined by the c++ standard and return <code>true</code> if they are passed to the xtd::char_object::isspace() or std::iswspace() method.  <br /></td></tr>
<tr class="separator:a1344c6559dbf009f5ab4bebe64b6bb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5dd5044af32ac25bb0baf9b6413342" id="r_a5f5dd5044af32ac25bb0baf9b6413342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f5dd5044af32ac25bb0baf9b6413342">split</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>) const noexcept</td></tr>
<tr class="memdesc:a5f5dd5044af32ac25bb0baf9b6413342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the characters in an array.  <br /></td></tr>
<tr class="separator:a5f5dd5044af32ac25bb0baf9b6413342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edaf9bbe18d8453a1a4efbf54e74870" id="r_a8edaf9bbe18d8453a1a4efbf54e74870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8edaf9bbe18d8453a1a4efbf54e74870">split</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a8edaf9bbe18d8453a1a4efbf54e74870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.  <br /></td></tr>
<tr class="separator:a8edaf9bbe18d8453a1a4efbf54e74870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2382e0600fa5915622f8eafd4c72bb" id="r_afd2382e0600fa5915622f8eafd4c72bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd2382e0600fa5915622f8eafd4c72bb">split</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const noexcept</td></tr>
<tr class="memdesc:afd2382e0600fa5915622f8eafd4c72bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return.  <br /></td></tr>
<tr class="separator:afd2382e0600fa5915622f8eafd4c72bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbf084f9d5a9dcd94e199f33e18da31" id="r_a2cbf084f9d5a9dcd94e199f33e18da31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cbf084f9d5a9dcd94e199f33e18da31">split</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a2cbf084f9d5a9dcd94e199f33e18da31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array.  <br /></td></tr>
<tr class="separator:a2cbf084f9d5a9dcd94e199f33e18da31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26322b05a341263f70f5dbb8559e1e49" id="r_a26322b05a341263f70f5dbb8559e1e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26322b05a341263f70f5dbb8559e1e49">split</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;separators) const noexcept</td></tr>
<tr class="memdesc:a26322b05a341263f70f5dbb8559e1e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the characters in an array.  <br /></td></tr>
<tr class="separator:a26322b05a341263f70f5dbb8559e1e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5de967d299899ed013ff09081289601" id="r_af5de967d299899ed013ff09081289601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5de967d299899ed013ff09081289601">split</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;separators, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:af5de967d299899ed013ff09081289601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.  <br /></td></tr>
<tr class="separator:af5de967d299899ed013ff09081289601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24f8ff6be34a9febe468cae4e98de8d" id="r_af24f8ff6be34a9febe468cae4e98de8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af24f8ff6be34a9febe468cae4e98de8d">split</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;separators, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const noexcept</td></tr>
<tr class="memdesc:af24f8ff6be34a9febe468cae4e98de8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return.  <br /></td></tr>
<tr class="separator:af24f8ff6be34a9febe468cae4e98de8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f0ee8ec40989e2f2b12c148174e73a" id="r_a77f0ee8ec40989e2f2b12c148174e73a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77f0ee8ec40989e2f2b12c148174e73a">split</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;separators, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a77f0ee8ec40989e2f2b12c148174e73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array.  <br /></td></tr>
<tr class="separator:a77f0ee8ec40989e2f2b12c148174e73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49e5676d2d8bc36ac6f9294626a433" id="r_acf49e5676d2d8bc36ac6f9294626a433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf49e5676d2d8bc36ac6f9294626a433">starts_with</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:acf49e5676d2d8bc36ac6f9294626a433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:acf49e5676d2d8bc36ac6f9294626a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844fc4d1f8f6465bb42b33c83ef11d38" id="r_a844fc4d1f8f6465bb42b33c83ef11d38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a844fc4d1f8f6465bb42b33c83ef11d38">starts_with</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:a844fc4d1f8f6465bb42b33c83ef11d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a844fc4d1f8f6465bb42b33c83ef11d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ab7003170f911983442950687fd66e" id="r_a46ab7003170f911983442950687fd66e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46ab7003170f911983442950687fd66e">starts_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a46ab7003170f911983442950687fd66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a46ab7003170f911983442950687fd66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc64225a0c82e51d464a248a98263d2" id="r_aefc64225a0c82e51d464a248a98263d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc64225a0c82e51d464a248a98263d2">starts_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:aefc64225a0c82e51d464a248a98263d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:aefc64225a0c82e51d464a248a98263d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa21b380225ae8dd5786e7d27b8a30fc" id="r_afa21b380225ae8dd5786e7d27b8a30fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa21b380225ae8dd5786e7d27b8a30fc">starts_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) const noexcept</td></tr>
<tr class="memdesc:afa21b380225ae8dd5786e7d27b8a30fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option.  <br /></td></tr>
<tr class="separator:afa21b380225ae8dd5786e7d27b8a30fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae796b1c2de68ac5b3c39e09361682bd2" id="r_ae796b1c2de68ac5b3c39e09361682bd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae796b1c2de68ac5b3c39e09361682bd2">substr</a> () const</td></tr>
<tr class="memdesc:ae796b1c2de68ac5b3c39e09361682bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:ae796b1c2de68ac5b3c39e09361682bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ea0f77673ecfbd266dc085d516e34a" id="r_aa8ea0f77673ecfbd266dc085d516e34a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8ea0f77673ecfbd266dc085d516e34a">substr</a> (size_type pos) const</td></tr>
<tr class="memdesc:aa8ea0f77673ecfbd266dc085d516e34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:aa8ea0f77673ecfbd266dc085d516e34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544b0e8a83055ed6041d1c8f32afb5ed" id="r_a544b0e8a83055ed6041d1c8f32afb5ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a544b0e8a83055ed6041d1c8f32afb5ed">substr</a> (size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>) const</td></tr>
<tr class="memdesc:a544b0e8a83055ed6041d1c8f32afb5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:a544b0e8a83055ed6041d1c8f32afb5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50394c19c9120fecc7228511cd07796b" id="r_a50394c19c9120fecc7228511cd07796b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50394c19c9120fecc7228511cd07796b">substring</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a50394c19c9120fecc7228511cd07796b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.  <br /></td></tr>
<tr class="separator:a50394c19c9120fecc7228511cd07796b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c075ac57baaa69e5cae23fa37a750de" id="r_a1c075ac57baaa69e5cae23fa37a750de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c075ac57baaa69e5cae23fa37a750de">substring</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>) const</td></tr>
<tr class="memdesc:a1c075ac57baaa69e5cae23fa37a750de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.  <br /></td></tr>
<tr class="separator:a1c075ac57baaa69e5cae23fa37a750de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65a379a9653c9aa95d4cdd67793ac53" id="r_af65a379a9653c9aa95d4cdd67793ac53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af65a379a9653c9aa95d4cdd67793ac53">to_array</a> () const noexcept</td></tr>
<tr class="memdesc:af65a379a9653c9aa95d4cdd67793ac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array.  <br /></td></tr>
<tr class="separator:af65a379a9653c9aa95d4cdd67793ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef5e889d2eec057dbb70531d7431ba1" id="r_a4ef5e889d2eec057dbb70531d7431ba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ef5e889d2eec057dbb70531d7431ba1">to_array</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a4ef5e889d2eec057dbb70531d7431ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index.  <br /></td></tr>
<tr class="separator:a4ef5e889d2eec057dbb70531d7431ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7c2c19ac001d245d0b6aacc6b893e9" id="r_aab7c2c19ac001d245d0b6aacc6b893e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab7c2c19ac001d245d0b6aacc6b893e9">to_array</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>) const</td></tr>
<tr class="memdesc:aab7c2c19ac001d245d0b6aacc6b893e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index with specified length.  <br /></td></tr>
<tr class="separator:aab7c2c19ac001d245d0b6aacc6b893e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57271b1de1ecc20c7f6eaaf9e1947a8d" id="r_a57271b1de1ecc20c7f6eaaf9e1947a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57271b1de1ecc20c7f6eaaf9e1947a8d">to_char_array</a> () const noexcept</td></tr>
<tr class="memdesc:a57271b1de1ecc20c7f6eaaf9e1947a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array.  <br /></td></tr>
<tr class="separator:a57271b1de1ecc20c7f6eaaf9e1947a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad26f801b726bf0e9f8e55ccfbb76bc" id="r_a7ad26f801b726bf0e9f8e55ccfbb76bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ad26f801b726bf0e9f8e55ccfbb76bc">to_char_array</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>) const</td></tr>
<tr class="memdesc:a7ad26f801b726bf0e9f8e55ccfbb76bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index with specified length.  <br /></td></tr>
<tr class="separator:a7ad26f801b726bf0e9f8e55ccfbb76bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0612d8c3d9feb6b741e2a0d0a07f2121" id="r_a0612d8c3d9feb6b741e2a0d0a07f2121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0612d8c3d9feb6b741e2a0d0a07f2121">to_lower</a> () const noexcept</td></tr>
<tr class="memdesc:a0612d8c3d9feb6b741e2a0d0a07f2121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> converted to lowercase.  <br /></td></tr>
<tr class="separator:a0612d8c3d9feb6b741e2a0d0a07f2121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dbb00bd5ca3a95303ece7973c23be8" id="r_a58dbb00bd5ca3a95303ece7973c23be8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58dbb00bd5ca3a95303ece7973c23be8">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:a58dbb00bd5ca3a95303ece7973c23be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;char&gt;.  <br /></td></tr>
<tr class="separator:a58dbb00bd5ca3a95303ece7973c23be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab652a0332d481e6ff0e234f6c8c629c" id="r_aab652a0332d481e6ff0e234f6c8c629c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab652a0332d481e6ff0e234f6c8c629c">to_title_case</a> () const noexcept</td></tr>
<tr class="memdesc:aab652a0332d481e6ff0e234f6c8c629c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to title case (except for words that are entirely in uppercase, which are considered to be acronyms).  <br /></td></tr>
<tr class="separator:aab652a0332d481e6ff0e234f6c8c629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5381c036c5cf11a5fff2b228dce8441" id="r_af5381c036c5cf11a5fff2b228dce8441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5381c036c5cf11a5fff2b228dce8441">to_u16string</a> () const noexcept</td></tr>
<tr class="memdesc:af5381c036c5cf11a5fff2b228dce8441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;.  <br /></td></tr>
<tr class="separator:af5381c036c5cf11a5fff2b228dce8441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de628a8933be7f9e8d1ec19b93b643" id="r_af6de628a8933be7f9e8d1ec19b93b643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6de628a8933be7f9e8d1ec19b93b643">to_u32string</a> () const noexcept</td></tr>
<tr class="memdesc:af6de628a8933be7f9e8d1ec19b93b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;.  <br /></td></tr>
<tr class="separator:af6de628a8933be7f9e8d1ec19b93b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c7f70f3570876064475705884708c6" id="r_ad8c7f70f3570876064475705884708c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8c7f70f3570876064475705884708c6">to_u8string</a> () const noexcept</td></tr>
<tr class="memdesc:ad8c7f70f3570876064475705884708c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;.  <br /></td></tr>
<tr class="separator:ad8c7f70f3570876064475705884708c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc6be7fa93346c34256fb76e6dc4b3a" id="r_a4cc6be7fa93346c34256fb76e6dc4b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a> () const noexcept</td></tr>
<tr class="memdesc:a4cc6be7fa93346c34256fb76e6dc4b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> converted to uppercase.  <br /></td></tr>
<tr class="separator:a4cc6be7fa93346c34256fb76e6dc4b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce3a3f2c42d41896f43593d3e853edf" id="r_a5ce3a3f2c42d41896f43593d3e853edf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ce3a3f2c42d41896f43593d3e853edf">to_wstring</a> () const noexcept</td></tr>
<tr class="memdesc:a5ce3a3f2c42d41896f43593d3e853edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302" title="Represents a wide character.">xtd::wchar</a>&gt;.  <br /></td></tr>
<tr class="separator:a5ce3a3f2c42d41896f43593d3e853edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12abc4b92c5666dbe597aebe733796e1" id="r_a12abc4b92c5666dbe597aebe733796e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12abc4b92c5666dbe597aebe733796e1">trim</a> () const noexcept</td></tr>
<tr class="memdesc:a12abc4b92c5666dbe597aebe733796e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a12abc4b92c5666dbe597aebe733796e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008a2167029ed114ad95a3911d717b81" id="r_a008a2167029ed114ad95a3911d717b81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a008a2167029ed114ad95a3911d717b81">trim</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> trim_char) const noexcept</td></tr>
<tr class="memdesc:a008a2167029ed114ad95a3911d717b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> .  <br /></td></tr>
<tr class="separator:a008a2167029ed114ad95a3911d717b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8146db206c16a41c826fe5cc5d62926" id="r_ad8146db206c16a41c826fe5cc5d62926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8146db206c16a41c826fe5cc5d62926">trim</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:ad8146db206c16a41c826fe5cc5d62926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:ad8146db206c16a41c826fe5cc5d62926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0a8e47fafff38f414e0a2fdae990bc" id="r_a9c0a8e47fafff38f414e0a2fdae990bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c0a8e47fafff38f414e0a2fdae990bc">trim_end</a> () const noexcept</td></tr>
<tr class="memdesc:a9c0a8e47fafff38f414e0a2fdae990bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a9c0a8e47fafff38f414e0a2fdae990bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cd7da5dcdbb9e48b57b074d45c4086" id="r_ac0cd7da5dcdbb9e48b57b074d45c4086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0cd7da5dcdbb9e48b57b074d45c4086">trim_end</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> trim_char) const noexcept</td></tr>
<tr class="memdesc:ac0cd7da5dcdbb9e48b57b074d45c4086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> .  <br /></td></tr>
<tr class="separator:ac0cd7da5dcdbb9e48b57b074d45c4086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040906f5d3bac8da047872886e0ec723" id="r_a040906f5d3bac8da047872886e0ec723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a040906f5d3bac8da047872886e0ec723">trim_end</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:a040906f5d3bac8da047872886e0ec723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a040906f5d3bac8da047872886e0ec723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86342c41edcf3e05ef56d2a170d1389" id="r_ac86342c41edcf3e05ef56d2a170d1389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac86342c41edcf3e05ef56d2a170d1389">trim_start</a> () const noexcept</td></tr>
<tr class="memdesc:ac86342c41edcf3e05ef56d2a170d1389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:ac86342c41edcf3e05ef56d2a170d1389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f441a6805a2fe3cfa6467eeecab5d3e" id="r_a4f441a6805a2fe3cfa6467eeecab5d3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f441a6805a2fe3cfa6467eeecab5d3e">trim_start</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> trim_char) const noexcept</td></tr>
<tr class="memdesc:a4f441a6805a2fe3cfa6467eeecab5d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> .  <br /></td></tr>
<tr class="separator:a4f441a6805a2fe3cfa6467eeecab5d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b36d97086675150ce441a1da48d3da3" id="r_a6b36d97086675150ce441a1da48d3da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b36d97086675150ce441a1da48d3da3">trim_start</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:a6b36d97086675150ce441a1da48d3da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a6b36d97086675150ce441a1da48d3da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:a6fb70bd0d2a63dbd30c7256fc22563ed" id="r_a6fb70bd0d2a63dbd30c7256fc22563ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fb70bd0d2a63dbd30c7256fc22563ed">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b) noexcept</td></tr>
<tr class="memdesc:a6fb70bd0d2a63dbd30c7256fc22563ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a6fb70bd0d2a63dbd30c7256fc22563ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f962d883014226a68c6a4d654ddb1b3" id="r_a6f962d883014226a68c6a4d654ddb1b3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f962d883014226a68c6a4d654ddb1b3">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:a6f962d883014226a68c6a4d654ddb1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a6f962d883014226a68c6a4d654ddb1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f90cbdcb6cc485cf796ba6105f0ed3" id="r_a03f90cbdcb6cc485cf796ba6105f0ed3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03f90cbdcb6cc485cf796ba6105f0ed3">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) noexcept</td></tr>
<tr class="memdesc:a03f90cbdcb6cc485cf796ba6105f0ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a03f90cbdcb6cc485cf796ba6105f0ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc411e57525bdd57f6de7607b8f6542" id="r_a9fc411e57525bdd57f6de7607b8f6542"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fc411e57525bdd57f6de7607b8f6542">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index_b, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>)</td></tr>
<tr class="memdesc:a9fc411e57525bdd57f6de7607b8f6542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a9fc411e57525bdd57f6de7607b8f6542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad607d694b591590cfb8a179a012a9641" id="r_ad607d694b591590cfb8a179a012a9641"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad607d694b591590cfb8a179a012a9641">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index_b, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>, bool ignore_case)</td></tr>
<tr class="memdesc:ad607d694b591590cfb8a179a012a9641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:ad607d694b591590cfb8a179a012a9641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a8880cff5658a0b1a23d8ee576328a" id="r_a58a8880cff5658a0b1a23d8ee576328a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58a8880cff5658a0b1a23d8ee576328a">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index_b, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type)</td></tr>
<tr class="memdesc:a58a8880cff5658a0b1a23d8ee576328a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a58a8880cff5658a0b1a23d8ee576328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897d161d82900b9f756cb79b479c5351" id="r_a897d161d82900b9f756cb79b479c5351"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a897d161d82900b9f756cb79b479c5351">concat</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_c, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_d) noexcept</td></tr>
<tr class="memdesc:a897d161d82900b9f756cb79b479c5351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates four specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a897d161d82900b9f756cb79b479c5351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45af237c4737e733b0ca2ced78e4fa95" id="r_a45af237c4737e733b0ca2ced78e4fa95"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t, class object_c_t, class object_d_t&gt; </td></tr>
<tr class="memitem:a45af237c4737e733b0ca2ced78e4fa95"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45af237c4737e733b0ca2ced78e4fa95">concat</a> (object_a_t obj_a, object_b_t obj_b, object_c_t obj_c, object_d_t obj_d) noexcept</td></tr>
<tr class="memdesc:a45af237c4737e733b0ca2ced78e4fa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates four specified instances of object.  <br /></td></tr>
<tr class="separator:a45af237c4737e733b0ca2ced78e4fa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e3085a92a360bc1f6085145673dc64" id="r_a72e3085a92a360bc1f6085145673dc64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72e3085a92a360bc1f6085145673dc64">concat</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_c) noexcept</td></tr>
<tr class="memdesc:a72e3085a92a360bc1f6085145673dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates three specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a72e3085a92a360bc1f6085145673dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e213408c3f1ed719e9df3f798ef2c2d" id="r_a7e213408c3f1ed719e9df3f798ef2c2d"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t, class object_c_t&gt; </td></tr>
<tr class="memitem:a7e213408c3f1ed719e9df3f798ef2c2d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e213408c3f1ed719e9df3f798ef2c2d">concat</a> (object_a_t obj_a, object_b_t obj_b, object_c_t obj_c) noexcept</td></tr>
<tr class="memdesc:a7e213408c3f1ed719e9df3f798ef2c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates three specified instances of object.  <br /></td></tr>
<tr class="separator:a7e213408c3f1ed719e9df3f798ef2c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9717df63b6c2f2372c428c637869da8a" id="r_a9717df63b6c2f2372c428c637869da8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9717df63b6c2f2372c428c637869da8a">concat</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b) noexcept</td></tr>
<tr class="memdesc:a9717df63b6c2f2372c428c637869da8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a9717df63b6c2f2372c428c637869da8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03788833b277a559456d8adfc727218c" id="r_a03788833b277a559456d8adfc727218c"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a03788833b277a559456d8adfc727218c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03788833b277a559456d8adfc727218c">concat</a> (object_a_t obj_a, object_b_t obj_b) noexcept</td></tr>
<tr class="memdesc:a03788833b277a559456d8adfc727218c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two specified instances of object.  <br /></td></tr>
<tr class="separator:a03788833b277a559456d8adfc727218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81226baa5f8d9ba7538c7d8b4a3449b" id="r_ac81226baa5f8d9ba7538c7d8b4a3449b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac81226baa5f8d9ba7538c7d8b4a3449b">concat</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; &amp;values) noexcept</td></tr>
<tr class="memdesc:ac81226baa5f8d9ba7538c7d8b4a3449b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the elements of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> array.  <br /></td></tr>
<tr class="separator:ac81226baa5f8d9ba7538c7d8b4a3449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2df32b25b6236f532243869d9bc5541" id="r_ab2df32b25b6236f532243869d9bc5541"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ab2df32b25b6236f532243869d9bc5541"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2df32b25b6236f532243869d9bc5541">concat</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; object_t &gt; &amp;args) noexcept</td></tr>
<tr class="memdesc:ab2df32b25b6236f532243869d9bc5541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representations of the elements in a specified object array.  <br /></td></tr>
<tr class="separator:ab2df32b25b6236f532243869d9bc5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4994f61a96b71e100492512d0a8e9b5" id="r_ac4994f61a96b71e100492512d0a8e9b5"><td class="memTemplParams" colspan="2">template&lt;class value_t&gt; </td></tr>
<tr class="memitem:ac4994f61a96b71e100492512d0a8e9b5"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4994f61a96b71e100492512d0a8e9b5">concat</a> (value_t value) noexcept</td></tr>
<tr class="memdesc:ac4994f61a96b71e100492512d0a8e9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representation of a specified object.  <br /></td></tr>
<tr class="separator:ac4994f61a96b71e100492512d0a8e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2778ed4d8fd85400ff448179da68a592" id="r_a2778ed4d8fd85400ff448179da68a592"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2778ed4d8fd85400ff448179da68a592">demangle</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;name)</td></tr>
<tr class="memdesc:a2778ed4d8fd85400ff448179da68a592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets demangled <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> of name,.  <br /></td></tr>
<tr class="separator:a2778ed4d8fd85400ff448179da68a592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9573cce5da4b27808874ef0c1aae00" id="r_a6c9573cce5da4b27808874ef0c1aae00"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c9573cce5da4b27808874ef0c1aae00">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a>, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a92eb5ffee6ae2fec3ad71c777531578f">b</a>) noexcept</td></tr>
<tr class="memdesc:a6c9573cce5da4b27808874ef0c1aae00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value.  <br /></td></tr>
<tr class="separator:a6c9573cce5da4b27808874ef0c1aae00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7ee87a503480f443dcefa417db2fe6" id="r_a9d7ee87a503480f443dcefa417db2fe6"><td class="memTemplParams" colspan="2">template&lt;class char_a_t, class char_b_t&gt; </td></tr>
<tr class="memitem:a9d7ee87a503480f443dcefa417db2fe6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d7ee87a503480f443dcefa417db2fe6">equals</a> (const char_a_t *<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a>, const char_b_t *<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a92eb5ffee6ae2fec3ad71c777531578f">b</a>) noexcept</td></tr>
<tr class="memdesc:a9d7ee87a503480f443dcefa417db2fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value.  <br /></td></tr>
<tr class="separator:a9d7ee87a503480f443dcefa417db2fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e41bbb8db6a246cf7965a565446ac8" id="r_a47e41bbb8db6a246cf7965a565446ac8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47e41bbb8db6a246cf7965a565446ac8">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a>, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a92eb5ffee6ae2fec3ad71c777531578f">b</a>, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:a47e41bbb8db6a246cf7965a565446ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a47e41bbb8db6a246cf7965a565446ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d99f1ae4294e002f20661d66567150f" id="r_a7d99f1ae4294e002f20661d66567150f"><td class="memTemplParams" colspan="2">template&lt;class char_a_t, class char_b_t&gt; </td></tr>
<tr class="memitem:a7d99f1ae4294e002f20661d66567150f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7d99f1ae4294e002f20661d66567150f">equals</a> (const char_a_t *<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a>, const char_b_t *<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a92eb5ffee6ae2fec3ad71c777531578f">b</a>, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:a7d99f1ae4294e002f20661d66567150f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a7d99f1ae4294e002f20661d66567150f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591487f7c52877614fd80f43a332d455" id="r_ga591487f7c52877614fd80f43a332d455"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:ga591487f7c52877614fd80f43a332d455"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__format__parse.html#ga591487f7c52877614fd80f43a332d455">format</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;fmt, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga591487f7c52877614fd80f43a332d455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the text representation of the specified arguments list, to string using the specified format information.  <br /></td></tr>
<tr class="separator:ga591487f7c52877614fd80f43a332d455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98008427f78fbbdc34fe5a97bbd1db48" id="r_ga98008427f78fbbdc34fe5a97bbd1db48"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:ga98008427f78fbbdc34fe5a97bbd1db48"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__format__parse.html#ga98008427f78fbbdc34fe5a97bbd1db48">format</a> (const std::locale &amp;loc, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;fmt, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga98008427f78fbbdc34fe5a97bbd1db48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the text representation of the specified arguments list, to string using the specified format information.  <br /></td></tr>
<tr class="separator:ga98008427f78fbbdc34fe5a97bbd1db48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bdd160233334a9b7d36af486906d4b" id="r_ab4bdd160233334a9b7d36af486906d4b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4bdd160233334a9b7d36af486906d4b">is_empty</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a>, traits_type, allocator_type &gt; &amp;<a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">string</a>) noexcept</td></tr>
<tr class="memdesc:ab4bdd160233334a9b7d36af486906d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specifeid <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> ("").  <br /></td></tr>
<tr class="separator:ab4bdd160233334a9b7d36af486906d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fec4215eab2492f3bc1bf81117dd09" id="r_a43fec4215eab2492f3bc1bf81117dd09"><td class="memTemplParams" colspan="2">template&lt;class collection_t&gt; </td></tr>
<tr class="memitem:a43fec4215eab2492f3bc1bf81117dd09"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43fec4215eab2492f3bc1bf81117dd09">join</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values) noexcept</td></tr>
<tr class="memdesc:a43fec4215eab2492f3bc1bf81117dd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a43fec4215eab2492f3bc1bf81117dd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aece978830816e4b33a685b27cc31e3" id="r_a5aece978830816e4b33a685b27cc31e3"><td class="memTemplParams" colspan="2">template&lt;class collection_t&gt; </td></tr>
<tr class="memitem:a5aece978830816e4b33a685b27cc31e3"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5aece978830816e4b33a685b27cc31e3">join</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index)</td></tr>
<tr class="memdesc:a5aece978830816e4b33a685b27cc31e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a5aece978830816e4b33a685b27cc31e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5012723424590a079c236dfdc8f8968e" id="r_a5012723424590a079c236dfdc8f8968e"><td class="memTemplParams" colspan="2">template&lt;class collection_t&gt; </td></tr>
<tr class="memitem:a5012723424590a079c236dfdc8f8968e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5012723424590a079c236dfdc8f8968e">join</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a05eea430b375cd6362b5cc42416e1fd2">count</a>)</td></tr>
<tr class="memdesc:a5012723424590a079c236dfdc8f8968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified Object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a5012723424590a079c236dfdc8f8968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0616ee2fd16ff911dafe84b19522ec75" id="r_a0616ee2fd16ff911dafe84b19522ec75"><td class="memTemplParams" colspan="2">template&lt;class value_t&gt; </td></tr>
<tr class="memitem:a0616ee2fd16ff911dafe84b19522ec75"><td class="memTemplItemLeft" align="right" valign="top">static value_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0616ee2fd16ff911dafe84b19522ec75">parse</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str)</td></tr>
<tr class="memdesc:a0616ee2fd16ff911dafe84b19522ec75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a value_t type.  <br /></td></tr>
<tr class="separator:a0616ee2fd16ff911dafe84b19522ec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d4b243f60f84e512a0fb001f40f066" id="r_ga06d4b243f60f84e512a0fb001f40f066"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:ga06d4b243f60f84e512a0fb001f40f066"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__format__parse.html#ga06d4b243f60f84e512a0fb001f40f066">sprintf</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;fmt, args_t &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:ga06d4b243f60f84e512a0fb001f40f066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the text representation of the specified arguments list, to <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> using the specified format information.  <br /></td></tr>
<tr class="separator:ga06d4b243f60f84e512a0fb001f40f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389cf357f98d28ecb33f535462289251" id="r_a389cf357f98d28ecb33f535462289251"><td class="memTemplParams" colspan="2">template&lt;class value_t&gt; </td></tr>
<tr class="memitem:a389cf357f98d28ecb33f535462289251"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a389cf357f98d28ecb33f535462289251">try_parse</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, value_t &amp;value) noexcept</td></tr>
<tr class="memdesc:a389cf357f98d28ecb33f535462289251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to convert a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a value_t type.  <br /></td></tr>
<tr class="separator:a389cf357f98d28ecb33f535462289251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:a1b6f4bbb7a3c18056332b28dae525927" id="r_a1b6f4bbb7a3c18056332b28dae525927"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td></tr>
<tr class="memdesc:a1b6f4bbb7a3c18056332b28dae525927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a1b6f4bbb7a3c18056332b28dae525927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca94147a6d4b2892d5b762764520cdd2" id="r_aca94147a6d4b2892d5b762764520cdd2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#aca94147a6d4b2892d5b762764520cdd2">iterator</a></td></tr>
<tr class="memdesc:aca94147a6d4b2892d5b762764520cdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:aca94147a6d4b2892d5b762764520cdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab620a4ddfe6c67a30040f3431b4322d5" id="r_ab620a4ddfe6c67a30040f3431b4322d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#ab620a4ddfe6c67a30040f3431b4322d5">const_iterator</a></td></tr>
<tr class="memdesc:ab620a4ddfe6c67a30040f3431b4322d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:ab620a4ddfe6c67a30040f3431b4322d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff72a2ec99d0023552f723de3705c4d" id="r_a6ff72a2ec99d0023552f723de3705c4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a6ff72a2ec99d0023552f723de3705c4d">iterator</a></td></tr>
<tr class="memdesc:a6ff72a2ec99d0023552f723de3705c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of enumerable value type.  <br /></td></tr>
<tr class="separator:a6ff72a2ec99d0023552f723de3705c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d5d971f36778bdd43d0e8eb5cc62e8" id="r_a37d5d971f36778bdd43d0e8eb5cc62e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a></td></tr>
<tr class="memdesc:a37d5d971f36778bdd43d0e8eb5cc62e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of enumerable value type.  <br /></td></tr>
<tr class="separator:a37d5d971f36778bdd43d0e8eb5cc62e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0428a5d439bb7fd6a75f0ca54751c5" id="r_afa0428a5d439bb7fd6a75f0ca54751c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afa0428a5d439bb7fd6a75f0ca54751c5">enumerable_type</a></td></tr>
<tr class="memdesc:afa0428a5d439bb7fd6a75f0ca54751c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable enumerable type.  <br /></td></tr>
<tr class="separator:afa0428a5d439bb7fd6a75f0ca54751c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723aac49b8d3459b2caaff26c2ab90e0" id="r_a723aac49b8d3459b2caaff26c2ab90e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a723aac49b8d3459b2caaff26c2ab90e0">source_type</a></td></tr>
<tr class="memdesc:a723aac49b8d3459b2caaff26c2ab90e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable source type.  <br /></td></tr>
<tr class="separator:a723aac49b8d3459b2caaff26c2ab90e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f" id="r_aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a></td></tr>
<tr class="memdesc:aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2" id="r_a417e4adb1792949e9a54516bee2ca3d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a></td></tr>
<tr class="memdesc:a417e4adb1792949e9a54516bee2ca3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a417e4adb1792949e9a54516bee2ca3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4cd1814acf74f3359393306249030536" name="a4cd1814acf74f3359393306249030536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd1814acf74f3359393306249030536">&#9670;&#160;</a></span>compare() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter:<ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the characters in the range [<code>s</code>, <code>s + count2</code>). The characters in [<code>s</code>, <code>s + count2</code>) may include null characters.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a785e7ca9244c89a0fd0552a30dca0df6" name="a785e7ca9244c89a0fd0552a30dca0df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785e7ca9244c89a0fd0552a30dca0df6">&#9670;&#160;</a></span>compare_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this instance with a specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An object that evaluates to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">This instance precedes <code>value</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">This instance has the same position in the sort order as <code>value</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">This instance follows <code>value</code>.   </td></tr>
</table>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`value` is not a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56991bcdcf3648e12180abbda6d0e4a2" name="a56991bcdcf3648e12180abbda6d0e4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56991bcdcf3648e12180abbda6d0e4a2">&#9670;&#160;</a></span>compare_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this instance with a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare with this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <code>value</code> parameter. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">This instance precedes <code>value</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">This instance has the same position in the sort order as <code>value</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">This instance follows <code>value</code>.   </td></tr>
</table>
</dd></dl>

<p>Implements <a class="el" href="classxtd_1_1icomparable.html#a8e5ad6ed9d798584e8b9be5749d6faa5">xtd::icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="a850cd349d2e010f36c975a32b150a981" name="a850cd349d2e010f36c975a32b150a981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850cd349d2e010f36c975a32b150a981">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified char occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a46fea739d2eea162481378cc3563e0e7" name="a46fea739d2eea162481378cc3563e0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fea739d2eea162481378cc3563e0e7">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified substring occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, or if value is the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="aa538684c095ac08578828af5eff7d48d" name="aa538684c095ac08578828af5eff7d48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa538684c095ac08578828af5eff7d48d">&#9670;&#160;</a></span>equals() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object, have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>obj</code> is a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> and its value is the same as this instance; otherwise, <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">xtd::object</a>.</p>

</div>
</div>
<a id="acf1e61a72cf0017e83126ebd8d409079" name="acf1e61a72cf0017e83126ebd8d409079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1e61a72cf0017e83126ebd8d409079">&#9670;&#160;</a></span>equals() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">xtd::iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="abe34c3ef80e295d524013594ab98e96f" name="abe34c3ef80e295d524013594ab98e96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe34c3ef80e295d524013594ab98e96f">&#9670;&#160;</a></span>equals() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing this instance and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal comparison. </dd></dl>

</div>
</div>
<a id="a88a32b980ce33e6240fad1bdf860be32" name="a88a32b980ce33e6240fad1bdf860be32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a32b980ce33e6240fad1bdf860be32">&#9670;&#160;</a></span>ends_with() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a235800cab8022150e0242be1f70ccba5" name="a235800cab8022150e0242be1f70ccba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235800cab8022150e0242be1f70ccba5">&#9670;&#160;</a></span>ends_with() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac9bb8f1452d6d3f0a504ed482aeff03d" name="ac9bb8f1452d6d3f0a504ed482aeff03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bb8f1452d6d3f0a504ed482aeff03d">&#9670;&#160;</a></span>ends_with() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="aad2260a3a56c452a4086de5c75d608f3" name="aad2260a3a56c452a4086de5c75d608f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2260a3a56c452a4086de5c75d608f3">&#9670;&#160;</a></span>ends_with() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a0d548b663eb6dc7b61394d0a5031a779" name="a0d548b663eb6dc7b61394d0a5031a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d548b663eb6dc7b61394d0a5031a779">&#9670;&#160;</a></span>ends_with() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a></td>          <td class="paramname"><span class="paramname"><em>comparison_type</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that determines how this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a995fc327f844695b7d54bb8c9dcefd64" name="a995fc327f844695b7d54bb8c9dcefd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995fc327f844695b7d54bb8c9dcefd64">&#9670;&#160;</a></span>find() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae7ef167753f97393efa4e8a04f645b1a" name="ae7ef167753f97393efa4e8a04f645b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef167753f97393efa4e8a04f645b1a">&#9670;&#160;</a></span>find() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="afa27496a7880e6ec15ed6af9f3ee63a9" name="afa27496a7880e6ec15ed6af9f3ee63a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa27496a7880e6ec15ed6af9f3ee63a9">&#9670;&#160;</a></span>find() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a5b84e810101f5722ea51155b57673c3a" name="a5b84e810101f5722ea51155b57673c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b84e810101f5722ea51155b57673c3a">&#9670;&#160;</a></span>find() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="afe01cbb72aa625955d5f91eaf20b4422" name="afe01cbb72aa625955d5f91eaf20b4422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe01cbb72aa625955d5f91eaf20b4422">&#9670;&#160;</a></span>find() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6e89be405fda67b0a224b7f5d19dbb74" name="a6e89be405fda67b0a224b7f5d19dbb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e89be405fda67b0a224b7f5d19dbb74">&#9670;&#160;</a></span>find() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="ada37711b3a6b2d96deb9937458eeed91" name="ada37711b3a6b2d96deb9937458eeed91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada37711b3a6b2d96deb9937458eeed91">&#9670;&#160;</a></span>find() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a190df4d0356f13ee707e02bf0ff69670" name="a190df4d0356f13ee707e02bf0ff69670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190df4d0356f13ee707e02bf0ff69670">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a47ad6cd829e5fb0e5ba7fd173fa52a4c" name="a47ad6cd829e5fb0e5ba7fd173fa52a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad6cd829e5fb0e5ba7fd173fa52a4c">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a92834b04a7c65b7de003f742e78d8309" name="a92834b04a7c65b7de003f742e78d8309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92834b04a7c65b7de003f742e78d8309">&#9670;&#160;</a></span>find_first_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="acb30d4555ab0d49edac1d1f29748968d" name="acb30d4555ab0d49edac1d1f29748968d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb30d4555ab0d49edac1d1f29748968d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a4bf3f78cb8fce98db32d6dea0dacb1fd" name="a4bf3f78cb8fce98db32d6dea0dacb1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf3f78cb8fce98db32d6dea0dacb1fd">&#9670;&#160;</a></span>find_first_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa63f087262d302ffd91d44441141395f" name="aa63f087262d302ffd91d44441141395f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63f087262d302ffd91d44441141395f">&#9670;&#160;</a></span>find_first_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="aebf0742e91a1bc6cc31486581993106d" name="aebf0742e91a1bc6cc31486581993106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf0742e91a1bc6cc31486581993106d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a44655a7fb2b16b0ac355f98efbe7f60a" name="a44655a7fb2b16b0ac355f98efbe7f60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44655a7fb2b16b0ac355f98efbe7f60a">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a865854c0f1fc517a76019ef74357471c" name="a865854c0f1fc517a76019ef74357471c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865854c0f1fc517a76019ef74357471c">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="aa7ee3d277929b2e2822347bbef0799ec" name="aa7ee3d277929b2e2822347bbef0799ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ee3d277929b2e2822347bbef0799ec">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa68c7409e9483b7fb2ecb4119a1a49c3" name="aa68c7409e9483b7fb2ecb4119a1a49c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68c7409e9483b7fb2ecb4119a1a49c3">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a394185c5018c818ca6e8c3cbf9048da1" name="a394185c5018c818ca6e8c3cbf9048da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394185c5018c818ca6e8c3cbf9048da1">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a525f7ed777b11690436a4e545cbd4c52" name="a525f7ed777b11690436a4e545cbd4c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525f7ed777b11690436a4e545cbd4c52">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="aa337f7f098dc744c16c768824cdbf5de" name="aa337f7f098dc744c16c768824cdbf5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa337f7f098dc744c16c768824cdbf5de">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="ada4b8376a5af873f844aa5de5a7f36f1" name="ada4b8376a5af873f844aa5de5a7f36f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4b8376a5af873f844aa5de5a7f36f1">&#9670;&#160;</a></span>find_last_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="abe8812d25aeb365b83a6e13b22d3ea15" name="abe8812d25aeb365b83a6e13b22d3ea15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8812d25aeb365b83a6e13b22d3ea15">&#9670;&#160;</a></span>find_last_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae683ad85d132dc61069a39ab5ecfc892" name="ae683ad85d132dc61069a39ab5ecfc892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae683ad85d132dc61069a39ab5ecfc892">&#9670;&#160;</a></span>find_last_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a3b9f9c97ebc85319e7bb0890747f95f0" name="a3b9f9c97ebc85319e7bb0890747f95f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9f9c97ebc85319e7bb0890747f95f0">&#9670;&#160;</a></span>find_last_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a43971d40fb8f9c14c8f2a8973fda5241" name="a43971d40fb8f9c14c8f2a8973fda5241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43971d40fb8f9c14c8f2a8973fda5241">&#9670;&#160;</a></span>find_last_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="ad3f1e765d3c800b53ad278aeea40cbbb" name="ad3f1e765d3c800b53ad278aeea40cbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f1e765d3c800b53ad278aeea40cbbb">&#9670;&#160;</a></span>find_last_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a2276b8461430eec909f87352134d92d8" name="a2276b8461430eec909f87352134d92d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2276b8461430eec909f87352134d92d8">&#9670;&#160;</a></span>find_last_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a85a0529754f7c547dd26d0e3df7d4d57" name="a85a0529754f7c547dd26d0e3df7d4d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a0529754f7c547dd26d0e3df7d4d57">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae7be46eecca48686b7893fdcc22f1064" name="ae7be46eecca48686b7893fdcc22f1064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7be46eecca48686b7893fdcc22f1064">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a0db0de794b93c1d3daec32ee93ebb840" name="a0db0de794b93c1d3daec32ee93ebb840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db0de794b93c1d3daec32ee93ebb840">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66" name="a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="ad867ec6c6bbe8ded000aab89983f5b37" name="ad867ec6c6bbe8ded000aab89983f5b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867ec6c6bbe8ded000aab89983f5b37">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a622aba17212244261f0a1dee4cf2a76c" name="a622aba17212244261f0a1dee4cf2a76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622aba17212244261f0a1dee4cf2a76c">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a2bb1e50a316279a814fbf6caa9a52512" name="a2bb1e50a316279a814fbf6caa9a52512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb1e50a316279a814fbf6caa9a52512">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a0f3fea87ee51c2cc221b5018ff83de9b" name="a0f3fea87ee51c2cc221b5018ff83de9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3fea87ee51c2cc221b5018ff83de9b">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="a38f45ba04d07446618d604b99c22fbb3" name="a38f45ba04d07446618d604b99c22fbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f45ba04d07446618d604b99c22fbb3">&#9670;&#160;</a></span>get_base_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const base_type &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_base_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type. </dd></dl>

</div>
</div>
<a id="a8204b499a2a327ac2193814c5ba59be4" name="a8204b499a2a327ac2193814c5ba59be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8204b499a2a327ac2193814c5ba59be4">&#9670;&#160;</a></span>get_hash_code()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_hash_code </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash code for this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">xtd::object</a>.</p>

</div>
</div>
<a id="a273eee6b3d879fdab255817b5406ff1b" name="a273eee6b3d879fdab255817b5406ff1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273eee6b3d879fdab255817b5406ff1b">&#9670;&#160;</a></span>get_enumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enumerator_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_enumerator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerator that iterates through a collection. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html" title="Supports a simple iteration over a generic collection.">xtd::collections::generic::enumerator</a> object that can be used to iterate through the collection. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a3247cf34dfb04a70d3efae2dce7ac8a7">xtd::collections::generic::ienumerable&lt; char_t &gt;</a>.</p>

</div>
</div>
<a id="aa2e2b0b18ffae65666bfe665f10c8eee" name="aa2e2b0b18ffae65666bfe665f10c8eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e2b0b18ffae65666bfe665f10c8eee">&#9670;&#160;</a></span>index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="ae8cdbff9d2baf8ca5354e0361db8b8f1" name="ae8cdbff9d2baf8ca5354e0361db8b8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cdbff9d2baf8ca5354e0361db8b8f1">&#9670;&#160;</a></span>index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a9376bff15d7276c49c0ce4ea3bd744b0" name="a9376bff15d7276c49c0ce4ea3bd744b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9376bff15d7276c49c0ce4ea3bd744b0">&#9670;&#160;</a></span>index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03cc9bdb3ebf738766cf0b8357d9f28d" name="a03cc9bdb3ebf738766cf0b8357d9f28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cc9bdb3ebf738766cf0b8357d9f28d">&#9670;&#160;</a></span>index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a1241d527912da0524fe79c1885104986" name="a1241d527912da0524fe79c1885104986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1241d527912da0524fe79c1885104986">&#9670;&#160;</a></span>index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a101dd613f8711c38c17443fbc8c29799" name="a101dd613f8711c38c17443fbc8c29799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101dd613f8711c38c17443fbc8c29799">&#9670;&#160;</a></span>index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50c38c1845d60e7d08f8750bb181aa4d" name="a50c38c1845d60e7d08f8750bb181aa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c38c1845d60e7d08f8750bb181aa4d">&#9670;&#160;</a></span>index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a19d7c6fb6ca5e05c6a464e8cb25c2e76" name="a19d7c6fb6ca5e05c6a464e8cb25c2e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d7c6fb6ca5e05c6a464e8cb25c2e76">&#9670;&#160;</a></span>index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac27b133bb5f4567decb3a19ff63a883" name="aac27b133bb5f4567decb3a19ff63a883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac27b133bb5f4567decb3a19ff63a883">&#9670;&#160;</a></span>index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48ce826afc61742ea2b759feb0987d9c" name="a48ce826afc61742ea2b759feb0987d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ce826afc61742ea2b759feb0987d9c">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a specified instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> at a specified index position in this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The index position of the insertion. </td></tr>
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to this instance but with value inserted at position start_index. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If start_index is equal to the length of this instance, value is appended to the end of this instance. </dd>
<dd>
For example, the return value of "abc".Insert(2, "XYZ") is "abXYZc". </dd></dl>

</div>
</div>
<a id="acc799a8cc31af232470d65cd88a1ca6a" name="acc799a8cc31af232470d65cd88a1ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc799a8cc31af232470d65cd88a1ca6a">&#9670;&#160;</a></span>last_index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a3b7a6db704899bd1263a714bf8363f6b" name="a3b7a6db704899bd1263a714bf8363f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a6db704899bd1263a714bf8363f6b">&#9670;&#160;</a></span>last_index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fb55029c7dfebcfb60989e102943e70" name="a4fb55029c7dfebcfb60989e102943e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb55029c7dfebcfb60989e102943e70">&#9670;&#160;</a></span>last_index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68a1c153b902e5edf0b877652add0e43" name="a68a1c153b902e5edf0b877652add0e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a1c153b902e5edf0b877652add0e43">&#9670;&#160;</a></span>last_index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this tring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="af8bdcec1f21421c38a7a80d8142ff7d5" name="af8bdcec1f21421c38a7a80d8142ff7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bdcec1f21421c38a7a80d8142ff7d5">&#9670;&#160;</a></span>last_index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c63d72cfa3f91e2cf9f23881f68d9a6" name="a8c63d72cfa3f91e2cf9f23881f68d9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c63d72cfa3f91e2cf9f23881f68d9a6">&#9670;&#160;</a></span>last_index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to find last index of. </td></tr>
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cef9de4c87f758793ab52f372999b98" name="a9cef9de4c87f758793ab52f372999b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cef9de4c87f758793ab52f372999b98">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ad9eee5a0186b0272dde1487fa3a76e31" name="ad9eee5a0186b0272dde1487fa3a76e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eee5a0186b0272dde1487fa3a76e31">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ac4c41879b43a215e17a3b3f1d940352b" name="ac4c41879b43a215e17a3b3f1d940352b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c41879b43a215e17a3b3f1d940352b">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a0841b4ac447cc426dfc86857696a59d3" name="a0841b4ac447cc426dfc86857696a59d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0841b4ac447cc426dfc86857696a59d3">&#9670;&#160;</a></span>pad_left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the right portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="acd8d49dec1f34267194ae3d6023e5bca" name="acd8d49dec1f34267194ae3d6023e5bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8d49dec1f34267194ae3d6023e5bca">&#9670;&#160;</a></span>pad_left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a></td>          <td class="paramname"><span class="paramname"><em>padding_char</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the right portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="abe37d71513cd7f2585290402bd45afb2" name="abe37d71513cd7f2585290402bd45afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe37d71513cd7f2585290402bd45afb2">&#9670;&#160;</a></span>pad_right() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but left-aligned and padded on the right with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The PadRight(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the end of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the left portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="a7948b86a1e0b7a58d6813048a74c4106" name="a7948b86a1e0b7a58d6813048a74c4106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7948b86a1e0b7a58d6813048a74c4106">&#9670;&#160;</a></span>pad_right() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a></td>          <td class="paramname"><span class="paramname"><em>padding_char</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but left-aligned and padded on the tight with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The <a class="el" href="#abe37d71513cd7f2585290402bd45afb2" title="Left-aligns the characters in this basic_string, padding with spaces on the right for a specified tot...">xtd::basic_string::pad_right</a> method pads the end of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the left portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="a5856547e0780ad2ada0c0f614dc063df" name="a5856547e0780ad2ada0c0f614dc063df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5856547e0780ad2ada0c0f614dc063df">&#9670;&#160;</a></span>quoted() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A new quoted <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>the delimiter is set to <pre class="fragment">" </pre> by default and the escape is set to <code>\</code> by default. </dd>
<dd>
for more information see <a href="https://en.cppreference.com/w/cpp/io/manip/quoted">std::quoted</a>. </dd></dl>

</div>
</div>
<a id="a773214921b5ced5e4a8d4c25dd88891c" name="a773214921b5ced5e4a8d4c25dd88891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773214921b5ced5e4a8d4c25dd88891c">&#9670;&#160;</a></span>quoted() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>The character to use as the delimiter, defaults to <code>"&lt;/tt&gt;.
@return A new quoted basic_string.
@remarks for more information see &lt;a href="<a href="https://en.cppreference.com/w/cpp/io/manip/quoted">https://en.cppreference.com/w/cpp/io/manip/quoted</a>" &gt;std::quoted. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19de7bf5a27c141a306859535be853a" name="af19de7bf5a27c141a306859535be853a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19de7bf5a27c141a306859535be853a">&#9670;&#160;</a></span>quoted() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>escape</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>The character to use as the delimiter, defaults to <code>"&lt;/tt&gt;.
@param escape The character to use as the escape character, defaults to &lt;tt&gt;\\&lt;/tt&gt;.
@return A new quoted basic_string.
@remarks for more information see &lt;a href="<a href="https://en.cppreference.com/w/cpp/io/manip/quoted">https://en.cppreference.com/w/cpp/io/manip/quoted</a>" &gt;std::quoted. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb28698bda96ef32e834d79377523c7" name="a5fb28698bda96ef32e834d79377523c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb28698bda96ef32e834d79377523c7">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is equivalent to this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> less the removed characters. </dd></dl>

</div>
</div>
<a id="a678f92a6d19c47147afc8eacf6f9c6b3" name="a678f92a6d19c47147afc8eacf6f9c6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f92a6d19c47147afc8eacf6f9c6b3">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is equivalent to this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> less the removed characters. </dd></dl>

</div>
</div>
<a id="aab8e9d4ff2110bf9f24035babdc2a1ef" name="aab8e9d4ff2110bf9f24035babdc2a1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8e9d4ff2110bf9f24035babdc2a1ef">&#9670;&#160;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>old_char</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>new_char</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified char_t in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified char_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>A char_t to be replaced. </td></tr>
    <tr><td class="paramname">new_char</td><td>A char_t to replace all occurrences of old_char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> but with all instances of old_char replaced with new_char. </dd></dl>

</div>
</div>
<a id="a80dba25995a5713a69ad528fc0dcf889" name="a80dba25995a5713a69ad528fc0dcf889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dba25995a5713a69ad528fc0dcf889">&#9670;&#160;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>old_string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_string</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_string</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to be replaced. </td></tr>
    <tr><td class="paramname">new_string</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to replace all occurrences of old_string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> but with all instances of old_string replaced with new_string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If new_string is empty, all occurrences of old_string are removed </dd></dl>

</div>
</div>
<a id="a2e4f156b7f8196bcf93d922f5a0936d3" name="a2e4f156b7f8196bcf93d922f5a0936d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4f156b7f8196bcf93d922f5a0936d3">&#9670;&#160;</a></span>rfind() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code><a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a></code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="ad58fe89ac239e9c5c32ed70df7c7c883" name="ad58fe89ac239e9c5c32ed70df7c7c883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58fe89ac239e9c5c32ed70df7c7c883">&#9670;&#160;</a></span>rfind() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="a2b86f1367a8a62bd5c9ec81730c6ff03" name="a2b86f1367a8a62bd5c9ec81730c6ff03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b86f1367a8a62bd5c9ec81730c6ff03">&#9670;&#160;</a></span>rfind() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a2c5e3a4d7133856d265119fea8ec612f" name="a2c5e3a4d7133856d265119fea8ec612f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5e3a4d7133856d265119fea8ec612f">&#9670;&#160;</a></span>rfind() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code><a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a></code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="afff7dc0272a38daae9fe92213bf3743f" name="afff7dc0272a38daae9fe92213bf3743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff7dc0272a38daae9fe92213bf3743f">&#9670;&#160;</a></span>rfind() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a89758e3790f9444b86efcdb7b0ecbee2" name="a89758e3790f9444b86efcdb7b0ecbee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89758e3790f9444b86efcdb7b0ecbee2">&#9670;&#160;</a></span>rfind() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code><a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a></code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a6f2a1c61ed2fd70d04090ff9e4ce3374" name="a6f2a1c61ed2fd70d04090ff9e4ce3374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2a1c61ed2fd70d04090ff9e4ce3374">&#9670;&#160;</a></span>rfind() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a1344c6559dbf009f5ab4bebe64b6bb69" name="a1344c6559dbf009f5ab4bebe64b6bb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1344c6559dbf009f5ab4bebe64b6bb69">&#9670;&#160;</a></span>split() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the default white-space characters. White-space characters are defined by the c++ standard and return <code>true</code> if they are passed to the xtd::char_object::isspace() or std::iswspace() method. </p>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in white-space separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="a5f5dd5044af32ac25bb0baf9b6413342" name="a5f5dd5044af32ac25bb0baf9b6413342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5dd5044af32ac25bb0baf9b6413342">&#9670;&#160;</a></span>split() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>separator</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A character that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="a8edaf9bbe18d8453a1a4efbf54e74870" name="a8edaf9bbe18d8453a1a4efbf54e74870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edaf9bbe18d8453a1a4efbf54e74870">&#9670;&#160;</a></span>split() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings based on the characters in an array. You can specify whether the substrings include empty array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A character that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the options parameter is remove_empty_entries and the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is zero, the method returns an empty array. </dd>
<dd>
Each element of separator defines a separate delimiter that consists of a single character. If the options argument is none, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. For example, if separator includes two elements, "-" and "_", the value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance is "-_aa-_", and the value of the options argument is None, the method returns a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> array with the following five elements:<ol type="1">
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that precedes the "-" character at index 0.</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between the "-" character at index 0 and the "_" character at index 1.</li>
<li>"aa",</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that follows the "_" character at index 4.</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that follows the "-" character at index 5. </li>
</ol>
</dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the c++ standard and return <code>true</code> if they are passed to the xtd::char_object::isspace() or std::iswspace() method. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="afd2382e0600fa5915622f8eafd4c72bb" name="afd2382e0600fa5915622f8eafd4c72bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2382e0600fa5915622f8eafd4c72bb">&#9670;&#160;</a></span>split() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return <code>true</code> if they are passed to the char_t.IsWhiteSpace method. </dd>
<dd>
Each element of separator defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If there are more than count substrings in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> are returned in the last element of the return value. </dd></dl>

</div>
</div>
<a id="a2cbf084f9d5a9dcd94e199f33e18da31" name="a2cbf084f9d5a9dcd94e199f33e18da31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbf084f9d5a9dcd94e199f33e18da31">&#9670;&#160;</a></span>split() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the count parameter is zero, or the options parameter is remove_empty_entries and the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is zero, an empty array is returned. </dd>
<dd>
Each element of separator defines a separate delimiter character. If the options parameter is None, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If there are more than count substrings in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> are returned in the last element of the return value. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="a26322b05a341263f70f5dbb8559e1e49" name="a26322b05a341263f70f5dbb8559e1e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26322b05a341263f70f5dbb8559e1e49">&#9670;&#160;</a></span>split() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>separators</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="af5de967d299899ed013ff09081289601" name="af5de967d299899ed013ff09081289601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5de967d299899ed013ff09081289601">&#9670;&#160;</a></span>split() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>separators</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings based on the characters in an array. You can specify whether the substrings include empty array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the options parameter is remove_empty_entries and the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is zero, the method returns an empty array. </dd>
<dd>
Each element of separator defines a separate delimiter that consists of a single character. If the options argument is none, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. For example, if separator includes two elements, "-" and "_", the value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance is "-_aa-_", and the value of the options argument is None, the method returns a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> array with the following five elements:<ol type="1">
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that precedes the "-" character at index 0.</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between the "-" character at index 0 and the "_" character at index 1.</li>
<li>"aa",</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that follows the "_" character at index 4.</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that follows the "-" character at index 5. </li>
</ol>
</dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the c++ standard and return <code>true</code> if they are passed to the xtd::char_object::isspace() or std::iswspace() method. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="af24f8ff6be34a9febe468cae4e98de8d" name="af24f8ff6be34a9febe468cae4e98de8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24f8ff6be34a9febe468cae4e98de8d">&#9670;&#160;</a></span>split() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>separators</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return <code>true</code> if they are passed to the char_t.IsWhiteSpace method. </dd>
<dd>
Each element of separator defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If there are more than count substrings in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> are returned in the last element of the return value. </dd></dl>

</div>
</div>
<a id="a77f0ee8ec40989e2f2b12c148174e73a" name="a77f0ee8ec40989e2f2b12c148174e73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f0ee8ec40989e2f2b12c148174e73a">&#9670;&#160;</a></span>split() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>separators</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the count parameter is zero, or the options parameter is remove_empty_entries and the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is zero, an empty array is returned. </dd>
<dd>
Each element of separator defines a separate delimiter character. If the options parameter is None, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If there are more than count substrings in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> are returned in the last element of the return value. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="acf49e5676d2d8bc36ac6f9294626a433" name="acf49e5676d2d8bc36ac6f9294626a433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf49e5676d2d8bc36ac6f9294626a433">&#9670;&#160;</a></span>starts_with() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="a844fc4d1f8f6465bb42b33c83ef11d38" name="a844fc4d1f8f6465bb42b33c83ef11d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844fc4d1f8f6465bb42b33c83ef11d38">&#9670;&#160;</a></span>starts_with() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to compare to. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="a46ab7003170f911983442950687fd66e" name="a46ab7003170f911983442950687fd66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ab7003170f911983442950687fd66e">&#9670;&#160;</a></span>starts_with() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="aefc64225a0c82e51d464a248a98263d2" name="aefc64225a0c82e51d464a248a98263d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc64225a0c82e51d464a248a98263d2">&#9670;&#160;</a></span>starts_with() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to compare to. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="afa21b380225ae8dd5786e7d27b8a30fc" name="afa21b380225ae8dd5786e7d27b8a30fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa21b380225ae8dd5786e7d27b8a30fc">&#9670;&#160;</a></span>starts_with() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a></td>          <td class="paramname"><span class="paramname"><em>comparison_type</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that determines how this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae796b1c2de68ac5b3c39e09361682bd2" name="ae796b1c2de68ac5b3c39e09361682bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae796b1c2de68ac5b3c39e09361682bd2">&#9670;&#160;</a></span>substr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="aa8ea0f77673ecfbd266dc085d516e34a" name="aa8ea0f77673ecfbd266dc085d516e34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ea0f77673ecfbd266dc085d516e34a">&#9670;&#160;</a></span>substr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="a544b0e8a83055ed6041d1c8f32afb5ed" name="a544b0e8a83055ed6041d1c8f32afb5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544b0e8a83055ed6041d1c8f32afb5ed">&#9670;&#160;</a></span>substr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="a50394c19c9120fecc7228511cd07796b" name="a50394c19c9120fecc7228511cd07796b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50394c19c9120fecc7228511cd07796b">&#9670;&#160;</a></span>substring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to substring. </td></tr>
    <tr><td class="paramname">start_index</td><td>The zero-based starting character position of a substring in this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the substring of length length that begins at start_index in this instance, or Empty if start_index is equal to the length of this instance and length is zero. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`start_index` is greater than the <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c075ac57baaa69e5cae23fa37a750de" name="a1c075ac57baaa69e5cae23fa37a750de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c075ac57baaa69e5cae23fa37a750de">&#9670;&#160;</a></span>substring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The zero-based starting character position of a substring in this instance. </td></tr>
    <tr><td class="paramname">length</td><td>The number of characters in the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the substring of length length that begins at start_index in this instance, or Empty if start_index is equal to the length of this instance and length is zero. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`start_index` plus `length` is greater than the <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af65a379a9653c9aa95d4cdd67793ac53" name="af65a379a9653c9aa95d4cdd67793ac53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65a379a9653c9aa95d4cdd67793ac53">&#9670;&#160;</a></span>to_array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_array </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array. </p>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a4ef5e889d2eec057dbb70531d7431ba1" name="a4ef5e889d2eec057dbb70531d7431ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef5e889d2eec057dbb70531d7431ba1">&#9670;&#160;</a></span>to_array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="aab7c2c19ac001d245d0b6aacc6b893e9" name="aab7c2c19ac001d245d0b6aacc6b893e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7c2c19ac001d245d0b6aacc6b893e9">&#9670;&#160;</a></span>to_array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index with specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a57271b1de1ecc20c7f6eaaf9e1947a8d" name="a57271b1de1ecc20c7f6eaaf9e1947a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57271b1de1ecc20c7f6eaaf9e1947a8d">&#9670;&#160;</a></span>to_char_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_char_array </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array. </p>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a7ad26f801b726bf0e9f8e55ccfbb76bc" name="a7ad26f801b726bf0e9f8e55ccfbb76bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad26f801b726bf0e9f8e55ccfbb76bc">&#9670;&#160;</a></span>to_char_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_char_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index with specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a0612d8c3d9feb6b741e2a0d0a07f2121" name="a0612d8c3d9feb6b741e2a0d0a07f2121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0612d8c3d9feb6b741e2a0d0a07f2121">&#9670;&#160;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> converted to lowercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A string in lowercase. </dd></dl>

</div>
</div>
<a id="a58dbb00bd5ca3a95303ece7973c23be8" name="a58dbb00bd5ca3a95303ece7973c23be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58dbb00bd5ca3a95303ece7973c23be8">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;char&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo</a></b></dt><dd>Uncomment the folllowing line and remove the next.. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">xtd::object</a>.</p>

</div>
</div>
<a id="aab652a0332d481e6ff0e234f6c8c629c" name="aab652a0332d481e6ff0e234f6c8c629c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab652a0332d481e6ff0e234f6c8c629c">&#9670;&#160;</a></span>to_title_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_title_case </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to title case (except for words that are entirely in uppercase, which are considered to be acronyms). </p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in title case. </dd></dl>

</div>
</div>
<a id="af5381c036c5cf11a5fff2b228dce8441" name="af5381c036c5cf11a5fff2b228dce8441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5381c036c5cf11a5fff2b228dce8441">&#9670;&#160;</a></span>to_u16string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_u16string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>

</div>
</div>
<a id="af6de628a8933be7f9e8d1ec19b93b643" name="af6de628a8933be7f9e8d1ec19b93b643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6de628a8933be7f9e8d1ec19b93b643">&#9670;&#160;</a></span>to_u32string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_u32string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>

</div>
</div>
<a id="ad8c7f70f3570876064475705884708c6" name="ad8c7f70f3570876064475705884708c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c7f70f3570876064475705884708c6">&#9670;&#160;</a></span>to_u8string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_u8string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>

</div>
</div>
<a id="a4cc6be7fa93346c34256fb76e6dc4b3a" name="a4cc6be7fa93346c34256fb76e6dc4b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc6be7fa93346c34256fb76e6dc4b3a">&#9670;&#160;</a></span>to_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> converted to uppercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A string in uppercase. </dd></dl>

</div>
</div>
<a id="a5ce3a3f2c42d41896f43593d3e853edf" name="a5ce3a3f2c42d41896f43593d3e853edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce3a3f2c42d41896f43593d3e853edf">&#9670;&#160;</a></span>to_wstring()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_wstring </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302" title="Represents a wide character.">xtd::wchar</a>&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>

</div>
</div>
<a id="a12abc4b92c5666dbe597aebe733796e1" name="a12abc4b92c5666dbe597aebe733796e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12abc4b92c5666dbe597aebe733796e1">&#9670;&#160;</a></span>trim() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start and te and of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a008a2167029ed114ad95a3911d717b81" name="a008a2167029ed114ad95a3911d717b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008a2167029ed114ad95a3911d717b81">&#9670;&#160;</a></span>trim() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>trim_char</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start and the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="ad8146db206c16a41c826fe5cc5d62926" name="ad8146db206c16a41c826fe5cc5d62926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8146db206c16a41c826fe5cc5d62926">&#9670;&#160;</a></span>trim() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trim_chars</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the characters in the trim_chars parameter are removed from the start and the edn of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a9c0a8e47fafff38f414e0a2fdae990bc" name="a9c0a8e47fafff38f414e0a2fdae990bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0a8e47fafff38f414e0a2fdae990bc">&#9670;&#160;</a></span>trim_end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="ac0cd7da5dcdbb9e48b57b074d45c4086" name="ac0cd7da5dcdbb9e48b57b074d45c4086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cd7da5dcdbb9e48b57b074d45c4086">&#9670;&#160;</a></span>trim_end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>trim_char</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a040906f5d3bac8da047872886e0ec723" name="a040906f5d3bac8da047872886e0ec723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040906f5d3bac8da047872886e0ec723">&#9670;&#160;</a></span>trim_end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trim_chars</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the characters in the trim_chars parameter are removed from the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="ac86342c41edcf3e05ef56d2a170d1389" name="ac86342c41edcf3e05ef56d2a170d1389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86342c41edcf3e05ef56d2a170d1389">&#9670;&#160;</a></span>trim_start() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_start </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a4f441a6805a2fe3cfa6467eeecab5d3e" name="a4f441a6805a2fe3cfa6467eeecab5d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f441a6805a2fe3cfa6467eeecab5d3e">&#9670;&#160;</a></span>trim_start() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>trim_char</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a6b36d97086675150ce441a1da48d3da3" name="a6b36d97086675150ce441a1da48d3da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b36d97086675150ce441a1da48d3da3">&#9670;&#160;</a></span>trim_start() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trim_chars</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the characters in the trim_chars parameter are removed from the start of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a6fb70bd0d2a63dbd30c7256fc22563ed" name="a6fb70bd0d2a63dbd30c7256fc22563ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb70bd0d2a63dbd30c7256fc22563ed">&#9670;&#160;</a></span>compare() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a6f962d883014226a68c6a4d654ddb1b3" name="a6f962d883014226a68c6a4d654ddb1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f962d883014226a68c6a4d654ddb1b3">&#9670;&#160;</a></span>compare() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a03f90cbdcb6cc485cf796ba6105f0ed3" name="a03f90cbdcb6cc485cf796ba6105f0ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f90cbdcb6cc485cf796ba6105f0ed3">&#9670;&#160;</a></span>compare() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a></td>          <td class="paramname"><span class="paramname"><em>comparison_type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects using the specified rules, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that specifies the rules to use in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a9fc411e57525bdd57f6de7607b8f6542" name="a9fc411e57525bdd57f6de7607b8f6542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc411e57525bdd57f6de7607b8f6542">&#9670;&#160;</a></span>compare() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ad607d694b591590cfb8a179a012a9641" name="ad607d694b591590cfb8a179a012a9641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad607d694b591590cfb8a179a012a9641">&#9670;&#160;</a></span>compare() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a58a8880cff5658a0b1a23d8ee576328a" name="a58a8880cff5658a0b1a23d8ee576328a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a8880cff5658a0b1a23d8ee576328a">&#9670;&#160;</a></span>compare() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a></td>          <td class="paramname"><span class="paramname"><em>comparison_type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects using the specified rules, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that specifies the rules to use in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a897d161d82900b9f756cb79b479c5351" name="a897d161d82900b9f756cb79b479c5351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897d161d82900b9f756cb79b479c5351">&#9670;&#160;</a></span>concat() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates four specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_c</td><td>The third <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_d</td><td>The fourth <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of str_a, str_b, str_c and str_d. </dd></dl>

</div>
</div>
<a id="a45af237c4737e733b0ca2ced78e4fa95" name="a45af237c4737e733b0ca2ced78e4fa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45af237c4737e733b0ca2ced78e4fa95">&#9670;&#160;</a></span>concat() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_a_t, class object_b_t, class object_c_t, class object_d_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t</td>          <td class="paramname"><span class="paramname"><em>obj_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t</td>          <td class="paramname"><span class="paramname"><em>obj_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_c_t</td>          <td class="paramname"><span class="paramname"><em>obj_c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_d_t</td>          <td class="paramname"><span class="paramname"><em>obj_d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates four specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
    <tr><td class="paramname">obj_c</td><td>The third object to concatenate. </td></tr>
    <tr><td class="paramname">obj_d</td><td>The fourth object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a, obj_b, obj_c and obj_d. </dd></dl>

</div>
</div>
<a id="a72e3085a92a360bc1f6085145673dc64" name="a72e3085a92a360bc1f6085145673dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e3085a92a360bc1f6085145673dc64">&#9670;&#160;</a></span>concat() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates three specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_c</td><td>The third <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> The concatenation of str_a, str_b and str_c. </dd></dl>

</div>
</div>
<a id="a7e213408c3f1ed719e9df3f798ef2c2d" name="a7e213408c3f1ed719e9df3f798ef2c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e213408c3f1ed719e9df3f798ef2c2d">&#9670;&#160;</a></span>concat() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_a_t, class object_b_t, class object_c_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t</td>          <td class="paramname"><span class="paramname"><em>obj_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t</td>          <td class="paramname"><span class="paramname"><em>obj_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_c_t</td>          <td class="paramname"><span class="paramname"><em>obj_c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates three specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
    <tr><td class="paramname">obj_c</td><td>The third object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a, obj_b and obj_c. </dd></dl>

</div>
</div>
<a id="a9717df63b6c2f2372c428c637869da8a" name="a9717df63b6c2f2372c428c637869da8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9717df63b6c2f2372c428c637869da8a">&#9670;&#160;</a></span>concat() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str_b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> The concatenation of str_a and str_b. </dd></dl>

</div>
</div>
<a id="a03788833b277a559456d8adfc727218c" name="a03788833b277a559456d8adfc727218c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03788833b277a559456d8adfc727218c">&#9670;&#160;</a></span>concat() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_a_t, class object_b_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t</td>          <td class="paramname"><span class="paramname"><em>obj_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t</td>          <td class="paramname"><span class="paramname"><em>obj_b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a and obj_b. </dd></dl>

</div>
</div>
<a id="ac81226baa5f8d9ba7538c7d8b4a3449b" name="ac81226baa5f8d9ba7538c7d8b4a3449b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81226baa5f8d9ba7538c7d8b4a3449b">&#9670;&#160;</a></span>concat() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the elements of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An array of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated elements of values. </dd></dl>

</div>
</div>
<a id="ab2df32b25b6236f532243869d9bc5541" name="ab2df32b25b6236f532243869d9bc5541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2df32b25b6236f532243869d9bc5541">&#9670;&#160;</a></span>concat() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; object_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representations of the elements in a specified object array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>An object array that contains the elements to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representations of the values of the elements in args. </dd></dl>

</div>
</div>
<a id="ac4994f61a96b71e100492512d0a8e9b5" name="ac4994f61a96b71e100492512d0a8e9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4994f61a96b71e100492512d0a8e9b5">&#9670;&#160;</a></span>concat() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">value_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representation of a specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to represent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representation of the value of arg. </dd></dl>

</div>
</div>
<a id="a2778ed4d8fd85400ff448179da68a592" name="a2778ed4d8fd85400ff448179da68a592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2778ed4d8fd85400ff448179da68a592">&#9670;&#160;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::demangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets demangled <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> of name,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to demangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The demangled <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> of name. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example shows how to use <a class="el" href="#a2778ed4d8fd85400ff448179da68a592" title="Gets demangled basic_string of name,.">xtd::basic_string::demangle</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;name = {}&quot;</span>, <span class="keyword">typeid</span>(<a class="code hl_class" href="classxtd_1_1date__time.html">xtd::date_time</a>).name());</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;demangled name = {}&quot;</span>, <a class="code hl_function" href="#a2778ed4d8fd85400ff448179da68a592">basic_string::demangle</a>(<span class="keyword">typeid</span>(<a class="code hl_class" href="classxtd_1_1date__time.html">xtd::date_time</a>).name()));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output on macOS :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// name = N3xtd9date_timeE</span></div>
<div class="line"><span class="comment">// demangled name = xtd::date_time</span></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_a2778ed4d8fd85400ff448179da68a592"><div class="ttname"><a href="#a2778ed4d8fd85400ff448179da68a592">xtd::basic_string::demangle</a></div><div class="ttdeci">static basic_string demangle(const basic_string &amp;name)</div><div class="ttdoc">Gets demangled basic_string of name,.</div><div class="ttdef"><b>Definition</b> basic_string.hpp:1636</div></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="aclassxtd_1_1date__time_html"><div class="ttname"><a href="classxtd_1_1date__time.html">xtd::date_time</a></div><div class="ttdoc">Represents an instant in time, typically expressed as a date and time of day.</div><div class="ttdef"><b>Definition</b> date_time.hpp:83</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> abstract_object.hpp:8</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6c9573cce5da4b27808874ef0c1aae00" name="a6c9573cce5da4b27808874ef0c1aae00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9573cce5da4b27808874ef0c1aae00">&#9670;&#160;</a></span>equals() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

</div>
</div>
<a id="a9d7ee87a503480f443dcefa417db2fe6" name="a9d7ee87a503480f443dcefa417db2fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7ee87a503480f443dcefa417db2fe6">&#9670;&#160;</a></span>equals() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class char_a_t, class char_b_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const char_a_t *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char_b_t *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

</div>
</div>
<a id="a47e41bbb8db6a246cf7965a565446ac8" name="a47e41bbb8db6a246cf7965a565446ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e41bbb8db6a246cf7965a565446ac8">&#9670;&#160;</a></span>equals() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing this instance and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal comparison. </dd></dl>

</div>
</div>
<a id="a7d99f1ae4294e002f20661d66567150f" name="a7d99f1ae4294e002f20661d66567150f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d99f1ae4294e002f20661d66567150f">&#9670;&#160;</a></span>equals() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class char_a_t, class char_b_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const char_a_t *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char_b_t *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing this instance and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal comparison. </dd></dl>

</div>
</div>
<a id="ab4bdd160233334a9b7d36af486906d4b" name="ab4bdd160233334a9b7d36af486906d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bdd160233334a9b7d36af486906d4b">&#9670;&#160;</a></span>is_empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a>, traits_type, allocator_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the specifeid <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to check if empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter is null or an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a43fec4215eab2492f3bc1bf81117dd09" name="a43fec4215eab2492f3bc1bf81117dd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fec4215eab2492f3bc1bf81117dd09">&#9670;&#160;</a></span>join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class collection_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> consisting of the elements of value interspersed with the separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a5aece978830816e4b33a685b27cc31e3" name="a5aece978830816e4b33a685b27cc31e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aece978830816e4b33a685b27cc31e3">&#9670;&#160;</a></span>join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class collection_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first array element in value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> consisting of the elements of value interspersed with the separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a5012723424590a079c236dfdc8f8968e" name="a5012723424590a079c236dfdc8f8968e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5012723424590a079c236dfdc8f8968e">&#9670;&#160;</a></span>join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class collection_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified Object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first array element in value to use. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements of value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> consisting of the elements of value interspersed with the separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a0616ee2fd16ff911dafe84b19522ec75" name="a0616ee2fd16ff911dafe84b19522ec75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0616ee2fd16ff911dafe84b19522ec75">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static value_t <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a value_t type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Ax <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to convert to value_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value_t object parsed. </dd></dl>

</div>
</div>
<a id="a389cf357f98d28ecb33f535462289251" name="a389cf357f98d28ecb33f535462289251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389cf357f98d28ecb33f535462289251">&#9670;&#160;</a></span>try_parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::try_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to convert a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a value_t type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to convert to value_t </td></tr>
    <tr><td class="paramname">value</td><td>The value that will contain the parsed <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>:=:try_parse succed; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="af6f4efe678e6742104ad6b0ddb3fc2db" name="af6f4efe678e6742104ad6b0ddb3fc2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f4efe678e6742104ad6b0ddb3fc2db">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the character at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the character to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6775931e51f45aad56df1c249c578832" name="a6775931e51f45aad56df1c249c578832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6775931e51f45aad56df1c249c578832">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator const base_type &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a8e7fad567430f490e373f26b2d7dce9d" name="a8e7fad567430f490e373f26b2d7dce9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7fad567430f490e373f26b2d7dce9d">&#9670;&#160;</a></span>operator=() <span class="overload">[1/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a9c813a8edbc5272897079137ac03b1a2" name="a9c813a8edbc5272897079137ac03b1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c813a8edbc5272897079137ac03b1a2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a1ab02a07cc26e5c65be216bca381b38f" name="a1ab02a07cc26e5c65be216bca381b38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab02a07cc26e5c65be216bca381b38f">&#9670;&#160;</a></span>operator=() <span class="overload">[3/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="af878d5d6403d2336b18b4fe35bdd4182" name="af878d5d6403d2336b18b4fe35bdd4182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af878d5d6403d2336b18b4fe35bdd4182">&#9670;&#160;</a></span>operator=() <span class="overload">[4/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ae09eea471e56aea42786fa52c8126a3b" name="ae09eea471e56aea42786fa52c8126a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09eea471e56aea42786fa52c8126a3b">&#9670;&#160;</a></span>operator=() <span class="overload">[5/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a05124e1ea82616e66fc72599e5ba5914" name="a05124e1ea82616e66fc72599e5ba5914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05124e1ea82616e66fc72599e5ba5914">&#9670;&#160;</a></span>operator=() <span class="overload">[6/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a6a91c59bacaef916f4aa1e62a4730ae6" name="a6a91c59bacaef916f4aa1e62a4730ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a91c59bacaef916f4aa1e62a4730ae6">&#9670;&#160;</a></span>operator=() <span class="overload">[7/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a1ca40ecd701f4cb13da77ee3e1d30587" name="a1ca40ecd701f4cb13da77ee3e1d30587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca40ecd701f4cb13da77ee3e1d30587">&#9670;&#160;</a></span>operator=() <span class="overload">[8/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aee11528245223380dd77959002077fbe" name="aee11528245223380dd77959002077fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee11528245223380dd77959002077fbe">&#9670;&#160;</a></span>operator=() <span class="overload">[9/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ac411bdfb98de0504a5c126ed67e954a1" name="ac411bdfb98de0504a5c126ed67e954a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac411bdfb98de0504a5c126ed67e954a1">&#9670;&#160;</a></span>operator=() <span class="overload">[10/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="abb658b3e0ec4abe277533ac512bc3ae1" name="abb658b3e0ec4abe277533ac512bc3ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb658b3e0ec4abe277533ac512bc3ae1">&#9670;&#160;</a></span>operator=() <span class="overload">[11/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a2eb8217139ce12832231bf9d40b19bfd" name="a2eb8217139ce12832231bf9d40b19bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb8217139ce12832231bf9d40b19bfd">&#9670;&#160;</a></span>operator=() <span class="overload">[12/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="acc9e59b3bf597261e69cb3d3f051aadf" name="acc9e59b3bf597261e69cb3d3f051aadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9e59b3bf597261e69cb3d3f051aadf">&#9670;&#160;</a></span>operator=() <span class="overload">[13/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ad0786502cf54544309a1abf38184a307" name="ad0786502cf54544309a1abf38184a307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0786502cf54544309a1abf38184a307">&#9670;&#160;</a></span>operator=() <span class="overload">[14/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ab3e497c98372f90481ebd0e1bd21f315" name="ab3e497c98372f90481ebd0e1bd21f315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e497c98372f90481ebd0e1bd21f315">&#9670;&#160;</a></span>operator=() <span class="overload">[15/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a5d0ea7a997d8fc99967e72b32c5fdd38" name="a5d0ea7a997d8fc99967e72b32c5fdd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0ea7a997d8fc99967e72b32c5fdd38">&#9670;&#160;</a></span>operator=() <span class="overload">[16/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; char &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a12a9907eb2556368b2c970ef1c55d304" name="a12a9907eb2556368b2c970ef1c55d304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a9907eb2556368b2c970ef1c55d304">&#9670;&#160;</a></span>operator=() <span class="overload">[17/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a21c2848f242d67f32fb93125d465593d" name="a21c2848f242d67f32fb93125d465593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c2848f242d67f32fb93125d465593d">&#9670;&#160;</a></span>operator=() <span class="overload">[18/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aaf6fd1ff22ea00f8c10049954764abbc" name="aaf6fd1ff22ea00f8c10049954764abbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6fd1ff22ea00f8c10049954764abbc">&#9670;&#160;</a></span>operator=() <span class="overload">[19/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="abd9428692f29a5b0aeeaa868ec5be9f1" name="abd9428692f29a5b0aeeaa868ec5be9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9428692f29a5b0aeeaa868ec5be9f1">&#9670;&#160;</a></span>operator=() <span class="overload">[20/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="abbdeadc513f43dc2cf9ee771b5cccf65" name="abbdeadc513f43dc2cf9ee771b5cccf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdeadc513f43dc2cf9ee771b5cccf65">&#9670;&#160;</a></span>operator=() <span class="overload">[21/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="acb13ea20a7630c0c25d59d22c407a25e" name="acb13ea20a7630c0c25d59d22c407a25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb13ea20a7630c0c25d59d22c407a25e">&#9670;&#160;</a></span>operator=() <span class="overload">[22/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ae9180140c3cb5474a4de317d1b81c99a" name="ae9180140c3cb5474a4de317d1b81c99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9180140c3cb5474a4de317d1b81c99a">&#9670;&#160;</a></span>operator=() <span class="overload">[23/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a918e97c3c720478e2b1ff5cb8773de52" name="a918e97c3c720478e2b1ff5cb8773de52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918e97c3c720478e2b1ff5cb8773de52">&#9670;&#160;</a></span>operator=() <span class="overload">[24/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aeaa66ed4bee7575c0d6791f9d3c2e0b5" name="aeaa66ed4bee7575c0d6791f9d3c2e0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa66ed4bee7575c0d6791f9d3c2e0b5">&#9670;&#160;</a></span>operator=() <span class="overload">[25/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ae22b7f387671fa95ea8462c297905b1f" name="ae22b7f387671fa95ea8462c297905b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22b7f387671fa95ea8462c297905b1f">&#9670;&#160;</a></span>operator=() <span class="overload">[26/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>character</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a4bbfe5d2566ab0966a19775ea334b5b7" name="a4bbfe5d2566ab0966a19775ea334b5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbfe5d2566ab0966a19775ea334b5b7">&#9670;&#160;</a></span>operator=() <span class="overload">[27/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a></td>          <td class="paramname"><span class="paramname"><em>character</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a20661ac7964f93e1cfbac62cec407934" name="a20661ac7964f93e1cfbac62cec407934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20661ac7964f93e1cfbac62cec407934">&#9670;&#160;</a></span>operator=() <span class="overload">[28/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a></td>          <td class="paramname"><span class="paramname"><em>character</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a068c674dbbe9cf949e8f6fe1d25903a6" name="a068c674dbbe9cf949e8f6fe1d25903a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068c674dbbe9cf949e8f6fe1d25903a6">&#9670;&#160;</a></span>operator=() <span class="overload">[29/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a></td>          <td class="paramname"><span class="paramname"><em>character</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="af78a2c22393147a7863d6612ea8ad596" name="af78a2c22393147a7863d6612ea8ad596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78a2c22393147a7863d6612ea8ad596">&#9670;&#160;</a></span>operator=() <span class="overload">[30/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a></td>          <td class="paramname"><span class="paramname"><em>character</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa57338bbd9341a8316c97a0cb0b52a0b" name="aa57338bbd9341a8316c97a0cb0b52a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57338bbd9341a8316c97a0cb0b52a0b">&#9670;&#160;</a></span>operator=() <span class="overload">[31/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>il</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa1ab06b38248888f8efed9bc86a970d6" name="aa1ab06b38248888f8efed9bc86a970d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ab06b38248888f8efed9bc86a970d6">&#9670;&#160;</a></span>operator=() <span class="overload">[32/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>il</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a52100794dde1bf6c481e50e94091916a" name="a52100794dde1bf6c481e50e94091916a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52100794dde1bf6c481e50e94091916a">&#9670;&#160;</a></span>operator=() <span class="overload">[33/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>il</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa75927d980766139c7c20de14f1f8d13" name="aa75927d980766139c7c20de14f1f8d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75927d980766139c7c20de14f1f8d13">&#9670;&#160;</a></span>operator=() <span class="overload">[34/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>il</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aed652c5e92066a11e47a0dd6cd647c90" name="aed652c5e92066a11e47a0dd6cd647c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed652c5e92066a11e47a0dd6cd647c90">&#9670;&#160;</a></span>operator=() <span class="overload">[35/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>il</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ab9f96281407a61fd50345eb7e2b8f7ca" name="ab9f96281407a61fd50345eb7e2b8f7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f96281407a61fd50345eb7e2b8f7ca">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="ad1e5dc85e2d471ae28f9957c4065248f" name="ad1e5dc85e2d471ae28f9957c4065248f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e5dc85e2d471ae28f9957c4065248f">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="ab58d46ec7ebf00e9bb57d8844bfa684d" name="ab58d46ec7ebf00e9bb57d8844bfa684d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58d46ec7ebf00e9bb57d8844bfa684d">&#9670;&#160;</a></span>operator+=() <span class="overload">[3/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a99fcc84e7cb9e168ed058dc58a3f4dfc" name="a99fcc84e7cb9e168ed058dc58a3f4dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fcc84e7cb9e168ed058dc58a3f4dfc">&#9670;&#160;</a></span>operator+=() <span class="overload">[4/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a1a84548f6b04aac050a32938bfe5e7c6" name="a1a84548f6b04aac050a32938bfe5e7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a84548f6b04aac050a32938bfe5e7c6">&#9670;&#160;</a></span>operator+=() <span class="overload">[5/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a6f21d4bbd734b2f65cf373c02a72e1ad" name="a6f21d4bbd734b2f65cf373c02a72e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f21d4bbd734b2f65cf373c02a72e1ad">&#9670;&#160;</a></span>operator+=() <span class="overload">[6/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a4eb5b1ef0dcf242170da7be8c770b1a9" name="a4eb5b1ef0dcf242170da7be8c770b1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb5b1ef0dcf242170da7be8c770b1a9">&#9670;&#160;</a></span>operator+=() <span class="overload">[7/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="ad3ad7d6ce3e3cfd9e32b049542eb8418" name="ad3ad7d6ce3e3cfd9e32b049542eb8418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ad7d6ce3e3cfd9e32b049542eb8418">&#9670;&#160;</a></span>operator+=() <span class="overload">[8/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a0e8d99044981bb8b49c438dd552b15c0" name="a0e8d99044981bb8b49c438dd552b15c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8d99044981bb8b49c438dd552b15c0">&#9670;&#160;</a></span>operator+=() <span class="overload">[9/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="ad891204bd0c088717a720bdf92f28212" name="ad891204bd0c088717a720bdf92f28212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad891204bd0c088717a720bdf92f28212">&#9670;&#160;</a></span>operator+=() <span class="overload">[10/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2fb3348705647e01e88be06aa3767894" name="a2fb3348705647e01e88be06aa3767894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb3348705647e01e88be06aa3767894">&#9670;&#160;</a></span>operator+=() <span class="overload">[11/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2b9bab82c073016f8b31a4f9afdb7ce8" name="a2b9bab82c073016f8b31a4f9afdb7ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9bab82c073016f8b31a4f9afdb7ce8">&#9670;&#160;</a></span>operator+=() <span class="overload">[12/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a9ea45b673c96bbe8fb31b5fcee7164a8" name="a9ea45b673c96bbe8fb31b5fcee7164a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea45b673c96bbe8fb31b5fcee7164a8">&#9670;&#160;</a></span>operator+=() <span class="overload">[13/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="accf189ea3fea2ff21c6afd2b226a2921" name="accf189ea3fea2ff21c6afd2b226a2921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf189ea3fea2ff21c6afd2b226a2921">&#9670;&#160;</a></span>operator+=() <span class="overload">[14/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="afba271dd4828ec9c22972ce98ed71543" name="afba271dd4828ec9c22972ce98ed71543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba271dd4828ec9c22972ce98ed71543">&#9670;&#160;</a></span>operator+=() <span class="overload">[15/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2769a07751f2040b086f2e532741c682" name="a2769a07751f2040b086f2e532741c682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2769a07751f2040b086f2e532741c682">&#9670;&#160;</a></span>operator+=() <span class="overload">[16/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="af555dcf021c5c3ced7e1a8bfbe5bfa50" name="af555dcf021c5c3ced7e1a8bfbe5bfa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af555dcf021c5c3ced7e1a8bfbe5bfa50">&#9670;&#160;</a></span>operator+=() <span class="overload">[17/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2c2a78449d887fa5d921f95856cd1487" name="a2c2a78449d887fa5d921f95856cd1487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2a78449d887fa5d921f95856cd1487">&#9670;&#160;</a></span>operator+=() <span class="overload">[18/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a9529e5baf23784330b6045f2ef2ec37f" name="a9529e5baf23784330b6045f2ef2ec37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9529e5baf23784330b6045f2ef2ec37f">&#9670;&#160;</a></span>operator+=() <span class="overload">[19/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a0ec59e366d520219d67a6ee712e07f34" name="a0ec59e366d520219d67a6ee712e07f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec59e366d520219d67a6ee712e07f34">&#9670;&#160;</a></span>operator+=() <span class="overload">[20/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2bdc9356f22e6ff9139f4a81b93a6175" name="a2bdc9356f22e6ff9139f4a81b93a6175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdc9356f22e6ff9139f4a81b93a6175">&#9670;&#160;</a></span>operator+=() <span class="overload">[21/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="acda811c544170f9951af6d7bac8ba707" name="acda811c544170f9951af6d7bac8ba707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda811c544170f9951af6d7bac8ba707">&#9670;&#160;</a></span>operator+=() <span class="overload">[22/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c">xtd::char16</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a7493fc8791204b6b8bde403fad729410" name="a7493fc8791204b6b8bde403fad729410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7493fc8791204b6b8bde403fad729410">&#9670;&#160;</a></span>operator+=() <span class="overload">[23/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">xtd::char32</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a9bfdd130d8ea5f20c20fe15bf794b572" name="a9bfdd130d8ea5f20c20fe15bf794b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfdd130d8ea5f20c20fe15bf794b572">&#9670;&#160;</a></span>operator+=() <span class="overload">[24/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98">xtd::char8</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a29c75ef362acb78e3f0072b8cbdf3e19" name="a29c75ef362acb78e3f0072b8cbdf3e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c75ef362acb78e3f0072b8cbdf3e19">&#9670;&#160;</a></span>operator+=() <span class="overload">[25/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302">xtd::wchar</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a6c9caea8081698b588cb6af9b6da8542" name="a6c9caea8081698b588cb6af9b6da8542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9caea8081698b588cb6af9b6da8542">&#9670;&#160;</a></span>is_empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name Public Deprecated Methods. </p>
<p>Indicates whether this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""). </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter is null or an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated</a></b></dt><dd>Replaced by xtd::basic_string::is_empty(const xtd::basic_string&amp;) - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a69a97f1b420e640208ecd970b0d17f09" name="a69a97f1b420e640208ecd970b0d17f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a97f1b420e640208ecd970b0d17f09">&#9670;&#160;</a></span>class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::class_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the object_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the object_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_&lt;object_t&gt;()</a>.name() - Will be removed in version 0.4.0. </dd></dl>
<p>Name Public Deprecated Static Methods </p>

</div>
</div>
<a id="a0da452ea8889d3c99e3ef0437d12b3a2" name="a0da452ea8889d3c99e3ef0437d12b3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da452ea8889d3c99e3ef0437d12b3a2">&#9670;&#160;</a></span>class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>object</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(object)</a>.name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a6a0695f721a034545f3ce21d8ac16944" name="a6a0695f721a034545f3ce21d8ac16944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0695f721a034545f3ce21d8ac16944">&#9670;&#160;</a></span>class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(info)</a>.name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="ac003a2b39a8e6160043f9d3a8681a178" name="ac003a2b39a8e6160043f9d3a8681a178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac003a2b39a8e6160043f9d3a8681a178">&#9670;&#160;</a></span>full_class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::full_class_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the objec_t, including the namespace of the objec_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the objec_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_&lt;object_t&gt;()</a>.full_name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="acc2dad45219c94eda3bd54742cc0a82a" name="acc2dad45219c94eda3bd54742cc0a82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2dad45219c94eda3bd54742cc0a82a">&#9670;&#160;</a></span>full_class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>object</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(object)</a>.full_name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a3f42e3b00b7c27ffa63cc8e48dde6aa4" name="a3f42e3b00b7c27ffa63cc8e48dde6aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f42e3b00b7c27ffa63cc8e48dde6aa4">&#9670;&#160;</a></span>full_class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(info)</a>.full_name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/<a class="el" href="basic__string_8hpp_source.html">basic_string.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 10 2025 12:01:40 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
