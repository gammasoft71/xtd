<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::basic_string&lt; char_t, traits_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1basic__string-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::basic_string&lt; char_t, traits_t, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__strings.html">strings</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::basic_string&lt; char_t, traits_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1basic__string.png" usemap="#xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,56,835,80"/>
<area href="classxtd_1_1icomparable.html" alt="xtd::icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;" shape="rect" coords="845,56,1680,80"/>
<area href="classxtd_1_1iequatable.html" alt="xtd::iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;" shape="rect" coords="2535,56,3370,80"/>
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" alt="xtd::collections::generic::ienumerable&lt; char_t &gt;" shape="rect" coords="4647,56,5482,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="422,0,1257,24"/>
<area href="classxtd_1_1extensions_1_1comparison__operators.html" alt="xtd::extensions::comparison_operators&lt; basic_string&lt; char_t, traits_t, allocator_t &gt;, icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt; &gt;" shape="rect" coords="1267,0,2102,24"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="2112,0,2947,24"/>
<area href="classxtd_1_1extensions_1_1equality__operators.html" alt="xtd::extensions::equality_operators&lt; basic_string&lt; char_t, traits_t, allocator_t &gt;, iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt; &gt;" shape="rect" coords="2957,0,3792,24"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="3802,0,4637,24"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html" alt="xtd::collections::generic::extensions::enumerable_iterators&lt; char_t, xtd::collections::generic::ienumerable&lt; char_t &gt; &gt;" shape="rect" coords="4647,0,5482,24"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html" alt="xtd::collections::generic::extensions::enumerable&lt; ienumerable&lt; char_t &gt;, char_t &gt;" shape="rect" coords="5492,0,6327,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class char_t, class traits_t, class allocator_t&gt;<br />
class xtd::basic_string&lt; char_t, traits_t, allocator_t &gt;</div><p>Represents text as a sequence of character units. </p>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is a sequential collection of char that represent a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is the content of the sequential collection of <code>char_t</code>, and unlike <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char_t&gt;</a> that value is immutable (that is, it is read-only). </dd>
<dd>
If you want the same mutable <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> class, you can use <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char_t&gt; class. </dd>
<dd>
<a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char&gt;</a> and therefore offers the full (immutable) API of std::basic_string. </dd>
<dd>
Several aliases for common character types are provided: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;char&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#gad9519a3c079fca351ff0c97ccd3b012a" title="Represents text as a sequence of UTF-16 code units.">xtd::u16string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga30cd2dda34afc715ec10817ced72ac25" title="Represents text as a sequence of UTF-32 code units.">xtd::u32string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga2a1c504cef5a83ac0d4dec15817b0511" title="Represents text as a sequence of UTF-8 code units.">xtd::u8string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#gaef465eea9979bb0b1332b8bc46abe0ff" title="Represents text as a sequence of UTF-16 code unit on Windows or UTF-32 code unit on non-Windows syste...">xtd::wstring</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302" title="Represents a wide character.">xtd::wchar</a>&gt;   </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is a sequential collection of char that represent a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is the content of the sequential collection of <code>char_t</code>, and unlike <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char_t&gt;</a> that value is immutable (that is, it is read-only). </dd>
<dd>
If you want the same mutable <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> class, you can use <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char_t&gt; class. </dd>
<dd>
<a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char&gt;</a> and therefore offers the full (immutable) API of <a href="https://en.cppreference.com/w/cpp/string/basic_string">std::string</a>. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Returns a reference to the character at specified location <code>pos</code>. /</p>
<p>/</p>
<p>/ / </p><dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. const_reference <a class="el" href="namespacextd.html#a856ad36e5aacc976277ccc570b035695" title="Gets the specified element with bounds checking.">at(size_type pos) const </a>{return operator [](pos);}</td></tr>
  </table>
  </dd>
</dl>
<p>/ Compares two character sequences. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The other string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to str. / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(const basic_string&amp; str) const {return chars_.compare(str);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string&amp; str) const {return chars_.compare(pos1, count1, str);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. /</td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / * If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string&amp; str, size_type pos2) const {return chars_.compare(pos1, count1, str, pos2);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. /</td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. /</td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / * If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string&amp; str, size_type pos2, size_type count2) const {return chars_.compare(pos1, count1, str, pos2, count2);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(const_pointer s) const {return chars_.compare(s);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1$ , <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). @remarks A character sequence consisting of</code>count1<code>characters starting at</code>data1<code>is compared to a character sequence consisting of</code>count2<code>characters starting at</code>data2<code>as follows:<ul>
<li>First, calculate the number of characters to compare, as if by</li>
</ul>
</code>size_type rlen = std::min(count1, count2)<code>.<ul>
<li>Then compare the sequences by calling</li>
</ul>
</code>traits_t::compare(data1, data2, rlen)`. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>
</td></tr>
<tr class="memitem:a42f4de83225ec7eb81d9e34a6d3fd461" id="r_a42f4de83225ec7eb81d9e34a6d3fd461"><td class="memItemLeft" align="right" valign="top"><a id="a42f4de83225ec7eb81d9e34a6d3fd461" name="a42f4de83225ec7eb81d9e34a6d3fd461"></a>
<a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compare</b> (size_type pos1, size_type count1, const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="separator:a42f4de83225ec7eb81d9e34a6d3fd461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd1814acf74f3359393306249030536" id="r_a4cd1814acf74f3359393306249030536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cd1814acf74f3359393306249030536">compare</a> (size_type pos1, size_type count1, const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type count2) const</td></tr>
<tr class="memdesc:a4cd1814acf74f3359393306249030536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a4cd1814acf74f3359393306249030536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785e7ca9244c89a0fd0552a30dca0df6" id="r_a785e7ca9244c89a0fd0552a30dca0df6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a785e7ca9244c89a0fd0552a30dca0df6">compare_to</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;value) const</td></tr>
<tr class="memdesc:a785e7ca9244c89a0fd0552a30dca0df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this instance with a specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a>.  <br /></td></tr>
<tr class="separator:a785e7ca9244c89a0fd0552a30dca0df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56991bcdcf3648e12180abbda6d0e4a2" id="r_a56991bcdcf3648e12180abbda6d0e4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56991bcdcf3648e12180abbda6d0e4a2">compare_to</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a56991bcdcf3648e12180abbda6d0e4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this instance with a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.  <br /></td></tr>
<tr class="separator:a56991bcdcf3648e12180abbda6d0e4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850cd349d2e010f36c975a32b150a981" id="r_a850cd349d2e010f36c975a32b150a981"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a850cd349d2e010f36c975a32b150a981">contains</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a850cd349d2e010f36c975a32b150a981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified char occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a850cd349d2e010f36c975a32b150a981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fea739d2eea162481378cc3563e0e7" id="r_a46fea739d2eea162481378cc3563e0e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46fea739d2eea162481378cc3563e0e7">contains</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a46fea739d2eea162481378cc3563e0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified substring occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a46fea739d2eea162481378cc3563e0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa538684c095ac08578828af5eff7d48d" id="r_aa538684c095ac08578828af5eff7d48d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa538684c095ac08578828af5eff7d48d">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept override</td></tr>
<tr class="memdesc:aa538684c095ac08578828af5eff7d48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object, have the same value.  <br /></td></tr>
<tr class="separator:aa538684c095ac08578828af5eff7d48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1e61a72cf0017e83126ebd8d409079" id="r_acf1e61a72cf0017e83126ebd8d409079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf1e61a72cf0017e83126ebd8d409079">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:acf1e61a72cf0017e83126ebd8d409079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value.  <br /></td></tr>
<tr class="separator:acf1e61a72cf0017e83126ebd8d409079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe34c3ef80e295d524013594ab98e96f" id="r_abe34c3ef80e295d524013594ab98e96f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe34c3ef80e295d524013594ab98e96f">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:abe34c3ef80e295d524013594ab98e96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:abe34c3ef80e295d524013594ab98e96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a32b980ce33e6240fad1bdf860be32" id="r_a88a32b980ce33e6240fad1bdf860be32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a32b980ce33e6240fad1bdf860be32">ends_with</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a88a32b980ce33e6240fad1bdf860be32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character.  <br /></td></tr>
<tr class="separator:a88a32b980ce33e6240fad1bdf860be32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235800cab8022150e0242be1f70ccba5" id="r_a235800cab8022150e0242be1f70ccba5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a235800cab8022150e0242be1f70ccba5">ends_with</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:a235800cab8022150e0242be1f70ccba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a235800cab8022150e0242be1f70ccba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bb8f1452d6d3f0a504ed482aeff03d" id="r_ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9bb8f1452d6d3f0a504ed482aeff03d">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2260a3a56c452a4086de5c75d608f3" id="r_aad2260a3a56c452a4086de5c75d608f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad2260a3a56c452a4086de5c75d608f3">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:aad2260a3a56c452a4086de5c75d608f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:aad2260a3a56c452a4086de5c75d608f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d548b663eb6dc7b61394d0a5031a779" id="r_a0d548b663eb6dc7b61394d0a5031a779"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d548b663eb6dc7b61394d0a5031a779">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) const noexcept</td></tr>
<tr class="memdesc:a0d548b663eb6dc7b61394d0a5031a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option.  <br /></td></tr>
<tr class="separator:a0d548b663eb6dc7b61394d0a5031a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995fc327f844695b7d54bb8c9dcefd64" id="r_a995fc327f844695b7d54bb8c9dcefd64"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a995fc327f844695b7d54bb8c9dcefd64">find</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a995fc327f844695b7d54bb8c9dcefd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a995fc327f844695b7d54bb8c9dcefd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ef167753f97393efa4e8a04f645b1a" id="r_ae7ef167753f97393efa4e8a04f645b1a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7ef167753f97393efa4e8a04f645b1a">find</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:ae7ef167753f97393efa4e8a04f645b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:ae7ef167753f97393efa4e8a04f645b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa27496a7880e6ec15ed6af9f3ee63a9" id="r_afa27496a7880e6ec15ed6af9f3ee63a9"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa27496a7880e6ec15ed6af9f3ee63a9">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:afa27496a7880e6ec15ed6af9f3ee63a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:afa27496a7880e6ec15ed6af9f3ee63a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b84e810101f5722ea51155b57673c3a" id="r_a5b84e810101f5722ea51155b57673c3a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b84e810101f5722ea51155b57673c3a">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a5b84e810101f5722ea51155b57673c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a5b84e810101f5722ea51155b57673c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe01cbb72aa625955d5f91eaf20b4422" id="r_afe01cbb72aa625955d5f91eaf20b4422"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe01cbb72aa625955d5f91eaf20b4422">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:afe01cbb72aa625955d5f91eaf20b4422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:afe01cbb72aa625955d5f91eaf20b4422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e89be405fda67b0a224b7f5d19dbb74" id="r_a6e89be405fda67b0a224b7f5d19dbb74"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e89be405fda67b0a224b7f5d19dbb74">find</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> ch) const</td></tr>
<tr class="memdesc:a6e89be405fda67b0a224b7f5d19dbb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a6e89be405fda67b0a224b7f5d19dbb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada37711b3a6b2d96deb9937458eeed91" id="r_ada37711b3a6b2d96deb9937458eeed91"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada37711b3a6b2d96deb9937458eeed91">find</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> ch, size_type pos) const</td></tr>
<tr class="memdesc:ada37711b3a6b2d96deb9937458eeed91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:ada37711b3a6b2d96deb9937458eeed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190df4d0356f13ee707e02bf0ff69670" id="r_a190df4d0356f13ee707e02bf0ff69670"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a190df4d0356f13ee707e02bf0ff69670">find_first_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a190df4d0356f13ee707e02bf0ff69670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a190df4d0356f13ee707e02bf0ff69670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ad6cd829e5fb0e5ba7fd173fa52a4c" id="r_a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47ad6cd829e5fb0e5ba7fd173fa52a4c">find_first_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92834b04a7c65b7de003f742e78d8309" id="r_a92834b04a7c65b7de003f742e78d8309"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92834b04a7c65b7de003f742e78d8309">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a92834b04a7c65b7de003f742e78d8309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a92834b04a7c65b7de003f742e78d8309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb30d4555ab0d49edac1d1f29748968d" id="r_acb30d4555ab0d49edac1d1f29748968d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb30d4555ab0d49edac1d1f29748968d">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:acb30d4555ab0d49edac1d1f29748968d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:acb30d4555ab0d49edac1d1f29748968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf3f78cb8fce98db32d6dea0dacb1fd" id="r_a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bf3f78cb8fce98db32d6dea0dacb1fd">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63f087262d302ffd91d44441141395f" id="r_aa63f087262d302ffd91d44441141395f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa63f087262d302ffd91d44441141395f">find_first_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:aa63f087262d302ffd91d44441141395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:aa63f087262d302ffd91d44441141395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0742e91a1bc6cc31486581993106d" id="r_aebf0742e91a1bc6cc31486581993106d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf0742e91a1bc6cc31486581993106d">find_first_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:aebf0742e91a1bc6cc31486581993106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:aebf0742e91a1bc6cc31486581993106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44655a7fb2b16b0ac355f98efbe7f60a" id="r_a44655a7fb2b16b0ac355f98efbe7f60a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44655a7fb2b16b0ac355f98efbe7f60a">find_first_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a44655a7fb2b16b0ac355f98efbe7f60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a44655a7fb2b16b0ac355f98efbe7f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865854c0f1fc517a76019ef74357471c" id="r_a865854c0f1fc517a76019ef74357471c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a865854c0f1fc517a76019ef74357471c">find_first_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a865854c0f1fc517a76019ef74357471c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a865854c0f1fc517a76019ef74357471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ee3d277929b2e2822347bbef0799ec" id="r_aa7ee3d277929b2e2822347bbef0799ec"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7ee3d277929b2e2822347bbef0799ec">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:aa7ee3d277929b2e2822347bbef0799ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:aa7ee3d277929b2e2822347bbef0799ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68c7409e9483b7fb2ecb4119a1a49c3" id="r_aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa68c7409e9483b7fb2ecb4119a1a49c3">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394185c5018c818ca6e8c3cbf9048da1" id="r_a394185c5018c818ca6e8c3cbf9048da1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a394185c5018c818ca6e8c3cbf9048da1">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a394185c5018c818ca6e8c3cbf9048da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a394185c5018c818ca6e8c3cbf9048da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525f7ed777b11690436a4e545cbd4c52" id="r_a525f7ed777b11690436a4e545cbd4c52"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a525f7ed777b11690436a4e545cbd4c52">find_first_not_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:a525f7ed777b11690436a4e545cbd4c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a525f7ed777b11690436a4e545cbd4c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa337f7f098dc744c16c768824cdbf5de" id="r_aa337f7f098dc744c16c768824cdbf5de"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa337f7f098dc744c16c768824cdbf5de">find_first_not_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:aa337f7f098dc744c16c768824cdbf5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:aa337f7f098dc744c16c768824cdbf5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4b8376a5af873f844aa5de5a7f36f1" id="r_ada4b8376a5af873f844aa5de5a7f36f1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada4b8376a5af873f844aa5de5a7f36f1">find_last_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:ada4b8376a5af873f844aa5de5a7f36f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:ada4b8376a5af873f844aa5de5a7f36f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8812d25aeb365b83a6e13b22d3ea15" id="r_abe8812d25aeb365b83a6e13b22d3ea15"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe8812d25aeb365b83a6e13b22d3ea15">find_last_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:abe8812d25aeb365b83a6e13b22d3ea15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:abe8812d25aeb365b83a6e13b22d3ea15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae683ad85d132dc61069a39ab5ecfc892" id="r_ae683ad85d132dc61069a39ab5ecfc892"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae683ad85d132dc61069a39ab5ecfc892">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:ae683ad85d132dc61069a39ab5ecfc892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:ae683ad85d132dc61069a39ab5ecfc892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9f9c97ebc85319e7bb0890747f95f0" id="r_a3b9f9c97ebc85319e7bb0890747f95f0"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b9f9c97ebc85319e7bb0890747f95f0">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a3b9f9c97ebc85319e7bb0890747f95f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a3b9f9c97ebc85319e7bb0890747f95f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43971d40fb8f9c14c8f2a8973fda5241" id="r_a43971d40fb8f9c14c8f2a8973fda5241"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43971d40fb8f9c14c8f2a8973fda5241">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a43971d40fb8f9c14c8f2a8973fda5241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a43971d40fb8f9c14c8f2a8973fda5241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f1e765d3c800b53ad278aeea40cbbb" id="r_ad3f1e765d3c800b53ad278aeea40cbbb"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3f1e765d3c800b53ad278aeea40cbbb">find_last_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:ad3f1e765d3c800b53ad278aeea40cbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:ad3f1e765d3c800b53ad278aeea40cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2276b8461430eec909f87352134d92d8" id="r_a2276b8461430eec909f87352134d92d8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2276b8461430eec909f87352134d92d8">find_last_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:a2276b8461430eec909f87352134d92d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a2276b8461430eec909f87352134d92d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a0529754f7c547dd26d0e3df7d4d57" id="r_a85a0529754f7c547dd26d0e3df7d4d57"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a0529754f7c547dd26d0e3df7d4d57">find_last_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a85a0529754f7c547dd26d0e3df7d4d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a85a0529754f7c547dd26d0e3df7d4d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7be46eecca48686b7893fdcc22f1064" id="r_ae7be46eecca48686b7893fdcc22f1064"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7be46eecca48686b7893fdcc22f1064">find_last_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:ae7be46eecca48686b7893fdcc22f1064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:ae7be46eecca48686b7893fdcc22f1064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db0de794b93c1d3daec32ee93ebb840" id="r_a0db0de794b93c1d3daec32ee93ebb840"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0db0de794b93c1d3daec32ee93ebb840">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a0db0de794b93c1d3daec32ee93ebb840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a0db0de794b93c1d3daec32ee93ebb840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66" id="r_a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867ec6c6bbe8ded000aab89983f5b37" id="r_ad867ec6c6bbe8ded000aab89983f5b37"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad867ec6c6bbe8ded000aab89983f5b37">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:ad867ec6c6bbe8ded000aab89983f5b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:ad867ec6c6bbe8ded000aab89983f5b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622aba17212244261f0a1dee4cf2a76c" id="r_a622aba17212244261f0a1dee4cf2a76c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a622aba17212244261f0a1dee4cf2a76c">find_last_not_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:a622aba17212244261f0a1dee4cf2a76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a622aba17212244261f0a1dee4cf2a76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb1e50a316279a814fbf6caa9a52512" id="r_a2bb1e50a316279a814fbf6caa9a52512"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bb1e50a316279a814fbf6caa9a52512">find_last_not_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:a2bb1e50a316279a814fbf6caa9a52512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned.  <br /></td></tr>
<tr class="separator:a2bb1e50a316279a814fbf6caa9a52512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fea87ee51c2cc221b5018ff83de9b" id="r_a0f3fea87ee51c2cc221b5018ff83de9b"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f3fea87ee51c2cc221b5018ff83de9b">get_allocator</a> () const</td></tr>
<tr class="memdesc:a0f3fea87ee51c2cc221b5018ff83de9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the string.  <br /></td></tr>
<tr class="separator:a0f3fea87ee51c2cc221b5018ff83de9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f45ba04d07446618d604b99c22fbb3" id="r_a38f45ba04d07446618d604b99c22fbb3"><td class="memItemLeft" align="right" valign="top">virtual const base_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38f45ba04d07446618d604b99c22fbb3">get_base_type</a> () const noexcept</td></tr>
<tr class="memdesc:a38f45ba04d07446618d604b99c22fbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type.  <br /></td></tr>
<tr class="separator:a38f45ba04d07446618d604b99c22fbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8204b499a2a327ac2193814c5ba59be4" id="r_a8204b499a2a327ac2193814c5ba59be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8204b499a2a327ac2193814c5ba59be4">get_hash_code</a> () const noexcept override</td></tr>
<tr class="memdesc:a8204b499a2a327ac2193814c5ba59be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash code for this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a8204b499a2a327ac2193814c5ba59be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273eee6b3d879fdab255817b5406ff1b" id="r_a273eee6b3d879fdab255817b5406ff1b"><td class="memItemLeft" align="right" valign="top">enumerator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a273eee6b3d879fdab255817b5406ff1b">get_enumerator</a> () const noexcept override</td></tr>
<tr class="memdesc:a273eee6b3d879fdab255817b5406ff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that iterates through a collection.  <br /></td></tr>
<tr class="separator:a273eee6b3d879fdab255817b5406ff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e2b0b18ffae65666bfe665f10c8eee" id="r_aa2e2b0b18ffae65666bfe665f10c8eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2e2b0b18ffae65666bfe665f10c8eee">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:aa2e2b0b18ffae65666bfe665f10c8eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:aa2e2b0b18ffae65666bfe665f10c8eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cdbff9d2baf8ca5354e0361db8b8f1" id="r_ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8cdbff9d2baf8ca5354e0361db8b8f1">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9376bff15d7276c49c0ce4ea3bd744b0" id="r_a9376bff15d7276c49c0ce4ea3bd744b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9376bff15d7276c49c0ce4ea3bd744b0">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a9376bff15d7276c49c0ce4ea3bd744b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a9376bff15d7276c49c0ce4ea3bd744b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cc9bdb3ebf738766cf0b8357d9f28d" id="r_a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03cc9bdb3ebf738766cf0b8357d9f28d">index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1241d527912da0524fe79c1885104986" id="r_a1241d527912da0524fe79c1885104986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1241d527912da0524fe79c1885104986">index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a1241d527912da0524fe79c1885104986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a1241d527912da0524fe79c1885104986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101dd613f8711c38c17443fbc8c29799" id="r_a101dd613f8711c38c17443fbc8c29799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a101dd613f8711c38c17443fbc8c29799">index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a101dd613f8711c38c17443fbc8c29799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a101dd613f8711c38c17443fbc8c29799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c38c1845d60e7d08f8750bb181aa4d" id="r_a50c38c1845d60e7d08f8750bb181aa4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50c38c1845d60e7d08f8750bb181aa4d">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a50c38c1845d60e7d08f8750bb181aa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a50c38c1845d60e7d08f8750bb181aa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d7c6fb6ca5e05c6a464e8cb25c2e76" id="r_a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d7c6fb6ca5e05c6a464e8cb25c2e76">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac27b133bb5f4567decb3a19ff63a883" id="r_aac27b133bb5f4567decb3a19ff63a883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac27b133bb5f4567decb3a19ff63a883">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:aac27b133bb5f4567decb3a19ff63a883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:aac27b133bb5f4567decb3a19ff63a883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ce826afc61742ea2b759feb0987d9c" id="r_a48ce826afc61742ea2b759feb0987d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48ce826afc61742ea2b759feb0987d9c">insert</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const</td></tr>
<tr class="memdesc:a48ce826afc61742ea2b759feb0987d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a specified instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> at a specified index position in this instance.  <br /></td></tr>
<tr class="separator:a48ce826afc61742ea2b759feb0987d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9caea8081698b588cb6af9b6da8542" id="r_a6c9caea8081698b588cb6af9b6da8542"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c9caea8081698b588cb6af9b6da8542">is_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a6c9caea8081698b588cb6af9b6da8542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> ("").  <br /></td></tr>
<tr class="separator:a6c9caea8081698b588cb6af9b6da8542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc799a8cc31af232470d65cd88a1ca6a" id="r_acc799a8cc31af232470d65cd88a1ca6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc799a8cc31af232470d65cd88a1ca6a">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:acc799a8cc31af232470d65cd88a1ca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:acc799a8cc31af232470d65cd88a1ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a6db704899bd1263a714bf8363f6b" id="r_a3b7a6db704899bd1263a714bf8363f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b7a6db704899bd1263a714bf8363f6b">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a3b7a6db704899bd1263a714bf8363f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a3b7a6db704899bd1263a714bf8363f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb55029c7dfebcfb60989e102943e70" id="r_a4fb55029c7dfebcfb60989e102943e70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fb55029c7dfebcfb60989e102943e70">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a4fb55029c7dfebcfb60989e102943e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a4fb55029c7dfebcfb60989e102943e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a1c153b902e5edf0b877652add0e43" id="r_a68a1c153b902e5edf0b877652add0e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68a1c153b902e5edf0b877652add0e43">last_index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a68a1c153b902e5edf0b877652add0e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this tring.  <br /></td></tr>
<tr class="separator:a68a1c153b902e5edf0b877652add0e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bdcec1f21421c38a7a80d8142ff7d5" id="r_af8bdcec1f21421c38a7a80d8142ff7d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bdcec1f21421c38a7a80d8142ff7d5">last_index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:af8bdcec1f21421c38a7a80d8142ff7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:af8bdcec1f21421c38a7a80d8142ff7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c63d72cfa3f91e2cf9f23881f68d9a6" id="r_a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c63d72cfa3f91e2cf9f23881f68d9a6">last_index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cef9de4c87f758793ab52f372999b98" id="r_a9cef9de4c87f758793ab52f372999b98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cef9de4c87f758793ab52f372999b98">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a9cef9de4c87f758793ab52f372999b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a9cef9de4c87f758793ab52f372999b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eee5a0186b0272dde1487fa3a76e31" id="r_ad9eee5a0186b0272dde1487fa3a76e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9eee5a0186b0272dde1487fa3a76e31">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:ad9eee5a0186b0272dde1487fa3a76e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ad9eee5a0186b0272dde1487fa3a76e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c41879b43a215e17a3b3f1d940352b" id="r_ac4c41879b43a215e17a3b3f1d940352b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4c41879b43a215e17a3b3f1d940352b">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:ac4c41879b43a215e17a3b3f1d940352b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ac4c41879b43a215e17a3b3f1d940352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0841b4ac447cc426dfc86857696a59d3" id="r_a0841b4ac447cc426dfc86857696a59d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0841b4ac447cc426dfc86857696a59d3">pad_left</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width) const noexcept</td></tr>
<tr class="memdesc:a0841b4ac447cc426dfc86857696a59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:a0841b4ac447cc426dfc86857696a59d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8d49dec1f34267194ae3d6023e5bca" id="r_acd8d49dec1f34267194ae3d6023e5bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd8d49dec1f34267194ae3d6023e5bca">pad_left</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width, <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a> padding_char) const noexcept</td></tr>
<tr class="memdesc:acd8d49dec1f34267194ae3d6023e5bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:acd8d49dec1f34267194ae3d6023e5bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37d71513cd7f2585290402bd45afb2" id="r_abe37d71513cd7f2585290402bd45afb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe37d71513cd7f2585290402bd45afb2">pad_right</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width) const noexcept</td></tr>
<tr class="memdesc:abe37d71513cd7f2585290402bd45afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:abe37d71513cd7f2585290402bd45afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948b86a1e0b7a58d6813048a74c4106" id="r_a7948b86a1e0b7a58d6813048a74c4106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7948b86a1e0b7a58d6813048a74c4106">pad_right</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width, <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a> padding_char) const noexcept</td></tr>
<tr class="memdesc:a7948b86a1e0b7a58d6813048a74c4106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:a7948b86a1e0b7a58d6813048a74c4106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856547e0780ad2ada0c0f614dc063df" id="r_a5856547e0780ad2ada0c0f614dc063df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5856547e0780ad2ada0c0f614dc063df">quoted</a> () const</td></tr>
<tr class="memdesc:a5856547e0780ad2ada0c0f614dc063df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>.  <br /></td></tr>
<tr class="separator:a5856547e0780ad2ada0c0f614dc063df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773214921b5ced5e4a8d4c25dd88891c" id="r_a773214921b5ced5e4a8d4c25dd88891c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a773214921b5ced5e4a8d4c25dd88891c">quoted</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> delimiter) const</td></tr>
<tr class="memdesc:a773214921b5ced5e4a8d4c25dd88891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter.  <br /></td></tr>
<tr class="separator:a773214921b5ced5e4a8d4c25dd88891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19de7bf5a27c141a306859535be853a" id="r_af19de7bf5a27c141a306859535be853a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af19de7bf5a27c141a306859535be853a">quoted</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> delimiter, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0ebc3c409070d07f1df0f2f4132509e">escape</a>) const</td></tr>
<tr class="memdesc:af19de7bf5a27c141a306859535be853a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape.  <br /></td></tr>
<tr class="separator:af19de7bf5a27c141a306859535be853a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb28698bda96ef32e834d79377523c7" id="r_a5fb28698bda96ef32e834d79377523c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb28698bda96ef32e834d79377523c7">remove</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a5fb28698bda96ef32e834d79377523c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a5fb28698bda96ef32e834d79377523c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f92a6d19c47147afc8eacf6f9c6b3" id="r_a678f92a6d19c47147afc8eacf6f9c6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a678f92a6d19c47147afc8eacf6f9c6b3">remove</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a678f92a6d19c47147afc8eacf6f9c6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a678f92a6d19c47147afc8eacf6f9c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8e9d4ff2110bf9f24035babdc2a1ef" id="r_aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab8e9d4ff2110bf9f24035babdc2a1ef">replace</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> old_char, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> new_char) const noexcept</td></tr>
<tr class="memdesc:aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified char_t in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified char_t.  <br /></td></tr>
<tr class="separator:aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dba25995a5713a69ad528fc0dcf889" id="r_a80dba25995a5713a69ad528fc0dcf889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80dba25995a5713a69ad528fc0dcf889">replace</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;old_string, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;new_string) const noexcept</td></tr>
<tr class="memdesc:a80dba25995a5713a69ad528fc0dcf889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a80dba25995a5713a69ad528fc0dcf889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5e3a4d7133856d265119fea8ec612f" id="r_a2c5e3a4d7133856d265119fea8ec612f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c5e3a4d7133856d265119fea8ec612f">rfind</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a2c5e3a4d7133856d265119fea8ec612f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at xtd::basic_string::npos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following xtd::basic_string::npos). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as xtd::basic_string::npos, the whole string will be searched. / @return Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. / @remarks Finds the first substring equal to</code>str<code>. size_type rfind(const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; str) const {return chars_.rfind(str);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param str The string to search for. / @param pos The position at which to start the search / @return Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. / @remarks Finds the first substring equal to</code>str<code>. size_type rfind(const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; str, size_type pos) const {return chars_.rfind(str, pos);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param str The string to search for. / @param pos The position at which to start the search / @param count The length of substring to search for. / @return Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. / @remarks Finds the first substring equal to the range [s, s + count). / @remarks This range may contain null characters. If [</code>s<code>,</code>s + count<code>) is not a valid range, the behavior is undefined. size_type rfind(const_pointer s, size_type pos, size_type count) const {return chars_.rfind(s, pos, count);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at xtd::basic_string::npos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following xtd::basic_string::npos). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as xtd::basic_string::npos, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a2c5e3a4d7133856d265119fea8ec612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7dc0272a38daae9fe92213bf3743f" id="r_afff7dc0272a38daae9fe92213bf3743f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff7dc0272a38daae9fe92213bf3743f">rfind</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:afff7dc0272a38daae9fe92213bf3743f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:afff7dc0272a38daae9fe92213bf3743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:a1b6f4bbb7a3c18056332b28dae525927" id="r_a1b6f4bbb7a3c18056332b28dae525927"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td></tr>
<tr class="memdesc:a1b6f4bbb7a3c18056332b28dae525927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a1b6f4bbb7a3c18056332b28dae525927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca94147a6d4b2892d5b762764520cdd2" id="r_aca94147a6d4b2892d5b762764520cdd2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#aca94147a6d4b2892d5b762764520cdd2">iterator</a></td></tr>
<tr class="memdesc:aca94147a6d4b2892d5b762764520cdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:aca94147a6d4b2892d5b762764520cdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab620a4ddfe6c67a30040f3431b4322d5" id="r_ab620a4ddfe6c67a30040f3431b4322d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#ab620a4ddfe6c67a30040f3431b4322d5">const_iterator</a></td></tr>
<tr class="memdesc:ab620a4ddfe6c67a30040f3431b4322d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:ab620a4ddfe6c67a30040f3431b4322d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887f291bffea0f450760702ed2682590" id="r_a887f291bffea0f450760702ed2682590"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a887f291bffea0f450760702ed2682590">iterator</a></td></tr>
<tr class="memdesc:a887f291bffea0f450760702ed2682590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of enumarable value type.  <br /></td></tr>
<tr class="separator:a887f291bffea0f450760702ed2682590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75470cb0387e1459f1a87c300f097560" id="r_a75470cb0387e1459f1a87c300f097560"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a75470cb0387e1459f1a87c300f097560">const_iterator</a></td></tr>
<tr class="memdesc:a75470cb0387e1459f1a87c300f097560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of enumarable value type.  <br /></td></tr>
<tr class="separator:a75470cb0387e1459f1a87c300f097560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0428a5d439bb7fd6a75f0ca54751c5" id="r_afa0428a5d439bb7fd6a75f0ca54751c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afa0428a5d439bb7fd6a75f0ca54751c5">enumerable_type</a></td></tr>
<tr class="memdesc:afa0428a5d439bb7fd6a75f0ca54751c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable enumerable type.  <br /></td></tr>
<tr class="separator:afa0428a5d439bb7fd6a75f0ca54751c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723aac49b8d3459b2caaff26c2ab90e0" id="r_a723aac49b8d3459b2caaff26c2ab90e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a723aac49b8d3459b2caaff26c2ab90e0">source_type</a></td></tr>
<tr class="memdesc:a723aac49b8d3459b2caaff26c2ab90e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable source type.  <br /></td></tr>
<tr class="separator:a723aac49b8d3459b2caaff26c2ab90e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f" id="r_aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a></td></tr>
<tr class="memdesc:aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2" id="r_a417e4adb1792949e9a54516bee2ca3d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a></td></tr>
<tr class="memdesc:a417e4adb1792949e9a54516bee2ca3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a417e4adb1792949e9a54516bee2ca3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d19ef177db62351b58a42f22138dbe" id="r_af2d19ef177db62351b58a42f22138dbe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:af2d19ef177db62351b58a42f22138dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:af2d19ef177db62351b58a42f22138dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9f8c15358cc78f7265ffe8f6480579" id="r_a7b9f8c15358cc78f7265ffe8f6480579"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a75470cb0387e1459f1a87c300f097560">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a7b9f8c15358cc78f7265ffe8f6480579">begin</a> () const</td></tr>
<tr class="memdesc:a7b9f8c15358cc78f7265ffe8f6480579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:a7b9f8c15358cc78f7265ffe8f6480579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e3a53b1e5c0e7769075bd28132d959" id="r_ad1e3a53b1e5c0e7769075bd28132d959"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a887f291bffea0f450760702ed2682590">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959">begin</a> ()</td></tr>
<tr class="memdesc:ad1e3a53b1e5c0e7769075bd28132d959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:ad1e3a53b1e5c0e7769075bd28132d959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c64ad67e8894d51bd1ee7da6f397e14" id="r_a9c64ad67e8894d51bd1ee7da6f397e14"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a75470cb0387e1459f1a87c300f097560">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a9c64ad67e8894d51bd1ee7da6f397e14">cbegin</a> () const</td></tr>
<tr class="memdesc:a9c64ad67e8894d51bd1ee7da6f397e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:a9c64ad67e8894d51bd1ee7da6f397e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab461dd402e7464666ba6657864ea5f40" id="r_ab461dd402e7464666ba6657864ea5f40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a75470cb0387e1459f1a87c300f097560">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ab461dd402e7464666ba6657864ea5f40">cend</a> () const</td></tr>
<tr class="memdesc:ab461dd402e7464666ba6657864ea5f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:ab461dd402e7464666ba6657864ea5f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f943e5420e93551f9d764a055a8e50a" id="r_a5f943e5420e93551f9d764a055a8e50a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a75470cb0387e1459f1a87c300f097560">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a5f943e5420e93551f9d764a055a8e50a">end</a> () const</td></tr>
<tr class="memdesc:a5f943e5420e93551f9d764a055a8e50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a5f943e5420e93551f9d764a055a8e50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc1239887628ed8028bdd1339af135a" id="r_a1cc1239887628ed8028bdd1339af135a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a887f291bffea0f450760702ed2682590">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a">end</a> ()</td></tr>
<tr class="memdesc:a1cc1239887628ed8028bdd1339af135a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a1cc1239887628ed8028bdd1339af135a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f3540f62b3b6140ecf188faf509842" id="r_a22f3540f62b3b6140ecf188faf509842"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a> (const std::function&lt; char_t(const char_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const</td></tr>
<tr class="memdesc:a22f3540f62b3b6140ecf188faf509842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a22f3540f62b3b6140ecf188faf509842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bbfa7cff2e26dcf33e973a97d42316" id="r_af8bbfa7cff2e26dcf33e973a97d42316"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#af8bbfa7cff2e26dcf33e973a97d42316">aggregate</a> (const char_t &amp;seed, const std::function&lt; char_t(const char_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const</td></tr>
<tr class="memdesc:af8bbfa7cff2e26dcf33e973a97d42316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:af8bbfa7cff2e26dcf33e973a97d42316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2705732af439af4da98a7a28f0a02f5a" id="r_a2705732af439af4da98a7a28f0a02f5a"><td class="memItemLeft" align="right" valign="top">accumulate_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2705732af439af4da98a7a28f0a02f5a">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const char_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const</td></tr>
<tr class="memdesc:a2705732af439af4da98a7a28f0a02f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a2705732af439af4da98a7a28f0a02f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487db86dcfc03a261804db9288b917df" id="r_a487db86dcfc03a261804db9288b917df"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a487db86dcfc03a261804db9288b917df">aggregate</a> (const char_t &amp;seed, const std::function&lt; char_t(const char_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; char_t(const char_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a487db86dcfc03a261804db9288b917df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a487db86dcfc03a261804db9288b917df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91578ce3ebc8da03751dfca700bf7d" id="r_a0b91578ce3ebc8da03751dfca700bf7d"><td class="memItemLeft" align="right" valign="top">result_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0b91578ce3ebc8da03751dfca700bf7d">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const char_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a0b91578ce3ebc8da03751dfca700bf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a0b91578ce3ebc8da03751dfca700bf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c344a4319826da54bae2611d78f7e41" id="r_a8c344a4319826da54bae2611d78f7e41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a8c344a4319826da54bae2611d78f7e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a8c344a4319826da54bae2611d78f7e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e647f592add925edc5682334fa2b29" id="r_a25e647f592add925edc5682334fa2b29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">any</a> () const noexcept</td></tr>
<tr class="memdesc:a25e647f592add925edc5682334fa2b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a25e647f592add925edc5682334fa2b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddaea79f05f3a1d7c83bdc64883ec44" id="r_a7ddaea79f05f3a1d7c83bdc64883ec44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a7ddaea79f05f3a1d7c83bdc64883ec44">any</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a7ddaea79f05f3a1d7c83bdc64883ec44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a7ddaea79f05f3a1d7c83bdc64883ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227fd05d7acfc24fe8805534fd706309" id="r_a227fd05d7acfc24fe8805534fd706309"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a227fd05d7acfc24fe8805534fd706309">append</a> (const char_t &amp;element) const noexcept</td></tr>
<tr class="memdesc:a227fd05d7acfc24fe8805534fd706309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a227fd05d7acfc24fe8805534fd706309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184c35f6e8a0058a196b533394dbccd7" id="r_a184c35f6e8a0058a196b533394dbccd7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a184c35f6e8a0058a196b533394dbccd7">as_enumerable</a> () const noexcept</td></tr>
<tr class="memdesc:a184c35f6e8a0058a196b533394dbccd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a184c35f6e8a0058a196b533394dbccd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5669f1a9bf9da6303aa9ff29197b4799" id="r_a5669f1a9bf9da6303aa9ff29197b4799"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5669f1a9bf9da6303aa9ff29197b4799">average</a> () const noexcept</td></tr>
<tr class="memdesc:a5669f1a9bf9da6303aa9ff29197b4799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of source_t values.  <br /></td></tr>
<tr class="separator:a5669f1a9bf9da6303aa9ff29197b4799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8353f4d5daa13e1810b8aad661eb938" id="r_ac8353f4d5daa13e1810b8aad661eb938"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ac8353f4d5daa13e1810b8aad661eb938">cast</a> () const noexcept</td></tr>
<tr class="memdesc:ac8353f4d5daa13e1810b8aad661eb938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> to the specified type.  <br /></td></tr>
<tr class="separator:ac8353f4d5daa13e1810b8aad661eb938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e97c665374affe07c6240f55db92a63" id="r_a8e97c665374affe07c6240f55db92a63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; char_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8e97c665374affe07c6240f55db92a63">chunk</a> (size_t <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">size</a>) const</td></tr>
<tr class="memdesc:a8e97c665374affe07c6240f55db92a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the elements of a sequence into chunks of size at most size.  <br /></td></tr>
<tr class="separator:a8e97c665374affe07c6240f55db92a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28746d3222dc23090a710dd8548e77e" id="r_ad28746d3222dc23090a710dd8548e77e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ad28746d3222dc23090a710dd8548e77e">concat</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;second) const noexcept</td></tr>
<tr class="memdesc:ad28746d3222dc23090a710dd8548e77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two sequences.  <br /></td></tr>
<tr class="separator:ad28746d3222dc23090a710dd8548e77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e29837254bb373971404eb103ba26" id="r_ad77e29837254bb373971404eb103ba26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ad77e29837254bb373971404eb103ba26">contains</a> (const char_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:ad77e29837254bb373971404eb103ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using the default equality comparer.  <br /></td></tr>
<tr class="separator:ad77e29837254bb373971404eb103ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4be2e1cde9d4316519230b03e0496" id="r_a87d4be2e1cde9d4316519230b03e0496"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a87d4be2e1cde9d4316519230b03e0496">contains</a> (const char_t &amp;value, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; char_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept</td></tr>
<tr class="memdesc:a87d4be2e1cde9d4316519230b03e0496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using a specified equality comparer.  <br /></td></tr>
<tr class="separator:a87d4be2e1cde9d4316519230b03e0496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0560a5c54fcf0e9786018f00e136c7fb" id="r_a0560a5c54fcf0e9786018f00e136c7fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a> () const noexcept</td></tr>
<tr class="memdesc:a0560a5c54fcf0e9786018f00e136c7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in current sequence.  <br /></td></tr>
<tr class="separator:a0560a5c54fcf0e9786018f00e136c7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef0abd344f629aef3c96e49d272b50c" id="r_aeef0abd344f629aef3c96e49d272b50c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aeef0abd344f629aef3c96e49d272b50c">count</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:aeef0abd344f629aef3c96e49d272b50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number that represents how many elements in the specified sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aeef0abd344f629aef3c96e49d272b50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b65916d2ccf5f2e4d1eb3f4ef4850d" id="r_a45b65916d2ccf5f2e4d1eb3f4ef4850d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a45b65916d2ccf5f2e4d1eb3f4ef4850d">count</a> (const char_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:a45b65916d2ccf5f2e4d1eb3f4ef4850d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with the specified value.  <br /></td></tr>
<tr class="separator:a45b65916d2ccf5f2e4d1eb3f4ef4850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dba2660f845875cd5908be53e52bbc7" id="r_a0dba2660f845875cd5908be53e52bbc7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; key_t, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0dba2660f845875cd5908be53e52bbc7">count_by</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector) const noexcept</td></tr>
<tr class="memdesc:a0dba2660f845875cd5908be53e52bbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:a0dba2660f845875cd5908be53e52bbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd274fa4579c9e02119888c7135d6c8e" id="r_acd274fa4579c9e02119888c7135d6c8e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; key_t, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#acd274fa4579c9e02119888c7135d6c8e">count_by</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;key_comparer) const noexcept</td></tr>
<tr class="memdesc:acd274fa4579c9e02119888c7135d6c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:acd274fa4579c9e02119888c7135d6c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb41413e817b71a549e3f99aaf743e1" id="r_a3fb41413e817b71a549e3f99aaf743e1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a3fb41413e817b71a549e3f99aaf743e1">default_if_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3fb41413e817b71a549e3f99aaf743e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a3fb41413e817b71a549e3f99aaf743e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5954e34075473c77cc41c979ed506fa3" id="r_a5954e34075473c77cc41c979ed506fa3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5954e34075473c77cc41c979ed506fa3">default_if_empty</a> (const char_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:a5954e34075473c77cc41c979ed506fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the specified value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a5954e34075473c77cc41c979ed506fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcddc251cf8f945686a5f77807e62dcd" id="r_afcddc251cf8f945686a5f77807e62dcd"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afcddc251cf8f945686a5f77807e62dcd">first_or_default</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>, const char_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:afcddc251cf8f945686a5f77807e62dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:afcddc251cf8f945686a5f77807e62dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52658d4876a5f7642288ef7cfd0be8" id="r_a2e52658d4876a5f7642288ef7cfd0be8"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2e52658d4876a5f7642288ef7cfd0be8">first_or_default</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:a2e52658d4876a5f7642288ef7cfd0be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2e52658d4876a5f7642288ef7cfd0be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0a757b76c036ef644cec12662f887" id="r_a2ba0a757b76c036ef644cec12662f887"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2ba0a757b76c036ef644cec12662f887">first_or_default</a> (const char_t default_value) const noexcept</td></tr>
<tr class="memdesc:a2ba0a757b76c036ef644cec12662f887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2ba0a757b76c036ef644cec12662f887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964948d137047014d18a7cc5db15f46f" id="r_a964948d137047014d18a7cc5db15f46f"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a964948d137047014d18a7cc5db15f46f">first_or_default</a> () const noexcept</td></tr>
<tr class="memdesc:a964948d137047014d18a7cc5db15f46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a964948d137047014d18a7cc5db15f46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ca739f420b3ddd4df01845ce9bd979" id="r_a69ca739f420b3ddd4df01845ce9bd979"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a69ca739f420b3ddd4df01845ce9bd979">select</a> (const std::function&lt; result_t(const char_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a69ca739f420b3ddd4df01845ce9bd979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a69ca739f420b3ddd4df01845ce9bd979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58637f7cae0e9518f0b728d47f2dc8f9" id="r_a58637f7cae0e9518f0b728d47f2dc8f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a58637f7cae0e9518f0b728d47f2dc8f9">select</a> (const std::function&lt; char_t(const char_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a58637f7cae0e9518f0b728d47f2dc8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a58637f7cae0e9518f0b728d47f2dc8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a6585ba5b3ff487437db47ade70486" id="r_a74a6585ba5b3ff487437db47ade70486"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a74a6585ba5b3ff487437db47ade70486">select</a> (const std::function&lt; result_t(const char_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a74a6585ba5b3ff487437db47ade70486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a74a6585ba5b3ff487437db47ade70486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009c5250029162433b826be3a1a93efd" id="r_a009c5250029162433b826be3a1a93efd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a009c5250029162433b826be3a1a93efd">select</a> (const std::function&lt; char_t(const char_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a009c5250029162433b826be3a1a93efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a009c5250029162433b826be3a1a93efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a910fbeb2bb448c779d761dd865063c" id="r_a6a910fbeb2bb448c779d761dd865063c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a6a910fbeb2bb448c779d761dd865063c">to_list</a> () const noexcept</td></tr>
<tr class="memdesc:a6a910fbeb2bb448c779d761dd865063c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a6a910fbeb2bb448c779d761dd865063c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669773bec96bcfe7a5b4f43068892620" id="r_a669773bec96bcfe7a5b4f43068892620"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a669773bec96bcfe7a5b4f43068892620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a669773bec96bcfe7a5b4f43068892620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c236ea62904000f45e720b7a7dbf17" id="r_a46c236ea62904000f45e720b7a7dbf17"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a46c236ea62904000f45e720b7a7dbf17">where</a> (const std::function&lt; bool(const char_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a46c236ea62904000f45e720b7a7dbf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a46c236ea62904000f45e720b7a7dbf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448a5456acc01f4fba47c60de3e131fb" id="r_a448a5456acc01f4fba47c60de3e131fb"><td class="memItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a448a5456acc01f4fba47c60de3e131fb">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a448a5456acc01f4fba47c60de3e131fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a448a5456acc01f4fba47c60de3e131fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4290d992ac1a1c103d8da2b51e0a5b3" id="r_ae4290d992ac1a1c103d8da2b51e0a5b3"><td class="memItemLeft" align="right" valign="top">static target_collection_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ae4290d992ac1a1c103d8da2b51e0a5b3">to_iterator</a> (typename source_collection_t::iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:ae4290d992ac1a1c103d8da2b51e0a5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:ae4290d992ac1a1c103d8da2b51e0a5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa952a17cd36abced37d4ff35733790cc" id="r_aa952a17cd36abced37d4ff35733790cc"><td class="memItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#aa952a17cd36abced37d4ff35733790cc">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:aa952a17cd36abced37d4ff35733790cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:aa952a17cd36abced37d4ff35733790cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f03a39012c080e229c4c3c5d1ad6df" id="r_a42f03a39012c080e229c4c3c5d1ad6df"><td class="memItemLeft" align="right" valign="top">static target_collection_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a42f03a39012c080e229c4c3c5d1ad6df">to_iterator</a> (typename source_collection_t::iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a42f03a39012c080e229c4c3c5d1ad6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a42f03a39012c080e229c4c3c5d1ad6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4cd1814acf74f3359393306249030536" name="a4cd1814acf74f3359393306249030536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd1814acf74f3359393306249030536">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the characters in the range [<code>s</code>, <code>s + count2</code>). The characters in [<code>s</code>, <code>s + count2</code>) may include null characters.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a785e7ca9244c89a0fd0552a30dca0df6" name="a785e7ca9244c89a0fd0552a30dca0df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785e7ca9244c89a0fd0552a30dca0df6">&#9670;&#160;</a></span>compare_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this instance with a specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An object that evaluates to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">This instance precedes <code>value</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">This instance has the same position in the sort order as <code>value</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">This instance follows <code>value</code>.   </td></tr>
</table>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`value` is not a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56991bcdcf3648e12180abbda6d0e4a2" name="a56991bcdcf3648e12180abbda6d0e4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56991bcdcf3648e12180abbda6d0e4a2">&#9670;&#160;</a></span>compare_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this instance with a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare with this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <code>value</code> parameter. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">This instance precedes <code>value</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">This instance has the same position in the sort order as <code>value</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">This instance follows <code>value</code>.   </td></tr>
</table>
</dd></dl>

<p>Implements <a class="el" href="classxtd_1_1icomparable.html#a8e5ad6ed9d798584e8b9be5749d6faa5">xtd::icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="a850cd349d2e010f36c975a32b150a981" name="a850cd349d2e010f36c975a32b150a981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850cd349d2e010f36c975a32b150a981">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified char occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a46fea739d2eea162481378cc3563e0e7" name="a46fea739d2eea162481378cc3563e0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fea739d2eea162481378cc3563e0e7">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified substring occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, or if value is the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="aa538684c095ac08578828af5eff7d48d" name="aa538684c095ac08578828af5eff7d48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa538684c095ac08578828af5eff7d48d">&#9670;&#160;</a></span>equals() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object, have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>obj</code> is a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> and its value is the same as this instance; otherwise, <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">xtd::object</a>.</p>

</div>
</div>
<a id="acf1e61a72cf0017e83126ebd8d409079" name="acf1e61a72cf0017e83126ebd8d409079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1e61a72cf0017e83126ebd8d409079">&#9670;&#160;</a></span>equals() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">xtd::iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="abe34c3ef80e295d524013594ab98e96f" name="abe34c3ef80e295d524013594ab98e96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe34c3ef80e295d524013594ab98e96f">&#9670;&#160;</a></span>equals() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing this instance and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal comparison. </dd></dl>

</div>
</div>
<a id="a88a32b980ce33e6240fad1bdf860be32" name="a88a32b980ce33e6240fad1bdf860be32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a32b980ce33e6240fad1bdf860be32">&#9670;&#160;</a></span>ends_with() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a235800cab8022150e0242be1f70ccba5" name="a235800cab8022150e0242be1f70ccba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235800cab8022150e0242be1f70ccba5">&#9670;&#160;</a></span>ends_with() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac9bb8f1452d6d3f0a504ed482aeff03d" name="ac9bb8f1452d6d3f0a504ed482aeff03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bb8f1452d6d3f0a504ed482aeff03d">&#9670;&#160;</a></span>ends_with() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="aad2260a3a56c452a4086de5c75d608f3" name="aad2260a3a56c452a4086de5c75d608f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2260a3a56c452a4086de5c75d608f3">&#9670;&#160;</a></span>ends_with() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a0d548b663eb6dc7b61394d0a5031a779" name="a0d548b663eb6dc7b61394d0a5031a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d548b663eb6dc7b61394d0a5031a779">&#9670;&#160;</a></span>ends_with() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a></td>          <td class="paramname"><span class="paramname"><em>comparison_type</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that determines how this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a995fc327f844695b7d54bb8c9dcefd64" name="a995fc327f844695b7d54bb8c9dcefd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995fc327f844695b7d54bb8c9dcefd64">&#9670;&#160;</a></span>find() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae7ef167753f97393efa4e8a04f645b1a" name="ae7ef167753f97393efa4e8a04f645b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef167753f97393efa4e8a04f645b1a">&#9670;&#160;</a></span>find() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="afa27496a7880e6ec15ed6af9f3ee63a9" name="afa27496a7880e6ec15ed6af9f3ee63a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa27496a7880e6ec15ed6af9f3ee63a9">&#9670;&#160;</a></span>find() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a5b84e810101f5722ea51155b57673c3a" name="a5b84e810101f5722ea51155b57673c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b84e810101f5722ea51155b57673c3a">&#9670;&#160;</a></span>find() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="afe01cbb72aa625955d5f91eaf20b4422" name="afe01cbb72aa625955d5f91eaf20b4422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe01cbb72aa625955d5f91eaf20b4422">&#9670;&#160;</a></span>find() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6e89be405fda67b0a224b7f5d19dbb74" name="a6e89be405fda67b0a224b7f5d19dbb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e89be405fda67b0a224b7f5d19dbb74">&#9670;&#160;</a></span>find() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="ada37711b3a6b2d96deb9937458eeed91" name="ada37711b3a6b2d96deb9937458eeed91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada37711b3a6b2d96deb9937458eeed91">&#9670;&#160;</a></span>find() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a190df4d0356f13ee707e02bf0ff69670" name="a190df4d0356f13ee707e02bf0ff69670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190df4d0356f13ee707e02bf0ff69670">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a47ad6cd829e5fb0e5ba7fd173fa52a4c" name="a47ad6cd829e5fb0e5ba7fd173fa52a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad6cd829e5fb0e5ba7fd173fa52a4c">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a92834b04a7c65b7de003f742e78d8309" name="a92834b04a7c65b7de003f742e78d8309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92834b04a7c65b7de003f742e78d8309">&#9670;&#160;</a></span>find_first_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="acb30d4555ab0d49edac1d1f29748968d" name="acb30d4555ab0d49edac1d1f29748968d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb30d4555ab0d49edac1d1f29748968d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a4bf3f78cb8fce98db32d6dea0dacb1fd" name="a4bf3f78cb8fce98db32d6dea0dacb1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf3f78cb8fce98db32d6dea0dacb1fd">&#9670;&#160;</a></span>find_first_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa63f087262d302ffd91d44441141395f" name="aa63f087262d302ffd91d44441141395f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63f087262d302ffd91d44441141395f">&#9670;&#160;</a></span>find_first_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="aebf0742e91a1bc6cc31486581993106d" name="aebf0742e91a1bc6cc31486581993106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf0742e91a1bc6cc31486581993106d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a44655a7fb2b16b0ac355f98efbe7f60a" name="a44655a7fb2b16b0ac355f98efbe7f60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44655a7fb2b16b0ac355f98efbe7f60a">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a865854c0f1fc517a76019ef74357471c" name="a865854c0f1fc517a76019ef74357471c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865854c0f1fc517a76019ef74357471c">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="aa7ee3d277929b2e2822347bbef0799ec" name="aa7ee3d277929b2e2822347bbef0799ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ee3d277929b2e2822347bbef0799ec">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa68c7409e9483b7fb2ecb4119a1a49c3" name="aa68c7409e9483b7fb2ecb4119a1a49c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68c7409e9483b7fb2ecb4119a1a49c3">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a394185c5018c818ca6e8c3cbf9048da1" name="a394185c5018c818ca6e8c3cbf9048da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394185c5018c818ca6e8c3cbf9048da1">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a525f7ed777b11690436a4e545cbd4c52" name="a525f7ed777b11690436a4e545cbd4c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525f7ed777b11690436a4e545cbd4c52">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="aa337f7f098dc744c16c768824cdbf5de" name="aa337f7f098dc744c16c768824cdbf5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa337f7f098dc744c16c768824cdbf5de">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="ada4b8376a5af873f844aa5de5a7f36f1" name="ada4b8376a5af873f844aa5de5a7f36f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4b8376a5af873f844aa5de5a7f36f1">&#9670;&#160;</a></span>find_last_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="abe8812d25aeb365b83a6e13b22d3ea15" name="abe8812d25aeb365b83a6e13b22d3ea15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8812d25aeb365b83a6e13b22d3ea15">&#9670;&#160;</a></span>find_last_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae683ad85d132dc61069a39ab5ecfc892" name="ae683ad85d132dc61069a39ab5ecfc892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae683ad85d132dc61069a39ab5ecfc892">&#9670;&#160;</a></span>find_last_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a3b9f9c97ebc85319e7bb0890747f95f0" name="a3b9f9c97ebc85319e7bb0890747f95f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9f9c97ebc85319e7bb0890747f95f0">&#9670;&#160;</a></span>find_last_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a43971d40fb8f9c14c8f2a8973fda5241" name="a43971d40fb8f9c14c8f2a8973fda5241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43971d40fb8f9c14c8f2a8973fda5241">&#9670;&#160;</a></span>find_last_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="ad3f1e765d3c800b53ad278aeea40cbbb" name="ad3f1e765d3c800b53ad278aeea40cbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f1e765d3c800b53ad278aeea40cbbb">&#9670;&#160;</a></span>find_last_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a2276b8461430eec909f87352134d92d8" name="a2276b8461430eec909f87352134d92d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2276b8461430eec909f87352134d92d8">&#9670;&#160;</a></span>find_last_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a85a0529754f7c547dd26d0e3df7d4d57" name="a85a0529754f7c547dd26d0e3df7d4d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a0529754f7c547dd26d0e3df7d4d57">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae7be46eecca48686b7893fdcc22f1064" name="ae7be46eecca48686b7893fdcc22f1064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7be46eecca48686b7893fdcc22f1064">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a0db0de794b93c1d3daec32ee93ebb840" name="a0db0de794b93c1d3daec32ee93ebb840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db0de794b93c1d3daec32ee93ebb840">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66" name="a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="ad867ec6c6bbe8ded000aab89983f5b37" name="ad867ec6c6bbe8ded000aab89983f5b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867ec6c6bbe8ded000aab89983f5b37">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a622aba17212244261f0a1dee4cf2a76c" name="a622aba17212244261f0a1dee4cf2a76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622aba17212244261f0a1dee4cf2a76c">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a2bb1e50a316279a814fbf6caa9a52512" name="a2bb1e50a316279a814fbf6caa9a52512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb1e50a316279a814fbf6caa9a52512">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::basic_string::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::basic_string::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a0f3fea87ee51c2cc221b5018ff83de9b" name="a0f3fea87ee51c2cc221b5018ff83de9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3fea87ee51c2cc221b5018ff83de9b">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="a38f45ba04d07446618d604b99c22fbb3" name="a38f45ba04d07446618d604b99c22fbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f45ba04d07446618d604b99c22fbb3">&#9670;&#160;</a></span>get_base_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const base_type &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_base_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type. </dd></dl>

</div>
</div>
<a id="a8204b499a2a327ac2193814c5ba59be4" name="a8204b499a2a327ac2193814c5ba59be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8204b499a2a327ac2193814c5ba59be4">&#9670;&#160;</a></span>get_hash_code()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_hash_code </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash code for this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">xtd::object</a>.</p>

</div>
</div>
<a id="a273eee6b3d879fdab255817b5406ff1b" name="a273eee6b3d879fdab255817b5406ff1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273eee6b3d879fdab255817b5406ff1b">&#9670;&#160;</a></span>get_enumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enumerator_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_enumerator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerator that iterates through a collection. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html" title="Supports a simple iteration over a generic collection.">xtd::collections::generic::enumerator</a> object that can be used to iterate through the collection. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#aaa7f31bc15aecee93e381b36c71c3058">xtd::collections::generic::ienumerable&lt; char_t &gt;</a>.</p>

</div>
</div>
<a id="aa2e2b0b18ffae65666bfe665f10c8eee" name="aa2e2b0b18ffae65666bfe665f10c8eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e2b0b18ffae65666bfe665f10c8eee">&#9670;&#160;</a></span>index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="ae8cdbff9d2baf8ca5354e0361db8b8f1" name="ae8cdbff9d2baf8ca5354e0361db8b8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cdbff9d2baf8ca5354e0361db8b8f1">&#9670;&#160;</a></span>index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a9376bff15d7276c49c0ce4ea3bd744b0" name="a9376bff15d7276c49c0ce4ea3bd744b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9376bff15d7276c49c0ce4ea3bd744b0">&#9670;&#160;</a></span>index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03cc9bdb3ebf738766cf0b8357d9f28d" name="a03cc9bdb3ebf738766cf0b8357d9f28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cc9bdb3ebf738766cf0b8357d9f28d">&#9670;&#160;</a></span>index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a1241d527912da0524fe79c1885104986" name="a1241d527912da0524fe79c1885104986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1241d527912da0524fe79c1885104986">&#9670;&#160;</a></span>index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a101dd613f8711c38c17443fbc8c29799" name="a101dd613f8711c38c17443fbc8c29799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101dd613f8711c38c17443fbc8c29799">&#9670;&#160;</a></span>index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50c38c1845d60e7d08f8750bb181aa4d" name="a50c38c1845d60e7d08f8750bb181aa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c38c1845d60e7d08f8750bb181aa4d">&#9670;&#160;</a></span>index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a19d7c6fb6ca5e05c6a464e8cb25c2e76" name="a19d7c6fb6ca5e05c6a464e8cb25c2e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d7c6fb6ca5e05c6a464e8cb25c2e76">&#9670;&#160;</a></span>index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac27b133bb5f4567decb3a19ff63a883" name="aac27b133bb5f4567decb3a19ff63a883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac27b133bb5f4567decb3a19ff63a883">&#9670;&#160;</a></span>index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48ce826afc61742ea2b759feb0987d9c" name="a48ce826afc61742ea2b759feb0987d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ce826afc61742ea2b759feb0987d9c">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a specified instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> at a specified index position in this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The index position of the insertion. </td></tr>
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to this instance but with value inserted at position start_index. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If start_index is equal to the length of this instance, value is appended to the end of this instance. </dd>
<dd>
For example, the return value of "abc".Insert(2, "XYZ") is "abXYZc". </dd></dl>

</div>
</div>
<a id="a6c9caea8081698b588cb6af9b6da8542" name="a6c9caea8081698b588cb6af9b6da8542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9caea8081698b588cb6af9b6da8542">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter is null or an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated</a></b></dt><dd>Replaced by xtd::basic_string::is_empty(const xtd::basic_string&amp;) - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="acc799a8cc31af232470d65cd88a1ca6a" name="acc799a8cc31af232470d65cd88a1ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc799a8cc31af232470d65cd88a1ca6a">&#9670;&#160;</a></span>last_index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a3b7a6db704899bd1263a714bf8363f6b" name="a3b7a6db704899bd1263a714bf8363f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a6db704899bd1263a714bf8363f6b">&#9670;&#160;</a></span>last_index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fb55029c7dfebcfb60989e102943e70" name="a4fb55029c7dfebcfb60989e102943e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb55029c7dfebcfb60989e102943e70">&#9670;&#160;</a></span>last_index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68a1c153b902e5edf0b877652add0e43" name="a68a1c153b902e5edf0b877652add0e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a1c153b902e5edf0b877652add0e43">&#9670;&#160;</a></span>last_index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this tring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="af8bdcec1f21421c38a7a80d8142ff7d5" name="af8bdcec1f21421c38a7a80d8142ff7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bdcec1f21421c38a7a80d8142ff7d5">&#9670;&#160;</a></span>last_index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c63d72cfa3f91e2cf9f23881f68d9a6" name="a8c63d72cfa3f91e2cf9f23881f68d9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c63d72cfa3f91e2cf9f23881f68d9a6">&#9670;&#160;</a></span>last_index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to find last index of. </td></tr>
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cef9de4c87f758793ab52f372999b98" name="a9cef9de4c87f758793ab52f372999b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cef9de4c87f758793ab52f372999b98">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ad9eee5a0186b0272dde1487fa3a76e31" name="ad9eee5a0186b0272dde1487fa3a76e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eee5a0186b0272dde1487fa3a76e31">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ac4c41879b43a215e17a3b3f1d940352b" name="ac4c41879b43a215e17a3b3f1d940352b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c41879b43a215e17a3b3f1d940352b">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a0841b4ac447cc426dfc86857696a59d3" name="a0841b4ac447cc426dfc86857696a59d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0841b4ac447cc426dfc86857696a59d3">&#9670;&#160;</a></span>pad_left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the right portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="acd8d49dec1f34267194ae3d6023e5bca" name="acd8d49dec1f34267194ae3d6023e5bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8d49dec1f34267194ae3d6023e5bca">&#9670;&#160;</a></span>pad_left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a></td>          <td class="paramname"><span class="paramname"><em>padding_char</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the right portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="abe37d71513cd7f2585290402bd45afb2" name="abe37d71513cd7f2585290402bd45afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe37d71513cd7f2585290402bd45afb2">&#9670;&#160;</a></span>pad_right() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but left-aligned and padded on the right with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The PadRight(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the end of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the left portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="a7948b86a1e0b7a58d6813048a74c4106" name="a7948b86a1e0b7a58d6813048a74c4106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7948b86a1e0b7a58d6813048a74c4106">&#9670;&#160;</a></span>pad_right() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a></td>          <td class="paramname"><span class="paramname"><em>padding_char</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but left-aligned and padded on the tight with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The <a class="el" href="#abe37d71513cd7f2585290402bd45afb2" title="Left-aligns the characters in this basic_string, padding with spaces on the right for a specified tot...">xtd::basic_string::pad_right</a> method pads the end of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the left portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="a5856547e0780ad2ada0c0f614dc063df" name="a5856547e0780ad2ada0c0f614dc063df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5856547e0780ad2ada0c0f614dc063df">&#9670;&#160;</a></span>quoted() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A new quoted <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>the delimiter is set to <pre class="fragment">" </pre> by default and the escape is set to <code>\</code> by default. </dd>
<dd>
for more information see <a href="https://en.cppreference.com/w/cpp/io/manip/quoted">std::quoted</a>. </dd></dl>

</div>
</div>
<a id="a773214921b5ced5e4a8d4c25dd88891c" name="a773214921b5ced5e4a8d4c25dd88891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773214921b5ced5e4a8d4c25dd88891c">&#9670;&#160;</a></span>quoted() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>The character to use as the delimiter, defaults to <code>"&lt;/tt&gt;.
@return A new quoted basic_string.
@remarks for more information see &lt;a href="<a href="https://en.cppreference.com/w/cpp/io/manip/quoted">https://en.cppreference.com/w/cpp/io/manip/quoted</a>" &gt;std::quoted. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19de7bf5a27c141a306859535be853a" name="af19de7bf5a27c141a306859535be853a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19de7bf5a27c141a306859535be853a">&#9670;&#160;</a></span>quoted() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>escape</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>The character to use as the delimiter, defaults to <code>"&lt;/tt&gt;.
@param escape The character to use as the escape character, defaults to &lt;tt&gt;\\&lt;/tt&gt;.
@return A new quoted basic_string.
@remarks for more information see &lt;a href="<a href="https://en.cppreference.com/w/cpp/io/manip/quoted">https://en.cppreference.com/w/cpp/io/manip/quoted</a>" &gt;std::quoted. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb28698bda96ef32e834d79377523c7" name="a5fb28698bda96ef32e834d79377523c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb28698bda96ef32e834d79377523c7">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is equivalent to this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> less the removed characters. </dd></dl>

</div>
</div>
<a id="a678f92a6d19c47147afc8eacf6f9c6b3" name="a678f92a6d19c47147afc8eacf6f9c6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f92a6d19c47147afc8eacf6f9c6b3">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is equivalent to this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> less the removed characters. </dd></dl>

</div>
</div>
<a id="aab8e9d4ff2110bf9f24035babdc2a1ef" name="aab8e9d4ff2110bf9f24035babdc2a1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8e9d4ff2110bf9f24035babdc2a1ef">&#9670;&#160;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>old_char</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>new_char</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified char_t in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified char_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>A char_t to be replaced. </td></tr>
    <tr><td class="paramname">new_char</td><td>A char_t to replace all occurrences of old_char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> but with all instances of old_char replaced with new_char. </dd></dl>

</div>
</div>
<a id="a80dba25995a5713a69ad528fc0dcf889" name="a80dba25995a5713a69ad528fc0dcf889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dba25995a5713a69ad528fc0dcf889">&#9670;&#160;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>old_string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_string</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_string</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to be replaced. </td></tr>
    <tr><td class="paramname">new_string</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to replace all occurrences of old_string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> but with all instances of old_string replaced with new_string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If new_string is empty, all occurrences of old_string are removed </dd></dl>

</div>
</div>
<a id="a2c5e3a4d7133856d265119fea8ec612f" name="a2c5e3a4d7133856d265119fea8ec612f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5e3a4d7133856d265119fea8ec612f">&#9670;&#160;</a></span>rfind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at xtd::basic_string::npos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following xtd::basic_string::npos). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as xtd::basic_string::npos, the whole string will be searched. / @return Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. / @remarks Finds the first substring equal to</code>str<code>. size_type rfind(const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; str) const {return chars_.rfind(str);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param str The string to search for. / @param pos The position at which to start the search / @return Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. / @remarks Finds the first substring equal to</code>str<code>. size_type rfind(const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; str, size_type pos) const {return chars_.rfind(str, pos);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param str The string to search for. / @param pos The position at which to start the search / @param count The length of substring to search for. / @return Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. / @remarks Finds the first substring equal to the range [s, s + count). / @remarks This range may contain null characters. If [</code>s<code>,</code>s + count<code>) is not a valid range, the behavior is undefined. size_type rfind(const_pointer s, size_type pos, size_type count) const {return chars_.rfind(s, pos, count);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at xtd::basic_string::npos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following xtd::basic_string::npos). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as xtd::basic_string::npos, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="afff7dc0272a38daae9fe92213bf3743f" name="afff7dc0272a38daae9fe92213bf3743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff7dc0272a38daae9fe92213bf3743f">&#9670;&#160;</a></span>rfind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If xtd::basic_string::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::basic_string::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/<a class="el" href="basic__string_8hpp_source.html">basic_string.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 1 2025 20:47:12 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
