<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::basic_string&lt; char_t, traits_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classxtd_1_1basic__string-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::basic_string&lt; char_t, traits_t, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__strings.html">strings</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::basic_string&lt; char_t, traits_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1basic__string.png" usemap="#xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,224,835,248"/>
<area href="classxtd_1_1icomparable.html" alt="xtd::icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;" shape="rect" coords="845,224,1680,248"/>
<area href="classxtd_1_1iequatable.html" alt="xtd::iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;" shape="rect" coords="2535,224,3370,248"/>
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" alt="xtd::collections::generic::ienumerable&lt; char_t &gt;" shape="rect" coords="4225,224,5060,248"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html" alt="xtd::collections::generic::extensions::enumerable&lt; ienumerable&lt; char_t &gt;, char_t &gt;" shape="rect" coords="5070,168,5905,192"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html" alt="xtd::collections::generic::extensions::enumerable_iterators&lt; char_t, xtd::collections::generic::ienumerable&lt; char_t &gt; &gt;" shape="rect" coords="5070,112,5905,136"/>
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable__abstract.html" title="Abstract object that represent ienumerable." alt="xtd::collections::generic::ienumerable_abstract" shape="rect" coords="5070,56,5905,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="5070,0,5905,24"/>
<area href="classxtd_1_1extensions_1_1equality__operators.html" alt="xtd::extensions::equality_operators&lt; basic_string&lt; char_t, traits_t, allocator_t &gt;, iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt; &gt;" shape="rect" coords="3380,168,4215,192"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="3380,112,4215,136"/>
<area href="classxtd_1_1extensions_1_1comparison__operators.html" alt="xtd::extensions::comparison_operators&lt; basic_string&lt; char_t, traits_t, allocator_t &gt;, icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt; &gt;" shape="rect" coords="1690,168,2525,192"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="1690,112,2525,136"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class char_t, class traits_t, class allocator_t&gt;<br />
class xtd::basic_string&lt; char_t, traits_t, allocator_t &gt;</div><p>Represents text as a sequence of character units. </p>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is a sequential collection of char that represent a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is the content of the sequential collection of <code>char_t</code>, and unlike <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char_t&gt;</a> that value is immutable (that is, it is read-only). </dd>
<dd>
If you want the same mutable <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> class, you can use <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char_t&gt; class. </dd>
<dd>
<a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char&gt;</a> and therefore offers the full (immutable) API of std::basic_string. </dd>
<dd>
Several aliases for common character types are provided: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;char&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#gad9519a3c079fca351ff0c97ccd3b012a" title="Represents text as a sequence of UTF-16 code units.">xtd::u16string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga30cd2dda34afc715ec10817ced72ac25" title="Represents text as a sequence of UTF-32 code units.">xtd::u32string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga2a1c504cef5a83ac0d4dec15817b0511" title="Represents text as a sequence of UTF-8 code units.">xtd::u8string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#gaef465eea9979bb0b1332b8bc46abe0ff" title="Represents text as a sequence of UTF-16 code unit on Windows or UTF-32 code unit on non-Windows syste...">xtd::wstring</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302" title="Represents a wide character.">xtd::wchar</a>&gt;   </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is a sequential collection of char that represent a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is the content of the sequential collection of <code>char_t</code>, and unlike <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char_t&gt;</a> that value is immutable (that is, it is read-only). </dd>
<dd>
If you want the same mutable <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> class, you can use <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char_t&gt; class. </dd>
<dd>
<a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char&gt;</a> and therefore offers the full (immutable) API of <a href="https://en.cppreference.com/w/cpp/string/basic_string">std::string</a>. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a69a97f1b420e640208ecd970b0d17f09" id="r_a69a97f1b420e640208ecd970b0d17f09"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a69a97f1b420e640208ecd970b0d17f09"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a69a97f1b420e640208ecd970b0d17f09">class_name</a> ()</td></tr>
<tr class="memdesc:a69a97f1b420e640208ecd970b0d17f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the object_t.  <br /></td></tr>
<tr class="separator:a69a97f1b420e640208ecd970b0d17f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da452ea8889d3c99e3ef0437d12b3a2" id="r_a0da452ea8889d3c99e3ef0437d12b3a2"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0da452ea8889d3c99e3ef0437d12b3a2">class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0695f721a034545f3ce21d8ac16944" id="r_a6a0695f721a034545f3ce21d8ac16944"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a0695f721a034545f3ce21d8ac16944">class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:a6a0695f721a034545f3ce21d8ac16944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a6a0695f721a034545f3ce21d8ac16944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac003a2b39a8e6160043f9d3a8681a178" id="r_ac003a2b39a8e6160043f9d3a8681a178"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac003a2b39a8e6160043f9d3a8681a178"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac003a2b39a8e6160043f9d3a8681a178">full_class_name</a> ()</td></tr>
<tr class="memdesc:ac003a2b39a8e6160043f9d3a8681a178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the objec_t, including the namespace of the objec_t.  <br /></td></tr>
<tr class="separator:ac003a2b39a8e6160043f9d3a8681a178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2dad45219c94eda3bd54742cc0a82a" id="r_acc2dad45219c94eda3bd54742cc0a82a"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:acc2dad45219c94eda3bd54742cc0a82a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acc2dad45219c94eda3bd54742cc0a82a">full_class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:acc2dad45219c94eda3bd54742cc0a82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:acc2dad45219c94eda3bd54742cc0a82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f42e3b00b7c27ffa63cc8e48dde6aa4" id="r_a3f42e3b00b7c27ffa63cc8e48dde6aa4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f42e3b00b7c27ffa63cc8e48dde6aa4">full_class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:a3f42e3b00b7c27ffa63cc8e48dde6aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:a3f42e3b00b7c27ffa63cc8e48dde6aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bebb497fb8cc571f2064b1385bc07a" id="r_a39bebb497fb8cc571f2064b1385bc07a"><td class="memItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a39bebb497fb8cc571f2064b1385bc07a">to_const_iterator</a> (typename source_collection_t::const_iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a39bebb497fb8cc571f2064b1385bc07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a39bebb497fb8cc571f2064b1385bc07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ddb6fd4017aa9c75838c0be754887c" id="r_a38ddb6fd4017aa9c75838c0be754887c"><td class="memItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a38ddb6fd4017aa9c75838c0be754887c">to_const_iterator</a> (typename source_collection_t::const_iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a38ddb6fd4017aa9c75838c0be754887c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a38ddb6fd4017aa9c75838c0be754887c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ae170d894810f9884bf9bf994e8ebb" id="r_a75ae170d894810f9884bf9bf994e8ebb"><td class="memItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a75ae170d894810f9884bf9bf994e8ebb">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a75ae170d894810f9884bf9bf994e8ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a75ae170d894810f9884bf9bf994e8ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a98d9b9cccd57f0512de8d49b3af99" id="r_a28a98d9b9cccd57f0512de8d49b3af99"><td class="memItemLeft" align="right" valign="top">static target_collection_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a28a98d9b9cccd57f0512de8d49b3af99">to_iterator</a> (typename source_collection_t::iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a28a98d9b9cccd57f0512de8d49b3af99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a28a98d9b9cccd57f0512de8d49b3af99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ef637a1485bdd83b5008e007f42000" id="r_ad5ef637a1485bdd83b5008e007f42000"><td class="memItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad5ef637a1485bdd83b5008e007f42000">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:ad5ef637a1485bdd83b5008e007f42000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:ad5ef637a1485bdd83b5008e007f42000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ff7eb8493f644dbfa729c4a815fbd" id="r_a385ff7eb8493f644dbfa729c4a815fbd"><td class="memItemLeft" align="right" valign="top">static target_collection_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a385ff7eb8493f644dbfa729c4a815fbd">to_iterator</a> (typename source_collection_t::iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a385ff7eb8493f644dbfa729c4a815fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a385ff7eb8493f644dbfa729c4a815fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Compares two character sequences. /</p>
<p>/</p>
<p>/ /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The other string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to str. / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(const basic_string &amp; str) const {return chars_.compare(str);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string &amp; str) const {return chars_.compare(pos1, count1, str);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. /</td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / * If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string &amp; str, size_type pos2) const {return chars_.compare(pos1, count1, str, pos2);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. /</td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. /</td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / * If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string &amp; str, size_type pos2, size_type count2) const {return chars_.compare(pos1, count1, str, pos2, count2);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> compare(const_pointer s) const {return chars_.compare(s);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1$ , <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). @remarks A character sequence consisting of</code>count1<code>characters starting at</code>data1<code>is compared to a character sequence consisting of</code>count2<code>characters starting at</code>data2<code>as follows:<ul>
<li>First, calculate the number of characters to compare, as if by</li>
</ul>
</code>size_type rlen = std::min(count1, count2)<code>.<ul>
<li>Then compare the sequences by calling</li>
</ul>
</code>traits_t::compare(data1, data2, rlen)`. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>
</td></tr>
<tr class="memitem:a42f4de83225ec7eb81d9e34a6d3fd461" id="r_a42f4de83225ec7eb81d9e34a6d3fd461"><td class="memItemLeft" align="right" valign="top"><a id="a42f4de83225ec7eb81d9e34a6d3fd461" name="a42f4de83225ec7eb81d9e34a6d3fd461"></a>
<a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compare</b> (size_type pos1, size_type count1, const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="separator:a42f4de83225ec7eb81d9e34a6d3fd461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd1814acf74f3359393306249030536" id="r_a4cd1814acf74f3359393306249030536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cd1814acf74f3359393306249030536">compare</a> (size_type pos1, size_type count1, const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type count2) const</td></tr>
<tr class="memdesc:a4cd1814acf74f3359393306249030536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a4cd1814acf74f3359393306249030536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785e7ca9244c89a0fd0552a30dca0df6" id="r_a785e7ca9244c89a0fd0552a30dca0df6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a785e7ca9244c89a0fd0552a30dca0df6">compare_to</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;value) const</td></tr>
<tr class="memdesc:a785e7ca9244c89a0fd0552a30dca0df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this instance with a specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a>.  <br /></td></tr>
<tr class="separator:a785e7ca9244c89a0fd0552a30dca0df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56991bcdcf3648e12180abbda6d0e4a2" id="r_a56991bcdcf3648e12180abbda6d0e4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56991bcdcf3648e12180abbda6d0e4a2">compare_to</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a56991bcdcf3648e12180abbda6d0e4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this instance with a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.  <br /></td></tr>
<tr class="separator:a56991bcdcf3648e12180abbda6d0e4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850cd349d2e010f36c975a32b150a981" id="r_a850cd349d2e010f36c975a32b150a981"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a850cd349d2e010f36c975a32b150a981">contains</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a850cd349d2e010f36c975a32b150a981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified char occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a850cd349d2e010f36c975a32b150a981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fea739d2eea162481378cc3563e0e7" id="r_a46fea739d2eea162481378cc3563e0e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46fea739d2eea162481378cc3563e0e7">contains</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a46fea739d2eea162481378cc3563e0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified substring occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a46fea739d2eea162481378cc3563e0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa538684c095ac08578828af5eff7d48d" id="r_aa538684c095ac08578828af5eff7d48d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa538684c095ac08578828af5eff7d48d">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept override</td></tr>
<tr class="memdesc:aa538684c095ac08578828af5eff7d48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object, have the same value.  <br /></td></tr>
<tr class="separator:aa538684c095ac08578828af5eff7d48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1e61a72cf0017e83126ebd8d409079" id="r_acf1e61a72cf0017e83126ebd8d409079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf1e61a72cf0017e83126ebd8d409079">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:acf1e61a72cf0017e83126ebd8d409079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value.  <br /></td></tr>
<tr class="separator:acf1e61a72cf0017e83126ebd8d409079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe34c3ef80e295d524013594ab98e96f" id="r_abe34c3ef80e295d524013594ab98e96f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe34c3ef80e295d524013594ab98e96f">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:abe34c3ef80e295d524013594ab98e96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:abe34c3ef80e295d524013594ab98e96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a32b980ce33e6240fad1bdf860be32" id="r_a88a32b980ce33e6240fad1bdf860be32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a32b980ce33e6240fad1bdf860be32">ends_with</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a88a32b980ce33e6240fad1bdf860be32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character.  <br /></td></tr>
<tr class="separator:a88a32b980ce33e6240fad1bdf860be32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235800cab8022150e0242be1f70ccba5" id="r_a235800cab8022150e0242be1f70ccba5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a235800cab8022150e0242be1f70ccba5">ends_with</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:a235800cab8022150e0242be1f70ccba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a235800cab8022150e0242be1f70ccba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bb8f1452d6d3f0a504ed482aeff03d" id="r_ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9bb8f1452d6d3f0a504ed482aeff03d">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2260a3a56c452a4086de5c75d608f3" id="r_aad2260a3a56c452a4086de5c75d608f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad2260a3a56c452a4086de5c75d608f3">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:aad2260a3a56c452a4086de5c75d608f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:aad2260a3a56c452a4086de5c75d608f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d548b663eb6dc7b61394d0a5031a779" id="r_a0d548b663eb6dc7b61394d0a5031a779"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d548b663eb6dc7b61394d0a5031a779">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) const noexcept</td></tr>
<tr class="memdesc:a0d548b663eb6dc7b61394d0a5031a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option.  <br /></td></tr>
<tr class="separator:a0d548b663eb6dc7b61394d0a5031a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995fc327f844695b7d54bb8c9dcefd64" id="r_a995fc327f844695b7d54bb8c9dcefd64"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a995fc327f844695b7d54bb8c9dcefd64">find</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a995fc327f844695b7d54bb8c9dcefd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a995fc327f844695b7d54bb8c9dcefd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ef167753f97393efa4e8a04f645b1a" id="r_ae7ef167753f97393efa4e8a04f645b1a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7ef167753f97393efa4e8a04f645b1a">find</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:ae7ef167753f97393efa4e8a04f645b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:ae7ef167753f97393efa4e8a04f645b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa27496a7880e6ec15ed6af9f3ee63a9" id="r_afa27496a7880e6ec15ed6af9f3ee63a9"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa27496a7880e6ec15ed6af9f3ee63a9">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:afa27496a7880e6ec15ed6af9f3ee63a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:afa27496a7880e6ec15ed6af9f3ee63a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b84e810101f5722ea51155b57673c3a" id="r_a5b84e810101f5722ea51155b57673c3a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b84e810101f5722ea51155b57673c3a">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a5b84e810101f5722ea51155b57673c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a5b84e810101f5722ea51155b57673c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe01cbb72aa625955d5f91eaf20b4422" id="r_afe01cbb72aa625955d5f91eaf20b4422"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe01cbb72aa625955d5f91eaf20b4422">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:afe01cbb72aa625955d5f91eaf20b4422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:afe01cbb72aa625955d5f91eaf20b4422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e89be405fda67b0a224b7f5d19dbb74" id="r_a6e89be405fda67b0a224b7f5d19dbb74"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e89be405fda67b0a224b7f5d19dbb74">find</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> ch) const</td></tr>
<tr class="memdesc:a6e89be405fda67b0a224b7f5d19dbb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a6e89be405fda67b0a224b7f5d19dbb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada37711b3a6b2d96deb9937458eeed91" id="r_ada37711b3a6b2d96deb9937458eeed91"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada37711b3a6b2d96deb9937458eeed91">find</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> ch, size_type pos) const</td></tr>
<tr class="memdesc:ada37711b3a6b2d96deb9937458eeed91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:ada37711b3a6b2d96deb9937458eeed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190df4d0356f13ee707e02bf0ff69670" id="r_a190df4d0356f13ee707e02bf0ff69670"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a190df4d0356f13ee707e02bf0ff69670">find_first_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a190df4d0356f13ee707e02bf0ff69670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a190df4d0356f13ee707e02bf0ff69670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ad6cd829e5fb0e5ba7fd173fa52a4c" id="r_a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47ad6cd829e5fb0e5ba7fd173fa52a4c">find_first_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92834b04a7c65b7de003f742e78d8309" id="r_a92834b04a7c65b7de003f742e78d8309"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92834b04a7c65b7de003f742e78d8309">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a92834b04a7c65b7de003f742e78d8309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a92834b04a7c65b7de003f742e78d8309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb30d4555ab0d49edac1d1f29748968d" id="r_acb30d4555ab0d49edac1d1f29748968d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb30d4555ab0d49edac1d1f29748968d">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:acb30d4555ab0d49edac1d1f29748968d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:acb30d4555ab0d49edac1d1f29748968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf3f78cb8fce98db32d6dea0dacb1fd" id="r_a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bf3f78cb8fce98db32d6dea0dacb1fd">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63f087262d302ffd91d44441141395f" id="r_aa63f087262d302ffd91d44441141395f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa63f087262d302ffd91d44441141395f">find_first_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:aa63f087262d302ffd91d44441141395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa63f087262d302ffd91d44441141395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0742e91a1bc6cc31486581993106d" id="r_aebf0742e91a1bc6cc31486581993106d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf0742e91a1bc6cc31486581993106d">find_first_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:aebf0742e91a1bc6cc31486581993106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aebf0742e91a1bc6cc31486581993106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44655a7fb2b16b0ac355f98efbe7f60a" id="r_a44655a7fb2b16b0ac355f98efbe7f60a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44655a7fb2b16b0ac355f98efbe7f60a">find_first_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a44655a7fb2b16b0ac355f98efbe7f60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a44655a7fb2b16b0ac355f98efbe7f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865854c0f1fc517a76019ef74357471c" id="r_a865854c0f1fc517a76019ef74357471c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a865854c0f1fc517a76019ef74357471c">find_first_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a865854c0f1fc517a76019ef74357471c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a865854c0f1fc517a76019ef74357471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ee3d277929b2e2822347bbef0799ec" id="r_aa7ee3d277929b2e2822347bbef0799ec"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7ee3d277929b2e2822347bbef0799ec">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:aa7ee3d277929b2e2822347bbef0799ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa7ee3d277929b2e2822347bbef0799ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68c7409e9483b7fb2ecb4119a1a49c3" id="r_aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa68c7409e9483b7fb2ecb4119a1a49c3">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394185c5018c818ca6e8c3cbf9048da1" id="r_a394185c5018c818ca6e8c3cbf9048da1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a394185c5018c818ca6e8c3cbf9048da1">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a394185c5018c818ca6e8c3cbf9048da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a394185c5018c818ca6e8c3cbf9048da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525f7ed777b11690436a4e545cbd4c52" id="r_a525f7ed777b11690436a4e545cbd4c52"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a525f7ed777b11690436a4e545cbd4c52">find_first_not_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:a525f7ed777b11690436a4e545cbd4c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a525f7ed777b11690436a4e545cbd4c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa337f7f098dc744c16c768824cdbf5de" id="r_aa337f7f098dc744c16c768824cdbf5de"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa337f7f098dc744c16c768824cdbf5de">find_first_not_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:aa337f7f098dc744c16c768824cdbf5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa337f7f098dc744c16c768824cdbf5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4b8376a5af873f844aa5de5a7f36f1" id="r_ada4b8376a5af873f844aa5de5a7f36f1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada4b8376a5af873f844aa5de5a7f36f1">find_last_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:ada4b8376a5af873f844aa5de5a7f36f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:ada4b8376a5af873f844aa5de5a7f36f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8812d25aeb365b83a6e13b22d3ea15" id="r_abe8812d25aeb365b83a6e13b22d3ea15"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe8812d25aeb365b83a6e13b22d3ea15">find_last_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:abe8812d25aeb365b83a6e13b22d3ea15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:abe8812d25aeb365b83a6e13b22d3ea15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae683ad85d132dc61069a39ab5ecfc892" id="r_ae683ad85d132dc61069a39ab5ecfc892"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae683ad85d132dc61069a39ab5ecfc892">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:ae683ad85d132dc61069a39ab5ecfc892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ae683ad85d132dc61069a39ab5ecfc892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9f9c97ebc85319e7bb0890747f95f0" id="r_a3b9f9c97ebc85319e7bb0890747f95f0"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b9f9c97ebc85319e7bb0890747f95f0">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a3b9f9c97ebc85319e7bb0890747f95f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a3b9f9c97ebc85319e7bb0890747f95f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43971d40fb8f9c14c8f2a8973fda5241" id="r_a43971d40fb8f9c14c8f2a8973fda5241"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43971d40fb8f9c14c8f2a8973fda5241">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a43971d40fb8f9c14c8f2a8973fda5241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a43971d40fb8f9c14c8f2a8973fda5241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f1e765d3c800b53ad278aeea40cbbb" id="r_ad3f1e765d3c800b53ad278aeea40cbbb"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3f1e765d3c800b53ad278aeea40cbbb">find_last_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:ad3f1e765d3c800b53ad278aeea40cbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ad3f1e765d3c800b53ad278aeea40cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2276b8461430eec909f87352134d92d8" id="r_a2276b8461430eec909f87352134d92d8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2276b8461430eec909f87352134d92d8">find_last_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:a2276b8461430eec909f87352134d92d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a2276b8461430eec909f87352134d92d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a0529754f7c547dd26d0e3df7d4d57" id="r_a85a0529754f7c547dd26d0e3df7d4d57"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a0529754f7c547dd26d0e3df7d4d57">find_last_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a85a0529754f7c547dd26d0e3df7d4d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a85a0529754f7c547dd26d0e3df7d4d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7be46eecca48686b7893fdcc22f1064" id="r_ae7be46eecca48686b7893fdcc22f1064"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7be46eecca48686b7893fdcc22f1064">find_last_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:ae7be46eecca48686b7893fdcc22f1064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ae7be46eecca48686b7893fdcc22f1064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db0de794b93c1d3daec32ee93ebb840" id="r_a0db0de794b93c1d3daec32ee93ebb840"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0db0de794b93c1d3daec32ee93ebb840">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a0db0de794b93c1d3daec32ee93ebb840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a0db0de794b93c1d3daec32ee93ebb840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66" id="r_a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867ec6c6bbe8ded000aab89983f5b37" id="r_ad867ec6c6bbe8ded000aab89983f5b37"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad867ec6c6bbe8ded000aab89983f5b37">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:ad867ec6c6bbe8ded000aab89983f5b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ad867ec6c6bbe8ded000aab89983f5b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622aba17212244261f0a1dee4cf2a76c" id="r_a622aba17212244261f0a1dee4cf2a76c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a622aba17212244261f0a1dee4cf2a76c">find_last_not_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:a622aba17212244261f0a1dee4cf2a76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a622aba17212244261f0a1dee4cf2a76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb1e50a316279a814fbf6caa9a52512" id="r_a2bb1e50a316279a814fbf6caa9a52512"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bb1e50a316279a814fbf6caa9a52512">find_last_not_of</a> (char_t ch, size_type pos) const</td></tr>
<tr class="memdesc:a2bb1e50a316279a814fbf6caa9a52512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a2bb1e50a316279a814fbf6caa9a52512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fea87ee51c2cc221b5018ff83de9b" id="r_a0f3fea87ee51c2cc221b5018ff83de9b"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f3fea87ee51c2cc221b5018ff83de9b">get_allocator</a> () const</td></tr>
<tr class="memdesc:a0f3fea87ee51c2cc221b5018ff83de9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the string.  <br /></td></tr>
<tr class="separator:a0f3fea87ee51c2cc221b5018ff83de9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f45ba04d07446618d604b99c22fbb3" id="r_a38f45ba04d07446618d604b99c22fbb3"><td class="memItemLeft" align="right" valign="top">virtual const base_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38f45ba04d07446618d604b99c22fbb3">get_base_type</a> () const noexcept</td></tr>
<tr class="memdesc:a38f45ba04d07446618d604b99c22fbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type.  <br /></td></tr>
<tr class="separator:a38f45ba04d07446618d604b99c22fbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8204b499a2a327ac2193814c5ba59be4" id="r_a8204b499a2a327ac2193814c5ba59be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8204b499a2a327ac2193814c5ba59be4">get_hash_code</a> () const noexcept override</td></tr>
<tr class="memdesc:a8204b499a2a327ac2193814c5ba59be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash code for this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a8204b499a2a327ac2193814c5ba59be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273eee6b3d879fdab255817b5406ff1b" id="r_a273eee6b3d879fdab255817b5406ff1b"><td class="memItemLeft" align="right" valign="top">enumerator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a273eee6b3d879fdab255817b5406ff1b">get_enumerator</a> () const noexcept override</td></tr>
<tr class="memdesc:a273eee6b3d879fdab255817b5406ff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that iterates through a collection.  <br /></td></tr>
<tr class="separator:a273eee6b3d879fdab255817b5406ff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e2b0b18ffae65666bfe665f10c8eee" id="r_aa2e2b0b18ffae65666bfe665f10c8eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2e2b0b18ffae65666bfe665f10c8eee">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:aa2e2b0b18ffae65666bfe665f10c8eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:aa2e2b0b18ffae65666bfe665f10c8eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cdbff9d2baf8ca5354e0361db8b8f1" id="r_ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8cdbff9d2baf8ca5354e0361db8b8f1">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9376bff15d7276c49c0ce4ea3bd744b0" id="r_a9376bff15d7276c49c0ce4ea3bd744b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9376bff15d7276c49c0ce4ea3bd744b0">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a9376bff15d7276c49c0ce4ea3bd744b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a9376bff15d7276c49c0ce4ea3bd744b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cc9bdb3ebf738766cf0b8357d9f28d" id="r_a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03cc9bdb3ebf738766cf0b8357d9f28d">index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1241d527912da0524fe79c1885104986" id="r_a1241d527912da0524fe79c1885104986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1241d527912da0524fe79c1885104986">index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a1241d527912da0524fe79c1885104986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a1241d527912da0524fe79c1885104986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101dd613f8711c38c17443fbc8c29799" id="r_a101dd613f8711c38c17443fbc8c29799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a101dd613f8711c38c17443fbc8c29799">index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a101dd613f8711c38c17443fbc8c29799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a101dd613f8711c38c17443fbc8c29799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c38c1845d60e7d08f8750bb181aa4d" id="r_a50c38c1845d60e7d08f8750bb181aa4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50c38c1845d60e7d08f8750bb181aa4d">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a50c38c1845d60e7d08f8750bb181aa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a50c38c1845d60e7d08f8750bb181aa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d7c6fb6ca5e05c6a464e8cb25c2e76" id="r_a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d7c6fb6ca5e05c6a464e8cb25c2e76">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac27b133bb5f4567decb3a19ff63a883" id="r_aac27b133bb5f4567decb3a19ff63a883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac27b133bb5f4567decb3a19ff63a883">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:aac27b133bb5f4567decb3a19ff63a883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:aac27b133bb5f4567decb3a19ff63a883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ce826afc61742ea2b759feb0987d9c" id="r_a48ce826afc61742ea2b759feb0987d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48ce826afc61742ea2b759feb0987d9c">insert</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const</td></tr>
<tr class="memdesc:a48ce826afc61742ea2b759feb0987d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a specified instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> at a specified index position in this instance.  <br /></td></tr>
<tr class="separator:a48ce826afc61742ea2b759feb0987d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc799a8cc31af232470d65cd88a1ca6a" id="r_acc799a8cc31af232470d65cd88a1ca6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc799a8cc31af232470d65cd88a1ca6a">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:acc799a8cc31af232470d65cd88a1ca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:acc799a8cc31af232470d65cd88a1ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a6db704899bd1263a714bf8363f6b" id="r_a3b7a6db704899bd1263a714bf8363f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b7a6db704899bd1263a714bf8363f6b">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a3b7a6db704899bd1263a714bf8363f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a3b7a6db704899bd1263a714bf8363f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb55029c7dfebcfb60989e102943e70" id="r_a4fb55029c7dfebcfb60989e102943e70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fb55029c7dfebcfb60989e102943e70">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a4fb55029c7dfebcfb60989e102943e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a4fb55029c7dfebcfb60989e102943e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a1c153b902e5edf0b877652add0e43" id="r_a68a1c153b902e5edf0b877652add0e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68a1c153b902e5edf0b877652add0e43">last_index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a68a1c153b902e5edf0b877652add0e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this tring.  <br /></td></tr>
<tr class="separator:a68a1c153b902e5edf0b877652add0e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bdcec1f21421c38a7a80d8142ff7d5" id="r_af8bdcec1f21421c38a7a80d8142ff7d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bdcec1f21421c38a7a80d8142ff7d5">last_index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:af8bdcec1f21421c38a7a80d8142ff7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:af8bdcec1f21421c38a7a80d8142ff7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c63d72cfa3f91e2cf9f23881f68d9a6" id="r_a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c63d72cfa3f91e2cf9f23881f68d9a6">last_index_of</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> value, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cef9de4c87f758793ab52f372999b98" id="r_a9cef9de4c87f758793ab52f372999b98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cef9de4c87f758793ab52f372999b98">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a9cef9de4c87f758793ab52f372999b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a9cef9de4c87f758793ab52f372999b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eee5a0186b0272dde1487fa3a76e31" id="r_ad9eee5a0186b0272dde1487fa3a76e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9eee5a0186b0272dde1487fa3a76e31">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:ad9eee5a0186b0272dde1487fa3a76e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ad9eee5a0186b0272dde1487fa3a76e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c41879b43a215e17a3b3f1d940352b" id="r_ac4c41879b43a215e17a3b3f1d940352b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4c41879b43a215e17a3b3f1d940352b">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:ac4c41879b43a215e17a3b3f1d940352b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ac4c41879b43a215e17a3b3f1d940352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0841b4ac447cc426dfc86857696a59d3" id="r_a0841b4ac447cc426dfc86857696a59d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0841b4ac447cc426dfc86857696a59d3">pad_left</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width) const noexcept</td></tr>
<tr class="memdesc:a0841b4ac447cc426dfc86857696a59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:a0841b4ac447cc426dfc86857696a59d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8d49dec1f34267194ae3d6023e5bca" id="r_acd8d49dec1f34267194ae3d6023e5bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd8d49dec1f34267194ae3d6023e5bca">pad_left</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width, <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a> padding_char) const noexcept</td></tr>
<tr class="memdesc:acd8d49dec1f34267194ae3d6023e5bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:acd8d49dec1f34267194ae3d6023e5bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37d71513cd7f2585290402bd45afb2" id="r_abe37d71513cd7f2585290402bd45afb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe37d71513cd7f2585290402bd45afb2">pad_right</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width) const noexcept</td></tr>
<tr class="memdesc:abe37d71513cd7f2585290402bd45afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:abe37d71513cd7f2585290402bd45afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948b86a1e0b7a58d6813048a74c4106" id="r_a7948b86a1e0b7a58d6813048a74c4106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7948b86a1e0b7a58d6813048a74c4106">pad_right</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> total_width, <a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a> padding_char) const noexcept</td></tr>
<tr class="memdesc:a7948b86a1e0b7a58d6813048a74c4106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:a7948b86a1e0b7a58d6813048a74c4106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856547e0780ad2ada0c0f614dc063df" id="r_a5856547e0780ad2ada0c0f614dc063df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5856547e0780ad2ada0c0f614dc063df">quoted</a> () const</td></tr>
<tr class="memdesc:a5856547e0780ad2ada0c0f614dc063df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>.  <br /></td></tr>
<tr class="separator:a5856547e0780ad2ada0c0f614dc063df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773214921b5ced5e4a8d4c25dd88891c" id="r_a773214921b5ced5e4a8d4c25dd88891c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a773214921b5ced5e4a8d4c25dd88891c">quoted</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> delimiter) const</td></tr>
<tr class="memdesc:a773214921b5ced5e4a8d4c25dd88891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter.  <br /></td></tr>
<tr class="separator:a773214921b5ced5e4a8d4c25dd88891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19de7bf5a27c141a306859535be853a" id="r_af19de7bf5a27c141a306859535be853a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af19de7bf5a27c141a306859535be853a">quoted</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> delimiter, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0ebc3c409070d07f1df0f2f4132509e">escape</a>) const</td></tr>
<tr class="memdesc:af19de7bf5a27c141a306859535be853a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape.  <br /></td></tr>
<tr class="separator:af19de7bf5a27c141a306859535be853a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb28698bda96ef32e834d79377523c7" id="r_a5fb28698bda96ef32e834d79377523c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb28698bda96ef32e834d79377523c7">remove</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a5fb28698bda96ef32e834d79377523c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a5fb28698bda96ef32e834d79377523c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f92a6d19c47147afc8eacf6f9c6b3" id="r_a678f92a6d19c47147afc8eacf6f9c6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a678f92a6d19c47147afc8eacf6f9c6b3">remove</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> start_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a678f92a6d19c47147afc8eacf6f9c6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a678f92a6d19c47147afc8eacf6f9c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8e9d4ff2110bf9f24035babdc2a1ef" id="r_aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab8e9d4ff2110bf9f24035babdc2a1ef">replace</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> old_char, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> new_char) const noexcept</td></tr>
<tr class="memdesc:aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified char_t in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified char_t.  <br /></td></tr>
<tr class="separator:aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dba25995a5713a69ad528fc0dcf889" id="r_a80dba25995a5713a69ad528fc0dcf889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80dba25995a5713a69ad528fc0dcf889">replace</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;old_string, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;new_string) const noexcept</td></tr>
<tr class="memdesc:a80dba25995a5713a69ad528fc0dcf889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a80dba25995a5713a69ad528fc0dcf889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5e3a4d7133856d265119fea8ec612f" id="r_a2c5e3a4d7133856d265119fea8ec612f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c5e3a4d7133856d265119fea8ec612f">rfind</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a2c5e3a4d7133856d265119fea8ec612f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched. / @return Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. / @remarks Finds the first substring equal to</code>str<code>. size_type rfind(const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> &amp; str) const {return chars_.rfind(str);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param str The string to search for. / @param pos The position at which to start the search / @return Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. / @remarks Finds the first substring equal to</code>str<code>. size_type rfind(const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> &amp; str, size_type pos) const {return chars_.rfind(str, pos);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param str The string to search for. / @param pos The position at which to start the search / @param count The length of substring to search for. / @return Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. / @remarks Finds the first substring equal to the range [s, s + count). / @remarks This range may contain null characters. If [</code>s<code>,</code>s + count<code>) is not a valid range, the behavior is undefined. size_type rfind(const_pointer s, size_type pos, size_type count) const {return chars_.rfind(s, pos, count);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a></code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a2c5e3a4d7133856d265119fea8ec612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7dc0272a38daae9fe92213bf3743f" id="r_afff7dc0272a38daae9fe92213bf3743f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff7dc0272a38daae9fe92213bf3743f">rfind</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:afff7dc0272a38daae9fe92213bf3743f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:afff7dc0272a38daae9fe92213bf3743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td class="ititle" colspan="2"><p>Returns a reference to the character at specified location index. /</p>
<p>/</p>
<p>/ /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the character to return. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. const_reference operator [](xtd::size index) const { if (index &gt;= <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> &amp;&amp; index != epos) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::index_out_of_range); return chars_[index == epos ? <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> - 1 : index]; }</td></tr>
  </table>
  </dd>
</dl>
<p>/ Returns a reference to the underlying base type. / </p><dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. operator const base_type&amp; () const noexcept {return chars_;}</dd></dl>
<p>/ Copy assignment operator. Replaces the contents with a copy of the contents of str. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const basic_string&lt;char&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, char&gt;::value) chars_ = str.chars_; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str.chars()); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of str. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const basic_string&lt;xtd::char16&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char16&gt;::value) chars_ = str.chars_; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str.chars()); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of str. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const basic_string&lt;xtd::char32&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char32&gt;::value) chars_ = str.chars_; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str.chars()); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of str. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const basic_string&lt;xtd::char8&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char8&gt;::value) chars_ = str.chars_; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str.chars()); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of str. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const basic_string&lt;xtd::wchar&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::wchar&gt;::value) chars_ = str.chars_; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str.chars()); return self_; }</dd></dl>
<p>/ Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(basic_string&lt;char&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, char&gt;::value) chars_ = std::move(str.chars_); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_))); return self_; } / Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(basic_string&lt;xtd::char16&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char16&gt;::value) chars_ = std::move(str.chars_); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_))); return self_; } / Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(basic_string&lt;xtd::char32&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char32&gt;::value) chars_ = std::move(str.chars_); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_))); return self_; } / Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(basic_string&lt;xtd::char8&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char8&gt;::value) chars_ = std::move(str.chars_); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_))); return self_; } / Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(basic_string&lt;xtd::wchar&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::wchar&gt;::value) chars_ = std::move(str.chars_); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_))); return self_; }</dd></dl>
<p>/ Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::basic_string&lt;char&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, char&gt;::value) chars_ = str; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::basic_string&lt;xtd::char16&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char16&gt;::value) chars_ = str; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::basic_string&lt;xtd::char32&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char32&gt;::value) chars_ = str; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::basic_string&lt;xtd::char8&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char8&gt;::value) chars_ = str; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::basic_string&lt;xtd::wchar&gt;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::wchar&gt;::value) chars_ = str; else chars_ = __xtd_convert_to_string&lt;value_type&gt;(str); return self_; }</dd></dl>
<p>/ Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(std::basic_string&lt;char&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, char&gt;::value) chars_ = std::move(str); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str))); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(std::basic_string&lt;xtd::char16&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char16&gt;::value) chars_ = std::move(str); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str))); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(std::basic_string&lt;xtd::char32&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char32&gt;::value) chars_ = std::move(str); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str))); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(std::basic_string&lt;xtd::char8&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::char8&gt;::value) chars_ = std::move(str); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str))); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(std::basic_string&lt;xtd::wchar&gt;&amp;&amp; str) noexcept { if constexpr(std::is_same&lt;char_t, xtd::wchar&gt;::value) chars_ = std::move(str); else chars_ = std::move(__xtd_convert_to_string&lt;value_type&gt;(std::move(str))); return self_; }</dd></dl>
<p>/ Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const char* str) { if (str == null) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::null_pointer); if constexpr(std::is_same_v&lt;char, char_t&gt;) chars_ = std::basic_string&lt;char&gt;(str); else chars_ = __xtd_convert_to_string&lt;value_type&gt;(std::basic_string&lt;char&gt;(str)); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const xtd::char16 * str) { if (str == null) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::null_pointer); if constexpr(std::is_same_v&lt;xtd::char16, char_t&gt;) chars_ = std::basic_string&lt;xtd::char16&gt;(str); else chars_ = __xtd_convert_to_string&lt;value_type&gt;(std::basic_string&lt;xtd::char16&gt;(str)); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const xtd::char32 * str) { if (str == null) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::null_pointer); if constexpr(std::is_same_v&lt;xtd::char32, char_t&gt;) chars_ = std::basic_string&lt;xtd::char32&gt;(str); else chars_ = __xtd_convert_to_string&lt;value_type&gt;(std::basic_string&lt;xtd::char32&gt;(str)); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const xtd::char8 * str) { if (str == null) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::null_pointer); if constexpr(std::is_same_v&lt;xtd::char8, char_t&gt;) chars_ = std::basic_string&lt;xtd::char8&gt;(str); else chars_ = __xtd_convert_to_string&lt;value_type&gt;(std::basic_string&lt;xtd::char8&gt;(str)); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const xtd::wchar * str) { if (str == null) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::null_pointer); if constexpr(std::is_same_v&lt;xtd::wchar, char_t&gt;) chars_ = std::basic_string&lt;xtd::wchar&gt;(str); else chars_ = __xtd_convert_to_string&lt;value_type&gt;(std::basic_string&lt;xtd::wchar&gt;(str)); return self_; }</dd></dl>
<p>/ Copy assignment operator. Replaces the contents with the specified character. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(char character) { self_ = basic_string(1, character); return self_; } / Copy assignment operator. Replaces the contents with the specified character. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(xtd::char16 character) { self_ = basic_string(1, character); return self_; } / Copy assignment operator. Replaces the contents with the specified character. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(xtd::char32 character) { self_ = basic_string(1, character); return self_; } / Copy assignment operator. Replaces the contents with the specified character. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(xtd::char8 character) { self_ = basic_string(1, character); return self_; } / Copy assignment operator. Replaces the contents with the specified character. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(xtd::wchar character) { self_ = basic_string(1, character); return self_; }</dd></dl>
<p>/ Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::initializer_list&lt;char&gt;&amp; il) { self_ = basic_string(il); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::initializer_list&lt;xtd::char16&gt;&amp; il) { self_ = basic_string(il); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::initializer_list&lt;xtd::char32&gt;&amp; il) { self_ = basic_string(il); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::initializer_list&lt;xtd::char8&gt;&amp; il) { self_ = basic_string(il); return self_; } / Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator =(const std::initializer_list&lt;xtd::wchar&gt;&amp; il) { self_ = basic_string(il); return self_; }</dd></dl>
<p>/ Addition assignment operator. Appends additional characters to the string. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const basic_string&lt;char&gt;&amp; str) { if constexpr(std::is_same_v&lt;char, char_t&gt;) chars_ += str.chars_; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str.chars_); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const basic_string&lt;xtd::char16&gt;&amp; str) { if constexpr(std::is_same_v&lt;xtd::char16, char_t&gt;) chars_ += str.chars_; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str.chars_); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const basic_string&lt;xtd::char32&gt;&amp; str) { if constexpr(std::is_same_v&lt;xtd::char32, char_t&gt;) chars_ += str.chars_; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str.chars_); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const basic_string&lt;xtd::char8&gt;&amp; str) { if constexpr(std::is_same_v&lt;xtd::char8, char_t&gt;) chars_ += str.chars_; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str.chars_); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const basic_string&lt;xtd::wchar&gt;&amp; str) { if constexpr(std::is_same_v&lt;xtd::wchar, char_t&gt;) chars_ += str.chars_; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str.chars_); return self_; }</dd></dl>
<p>/ Addition assignment operator. Appends additional characters to the string. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(basic_string&lt;char&gt;&amp;&amp; str) { if constexpr(std::is_same_v&lt;char, char_t&gt;) chars_ += std::move(str.chars_); else chars_ += __xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_)); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(basic_string&lt;xtd::char16&gt;&amp;&amp; str) { if constexpr(std::is_same_v&lt;xtd::char16, char_t&gt;) chars_ += std::move(str.chars_); else chars_ += __xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_)); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(basic_string&lt;xtd::char32&gt;&amp;&amp; str) { if constexpr(std::is_same_v&lt;xtd::char32, char_t&gt;) chars_ += std::move(str.chars_); else chars_ += __xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_)); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(basic_string&lt;xtd::char8&gt;&amp;&amp; str) { if constexpr(std::is_same_v&lt;xtd::char8, char_t&gt;) chars_ += std::move(str.chars_); else chars_ += __xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_)); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(basic_string&lt;xtd::wchar&gt;&amp;&amp; str) { if constexpr(std::is_same_v&lt;xtd::wchar, char_t&gt;) chars_ += std::move(str.chars_); else chars_ += __xtd_convert_to_string&lt;value_type&gt;(std::move(str.chars_)); return self_; }</dd></dl>
<p>/ Addition assignment operator. Appends additional characters to the string. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const std::basic_string&lt;char&gt;&amp; str) { if constexpr(std::is_same_v&lt;char, char_t&gt;) chars_ += str; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const std::basic_string&lt;xtd::char16&gt;&amp; str) { if constexpr(std::is_same_v&lt;xtd::char16, char_t&gt;) chars_ += str; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const std::basic_string&lt;xtd::char32&gt;&amp; str) { if constexpr(std::is_same_v&lt;xtd::char32, char_t&gt;) chars_ += str; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const std::basic_string&lt;xtd::char8&gt;&amp; str) { if constexpr(std::is_same_v&lt;xtd::char8, char_t&gt;) chars_ += str; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const std::basic_string&lt;xtd::wchar&gt;&amp; str) { if constexpr(std::is_same_v&lt;xtd::wchar, char_t&gt;) chars_ += str; else chars_ += __xtd_convert_to_string&lt;value_type&gt;(str); return self_; }</dd></dl>
<p>/ Addition assignment operator. Appends additional characters to the string. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const char* str) { chars_ += basic_string(str).chars_; return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const xtd::char16 * str) { chars_.append(basic_string(str).chars_); return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const xtd::char32 * str) { chars_ += basic_string(str).chars_; return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const xtd::char8 * str) { chars_ += basic_string(str).chars_; return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(const xtd::wchar * str) { chars_ += basic_string(str).chars_; return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(char ch) { chars_ += basic_string(1, ch).chars_; return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(xtd::char16 ch) { chars_ += basic_string(1, ch).chars_; return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(xtd::char32 ch) { chars_ += basic_string(1, ch).chars_; return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(xtd::char8 ch) { chars_ += basic_string(1, ch).chars_; return self_; } / Addition assignment operator. Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>&amp; operator +=(xtd::wchar ch) { chars_ += basic_string(1, ch).chars_; return self_; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const basic_string&lt;char&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const basic_string&lt;xtd::char16&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const basic_string&lt;xtd::char32&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const basic_string&lt;xtd::char8&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const basic_string&lt;xtd::wchar&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, basic_string&lt;char&gt;&amp;&amp; rhs) { auto result = std::move(lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, basic_string&lt;xtd::char16&gt;&amp;&amp; rhs) { auto result = std::move(lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, basic_string&lt;xtd::char32&gt;&amp;&amp; rhs) { auto result = std::move(lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, basic_string&lt;xtd::char8&gt;&amp;&amp; rhs) { auto result = std::move(lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, basic_string&lt;xtd::wchar&gt;&amp;&amp; rhs) { auto result = std::move(lhs); result += std::move(rhs); return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const basic_string&lt;char&gt;&amp; rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const basic_string&lt;xtd::char16&gt;&amp; rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const basic_string&lt;xtd::char32&gt;&amp; rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const basic_string&lt;xtd::char8&gt;&amp; rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const basic_string&lt;xtd::wchar&gt;&amp; rhs) { auto result = std::move(lhs); result += rhs; return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, basic_string&lt;char&gt;&amp;&amp; rhs) { auto result = lhs; result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, basic_string&lt;xtd::char16&gt;&amp;&amp; rhs) { auto result = lhs; result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, basic_string&lt;xtd::char32&gt;&amp;&amp; rhs) { auto result = lhs; result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, basic_string&lt;xtd::char8&gt;&amp;&amp; rhs) { auto result = lhs; result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, basic_string&lt;xtd::wchar&gt;&amp;&amp; rhs) { auto result = lhs; result += std::move(rhs); return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const std::basic_string&lt;char&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const std::basic_string&lt;xtd::char16&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const std::basic_string&lt;xtd::char32&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const std::basic_string&lt;xtd::char8&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const std::basic_string&lt;xtd::wchar&gt;&amp; rhs) { auto result = lhs; result += rhs; return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const std::basic_string&lt;char&gt;&amp; lhs, const basic_string &amp; rhs) { auto result = lhs; if constexpr(std::is_same_v&lt;char, char_t&gt;) result += rhs.chars(); else result += __xtd_convert_to_string&lt;char&gt;(rhs.chars()); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const std::basic_string&lt;xtd::char16&gt;&amp; lhs, const basic_string &amp; rhs) { auto result = lhs; if constexpr(std::is_same_v&lt;xtd::char16, char_t&gt;) result += rhs.chars(); else result += __xtd_convert_to_string&lt;xtd::char16&gt;(rhs.chars()); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const std::basic_string&lt;xtd::char32&gt;&amp; lhs, const basic_string &amp; rhs) { auto result = lhs; if constexpr(std::is_same_v&lt;xtd::char32, char_t&gt;) result += rhs.chars(); else result += __xtd_convert_to_string&lt;xtd::char32&gt;(rhs.chars()); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const std::basic_string&lt;xtd::char8&gt;&amp; lhs, const basic_string &amp; rhs) { auto result = lhs; if constexpr(std::is_same_v&lt;xtd::char8, char_t&gt;) result += rhs.chars(); else result += __xtd_convert_to_string&lt;xtd::char8&gt;(rhs.chars()); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const std::basic_string&lt;xtd::wchar&gt;&amp; lhs, const basic_string &amp; rhs) { auto result = lhs; if constexpr(std::is_same_v&lt;xtd::wchar, char_t&gt;) result += rhs.chars(); else result += __xtd_convert_to_string&lt;xtd::wchar&gt;(rhs.chars()); return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const char* rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const xtd::char16 * rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const xtd::char32 * rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const xtd::char8 * rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const xtd::wchar * rhs) { auto result = lhs; result += rhs; return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const char* rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const xtd::char16 * rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const xtd::char32 * rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const xtd::char8 * rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const xtd::wchar * rhs) { auto result = std::move(lhs); result += rhs; return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const char* lhs, const basic_string &amp; rhs) { auto result = basic_string(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const xtd::char16 * lhs, const basic_string &amp; rhs) { auto result = basic_string(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const xtd::char32 * lhs, const basic_string &amp; rhs) { auto result = basic_string(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const xtd::char8 * lhs, const basic_string &amp; rhs) { auto result = basic_string(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const xtd::wchar * lhs, const basic_string &amp; rhs) { auto result = basic_string(lhs); result += rhs; return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const char* lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const xtd::char16 * lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const xtd::char32 * lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const xtd::char8 * lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const xtd::wchar * lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(lhs); result += std::move(rhs); return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const char rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const xtd::char16 rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const xtd::char32 rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const xtd::char8 rhs) { auto result = lhs; result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(const basic_string &amp; lhs, const xtd::wchar rhs) { auto result = lhs; result += rhs; return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const char rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const xtd::char16 rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const xtd::char32 rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const xtd::char8 rhs) { auto result = std::move(lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The string characters who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The character who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(basic_string&amp;&amp; lhs, const xtd::wchar rhs) { auto result = std::move(lhs); result += rhs; return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(char lhs, const basic_string &amp; rhs) { auto result = basic_string(1, lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(xtd::char16 lhs, const basic_string &amp; rhs) { auto result = basic_string(1, lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(xtd::char32 lhs, const basic_string &amp; rhs) { auto result = basic_string(1, lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(xtd::char8 lhs, const basic_string &amp; rhs) { auto result = basic_string(1, lhs); result += rhs; return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(xtd::wchar lhs, const basic_string &amp; rhs) { auto result = basic_string(1, lhs); result += rhs; return result; }</dd></dl>
<p>/ Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(char lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(1, lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(xtd::char16 lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(1, lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(xtd::char32 lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(1, lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(xtd::char8 lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(1, lhs); result += std::move(rhs); return result; } / Addition operator. Returns a string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The character who will precede the <code>rhs</code>. /</td></tr>
    <tr><td class="paramname">rhs</td><td>The string characters who will follow the <code>lhs</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing characters from <code>lhs</code> followed by the characters from <code>rhs</code>. friend <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> operator +(xtd::wchar lhs, basic_string&amp;&amp; rhs) { auto result = basic_string(1, lhs); result += std::move(rhs); return result; }</dd></dl>
<p>/ </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo</a></b></dt><dd>uncomment following operators /</dd></dl>
<p>Output stream operator. Behaves as a <a href="https://en.cppreference.com/w/cpp/named_req/FormattedOutputFunction">FormattedOutputFunction</a>. After constructing and checking the sentry object, <a href="https://en.cppreference.com/w/cpp/named_req/FormattedOutputFunction#Padding">determines the output format padding</a>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The character output stream. /</td></tr>
    <tr><td class="paramname">str</td><td>The string to be inserted. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Then inserts each character from the resulting sequence <code>seq</code> (the contents of <code>str</code> plus padding) to the output stream <code>os</code> as if by calling <code>os.rdbuf()-&gt;sputn(seq, n)</code>, where n is <code>std::max(os.width(), str.size())</code>. / </dd>
<dd>
Finally, calls <code>os.width(0)</code> to cancel the effects of std::setw, if any. / </dd>
<dd>
Equivalent to <code>return os &lt;&lt; std::basic_string_view&lt;char_t, traits_t&gt;(str);</code>. / </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo</a></b></dt><dd>uncomment following line and remove the next. friend std::basic_ostream&lt;char&gt;&amp; operator &lt;&lt;(std::basic_ostream&lt;char&gt;&amp; stream, const basic_string&amp; str) {return stream &lt;&lt; str.to_string().chars_;} friend std::basic_ostream&lt;char&gt;&amp; operator &lt;&lt;(std::basic_ostream&lt;char&gt;&amp; stream, const basic_string &amp; str) { if constexpr(std::is_same_v&lt;char, char_t&gt;) return stream &lt;&lt; str.chars(); else return stream &lt;&lt; __xtd_convert_to_string&lt;char&gt;(str.chars()); } /</dd></dl>
<p>Output stream operator. Behaves as a <a href="https://en.cppreference.com/w/cpp/named_req/FormattedOutputFunction">FormattedOutputFunction</a>. After constructing and checking the sentry object, <a href="https://en.cppreference.com/w/cpp/named_req/FormattedOutputFunction#Padding">determines the output format padding</a>. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The character output stream. /</td></tr>
    <tr><td class="paramname">str</td><td>The string to be inserted. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Then inserts each character from the resulting sequence <code>seq</code> (the contents of <code>str</code> plus padding) to the output stream <code>os</code> as if by calling <code>os.rdbuf()-&gt;sputn(seq, n)</code>, where n is <code>std::max(os.width(), str.size())</code>. / </dd>
<dd>
Finally, calls <code>os.width(0)</code> to cancel the effects of std::setw, if any. / </dd>
<dd>
Equivalent to <code>return os &lt;&lt; std::basic_string_view&lt;char_t, traits_t&gt;(str);</code>. friend std::basic_ostream&lt;xtd::wchar&gt;&amp; operator &lt;&lt;(std::basic_ostream&lt;xtd::wchar&gt;&amp; stream, const basic_string &amp; str) {return stream &lt;&lt; str.to_wstring().chars();}</dd></dl>
<p>/ Input stream operator. Behaves as a <a href="https://en.cppreference.com/w/cpp/named_req/FormattedInputFunction">FormattedInputFunction</a>. After constructing and checking the sentry object, which may skip leading whitespace, first clears <code>str</code> with <code>str.erase()</code>, then reads characters from <code>is</code> and appends them to <code>str</code> as if by <code>str.append(1, c)</code>, until one of the following conditions becomes <code>true</code>: / * N characters are read, where N is <code>is.width()</code> if <code>is.width() &gt; 0</code>, otherwise N is <code>str.max_size()</code>, / * the end-of-file condition occurs in the stream is, or / * <code>std::isspace(c, is.getloc())</code> is <code>true</code> for the next character <code>c</code> in <code>is</code> (this whitespace character remains in the input stream). /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The character input stream. /</td></tr>
    <tr><td class="paramname">str</td><td>The string to be extracted. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no characters are extracted then std::ios::failbit is set on <code>is</code>, which may throw <a href="https://en.cppreference.com/w/cpp/io/ios_base/failure">std::ios_base::failure</a>. / </dd>
<dd>
Finally, calls <code>is.width(0)</code> to cancel the effects of <a href="https://en.cppreference.com/w/cpp/io/manip/setw">std::setw</a>, if any. friend std::basic_istream&lt;char&gt;&amp; operator &gt;&gt;(std::basic_istream&lt;char&gt;&amp; stream, basic_string &amp; str) { auto s = std::basic_string&lt;char&gt; {}; stream &gt;&gt; s; str = s; return stream; } / Input stream operator. Behaves as a <a href="https://en.cppreference.com/w/cpp/named_req/FormattedInputFunction">FormattedInputFunction</a>. After constructing and checking the sentry object, which may skip leading whitespace, first clears <code>str</code> with <code>str.erase()</code>, then reads characters from <code>is</code> and appends them to <code>str</code> as if by <code>str.append(1, c)</code>, until one of the following conditions becomes <code>true</code>: / * N characters are read, where N is <code>is.width()</code> if <code>is.width() &gt; 0</code>, otherwise N is <code>str.max_size()</code>, / * the end-of-file condition occurs in the stream is, or / * <code>std::isspace(c, is.getloc())</code> is <code>true</code> for the next character <code>c</code> in <code>is</code> (this whitespace character remains in the input stream). /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The character input stream. /</td></tr>
    <tr><td class="paramname">str</td><td>The string to be extracted. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no characters are extracted then std::ios::failbit is set on <code>is</code>, which may throw <a href="https://en.cppreference.com/w/cpp/io/ios_base/failure">std::ios_base::failure</a>. / </dd>
<dd>
Finally, calls <code>is.width(0)</code> to cancel the effects of <a href="https://en.cppreference.com/w/cpp/io/manip/setw">std::setw</a>, if any. friend std::basic_istream&lt;xtd::wchar&gt;&amp; operator &gt;&gt;(std::basic_istream&lt;xtd::wchar&gt;&amp; stream, basic_string &amp; str) { auto s = std::basic_string&lt;xtd::wchar&gt; {}; stream &gt;&gt; s; str = s; return stream; } / </dd></dl>
</td></tr>
<tr class="memitem:a6c9caea8081698b588cb6af9b6da8542" id="r_a6c9caea8081698b588cb6af9b6da8542"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c9caea8081698b588cb6af9b6da8542">is_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a6c9caea8081698b588cb6af9b6da8542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""). /.  <br /></td></tr>
<tr class="separator:a6c9caea8081698b588cb6af9b6da8542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:a1b6f4bbb7a3c18056332b28dae525927" id="r_a1b6f4bbb7a3c18056332b28dae525927"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td></tr>
<tr class="memdesc:a1b6f4bbb7a3c18056332b28dae525927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a1b6f4bbb7a3c18056332b28dae525927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca94147a6d4b2892d5b762764520cdd2" id="r_aca94147a6d4b2892d5b762764520cdd2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#aca94147a6d4b2892d5b762764520cdd2">iterator</a></td></tr>
<tr class="memdesc:aca94147a6d4b2892d5b762764520cdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:aca94147a6d4b2892d5b762764520cdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab620a4ddfe6c67a30040f3431b4322d5" id="r_ab620a4ddfe6c67a30040f3431b4322d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#ab620a4ddfe6c67a30040f3431b4322d5">const_iterator</a></td></tr>
<tr class="memdesc:ab620a4ddfe6c67a30040f3431b4322d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:ab620a4ddfe6c67a30040f3431b4322d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff72a2ec99d0023552f723de3705c4d" id="r_a6ff72a2ec99d0023552f723de3705c4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a6ff72a2ec99d0023552f723de3705c4d">iterator</a></td></tr>
<tr class="memdesc:a6ff72a2ec99d0023552f723de3705c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of enumerable value type.  <br /></td></tr>
<tr class="separator:a6ff72a2ec99d0023552f723de3705c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d5d971f36778bdd43d0e8eb5cc62e8" id="r_a37d5d971f36778bdd43d0e8eb5cc62e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a></td></tr>
<tr class="memdesc:a37d5d971f36778bdd43d0e8eb5cc62e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of enumerable value type.  <br /></td></tr>
<tr class="separator:a37d5d971f36778bdd43d0e8eb5cc62e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0428a5d439bb7fd6a75f0ca54751c5" id="r_afa0428a5d439bb7fd6a75f0ca54751c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afa0428a5d439bb7fd6a75f0ca54751c5">enumerable_type</a></td></tr>
<tr class="memdesc:afa0428a5d439bb7fd6a75f0ca54751c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable enumerable type.  <br /></td></tr>
<tr class="separator:afa0428a5d439bb7fd6a75f0ca54751c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723aac49b8d3459b2caaff26c2ab90e0" id="r_a723aac49b8d3459b2caaff26c2ab90e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a723aac49b8d3459b2caaff26c2ab90e0">source_type</a></td></tr>
<tr class="memdesc:a723aac49b8d3459b2caaff26c2ab90e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable source type.  <br /></td></tr>
<tr class="separator:a723aac49b8d3459b2caaff26c2ab90e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f" id="r_aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a></td></tr>
<tr class="memdesc:aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2" id="r_a417e4adb1792949e9a54516bee2ca3d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a></td></tr>
<tr class="memdesc:a417e4adb1792949e9a54516bee2ca3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a417e4adb1792949e9a54516bee2ca3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d19ef177db62351b58a42f22138dbe" id="r_af2d19ef177db62351b58a42f22138dbe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:af2d19ef177db62351b58a42f22138dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:af2d19ef177db62351b58a42f22138dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436d1607f6b62c831e84221b6c196b37" id="r_a436d1607f6b62c831e84221b6c196b37"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a436d1607f6b62c831e84221b6c196b37">begin</a> () const</td></tr>
<tr class="memdesc:a436d1607f6b62c831e84221b6c196b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:a436d1607f6b62c831e84221b6c196b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fbecfad24d9e7a1bc54529c86e2c7f" id="r_ac8fbecfad24d9e7a1bc54529c86e2c7f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a6ff72a2ec99d0023552f723de3705c4d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ac8fbecfad24d9e7a1bc54529c86e2c7f">begin</a> ()</td></tr>
<tr class="memdesc:ac8fbecfad24d9e7a1bc54529c86e2c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:ac8fbecfad24d9e7a1bc54529c86e2c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3244c6835d9103844098ceee00dd929c" id="r_a3244c6835d9103844098ceee00dd929c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a3244c6835d9103844098ceee00dd929c">cbegin</a> () const</td></tr>
<tr class="memdesc:a3244c6835d9103844098ceee00dd929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:a3244c6835d9103844098ceee00dd929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549d04adc2cad4650f5f81273cf94eb1" id="r_a549d04adc2cad4650f5f81273cf94eb1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a549d04adc2cad4650f5f81273cf94eb1">cend</a> () const</td></tr>
<tr class="memdesc:a549d04adc2cad4650f5f81273cf94eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:a549d04adc2cad4650f5f81273cf94eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6170ebbcc1ed30723db0d8f695a88477" id="r_a6170ebbcc1ed30723db0d8f695a88477"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a37d5d971f36778bdd43d0e8eb5cc62e8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a6170ebbcc1ed30723db0d8f695a88477">end</a> () const</td></tr>
<tr class="memdesc:a6170ebbcc1ed30723db0d8f695a88477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:a6170ebbcc1ed30723db0d8f695a88477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7158d69d20933e2f4216cbbdb82c6591" id="r_a7158d69d20933e2f4216cbbdb82c6591"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a6ff72a2ec99d0023552f723de3705c4d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a7158d69d20933e2f4216cbbdb82c6591">end</a> ()</td></tr>
<tr class="memdesc:a7158d69d20933e2f4216cbbdb82c6591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:a7158d69d20933e2f4216cbbdb82c6591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f3540f62b3b6140ecf188faf509842" id="r_a22f3540f62b3b6140ecf188faf509842"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a> (const std::function&lt; char_t(const char_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const</td></tr>
<tr class="memdesc:a22f3540f62b3b6140ecf188faf509842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a22f3540f62b3b6140ecf188faf509842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bbfa7cff2e26dcf33e973a97d42316" id="r_af8bbfa7cff2e26dcf33e973a97d42316"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#af8bbfa7cff2e26dcf33e973a97d42316">aggregate</a> (const char_t &amp;seed, const std::function&lt; char_t(const char_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const</td></tr>
<tr class="memdesc:af8bbfa7cff2e26dcf33e973a97d42316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:af8bbfa7cff2e26dcf33e973a97d42316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359f0f326affdbf94b54eb5933bf747e" id="r_a359f0f326affdbf94b54eb5933bf747e"><td class="memItemLeft" align="right" valign="top">accumulate_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a359f0f326affdbf94b54eb5933bf747e">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const accumulate_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const</td></tr>
<tr class="memdesc:a359f0f326affdbf94b54eb5933bf747e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a359f0f326affdbf94b54eb5933bf747e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487db86dcfc03a261804db9288b917df" id="r_a487db86dcfc03a261804db9288b917df"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a487db86dcfc03a261804db9288b917df">aggregate</a> (const char_t &amp;seed, const std::function&lt; char_t(const char_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; char_t(const char_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a487db86dcfc03a261804db9288b917df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a487db86dcfc03a261804db9288b917df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a25236539c411682f728129aaeba9a2" id="r_a7a25236539c411682f728129aaeba9a2"><td class="memItemLeft" align="right" valign="top">result_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a7a25236539c411682f728129aaeba9a2">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const accumulate_t &amp;, const char_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a7a25236539c411682f728129aaeba9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a7a25236539c411682f728129aaeba9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c344a4319826da54bae2611d78f7e41" id="r_a8c344a4319826da54bae2611d78f7e41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a8c344a4319826da54bae2611d78f7e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a8c344a4319826da54bae2611d78f7e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e647f592add925edc5682334fa2b29" id="r_a25e647f592add925edc5682334fa2b29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">any</a> () const noexcept</td></tr>
<tr class="memdesc:a25e647f592add925edc5682334fa2b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a25e647f592add925edc5682334fa2b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddaea79f05f3a1d7c83bdc64883ec44" id="r_a7ddaea79f05f3a1d7c83bdc64883ec44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a7ddaea79f05f3a1d7c83bdc64883ec44">any</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a7ddaea79f05f3a1d7c83bdc64883ec44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a7ddaea79f05f3a1d7c83bdc64883ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34c33a40d0180b2be5a5bfae2bda31e" id="r_ae34c33a40d0180b2be5a5bfae2bda31e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae34c33a40d0180b2be5a5bfae2bda31e">append</a> (const char_t &amp;element) const noexcept</td></tr>
<tr class="memdesc:ae34c33a40d0180b2be5a5bfae2bda31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:ae34c33a40d0180b2be5a5bfae2bda31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d20a7b596a0b4f468a80faaa8d0c93" id="r_ae9d20a7b596a0b4f468a80faaa8d0c93"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae9d20a7b596a0b4f468a80faaa8d0c93">as_enumerable</a> () const noexcept</td></tr>
<tr class="memdesc:ae9d20a7b596a0b4f468a80faaa8d0c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ae9d20a7b596a0b4f468a80faaa8d0c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5669f1a9bf9da6303aa9ff29197b4799" id="r_a5669f1a9bf9da6303aa9ff29197b4799"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5669f1a9bf9da6303aa9ff29197b4799">average</a> () const noexcept</td></tr>
<tr class="memdesc:a5669f1a9bf9da6303aa9ff29197b4799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of source_t values.  <br /></td></tr>
<tr class="separator:a5669f1a9bf9da6303aa9ff29197b4799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994683d04e77ec8464431ec8ac429a7c" id="r_a994683d04e77ec8464431ec8ac429a7c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a994683d04e77ec8464431ec8ac429a7c">cast</a> () const noexcept</td></tr>
<tr class="memdesc:a994683d04e77ec8464431ec8ac429a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> to the specified type.  <br /></td></tr>
<tr class="separator:a994683d04e77ec8464431ec8ac429a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992667d25a4fc7fd3383d9eafd716eca" id="r_a992667d25a4fc7fd3383d9eafd716eca"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a992667d25a4fc7fd3383d9eafd716eca">chunk</a> (size_t <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">size</a>) const</td></tr>
<tr class="memdesc:a992667d25a4fc7fd3383d9eafd716eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the elements of a sequence into chunks of size at most size.  <br /></td></tr>
<tr class="separator:a992667d25a4fc7fd3383d9eafd716eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc904cd780ff73da92d5d8f4e6c81468" id="r_afc904cd780ff73da92d5d8f4e6c81468"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afc904cd780ff73da92d5d8f4e6c81468">concat</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; char_t &gt; &amp;second) const noexcept</td></tr>
<tr class="memdesc:afc904cd780ff73da92d5d8f4e6c81468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two sequences.  <br /></td></tr>
<tr class="separator:afc904cd780ff73da92d5d8f4e6c81468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e29837254bb373971404eb103ba26" id="r_ad77e29837254bb373971404eb103ba26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ad77e29837254bb373971404eb103ba26">contains</a> (const char_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:ad77e29837254bb373971404eb103ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using the default equality comparer.  <br /></td></tr>
<tr class="separator:ad77e29837254bb373971404eb103ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4be2e1cde9d4316519230b03e0496" id="r_a87d4be2e1cde9d4316519230b03e0496"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a87d4be2e1cde9d4316519230b03e0496">contains</a> (const char_t &amp;value, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; char_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept</td></tr>
<tr class="memdesc:a87d4be2e1cde9d4316519230b03e0496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using a specified equality comparer.  <br /></td></tr>
<tr class="separator:a87d4be2e1cde9d4316519230b03e0496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0560a5c54fcf0e9786018f00e136c7fb" id="r_a0560a5c54fcf0e9786018f00e136c7fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a> () const noexcept</td></tr>
<tr class="memdesc:a0560a5c54fcf0e9786018f00e136c7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in current sequence.  <br /></td></tr>
<tr class="separator:a0560a5c54fcf0e9786018f00e136c7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef0abd344f629aef3c96e49d272b50c" id="r_aeef0abd344f629aef3c96e49d272b50c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aeef0abd344f629aef3c96e49d272b50c">count</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:aeef0abd344f629aef3c96e49d272b50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number that represents how many elements in the specified sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aeef0abd344f629aef3c96e49d272b50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b65916d2ccf5f2e4d1eb3f4ef4850d" id="r_a45b65916d2ccf5f2e4d1eb3f4ef4850d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a45b65916d2ccf5f2e4d1eb3f4ef4850d">count</a> (const char_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:a45b65916d2ccf5f2e4d1eb3f4ef4850d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with the specified value.  <br /></td></tr>
<tr class="separator:a45b65916d2ccf5f2e4d1eb3f4ef4850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4457cca131d9c0a6ffe086e8eb0f94" id="r_a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4e4457cca131d9c0a6ffe086e8eb0f94">count_by</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector) const noexcept</td></tr>
<tr class="memdesc:a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc573c1483ac2d7952eb75e8b114e49" id="r_acfc573c1483ac2d7952eb75e8b114e49"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#acfc573c1483ac2d7952eb75e8b114e49">count_by</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;key_comparer) const noexcept</td></tr>
<tr class="memdesc:acfc573c1483ac2d7952eb75e8b114e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:acfc573c1483ac2d7952eb75e8b114e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b55e90e328b05491b96d053b5d5fc0f" id="r_a6b55e90e328b05491b96d053b5d5fc0f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a6b55e90e328b05491b96d053b5d5fc0f">default_if_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a6b55e90e328b05491b96d053b5d5fc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a6b55e90e328b05491b96d053b5d5fc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adcbae38abdfd1ce51e6bb29ed2c3e3" id="r_a5adcbae38abdfd1ce51e6bb29ed2c3e3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5adcbae38abdfd1ce51e6bb29ed2c3e3">default_if_empty</a> (const char_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:a5adcbae38abdfd1ce51e6bb29ed2c3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the specified value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a5adcbae38abdfd1ce51e6bb29ed2c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed33cd2bdca30be4a7746d569a8367a7" id="r_aed33cd2bdca30be4a7746d569a8367a7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aed33cd2bdca30be4a7746d569a8367a7">distinct</a> () const noexcept</td></tr>
<tr class="memdesc:aed33cd2bdca30be4a7746d569a8367a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distinct elements from a sequence by using the default equality comparer to compare values.  <br /></td></tr>
<tr class="separator:aed33cd2bdca30be4a7746d569a8367a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4e42accb00e5e59a3262c6624dfc7c" id="r_abb4e42accb00e5e59a3262c6624dfc7c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#abb4e42accb00e5e59a3262c6624dfc7c">distinct</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; char_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept</td></tr>
<tr class="memdesc:abb4e42accb00e5e59a3262c6624dfc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distinct elements from a sequence by using a specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; to compare values.  <br /></td></tr>
<tr class="separator:abb4e42accb00e5e59a3262c6624dfc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcddc251cf8f945686a5f77807e62dcd" id="r_afcddc251cf8f945686a5f77807e62dcd"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afcddc251cf8f945686a5f77807e62dcd">first_or_default</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>, const char_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:afcddc251cf8f945686a5f77807e62dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:afcddc251cf8f945686a5f77807e62dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52658d4876a5f7642288ef7cfd0be8" id="r_a2e52658d4876a5f7642288ef7cfd0be8"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2e52658d4876a5f7642288ef7cfd0be8">first_or_default</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:a2e52658d4876a5f7642288ef7cfd0be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2e52658d4876a5f7642288ef7cfd0be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0a757b76c036ef644cec12662f887" id="r_a2ba0a757b76c036ef644cec12662f887"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2ba0a757b76c036ef644cec12662f887">first_or_default</a> (const char_t default_value) const noexcept</td></tr>
<tr class="memdesc:a2ba0a757b76c036ef644cec12662f887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2ba0a757b76c036ef644cec12662f887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964948d137047014d18a7cc5db15f46f" id="r_a964948d137047014d18a7cc5db15f46f"><td class="memItemLeft" align="right" valign="top">char_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a964948d137047014d18a7cc5db15f46f">first_or_default</a> () const noexcept</td></tr>
<tr class="memdesc:a964948d137047014d18a7cc5db15f46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a964948d137047014d18a7cc5db15f46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9472d2fb32abc451658a9a49b1850a" id="r_abd9472d2fb32abc451658a9a49b1850a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#abd9472d2fb32abc451658a9a49b1850a">order_by</a> (const std::function&lt; char_t(const char_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:abd9472d2fb32abc451658a9a49b1850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order according to a key.  <br /></td></tr>
<tr class="separator:abd9472d2fb32abc451658a9a49b1850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dd17c4172c503636ef8c0b1954415f" id="r_a22dd17c4172c503636ef8c0b1954415f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22dd17c4172c503636ef8c0b1954415f">order_by</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:a22dd17c4172c503636ef8c0b1954415f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order according to a key.  <br /></td></tr>
<tr class="separator:a22dd17c4172c503636ef8c0b1954415f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf1d21996e82ad730383c1c83f9d4f5" id="r_a5cf1d21996e82ad730383c1c83f9d4f5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5cf1d21996e82ad730383c1c83f9d4f5">order_by_descending</a> (const std::function&lt; key_t(const char_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:a5cf1d21996e82ad730383c1c83f9d4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in descending order according to a key.  <br /></td></tr>
<tr class="separator:a5cf1d21996e82ad730383c1c83f9d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab380ad6e3fcd5d1cad403eae4e5d9d56" id="r_ab380ad6e3fcd5d1cad403eae4e5d9d56"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ab380ad6e3fcd5d1cad403eae4e5d9d56">order_by_descending</a> (const std::function&lt; char_t(const char_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:ab380ad6e3fcd5d1cad403eae4e5d9d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in descending order according to a key.  <br /></td></tr>
<tr class="separator:ab380ad6e3fcd5d1cad403eae4e5d9d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf27a2adb67c1144bc20c98151c45639" id="r_adf27a2adb67c1144bc20c98151c45639"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#adf27a2adb67c1144bc20c98151c45639">select</a> (const std::function&lt; result_t(const char_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:adf27a2adb67c1144bc20c98151c45639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:adf27a2adb67c1144bc20c98151c45639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2388e79e9cf3b548edcbfd01c7fb606" id="r_ac2388e79e9cf3b548edcbfd01c7fb606"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ac2388e79e9cf3b548edcbfd01c7fb606">select</a> (const std::function&lt; char_t(const char_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:ac2388e79e9cf3b548edcbfd01c7fb606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:ac2388e79e9cf3b548edcbfd01c7fb606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72b6ac4c22f5ed599d5bcad4bcb8f51" id="r_ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae72b6ac4c22f5ed599d5bcad4bcb8f51">select</a> (const std::function&lt; result_t(const char_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057c689f8c51e80cbf49b14e8cad1b00" id="r_a057c689f8c51e80cbf49b14e8cad1b00"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a057c689f8c51e80cbf49b14e8cad1b00">select</a> (const std::function&lt; char_t(const char_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a057c689f8c51e80cbf49b14e8cad1b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a057c689f8c51e80cbf49b14e8cad1b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9186b87e4e781e16cfeca4d3e83ca6ba" id="r_a9186b87e4e781e16cfeca4d3e83ca6ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a>&lt; char_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a9186b87e4e781e16cfeca4d3e83ca6ba">to_list</a> () const noexcept</td></tr>
<tr class="memdesc:a9186b87e4e781e16cfeca4d3e83ca6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a9186b87e4e781e16cfeca4d3e83ca6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb58e81e7cbc4401a227fa23918fd3c" id="r_accb58e81e7cbc4401a227fa23918fd3c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#accb58e81e7cbc4401a227fa23918fd3c">where</a> (const std::function&lt; bool(const char_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:accb58e81e7cbc4401a227fa23918fd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:accb58e81e7cbc4401a227fa23918fd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cebfce505a8ba369e428df6c5935491" id="r_a2cebfce505a8ba369e428df6c5935491"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2cebfce505a8ba369e428df6c5935491">where</a> (const std::function&lt; bool(const char_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a2cebfce505a8ba369e428df6c5935491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a2cebfce505a8ba369e428df6c5935491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4cd1814acf74f3359393306249030536" name="a4cd1814acf74f3359393306249030536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd1814acf74f3359393306249030536">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter:<ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the characters in the range [<code>s</code>, <code>s + count2</code>). The characters in [<code>s</code>, <code>s + count2</code>) may include null characters.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a785e7ca9244c89a0fd0552a30dca0df6" name="a785e7ca9244c89a0fd0552a30dca0df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785e7ca9244c89a0fd0552a30dca0df6">&#9670;&#160;</a></span>compare_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this instance with a specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An object that evaluates to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">This instance precedes <code>value</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">This instance has the same position in the sort order as <code>value</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">This instance follows <code>value</code>.   </td></tr>
</table>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`value` is not a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56991bcdcf3648e12180abbda6d0e4a2" name="a56991bcdcf3648e12180abbda6d0e4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56991bcdcf3648e12180abbda6d0e4a2">&#9670;&#160;</a></span>compare_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this instance with a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare with this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <code>value</code> parameter. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">This instance precedes <code>value</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">This instance has the same position in the sort order as <code>value</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">This instance follows <code>value</code>.   </td></tr>
</table>
</dd></dl>

<p>Implements <a class="el" href="classxtd_1_1icomparable.html#a8e5ad6ed9d798584e8b9be5749d6faa5">xtd::icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="a850cd349d2e010f36c975a32b150a981" name="a850cd349d2e010f36c975a32b150a981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850cd349d2e010f36c975a32b150a981">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified char occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a46fea739d2eea162481378cc3563e0e7" name="a46fea739d2eea162481378cc3563e0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fea739d2eea162481378cc3563e0e7">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified substring occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, or if value is the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="aa538684c095ac08578828af5eff7d48d" name="aa538684c095ac08578828af5eff7d48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa538684c095ac08578828af5eff7d48d">&#9670;&#160;</a></span>equals() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object, have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>obj</code> is a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> and its value is the same as this instance; otherwise, <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">xtd::object</a>.</p>

</div>
</div>
<a id="acf1e61a72cf0017e83126ebd8d409079" name="acf1e61a72cf0017e83126ebd8d409079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1e61a72cf0017e83126ebd8d409079">&#9670;&#160;</a></span>equals() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">xtd::iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="abe34c3ef80e295d524013594ab98e96f" name="abe34c3ef80e295d524013594ab98e96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe34c3ef80e295d524013594ab98e96f">&#9670;&#160;</a></span>equals() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing this instance and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal comparison. </dd></dl>

</div>
</div>
<a id="a88a32b980ce33e6240fad1bdf860be32" name="a88a32b980ce33e6240fad1bdf860be32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a32b980ce33e6240fad1bdf860be32">&#9670;&#160;</a></span>ends_with() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a235800cab8022150e0242be1f70ccba5" name="a235800cab8022150e0242be1f70ccba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235800cab8022150e0242be1f70ccba5">&#9670;&#160;</a></span>ends_with() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac9bb8f1452d6d3f0a504ed482aeff03d" name="ac9bb8f1452d6d3f0a504ed482aeff03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bb8f1452d6d3f0a504ed482aeff03d">&#9670;&#160;</a></span>ends_with() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="aad2260a3a56c452a4086de5c75d608f3" name="aad2260a3a56c452a4086de5c75d608f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2260a3a56c452a4086de5c75d608f3">&#9670;&#160;</a></span>ends_with() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_case</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a0d548b663eb6dc7b61394d0a5031a779" name="a0d548b663eb6dc7b61394d0a5031a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d548b663eb6dc7b61394d0a5031a779">&#9670;&#160;</a></span>ends_with() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a></td>          <td class="paramname"><span class="paramname"><em>comparison_type</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that determines how this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a995fc327f844695b7d54bb8c9dcefd64" name="a995fc327f844695b7d54bb8c9dcefd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995fc327f844695b7d54bb8c9dcefd64">&#9670;&#160;</a></span>find() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae7ef167753f97393efa4e8a04f645b1a" name="ae7ef167753f97393efa4e8a04f645b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef167753f97393efa4e8a04f645b1a">&#9670;&#160;</a></span>find() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="afa27496a7880e6ec15ed6af9f3ee63a9" name="afa27496a7880e6ec15ed6af9f3ee63a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa27496a7880e6ec15ed6af9f3ee63a9">&#9670;&#160;</a></span>find() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a5b84e810101f5722ea51155b57673c3a" name="a5b84e810101f5722ea51155b57673c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b84e810101f5722ea51155b57673c3a">&#9670;&#160;</a></span>find() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="afe01cbb72aa625955d5f91eaf20b4422" name="afe01cbb72aa625955d5f91eaf20b4422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe01cbb72aa625955d5f91eaf20b4422">&#9670;&#160;</a></span>find() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6e89be405fda67b0a224b7f5d19dbb74" name="a6e89be405fda67b0a224b7f5d19dbb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e89be405fda67b0a224b7f5d19dbb74">&#9670;&#160;</a></span>find() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="ada37711b3a6b2d96deb9937458eeed91" name="ada37711b3a6b2d96deb9937458eeed91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada37711b3a6b2d96deb9937458eeed91">&#9670;&#160;</a></span>find() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a190df4d0356f13ee707e02bf0ff69670" name="a190df4d0356f13ee707e02bf0ff69670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190df4d0356f13ee707e02bf0ff69670">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a47ad6cd829e5fb0e5ba7fd173fa52a4c" name="a47ad6cd829e5fb0e5ba7fd173fa52a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad6cd829e5fb0e5ba7fd173fa52a4c">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a92834b04a7c65b7de003f742e78d8309" name="a92834b04a7c65b7de003f742e78d8309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92834b04a7c65b7de003f742e78d8309">&#9670;&#160;</a></span>find_first_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="acb30d4555ab0d49edac1d1f29748968d" name="acb30d4555ab0d49edac1d1f29748968d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb30d4555ab0d49edac1d1f29748968d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a4bf3f78cb8fce98db32d6dea0dacb1fd" name="a4bf3f78cb8fce98db32d6dea0dacb1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf3f78cb8fce98db32d6dea0dacb1fd">&#9670;&#160;</a></span>find_first_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa63f087262d302ffd91d44441141395f" name="aa63f087262d302ffd91d44441141395f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63f087262d302ffd91d44441141395f">&#9670;&#160;</a></span>find_first_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="aebf0742e91a1bc6cc31486581993106d" name="aebf0742e91a1bc6cc31486581993106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf0742e91a1bc6cc31486581993106d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a44655a7fb2b16b0ac355f98efbe7f60a" name="a44655a7fb2b16b0ac355f98efbe7f60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44655a7fb2b16b0ac355f98efbe7f60a">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a865854c0f1fc517a76019ef74357471c" name="a865854c0f1fc517a76019ef74357471c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865854c0f1fc517a76019ef74357471c">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="aa7ee3d277929b2e2822347bbef0799ec" name="aa7ee3d277929b2e2822347bbef0799ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ee3d277929b2e2822347bbef0799ec">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa68c7409e9483b7fb2ecb4119a1a49c3" name="aa68c7409e9483b7fb2ecb4119a1a49c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68c7409e9483b7fb2ecb4119a1a49c3">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a394185c5018c818ca6e8c3cbf9048da1" name="a394185c5018c818ca6e8c3cbf9048da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394185c5018c818ca6e8c3cbf9048da1">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a525f7ed777b11690436a4e545cbd4c52" name="a525f7ed777b11690436a4e545cbd4c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525f7ed777b11690436a4e545cbd4c52">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="aa337f7f098dc744c16c768824cdbf5de" name="aa337f7f098dc744c16c768824cdbf5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa337f7f098dc744c16c768824cdbf5de">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="ada4b8376a5af873f844aa5de5a7f36f1" name="ada4b8376a5af873f844aa5de5a7f36f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4b8376a5af873f844aa5de5a7f36f1">&#9670;&#160;</a></span>find_last_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="abe8812d25aeb365b83a6e13b22d3ea15" name="abe8812d25aeb365b83a6e13b22d3ea15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8812d25aeb365b83a6e13b22d3ea15">&#9670;&#160;</a></span>find_last_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae683ad85d132dc61069a39ab5ecfc892" name="ae683ad85d132dc61069a39ab5ecfc892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae683ad85d132dc61069a39ab5ecfc892">&#9670;&#160;</a></span>find_last_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a3b9f9c97ebc85319e7bb0890747f95f0" name="a3b9f9c97ebc85319e7bb0890747f95f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9f9c97ebc85319e7bb0890747f95f0">&#9670;&#160;</a></span>find_last_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a43971d40fb8f9c14c8f2a8973fda5241" name="a43971d40fb8f9c14c8f2a8973fda5241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43971d40fb8f9c14c8f2a8973fda5241">&#9670;&#160;</a></span>find_last_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="ad3f1e765d3c800b53ad278aeea40cbbb" name="ad3f1e765d3c800b53ad278aeea40cbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f1e765d3c800b53ad278aeea40cbbb">&#9670;&#160;</a></span>find_last_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a2276b8461430eec909f87352134d92d8" name="a2276b8461430eec909f87352134d92d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2276b8461430eec909f87352134d92d8">&#9670;&#160;</a></span>find_last_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a85a0529754f7c547dd26d0e3df7d4d57" name="a85a0529754f7c547dd26d0e3df7d4d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a0529754f7c547dd26d0e3df7d4d57">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae7be46eecca48686b7893fdcc22f1064" name="ae7be46eecca48686b7893fdcc22f1064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7be46eecca48686b7893fdcc22f1064">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a0db0de794b93c1d3daec32ee93ebb840" name="a0db0de794b93c1d3daec32ee93ebb840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db0de794b93c1d3daec32ee93ebb840">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66" name="a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="ad867ec6c6bbe8ded000aab89983f5b37" name="ad867ec6c6bbe8ded000aab89983f5b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867ec6c6bbe8ded000aab89983f5b37">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a622aba17212244261f0a1dee4cf2a76c" name="a622aba17212244261f0a1dee4cf2a76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622aba17212244261f0a1dee4cf2a76c">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a2bb1e50a316279a814fbf6caa9a52512" name="a2bb1e50a316279a814fbf6caa9a52512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb1e50a316279a814fbf6caa9a52512">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a0f3fea87ee51c2cc221b5018ff83de9b" name="a0f3fea87ee51c2cc221b5018ff83de9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3fea87ee51c2cc221b5018ff83de9b">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="a38f45ba04d07446618d604b99c22fbb3" name="a38f45ba04d07446618d604b99c22fbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f45ba04d07446618d604b99c22fbb3">&#9670;&#160;</a></span>get_base_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const base_type &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_base_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type. </dd></dl>

</div>
</div>
<a id="a8204b499a2a327ac2193814c5ba59be4" name="a8204b499a2a327ac2193814c5ba59be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8204b499a2a327ac2193814c5ba59be4">&#9670;&#160;</a></span>get_hash_code()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_hash_code </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash code for this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">xtd::object</a>.</p>

</div>
</div>
<a id="a273eee6b3d879fdab255817b5406ff1b" name="a273eee6b3d879fdab255817b5406ff1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273eee6b3d879fdab255817b5406ff1b">&#9670;&#160;</a></span>get_enumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enumerator_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_enumerator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerator that iterates through a collection. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html" title="Supports a simple iteration over a generic collection.">xtd::collections::generic::enumerator</a> object that can be used to iterate through the collection. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#aaa7f31bc15aecee93e381b36c71c3058">xtd::collections::generic::ienumerable&lt; char_t &gt;</a>.</p>

</div>
</div>
<a id="aa2e2b0b18ffae65666bfe665f10c8eee" name="aa2e2b0b18ffae65666bfe665f10c8eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e2b0b18ffae65666bfe665f10c8eee">&#9670;&#160;</a></span>index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="ae8cdbff9d2baf8ca5354e0361db8b8f1" name="ae8cdbff9d2baf8ca5354e0361db8b8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cdbff9d2baf8ca5354e0361db8b8f1">&#9670;&#160;</a></span>index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a9376bff15d7276c49c0ce4ea3bd744b0" name="a9376bff15d7276c49c0ce4ea3bd744b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9376bff15d7276c49c0ce4ea3bd744b0">&#9670;&#160;</a></span>index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03cc9bdb3ebf738766cf0b8357d9f28d" name="a03cc9bdb3ebf738766cf0b8357d9f28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cc9bdb3ebf738766cf0b8357d9f28d">&#9670;&#160;</a></span>index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a1241d527912da0524fe79c1885104986" name="a1241d527912da0524fe79c1885104986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1241d527912da0524fe79c1885104986">&#9670;&#160;</a></span>index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a101dd613f8711c38c17443fbc8c29799" name="a101dd613f8711c38c17443fbc8c29799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101dd613f8711c38c17443fbc8c29799">&#9670;&#160;</a></span>index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50c38c1845d60e7d08f8750bb181aa4d" name="a50c38c1845d60e7d08f8750bb181aa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c38c1845d60e7d08f8750bb181aa4d">&#9670;&#160;</a></span>index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a19d7c6fb6ca5e05c6a464e8cb25c2e76" name="a19d7c6fb6ca5e05c6a464e8cb25c2e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d7c6fb6ca5e05c6a464e8cb25c2e76">&#9670;&#160;</a></span>index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac27b133bb5f4567decb3a19ff63a883" name="aac27b133bb5f4567decb3a19ff63a883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac27b133bb5f4567decb3a19ff63a883">&#9670;&#160;</a></span>index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48ce826afc61742ea2b759feb0987d9c" name="a48ce826afc61742ea2b759feb0987d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ce826afc61742ea2b759feb0987d9c">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a specified instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> at a specified index position in this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The index position of the insertion. </td></tr>
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to this instance but with value inserted at position start_index. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If start_index is equal to the length of this instance, value is appended to the end of this instance. </dd>
<dd>
For example, the return value of "abc".Insert(2, "XYZ") is "abXYZc". </dd></dl>

</div>
</div>
<a id="acc799a8cc31af232470d65cd88a1ca6a" name="acc799a8cc31af232470d65cd88a1ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc799a8cc31af232470d65cd88a1ca6a">&#9670;&#160;</a></span>last_index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a3b7a6db704899bd1263a714bf8363f6b" name="a3b7a6db704899bd1263a714bf8363f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a6db704899bd1263a714bf8363f6b">&#9670;&#160;</a></span>last_index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fb55029c7dfebcfb60989e102943e70" name="a4fb55029c7dfebcfb60989e102943e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb55029c7dfebcfb60989e102943e70">&#9670;&#160;</a></span>last_index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68a1c153b902e5edf0b877652add0e43" name="a68a1c153b902e5edf0b877652add0e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a1c153b902e5edf0b877652add0e43">&#9670;&#160;</a></span>last_index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this tring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="af8bdcec1f21421c38a7a80d8142ff7d5" name="af8bdcec1f21421c38a7a80d8142ff7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bdcec1f21421c38a7a80d8142ff7d5">&#9670;&#160;</a></span>last_index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c63d72cfa3f91e2cf9f23881f68d9a6" name="a8c63d72cfa3f91e2cf9f23881f68d9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c63d72cfa3f91e2cf9f23881f68d9a6">&#9670;&#160;</a></span>last_index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to find last index of. </td></tr>
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cef9de4c87f758793ab52f372999b98" name="a9cef9de4c87f758793ab52f372999b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cef9de4c87f758793ab52f372999b98">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ad9eee5a0186b0272dde1487fa3a76e31" name="ad9eee5a0186b0272dde1487fa3a76e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eee5a0186b0272dde1487fa3a76e31">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ac4c41879b43a215e17a3b3f1d940352b" name="ac4c41879b43a215e17a3b3f1d940352b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c41879b43a215e17a3b3f1d940352b">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a0841b4ac447cc426dfc86857696a59d3" name="a0841b4ac447cc426dfc86857696a59d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0841b4ac447cc426dfc86857696a59d3">&#9670;&#160;</a></span>pad_left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the right portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="acd8d49dec1f34267194ae3d6023e5bca" name="acd8d49dec1f34267194ae3d6023e5bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8d49dec1f34267194ae3d6023e5bca">&#9670;&#160;</a></span>pad_left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a></td>          <td class="paramname"><span class="paramname"><em>padding_char</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the right portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="abe37d71513cd7f2585290402bd45afb2" name="abe37d71513cd7f2585290402bd45afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe37d71513cd7f2585290402bd45afb2">&#9670;&#160;</a></span>pad_right() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but left-aligned and padded on the right with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The PadRight(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the end of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the left portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="a7948b86a1e0b7a58d6813048a74c4106" name="a7948b86a1e0b7a58d6813048a74c4106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7948b86a1e0b7a58d6813048a74c4106">&#9670;&#160;</a></span>pad_right() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>total_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9">char32</a></td>          <td class="paramname"><span class="paramname"><em>padding_char</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but left-aligned and padded on the tight with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The <a class="el" href="#abe37d71513cd7f2585290402bd45afb2" title="Left-aligns the characters in this basic_string, padding with spaces on the right for a specified tot...">xtd::basic_string::pad_right</a> method pads the end of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the left portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="a5856547e0780ad2ada0c0f614dc063df" name="a5856547e0780ad2ada0c0f614dc063df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5856547e0780ad2ada0c0f614dc063df">&#9670;&#160;</a></span>quoted() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A new quoted <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>the delimiter is set to <pre class="fragment">" </pre> by default and the escape is set to <code>\</code> by default. </dd>
<dd>
for more information see <a href="https://en.cppreference.com/w/cpp/io/manip/quoted">std::quoted</a>. </dd></dl>

</div>
</div>
<a id="a773214921b5ced5e4a8d4c25dd88891c" name="a773214921b5ced5e4a8d4c25dd88891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773214921b5ced5e4a8d4c25dd88891c">&#9670;&#160;</a></span>quoted() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>The character to use as the delimiter, defaults to <code>"&lt;/tt&gt;.
@return A new quoted basic_string.
@remarks for more information see &lt;a href="<a href="https://en.cppreference.com/w/cpp/io/manip/quoted">https://en.cppreference.com/w/cpp/io/manip/quoted</a>" &gt;std::quoted. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19de7bf5a27c141a306859535be853a" name="af19de7bf5a27c141a306859535be853a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19de7bf5a27c141a306859535be853a">&#9670;&#160;</a></span>quoted() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>escape</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>The character to use as the delimiter, defaults to <code>"&lt;/tt&gt;.
@param escape The character to use as the escape character, defaults to &lt;tt&gt;\\&lt;/tt&gt;.
@return A new quoted basic_string.
@remarks for more information see &lt;a href="<a href="https://en.cppreference.com/w/cpp/io/manip/quoted">https://en.cppreference.com/w/cpp/io/manip/quoted</a>" &gt;std::quoted. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb28698bda96ef32e834d79377523c7" name="a5fb28698bda96ef32e834d79377523c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb28698bda96ef32e834d79377523c7">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is equivalent to this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> less the removed characters. </dd></dl>

</div>
</div>
<a id="a678f92a6d19c47147afc8eacf6f9c6b3" name="a678f92a6d19c47147afc8eacf6f9c6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f92a6d19c47147afc8eacf6f9c6b3">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is equivalent to this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> less the removed characters. </dd></dl>

</div>
</div>
<a id="aab8e9d4ff2110bf9f24035babdc2a1ef" name="aab8e9d4ff2110bf9f24035babdc2a1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8e9d4ff2110bf9f24035babdc2a1ef">&#9670;&#160;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>old_char</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a></td>          <td class="paramname"><span class="paramname"><em>new_char</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified char_t in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified char_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>A char_t to be replaced. </td></tr>
    <tr><td class="paramname">new_char</td><td>A char_t to replace all occurrences of old_char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> but with all instances of old_char replaced with new_char. </dd></dl>

</div>
</div>
<a id="a80dba25995a5713a69ad528fc0dcf889" name="a80dba25995a5713a69ad528fc0dcf889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dba25995a5713a69ad528fc0dcf889">&#9670;&#160;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>old_string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_string</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_string</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to be replaced. </td></tr>
    <tr><td class="paramname">new_string</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to replace all occurrences of old_string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> but with all instances of old_string replaced with new_string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If new_string is empty, all occurrences of old_string are removed </dd></dl>

</div>
</div>
<a id="a2c5e3a4d7133856d265119fea8ec612f" name="a2c5e3a4d7133856d265119fea8ec612f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5e3a4d7133856d265119fea8ec612f">&#9670;&#160;</a></span>rfind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched. / @return Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. / @remarks Finds the first substring equal to</code>str<code>. size_type rfind(const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> &amp; str) const {return chars_.rfind(str);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param str The string to search for. / @param pos The position at which to start the search / @return Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. / @remarks Finds the first substring equal to</code>str<code>. size_type rfind(const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> &amp; str, size_type pos) const {return chars_.rfind(str, pos);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param str The string to search for. / @param pos The position at which to start the search / @param count The length of substring to search for. / @return Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. / @remarks Finds the first substring equal to the range [s, s + count). / @remarks This range may contain null characters. If [</code>s<code>,</code>s + count<code>) is not a valid range, the behavior is undefined. size_type rfind(const_pointer s, size_type pos, size_type count) const {return chars_.rfind(s, pos, count);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a></code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="afff7dc0272a38daae9fe92213bf3743f" name="afff7dc0272a38daae9fe92213bf3743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff7dc0272a38daae9fe92213bf3743f">&#9670;&#160;</a></span>rfind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="group__system.html#ga94bb9e7be783a1b9d24894b3b23859e6" title="Represents a value that is not a valid position in a collection.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6c9caea8081698b588cb6af9b6da8542" name="a6c9caea8081698b588cb6af9b6da8542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9caea8081698b588cb6af9b6da8542">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""). /. </p>
<p>/ Name Public Deprecated Methods</p>
<p>/ </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter is null or an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated</a></b></dt><dd>Replaced by xtd::basic_string::is_empty(const xtd::basic_string&amp;) - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a69a97f1b420e640208ecd970b0d17f09" name="a69a97f1b420e640208ecd970b0d17f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a97f1b420e640208ecd970b0d17f09">&#9670;&#160;</a></span>class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::class_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the object_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the object_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_&lt;object_t&gt;()</a>.name() - Will be removed in version 0.4.0. </dd></dl>
<p>Name Public Deprecated Static Methods </p>

</div>
</div>
<a id="a0da452ea8889d3c99e3ef0437d12b3a2" name="a0da452ea8889d3c99e3ef0437d12b3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da452ea8889d3c99e3ef0437d12b3a2">&#9670;&#160;</a></span>class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>object</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(object)</a>.name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a6a0695f721a034545f3ce21d8ac16944" name="a6a0695f721a034545f3ce21d8ac16944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0695f721a034545f3ce21d8ac16944">&#9670;&#160;</a></span>class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(info)</a>.name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="ac003a2b39a8e6160043f9d3a8681a178" name="ac003a2b39a8e6160043f9d3a8681a178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac003a2b39a8e6160043f9d3a8681a178">&#9670;&#160;</a></span>full_class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::full_class_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the objec_t, including the namespace of the objec_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the objec_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_&lt;object_t&gt;()</a>.full_name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="acc2dad45219c94eda3bd54742cc0a82a" name="acc2dad45219c94eda3bd54742cc0a82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2dad45219c94eda3bd54742cc0a82a">&#9670;&#160;</a></span>full_class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>object</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(object)</a>.full_name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a3f42e3b00b7c27ffa63cc8e48dde6aa4" name="a3f42e3b00b7c27ffa63cc8e48dde6aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f42e3b00b7c27ffa63cc8e48dde6aa4">&#9670;&#160;</a></span>full_class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t, class allocator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(info)</a>.full_name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/<a class="el" href="basic__string_8hpp_source.html">basic_string.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 12 2025 21:43:08 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
