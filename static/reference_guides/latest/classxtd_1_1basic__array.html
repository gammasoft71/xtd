<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::basic_array&lt; type_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1basic__array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::basic_array&lt; type_t, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::basic_array&lt; type_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1basic__array.png" usemap="#xtd::basic_5Farray_3C_20type_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::basic_5Farray_3C_20type_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::basic_5Farray_3C_20type_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1array__abstract__object.html" title="Abstract object that represent array." alt="xtd::array_abstract_object" shape="rect" coords="0,112,542,136"/>
<area href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f..." alt="xtd::iequatable&lt; type_t &gt;" shape="rect" coords="1104,112,1646,136"/>
<area href="classxtd_1_1abstract__object.html" title="Represent an abstract class." alt="xtd::abstract_object" shape="rect" coords="0,56,542,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="828,56,1370,80"/>
<area href="classxtd_1_1extensions_1_1equality__operators.html" alt="xtd::extensions::equality_operators&lt; type_t, iequatable&lt; type_t &gt; &gt;" shape="rect" coords="1380,56,1922,80"/>
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,542,24"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::string &gt;" shape="rect" coords="1104,224,1646,248"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::diagnostics::stack_frame &gt;" shape="rect" coords="1104,280,1646,304"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::drawing::color &gt;" shape="rect" coords="1104,336,1646,360"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::array&lt; bool &gt; &gt;" shape="rect" coords="1104,392,1646,416"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::drawing::point &gt;" shape="rect" coords="1104,448,1646,472"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::size &gt;" shape="rect" coords="1104,504,1646,528"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; item &gt;" shape="rect" coords="1104,560,1646,584"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::forms::shadow &gt;" shape="rect" coords="1104,616,1646,640"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt;<br />
class xtd::basic_array&lt; type_t, allocator_t &gt;</div><p>Base object that represent array. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> type_t, <span class="keyword">class</span> allocator_t = xtd::collections::<span class="keyword">generic</span>::helpers::allocator&lt;type_t&gt;&gt;</div>
<div class="line"><span class="keyword">class </span>basic_array : <span class="keyword">public</span> xtd::array_object, <span class="keyword">public</span> xtd::collections::generic::ilist&lt;type_t&gt;, <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1iequatable.html">xtd::iequatable</a>&lt;basic_array&lt;type_t, allocator_t&gt;&gt;;</div>
<div class="ttc" id="aclassxtd_1_1iequatable_html"><div class="ttname"><a href="classxtd_1_1iequatable.html">xtd::iequatable</a></div><div class="ttdoc">Defines a generalized method that a value type or class implements to create a type-specific method f...</div><div class="ttdef"><b>Definition</b> iequatable.hpp:22</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:a8a186922544d50c32678dbeead9d34fe" id="r_a8a186922544d50c32678dbeead9d34fe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a></td></tr>
<tr class="memdesc:a8a186922544d50c32678dbeead9d34fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array value type.  <br /></td></tr>
<tr class="separator:a8a186922544d50c32678dbeead9d34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e6f5ee12cd3d0e7e27c43bb4956d3b" id="r_a08e6f5ee12cd3d0e7e27c43bb4956d3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08e6f5ee12cd3d0e7e27c43bb4956d3b">allocator_type</a></td></tr>
<tr class="memdesc:a08e6f5ee12cd3d0e7e27c43bb4956d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array allocator type.  <br /></td></tr>
<tr class="separator:a08e6f5ee12cd3d0e7e27c43bb4956d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65616e6a94b988a1346bce86b911595" id="r_af65616e6a94b988a1346bce86b911595"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af65616e6a94b988a1346bce86b911595">base_type</a></td></tr>
<tr class="memdesc:af65616e6a94b988a1346bce86b911595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array base type.  <br /></td></tr>
<tr class="separator:af65616e6a94b988a1346bce86b911595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b44083298196790c9d898bf520828a" id="r_af9b44083298196790c9d898bf520828a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td></tr>
<tr class="memdesc:af9b44083298196790c9d898bf520828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array size type (usually <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::size</a>).  <br /></td></tr>
<tr class="separator:af9b44083298196790c9d898bf520828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1c0a188f5cfd2673e9b90c0d300e3e" id="r_a2c1c0a188f5cfd2673e9b90c0d300e3e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c1c0a188f5cfd2673e9b90c0d300e3e">difference_type</a></td></tr>
<tr class="memdesc:a2c1c0a188f5cfd2673e9b90c0d300e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array difference type (usually <a class="el" href="group__types.html#gae3c4f13b0aabf2474d7c5b2e36aad317" title="Represent the signed integer type of the result of subtracting two pointers.">xtd::ptrdiff</a>).  <br /></td></tr>
<tr class="separator:a2c1c0a188f5cfd2673e9b90c0d300e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6054c9522c7a58c05453b86e0c6f1913" id="r_a6054c9522c7a58c05453b86e0c6f1913"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a></td></tr>
<tr class="memdesc:a6054c9522c7a58c05453b86e0c6f1913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reference of array value type.  <br /></td></tr>
<tr class="separator:a6054c9522c7a58c05453b86e0c6f1913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a0d032eb60a2a8f0bdf84ba3fe1204" id="r_a01a0d032eb60a2a8f0bdf84ba3fe1204"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a></td></tr>
<tr class="memdesc:a01a0d032eb60a2a8f0bdf84ba3fe1204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reference of array value type.  <br /></td></tr>
<tr class="separator:a01a0d032eb60a2a8f0bdf84ba3fe1204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58756d2450f08851d601a29456ba4273" id="r_a58756d2450f08851d601a29456ba4273"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58756d2450f08851d601a29456ba4273">pointer</a></td></tr>
<tr class="memdesc:a58756d2450f08851d601a29456ba4273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the pointer of array value type.  <br /></td></tr>
<tr class="separator:a58756d2450f08851d601a29456ba4273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52835b4b627c5d7783f5d523aa265927" id="r_a52835b4b627c5d7783f5d523aa265927"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52835b4b627c5d7783f5d523aa265927">const_pointer</a></td></tr>
<tr class="memdesc:a52835b4b627c5d7783f5d523aa265927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const pointer of array value type.  <br /></td></tr>
<tr class="separator:a52835b4b627c5d7783f5d523aa265927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a69b60fa4687e14ec5c1180f7d7553" id="r_ac5a69b60fa4687e14ec5c1180f7d7553"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a></td></tr>
<tr class="memdesc:ac5a69b60fa4687e14ec5c1180f7d7553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of array value type.  <br /></td></tr>
<tr class="separator:ac5a69b60fa4687e14ec5c1180f7d7553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d9a52e3c55ac56d32fd81c5d7d9cee" id="r_a27d9a52e3c55ac56d32fd81c5d7d9cee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a></td></tr>
<tr class="memdesc:a27d9a52e3c55ac56d32fd81c5d7d9cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of array value type.  <br /></td></tr>
<tr class="separator:a27d9a52e3c55ac56d32fd81c5d7d9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952602a26a94abb3227e2d492e0e2d0a" id="r_a952602a26a94abb3227e2d492e0e2d0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a952602a26a94abb3227e2d492e0e2d0a">reverse_iterator</a></td></tr>
<tr class="memdesc:a952602a26a94abb3227e2d492e0e2d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reverse iterator of array value type.  <br /></td></tr>
<tr class="separator:a952602a26a94abb3227e2d492e0e2d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29160210c0d2edcac151cbcc42cd81a8" id="r_a29160210c0d2edcac151cbcc42cd81a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29160210c0d2edcac151cbcc42cd81a8">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a29160210c0d2edcac151cbcc42cd81a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reverse iterator of array value type.  <br /></td></tr>
<tr class="separator:a29160210c0d2edcac151cbcc42cd81a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:ad830194f7a76eec01d6bd96b1f3343bb" id="r_ad830194f7a76eec01d6bd96b1f3343bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad830194f7a76eec01d6bd96b1f3343bb">back</a> ()</td></tr>
<tr class="memdesc:ad830194f7a76eec01d6bd96b1f3343bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:ad830194f7a76eec01d6bd96b1f3343bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a1eac93ddf1500a9515fc560d7b572" id="r_a52a1eac93ddf1500a9515fc560d7b572"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52a1eac93ddf1500a9515fc560d7b572">back</a> () const</td></tr>
<tr class="memdesc:a52a1eac93ddf1500a9515fc560d7b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:a52a1eac93ddf1500a9515fc560d7b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb48e8ab13f64c2bbc8579286cdc33c" id="r_a7cb48e8ab13f64c2bbc8579286cdc33c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cb48e8ab13f64c2bbc8579286cdc33c">begin</a> () const noexcept override</td></tr>
<tr class="memdesc:a7cb48e8ab13f64c2bbc8579286cdc33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:a7cb48e8ab13f64c2bbc8579286cdc33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acd2ad2fa08cf8fb94d254f70c91de3" id="r_a7acd2ad2fa08cf8fb94d254f70c91de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">begin</a> () noexcept override</td></tr>
<tr class="memdesc:a7acd2ad2fa08cf8fb94d254f70c91de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:a7acd2ad2fa08cf8fb94d254f70c91de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4978aa1d73aaf5e204cac3841ea866" id="r_adb4978aa1d73aaf5e204cac3841ea866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb4978aa1d73aaf5e204cac3841ea866">cbegin</a> () const noexcept override</td></tr>
<tr class="memdesc:adb4978aa1d73aaf5e204cac3841ea866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:adb4978aa1d73aaf5e204cac3841ea866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23631ee443a12598cc846b128473312d" id="r_a23631ee443a12598cc846b128473312d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23631ee443a12598cc846b128473312d">cend</a> () const noexcept override</td></tr>
<tr class="memdesc:a23631ee443a12598cc846b128473312d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:a23631ee443a12598cc846b128473312d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e50b538f5aa4913d3180fcee49499c2" id="r_a2e50b538f5aa4913d3180fcee49499c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e50b538f5aa4913d3180fcee49499c2">count</a> () const noexcept override</td></tr>
<tr class="memdesc:a2e50b538f5aa4913d3180fcee49499c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements contained in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a2e50b538f5aa4913d3180fcee49499c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95718ca09e080a530bb22ab7fc29928" id="r_af95718ca09e080a530bb22ab7fc29928"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a29160210c0d2edcac151cbcc42cd81a8">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af95718ca09e080a530bb22ab7fc29928">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:af95718ca09e080a530bb22ab7fc29928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>.  <br /></td></tr>
<tr class="separator:af95718ca09e080a530bb22ab7fc29928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14a4aeb972e3b0ad85bc83d4596dd03" id="r_ac14a4aeb972e3b0ad85bc83d4596dd03"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a29160210c0d2edcac151cbcc42cd81a8">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac14a4aeb972e3b0ad85bc83d4596dd03">crend</a> () const noexcept</td></tr>
<tr class="memdesc:ac14a4aeb972e3b0ad85bc83d4596dd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:ac14a4aeb972e3b0ad85bc83d4596dd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5a9ce8373768ab8c68b261b33d5b6f" id="r_a5b5a9ce8373768ab8c68b261b33d5b6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a58756d2450f08851d601a29456ba4273">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">data</a> () noexcept</td></tr>
<tr class="memdesc:a5b5a9ce8373768ab8c68b261b33d5b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <br /></td></tr>
<tr class="separator:a5b5a9ce8373768ab8c68b261b33d5b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1405502cc9db3c5decf3d44c99fda34b" id="r_a1405502cc9db3c5decf3d44c99fda34b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a52835b4b627c5d7783f5d523aa265927">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1405502cc9db3c5decf3d44c99fda34b">data</a> () const noexcept</td></tr>
<tr class="memdesc:a1405502cc9db3c5decf3d44c99fda34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <br /></td></tr>
<tr class="separator:a1405502cc9db3c5decf3d44c99fda34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c2af41aeaa2af9847c1d6567df83c6" id="r_a69c2af41aeaa2af9847c1d6567df83c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69c2af41aeaa2af9847c1d6567df83c6">end</a> () const noexcept override</td></tr>
<tr class="memdesc:a69c2af41aeaa2af9847c1d6567df83c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:a69c2af41aeaa2af9847c1d6567df83c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb880053eba2eefbc54d5d312626586" id="r_aabb880053eba2eefbc54d5d312626586"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabb880053eba2eefbc54d5d312626586">end</a> () noexcept override</td></tr>
<tr class="memdesc:aabb880053eba2eefbc54d5d312626586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:aabb880053eba2eefbc54d5d312626586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8f87d8d029713510c61ba59d1858a0" id="r_a2d8f87d8d029713510c61ba59d1858a0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d8f87d8d029713510c61ba59d1858a0">front</a> ()</td></tr>
<tr class="memdesc:a2d8f87d8d029713510c61ba59d1858a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:a2d8f87d8d029713510c61ba59d1858a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac754e2b8fe8c218619603f807d2dede6" id="r_ac754e2b8fe8c218619603f807d2dede6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac754e2b8fe8c218619603f807d2dede6">front</a> () const</td></tr>
<tr class="memdesc:ac754e2b8fe8c218619603f807d2dede6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:ac754e2b8fe8c218619603f807d2dede6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb6f585d484eac04eb282dd0a5fe9fd" id="r_acdb6f585d484eac04eb282dd0a5fe9fd"><td class="memItemLeft" align="right" valign="top"><a id="acdb6f585d484eac04eb282dd0a5fe9fd" name="acdb6f585d484eac04eb282dd0a5fe9fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_fixed_size</b> () const noexcept override</td></tr>
<tr class="separator:acdb6f585d484eac04eb282dd0a5fe9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95524d29f8f4a218254d137c5046cb1" id="r_ad95524d29f8f4a218254d137c5046cb1"><td class="memItemLeft" align="right" valign="top"><a id="ad95524d29f8f4a218254d137c5046cb1" name="ad95524d29f8f4a218254d137c5046cb1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_read_only</b> () const noexcept override</td></tr>
<tr class="separator:ad95524d29f8f4a218254d137c5046cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbb0b954165a263596fe7fd433d6125" id="r_a5cbb0b954165a263596fe7fd433d6125"><td class="memItemLeft" align="right" valign="top"><a id="a5cbb0b954165a263596fe7fd433d6125" name="a5cbb0b954165a263596fe7fd433d6125"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_synchronized</b> () const noexcept override</td></tr>
<tr class="separator:a5cbb0b954165a263596fe7fd433d6125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d7c124db651f72d7f2b4971c5862f5" id="r_ab5d7c124db651f72d7f2b4971c5862f5"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="#af65616e6a94b988a1346bce86b911595">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5d7c124db651f72d7f2b4971c5862f5">items</a> () const noexcept</td></tr>
<tr class="memdesc:ab5d7c124db651f72d7f2b4971c5862f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:ab5d7c124db651f72d7f2b4971c5862f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb7eadaa77baa15c8193de6af45eaec" id="r_adfb7eadaa77baa15c8193de6af45eaec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#af65616e6a94b988a1346bce86b911595">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb7eadaa77baa15c8193de6af45eaec">items</a> () noexcept</td></tr>
<tr class="memdesc:adfb7eadaa77baa15c8193de6af45eaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:adfb7eadaa77baa15c8193de6af45eaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf70989e6cabeaccefd32e3b760753ef" id="r_aaf70989e6cabeaccefd32e3b760753ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf70989e6cabeaccefd32e3b760753ef">length</a> () const noexcept</td></tr>
<tr class="memdesc:aaf70989e6cabeaccefd32e3b760753ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a size that represents the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:aaf70989e6cabeaccefd32e3b760753ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48551f7aa950699c881a79fdd70f4f39" id="r_a48551f7aa950699c881a79fdd70f4f39"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48551f7aa950699c881a79fdd70f4f39">long_length</a> ()</td></tr>
<tr class="memdesc:a48551f7aa950699c881a79fdd70f4f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:a48551f7aa950699c881a79fdd70f4f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760f9d630aee4ee6076c5f1fb0ba412f" id="r_a760f9d630aee4ee6076c5f1fb0ba412f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760f9d630aee4ee6076c5f1fb0ba412f">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a760f9d630aee4ee6076c5f1fb0ba412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">xtd::array::begin()</a>, <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a>) for the largest container.  <br /></td></tr>
<tr class="separator:a760f9d630aee4ee6076c5f1fb0ba412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0e476086ae44f64d6ed64a8cfbfc73" id="r_a0f0e476086ae44f64d6ed64a8cfbfc73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73">rank</a> () const noexcept</td></tr>
<tr class="memdesc:a0f0e476086ae44f64d6ed64a8cfbfc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rank (number of dimensions) of the array.  <br /></td></tr>
<tr class="separator:a0f0e476086ae44f64d6ed64a8cfbfc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f34355f80375edca7538ed77d2bc431" id="r_a9f34355f80375edca7538ed77d2bc431"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a952602a26a94abb3227e2d492e0e2d0a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f34355f80375edca7538ed77d2bc431">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a9f34355f80375edca7538ed77d2bc431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>.  <br /></td></tr>
<tr class="separator:a9f34355f80375edca7538ed77d2bc431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6f68bf56a69ac0b57970e6ba9441a2" id="r_a0d6f68bf56a69ac0b57970e6ba9441a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a29160210c0d2edcac151cbcc42cd81a8">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d6f68bf56a69ac0b57970e6ba9441a2">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a0d6f68bf56a69ac0b57970e6ba9441a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>.  <br /></td></tr>
<tr class="separator:a0d6f68bf56a69ac0b57970e6ba9441a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c8b33119f80c64566c9c4fe307be46" id="r_ab5c8b33119f80c64566c9c4fe307be46"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a952602a26a94abb3227e2d492e0e2d0a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">rend</a> () noexcept</td></tr>
<tr class="memdesc:ab5c8b33119f80c64566c9c4fe307be46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:ab5c8b33119f80c64566c9c4fe307be46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3432941b86f8c8e7c78bcf7132843e6d" id="r_a3432941b86f8c8e7c78bcf7132843e6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a29160210c0d2edcac151cbcc42cd81a8">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3432941b86f8c8e7c78bcf7132843e6d">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a3432941b86f8c8e7c78bcf7132843e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a3432941b86f8c8e7c78bcf7132843e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5a20a84786e5ae303364a521972609" id="r_aee5a20a84786e5ae303364a521972609"><td class="memItemLeft" align="right" valign="top"><a id="aee5a20a84786e5ae303364a521972609" name="aee5a20a84786e5ae303364a521972609"></a>
const <a class="el" href="classxtd_1_1object.html">xtd::object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sync_root</b> () const noexcept override</td></tr>
<tr class="separator:aee5a20a84786e5ae303364a521972609"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a34472044617550faf939f05c223b6227" id="r_a34472044617550faf939f05c223b6227"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34472044617550faf939f05c223b6227">at</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index)</td></tr>
<tr class="memdesc:a34472044617550faf939f05c223b6227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <br /></td></tr>
<tr class="separator:a34472044617550faf939f05c223b6227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadefb8b17214889a16b31088e0131431" id="r_aadefb8b17214889a16b31088e0131431"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadefb8b17214889a16b31088e0131431">at</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index) const</td></tr>
<tr class="memdesc:aadefb8b17214889a16b31088e0131431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <br /></td></tr>
<tr class="separator:aadefb8b17214889a16b31088e0131431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564a11cba948c390dcce1e3d4002fde5" id="r_a564a11cba948c390dcce1e3d4002fde5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a564a11cba948c390dcce1e3d4002fde5">contains</a> (const type_t &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a564a11cba948c390dcce1e3d4002fde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an element is in the array.  <br /></td></tr>
<tr class="separator:a564a11cba948c390dcce1e3d4002fde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6766e45b973a8659323055151b0cff9e" id="r_a6766e45b973a8659323055151b0cff9e"><td class="memItemLeft" align="right" valign="top"><a id="a6766e45b973a8659323055151b0cff9e" name="a6766e45b973a8659323055151b0cff9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_to</b> (<a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; type_t &gt; &amp;<a class="el" href="classxtd_1_1array.html">array</a>, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index) const override</td></tr>
<tr class="separator:a6766e45b973a8659323055151b0cff9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ff0322a96e0ed8a3c268fd8a3d4eca" id="r_a88ff0322a96e0ed8a3c268fd8a3d4eca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88ff0322a96e0ed8a3c268fd8a3d4eca">copy_to</a> (<a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; type_t &gt; &amp;<a class="el" href="classxtd_1_1array.html">array</a>, <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a> index) const</td></tr>
<tr class="memdesc:a88ff0322a96e0ed8a3c268fd8a3d4eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 64-bit integer.  <br /></td></tr>
<tr class="separator:a88ff0322a96e0ed8a3c268fd8a3d4eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391534692d321eadc7a5810486c16650" id="r_a391534692d321eadc7a5810486c16650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a391534692d321eadc7a5810486c16650">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept override</td></tr>
<tr class="memdesc:a391534692d321eadc7a5810486c16650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a391534692d321eadc7a5810486c16650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b108d6bbebf0dde60afcbe2c7a1e0f" id="r_a93b108d6bbebf0dde60afcbe2c7a1e0f"><td class="memItemLeft" align="right" valign="top"><a id="a93b108d6bbebf0dde60afcbe2c7a1e0f" name="a93b108d6bbebf0dde60afcbe2c7a1e0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;rhs) const noexcept override</td></tr>
<tr class="separator:a93b108d6bbebf0dde60afcbe2c7a1e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ef003c8174b830377e38610e743e4f" id="r_a92ef003c8174b830377e38610e743e4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92ef003c8174b830377e38610e743e4f">fill</a> (const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a92ef003c8174b830377e38610e743e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value to all elements in the container.  <br /></td></tr>
<tr class="separator:a92ef003c8174b830377e38610e743e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6753ddfe99de81064d777312541cea34" id="r_a6753ddfe99de81064d777312541cea34"><td class="memItemLeft" align="right" valign="top"><a id="a6753ddfe99de81064d777312541cea34" name="a6753ddfe99de81064d777312541cea34"></a>
<a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">xtd::collections::generic::enumerator</a>&lt; <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_enumerator</b> () const noexcept override</td></tr>
<tr class="separator:a6753ddfe99de81064d777312541cea34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4132e3affe66da23dc58780f520124e2" id="r_a4132e3affe66da23dc58780f520124e2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4132e3affe66da23dc58780f520124e2">get_length</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:a4132e3affe66da23dc58780f520124e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:a4132e3affe66da23dc58780f520124e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe84abedf478ba9a5059c08b7ff020" id="r_a06fe84abedf478ba9a5059c08b7ff020"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06fe84abedf478ba9a5059c08b7ff020">get_long_length</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:a06fe84abedf478ba9a5059c08b7ff020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:a06fe84abedf478ba9a5059c08b7ff020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac6c2f6144b73e261745e2bec9f6771" id="r_a6ac6c2f6144b73e261745e2bec9f6771"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ac6c2f6144b73e261745e2bec9f6771">get_lower_bound</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:a6ac6c2f6144b73e261745e2bec9f6771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower bound of the specified dimension in the array.  <br /></td></tr>
<tr class="separator:a6ac6c2f6144b73e261745e2bec9f6771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74ed5a54361b742c7e27ff7b180a986" id="r_ab74ed5a54361b742c7e27ff7b180a986"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab74ed5a54361b742c7e27ff7b180a986">get_upper_bound</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:ab74ed5a54361b742c7e27ff7b180a986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the upper bound of the specified dimension in the array.  <br /></td></tr>
<tr class="separator:ab74ed5a54361b742c7e27ff7b180a986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21516522b32f0b1a6f92ab99d7cf271c" id="r_a21516522b32f0b1a6f92ab99d7cf271c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21516522b32f0b1a6f92ab99d7cf271c">get_value</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes) const</td></tr>
<tr class="memdesc:a21516522b32f0b1a6f92ab99d7cf271c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the multidimensional array. The indexes are specified as 32-bit integers array.  <br /></td></tr>
<tr class="separator:a21516522b32f0b1a6f92ab99d7cf271c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff23cf9bbd59f42928e36dcc042425" id="r_a63ff23cf9bbd59f42928e36dcc042425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63ff23cf9bbd59f42928e36dcc042425">index_of</a> (const type_t &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a63ff23cf9bbd59f42928e36dcc042425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a63ff23cf9bbd59f42928e36dcc042425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795fd3bff66d49a57311b81cf697953f" id="r_a795fd3bff66d49a57311b81cf697953f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a795fd3bff66d49a57311b81cf697953f">resize</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> new_size, <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> value)</td></tr>
<tr class="memdesc:a795fd3bff66d49a57311b81cf697953f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="#aaf70989e6cabeaccefd32e3b760753ef" title="Gets a size that represents the total number of elements in all the dimensions of the array.">length()</a>. / @param new_size The new size of the container. / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#af4ad72063824fdf6ac996a5b6cb041ec" title="Gets the total number of elements the internal data structure can hold without resizing.">xtd::collections::generic::list::capacity</a> is set to a value that is less than <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a9fc65d3d8c22e9fafb4b35265be9c438" title="Gets the number of elements contained in the xtd::collections::generic::list &lt;type_t&gt;.">xtd::collections::generic::list::count</a>. / @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. / @remarks If the current size is less than</code>count`, additional default-inserted elements are appended. void resize(size_type new_size) {resize(new_size, <a class="el" href="#a8a186922544d50c32678dbeead9d34fe" title="Represents the array value type.">value_type</a> {});}.  <br /></td></tr>
<tr class="separator:a795fd3bff66d49a57311b81cf697953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b80cc0f2926f2b4fcfb5f5c1346eb7" id="r_a16b80cc0f2926f2b4fcfb5f5c1346eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16b80cc0f2926f2b4fcfb5f5c1346eb7">set_value</a> (const type_t &amp;value, const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes)</td></tr>
<tr class="memdesc:a16b80cc0f2926f2b4fcfb5f5c1346eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the element at the specified position in the multidimensional array.  <br /></td></tr>
<tr class="separator:a16b80cc0f2926f2b4fcfb5f5c1346eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29d8f865aaa14d1f3ce4ae201fdf1b5" id="r_ac29d8f865aaa14d1f3ce4ae201fdf1b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac29d8f865aaa14d1f3ce4ae201fdf1b5">swap</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:ac29d8f865aaa14d1f3ce4ae201fdf1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents and capacity of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.  <br /></td></tr>
<tr class="separator:ac29d8f865aaa14d1f3ce4ae201fdf1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ec27387ef0582948fc499fde1eba65" id="r_ac4ec27387ef0582948fc499fde1eba65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4ec27387ef0582948fc499fde1eba65">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:ac4ec27387ef0582948fc499fde1eba65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:ac4ec27387ef0582948fc499fde1eba65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:ab88cfef04f0ae0cb609068f0a2ff0a25" id="r_ab88cfef04f0ae0cb609068f0a2ff0a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab88cfef04f0ae0cb609068f0a2ff0a25">sort</a> ()</td></tr>
<tr class="memdesc:ab88cfef04f0ae0cb609068f0a2ff0a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the entire <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; using the default comparer.  <br /></td></tr>
<tr class="separator:ab88cfef04f0ae0cb609068f0a2ff0a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfc756583b9aac6e8851cc26a36ccf8" id="r_a2bfc756583b9aac6e8851cc26a36ccf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bfc756583b9aac6e8851cc26a36ccf8">sort</a> (comparison_comparer <a class="el" href="group__delegates.html#ga6aa9a3d2680df2fc027c12383aa9e7cc">comparison</a>)</td></tr>
<tr class="memdesc:a2bfc756583b9aac6e8851cc26a36ccf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the entire <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; using the specified <a class="el" href="group__delegates.html#ga6aa9a3d2680df2fc027c12383aa9e7cc" title="Represents the method that compares two objects of the same type.">xtd::comparison</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a2bfc756583b9aac6e8851cc26a36ccf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1920205ef433c6639a21ed08b81bf7" id="r_a3c1920205ef433c6639a21ed08b81bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c1920205ef433c6639a21ed08b81bf7">sort</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1icomparer.html">xtd::collections::generic::icomparer</a>&lt; type_t &gt; &amp;comparer)</td></tr>
<tr class="memdesc:a3c1920205ef433c6639a21ed08b81bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the entire <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; using the specified comparer.  <br /></td></tr>
<tr class="separator:a3c1920205ef433c6639a21ed08b81bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd2289581f85c14ab799af32e51f9e3" id="r_abdd2289581f85c14ab799af32e51f9e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdd2289581f85c14ab799af32e51f9e3">sort</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="#a2e50b538f5aa4913d3180fcee49499c2">count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1icomparer.html">xtd::collections::generic::icomparer</a>&lt; type_t &gt; &amp;comparer)</td></tr>
<tr class="memdesc:abdd2289581f85c14ab799af32e51f9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in a range of elements in <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; using the specified comparer.  <br /></td></tr>
<tr class="separator:abdd2289581f85c14ab799af32e51f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e8d16cbfd4478600885c5ebbc0cb90" id="r_a56e8d16cbfd4478600885c5ebbc0cb90"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56e8d16cbfd4478600885c5ebbc0cb90">index_of</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>, const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a56e8d16cbfd4478600885c5ebbc0cb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the array specified.  <br /></td></tr>
<tr class="separator:a56e8d16cbfd4478600885c5ebbc0cb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d15bd70091aef74009040a66e96c7" id="r_ad62d15bd70091aef74009040a66e96c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad62d15bd70091aef74009040a66e96c7">index_of</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>, const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index)</td></tr>
<tr class="memdesc:ad62d15bd70091aef74009040a66e96c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the array specified.  <br /></td></tr>
<tr class="separator:ad62d15bd70091aef74009040a66e96c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ce2959fbb235a756ad16dd2a3f343e" id="r_ad5ce2959fbb235a756ad16dd2a3f343e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5ce2959fbb235a756ad16dd2a3f343e">index_of</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>, const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="#a2e50b538f5aa4913d3180fcee49499c2">count</a>)</td></tr>
<tr class="memdesc:ad5ce2959fbb235a756ad16dd2a3f343e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the array specified.  <br /></td></tr>
<tr class="separator:ad5ce2959fbb235a756ad16dd2a3f343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc2546d5b6d814fdebcd0318d76e91" id="r_ad1bc2546d5b6d814fdebcd0318d76e91"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1bc2546d5b6d814fdebcd0318d76e91">reverse</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>) noexcept</td></tr>
<tr class="memdesc:ad1bc2546d5b6d814fdebcd0318d76e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the entire <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a>.  <br /></td></tr>
<tr class="separator:ad1bc2546d5b6d814fdebcd0318d76e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5089c1fc7d9e8010517893f5cf4a946" id="r_af5089c1fc7d9e8010517893f5cf4a946"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5089c1fc7d9e8010517893f5cf4a946">reverse</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="#a2e50b538f5aa4913d3180fcee49499c2">count</a>)</td></tr>
<tr class="memdesc:af5089c1fc7d9e8010517893f5cf4a946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the specified range.  <br /></td></tr>
<tr class="separator:af5089c1fc7d9e8010517893f5cf4a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:a9ca38a735b49019beb5e5f14ab8d4ac1" id="r_a9ca38a735b49019beb5e5f14ab8d4ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ca38a735b49019beb5e5f14ab8d4ac1">operator=</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a9ca38a735b49019beb5e5f14ab8d4ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of other.  <br /></td></tr>
<tr class="separator:a9ca38a735b49019beb5e5f14ab8d4ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ca7652bd75af5a950e375cad3ce53c" id="r_ab2ca7652bd75af5a950e375cad3ce53c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ca7652bd75af5a950e375cad3ce53c">operator=</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:ab2ca7652bd75af5a950e375cad3ce53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:ab2ca7652bd75af5a950e375cad3ce53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8aa56257fec1b361de7c00c2222b5" id="r_ad4c8aa56257fec1b361de7c00c2222b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4c8aa56257fec1b361de7c00c2222b5">operator=</a> (std::initializer_list&lt; type_t &gt; &amp;<a class="el" href="#ab5d7c124db651f72d7f2b4971c5862f5">items</a>)</td></tr>
<tr class="memdesc:ad4c8aa56257fec1b361de7c00c2222b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist.  <br /></td></tr>
<tr class="separator:ad4c8aa56257fec1b361de7c00c2222b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c62871eef03c2d45676040e137e604" id="r_ac5c62871eef03c2d45676040e137e604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5c62871eef03c2d45676040e137e604">operator[]</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index) const override</td></tr>
<tr class="memdesc:ac5c62871eef03c2d45676040e137e604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index.  <br /></td></tr>
<tr class="separator:ac5c62871eef03c2d45676040e137e604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc74a419dc77ebae92d7a7aaa80c2249" id="r_afc74a419dc77ebae92d7a7aaa80c2249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc74a419dc77ebae92d7a7aaa80c2249">operator[]</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index) override</td></tr>
<tr class="memdesc:afc74a419dc77ebae92d7a7aaa80c2249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index.  <br /></td></tr>
<tr class="separator:afc74a419dc77ebae92d7a7aaa80c2249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c15ccc5efbe20ca6656e87436036c3" id="r_a49c15ccc5efbe20ca6656e87436036c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49c15ccc5efbe20ca6656e87436036c3">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:a49c15ccc5efbe20ca6656e87436036c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a49c15ccc5efbe20ca6656e87436036c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eac9b62b7209d7ef1bda73d4b77c8a7" id="r_a3eac9b62b7209d7ef1bda73d4b77c8a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3eac9b62b7209d7ef1bda73d4b77c8a7">operator base_type &amp;</a> () noexcept</td></tr>
<tr class="memdesc:a3eac9b62b7209d7ef1bda73d4b77c8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a3eac9b62b7209d7ef1bda73d4b77c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7c8053e686383179fc57895fc0d3d9" id="r_aee7c8053e686383179fc57895fc0d3d9"><td class="memItemLeft" align="right" valign="top">type_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee7c8053e686383179fc57895fc0d3d9">operator()</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes)</td></tr>
<tr class="memdesc:aee7c8053e686383179fc57895fc0d3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array.  <br /></td></tr>
<tr class="separator:aee7c8053e686383179fc57895fc0d3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39c6f97b33ca7b85614188ce9443f72" id="r_ab39c6f97b33ca7b85614188ce9443f72"><td class="memItemLeft" align="right" valign="top">const type_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab39c6f97b33ca7b85614188ce9443f72">operator()</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes) const</td></tr>
<tr class="memdesc:ab39c6f97b33ca7b85614188ce9443f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array.  <br /></td></tr>
<tr class="separator:ab39c6f97b33ca7b85614188ce9443f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd11aa88ce86568b701b33fd1b3e508" id="r_a6bd11aa88ce86568b701b33fd1b3e508"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a6bd11aa88ce86568b701b33fd1b3e508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a6bd11aa88ce86568b701b33fd1b3e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8bbde943d2e5ecf565734c60e23903" id="r_a1f8bbde943d2e5ecf565734c60e23903"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a> (const type_t &amp;) const noexcept=0</td></tr>
<tr class="memdesc:a1f8bbde943d2e5ecf565734c60e23903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current object is equal to another object of the same type.  <br /></td></tr>
<tr class="separator:a1f8bbde943d2e5ecf565734c60e23903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a701628e47b725c0bc15400085d714" id="r_ad7a701628e47b725c0bc15400085d714"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1abstract__object.html#ad7a701628e47b725c0bc15400085d714">abstract_object</a> ()=default</td></tr>
<tr class="memdesc:ad7a701628e47b725c0bc15400085d714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1abstract__object.html" title="Represent an abstract class.">xtd::abstract_object</a> class.  <br /></td></tr>
<tr class="separator:ad7a701628e47b725c0bc15400085d714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8a186922544d50c32678dbeead9d34fe" name="a8a186922544d50c32678dbeead9d34fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a186922544d50c32678dbeead9d34fe">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array value type. </p>

</div>
</div>
<a id="a08e6f5ee12cd3d0e7e27c43bb4956d3b" name="a08e6f5ee12cd3d0e7e27c43bb4956d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e6f5ee12cd3d0e7e27c43bb4956d3b">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array allocator type. </p>

</div>
</div>
<a id="af65616e6a94b988a1346bce86b911595" name="af65616e6a94b988a1346bce86b911595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65616e6a94b988a1346bce86b911595">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::base_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array base type. </p>

</div>
</div>
<a id="af9b44083298196790c9d898bf520828a" name="af9b44083298196790c9d898bf520828a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b44083298196790c9d898bf520828a">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array size type (usually <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::size</a>). </p>

</div>
</div>
<a id="a2c1c0a188f5cfd2673e9b90c0d300e3e" name="a2c1c0a188f5cfd2673e9b90c0d300e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1c0a188f5cfd2673e9b90c0d300e3e">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array difference type (usually <a class="el" href="group__types.html#gae3c4f13b0aabf2474d7c5b2e36aad317" title="Represent the signed integer type of the result of subtracting two pointers.">xtd::ptrdiff</a>). </p>

</div>
</div>
<a id="a6054c9522c7a58c05453b86e0c6f1913" name="a6054c9522c7a58c05453b86e0c6f1913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6054c9522c7a58c05453b86e0c6f1913">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the reference of array value type. </p>

</div>
</div>
<a id="a01a0d032eb60a2a8f0bdf84ba3fe1204" name="a01a0d032eb60a2a8f0bdf84ba3fe1204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const reference of array value type. </p>

</div>
</div>
<a id="a58756d2450f08851d601a29456ba4273" name="a58756d2450f08851d601a29456ba4273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58756d2450f08851d601a29456ba4273">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the pointer of array value type. </p>

</div>
</div>
<a id="a52835b4b627c5d7783f5d523aa265927" name="a52835b4b627c5d7783f5d523aa265927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52835b4b627c5d7783f5d523aa265927">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const pointer of array value type. </p>

</div>
</div>
<a id="ac5a69b60fa4687e14ec5c1180f7d7553" name="ac5a69b60fa4687e14ec5c1180f7d7553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a69b60fa4687e14ec5c1180f7d7553">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the iterator of array value type. </p>

</div>
</div>
<a id="a27d9a52e3c55ac56d32fd81c5d7d9cee" name="a27d9a52e3c55ac56d32fd81c5d7d9cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const iterator of array value type. </p>

</div>
</div>
<a id="a952602a26a94abb3227e2d492e0e2d0a" name="a952602a26a94abb3227e2d492e0e2d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952602a26a94abb3227e2d492e0e2d0a">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the reverse iterator of array value type. </p>

</div>
</div>
<a id="a29160210c0d2edcac151cbcc42cd81a8" name="a29160210c0d2edcac151cbcc42cd81a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29160210c0d2edcac151cbcc42cd81a8">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const reverse iterator of array value type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad830194f7a76eec01d6bd96b1f3343bb" name="ad830194f7a76eec01d6bd96b1f3343bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad830194f7a76eec01d6bd96b1f3343bb">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="a52a1eac93ddf1500a9515fc560d7b572" name="a52a1eac93ddf1500a9515fc560d7b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a1eac93ddf1500a9515fc560d7b572">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="a7cb48e8ab13f64c2bbc8579286cdc33c" name="a7cb48e8ab13f64c2bbc8579286cdc33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb48e8ab13f64c2bbc8579286cdc33c">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a7acd2ad2fa08cf8fb94d254f70c91de3" name="a7acd2ad2fa08cf8fb94d254f70c91de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acd2ad2fa08cf8fb94d254f70c91de3">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="adb4978aa1d73aaf5e204cac3841ea866" name="adb4978aa1d73aaf5e204cac3841ea866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4978aa1d73aaf5e204cac3841ea866">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a23631ee443a12598cc846b128473312d" name="a23631ee443a12598cc846b128473312d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23631ee443a12598cc846b128473312d">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a2e50b538f5aa4913d3180fcee49499c2" name="a2e50b538f5aa4913d3180fcee49499c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e50b538f5aa4913d3180fcee49499c2">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of elements contained in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements contained in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Retrieving the value of this property is an O(1) operation; setting the property is an O(n) operation, where n is the new capacity. </dd></dl>

</div>
</div>
<a id="af95718ca09e080a530bb22ab7fc29928" name="af95718ca09e080a530bb22ab7fc29928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95718ca09e080a530bb22ab7fc29928">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a29160210c0d2edcac151cbcc42cd81a8">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </dd></dl>

</div>
</div>
<a id="ac14a4aeb972e3b0ad85bc83d4596dd03" name="ac14a4aeb972e3b0ad85bc83d4596dd03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14a4aeb972e3b0ad85bc83d4596dd03">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a29160210c0d2edcac151cbcc42cd81a8">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a5b5a9ce8373768ab8c68b261b33d5b6f" name="a5b5a9ce8373768ab8c68b261b33d5b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5a9ce8373768ab8c68b261b33d5b6f">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a58756d2450f08851d601a29456ba4273">pointer</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, the returned pointer compares equal to the address of the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer is such that range [<a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a>, <a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a> + xtd::array::size()) is always a valid range, even if the container is empty (<a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a> is not dereferenceable in that case). </dd></dl>

</div>
</div>
<a id="a1405502cc9db3c5decf3d44c99fda34b" name="a1405502cc9db3c5decf3d44c99fda34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1405502cc9db3c5decf3d44c99fda34b">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a52835b4b627c5d7783f5d523aa265927">const_pointer</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, the returned pointer compares equal to the address of the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer is such that range [<a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a>, <a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a> + xtd::array::size()) is always a valid range, even if the container is empty (<a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a> is not dereferenceable in that case). </dd></dl>

</div>
</div>
<a id="a69c2af41aeaa2af9847c1d6567df83c6" name="a69c2af41aeaa2af9847c1d6567df83c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c2af41aeaa2af9847c1d6567df83c6">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="aabb880053eba2eefbc54d5d312626586" name="aabb880053eba2eefbc54d5d312626586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb880053eba2eefbc54d5d312626586">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a2d8f87d8d029713510c61ba59d1858a0" name="a2d8f87d8d029713510c61ba59d1858a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8f87d8d029713510c61ba59d1858a0">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="ac754e2b8fe8c218619603f807d2dede6" name="ac754e2b8fe8c218619603f807d2dede6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac754e2b8fe8c218619603f807d2dede6">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="ab5d7c124db651f72d7f2b4971c5862f5" name="ab5d7c124db651f72d7f2b4971c5862f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d7c124db651f72d7f2b4971c5862f5">&#9670;&#160;</a></span>items() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="#af65616e6a94b988a1346bce86b911595">base_type</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="adfb7eadaa77baa15c8193de6af45eaec" name="adfb7eadaa77baa15c8193de6af45eaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb7eadaa77baa15c8193de6af45eaec">&#9670;&#160;</a></span>items() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#af65616e6a94b988a1346bce86b911595">base_type</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="aaf70989e6cabeaccefd32e3b760753ef" name="aaf70989e6cabeaccefd32e3b760753ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf70989e6cabeaccefd32e3b760753ef">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a size that represents the total number of elements in all the dimensions of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>A size that represents the total number of elements in all the dimensions of the array; zero if there are no elements in the array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Retrieving the value of this property is an O(1) operation. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates methods to get the length of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a48551f7aa950699c881a79fdd70f4f39" name="a48551f7aa950699c881a79fdd70f4f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48551f7aa950699c881a79fdd70f4f39">&#9670;&#160;</a></span>long_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::long_length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9" title="Represents a 64-bit signed integer.">int64</a> A 64-bit integer that represents the total number of elements in all the dimensions of the array; zero if there are no elements in the array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Retrieving the value of this property is an O(1) operation. </dd></dl>

</div>
</div>
<a id="a760f9d630aee4ee6076c5f1fb0ba412f" name="a760f9d630aee4ee6076c5f1fb0ba412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760f9d630aee4ee6076c5f1fb0ba412f">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">xtd::array::begin()</a>, <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a>) for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

</div>
</div>
<a id="a0f0e476086ae44f64d6ed64a8cfbfc73" name="a0f0e476086ae44f64d6ed64a8cfbfc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0e476086ae44f64d6ed64a8cfbfc73">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rank </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the rank (number of dimensions) of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>The rank (number of dimensions) of the array. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates methods to get the rank of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

<p>Reimplemented in <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; type_t, rank_, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; byte &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; item &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; item &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; item_t &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; type_t, 1, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array_3_01type__t_00_011_00_01allocator__t_01_4.html#ad5324486e5498e9173e929f53dfe95f8">xtd::array&lt; type_t, 1, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; type_t, 2, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array_3_01type__t_00_012_00_01allocator__t_01_4.html#a5cfd24ddc397b46a08ea0cc1044bf390">xtd::array&lt; type_t, 2, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; type_t, 3, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array_3_01type__t_00_013_00_01allocator__t_01_4.html#a5dacc6a3783b27ebe998d4008e46b177">xtd::array&lt; type_t, 3, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; value_type &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::array&lt; bool &gt; &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::array&lt; bool &gt; &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::array&lt; xtd::byte &gt; &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::basic_string&lt; char &gt; &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::byte &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::diagnostics::stack_frame &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::diagnostics::stack_frame &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::color &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::color &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::imaging::encoder_parameter &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::point &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::point &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::forms::shadow &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::forms::shadow &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::net::ip_address &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::size &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::size &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::string &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::string &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::uint16 &gt;</a>, and <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt;&gt;</a>.</p>

</div>
</div>
<a id="a9f34355f80375edca7538ed77d2bc431" name="a9f34355f80375edca7538ed77d2bc431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f34355f80375edca7538ed77d2bc431">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a952602a26a94abb3227e2d492e0e2d0a">reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </dd></dl>

</div>
</div>
<a id="a0d6f68bf56a69ac0b57970e6ba9441a2" name="a0d6f68bf56a69ac0b57970e6ba9441a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6f68bf56a69ac0b57970e6ba9441a2">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a29160210c0d2edcac151cbcc42cd81a8">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </dd></dl>

</div>
</div>
<a id="ab5c8b33119f80c64566c9c4fe307be46" name="ab5c8b33119f80c64566c9c4fe307be46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c8b33119f80c64566c9c4fe307be46">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a952602a26a94abb3227e2d492e0e2d0a">reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a3432941b86f8c8e7c78bcf7132843e6d" name="a3432941b86f8c8e7c78bcf7132843e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3432941b86f8c8e7c78bcf7132843e6d">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a29160210c0d2edcac151cbcc42cd81a8">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a34472044617550faf939f05c223b6227" name="a34472044617550faf939f05c223b6227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34472044617550faf939f05c223b6227">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadefb8b17214889a16b31088e0131431" name="aadefb8b17214889a16b31088e0131431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadefb8b17214889a16b31088e0131431">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a564a11cba948c390dcce1e3d4002fde5" name="a564a11cba948c390dcce1e3d4002fde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564a11cba948c390dcce1e3d4002fde5">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const type_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether an element is in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to be added to the end of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ff0322a96e0ed8a3c268fd8a3d4eca" name="a88ff0322a96e0ed8a3c268fd8a3d4eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ff0322a96e0ed8a3c268fd8a3d4eca">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; type_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 64-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The one-dimensional array that is the destination of the elements copied from the current array. </td></tr>
    <tr><td class="paramname">index</td><td>A 64-bit integer that represents the index in array at which copying begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`array` is multidimensional. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is outside the range of valid indexes for array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391534692d321eadc7a5810486c16650" name="a391534692d321eadc7a5810486c16650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391534692d321eadc7a5810486c16650">&#9670;&#160;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified object is equal to the current object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to compare with the current object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified object is equal to the current object. otherwise, <code>false</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example compares the current instance with another object. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> object1 = <a class="code hl_function" href="group__xtd__core.html#ga2fd68f03198b2bf84b1e93149494b685">new_ptr&lt;object&gt;</a>();</div>
<div class="line">  <span class="keyword">auto</span> object2 = <a class="code hl_function" href="group__xtd__core.html#ga2fd68f03198b2bf84b1e93149494b685">new_ptr&lt;object&gt;</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> object3 = object2;</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(object1-&gt;equals(*object3));</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(*object1 == *object3);</div>
<div class="line">  object3 = object1;</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(object1-&gt;equals(*object3));</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(*object1 == *object3);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="agroup__xtd__core_html_ga2fd68f03198b2bf84b1e93149494b685"><div class="ttname"><a href="group__xtd__core.html#ga2fd68f03198b2bf84b1e93149494b685">xtd::new_ptr</a></div><div class="ttdeci">ptr&lt; type_t &gt; new_ptr(args_t &amp;&amp;... args)</div><div class="ttdoc">The xtd::new_ptr operator creates a xtd::ptr object.</div><div class="ttdef"><b>Definition</b> new_ptr.hpp:24</div></div>
</div><!-- fragment --> </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">xtd::object</a>.</p>

</div>
</div>
<a id="a92ef003c8174b830377e38610e743e4f" name="a92ef003c8174b830377e38610e743e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ef003c8174b830377e38610e743e4f">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the value to all elements in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to assign to the elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4132e3affe66da23dc58780f520124e2" name="a4132e3affe66da23dc58780f520124e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4132e3affe66da23dc58780f520124e2">&#9670;&#160;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total number of elements in all the dimensions of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>A zero-based dimension of the array whose length needs to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of elements in all the dimensions of the array; zero if there are no elements in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`dimension` is equal to or greater than <a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73" title="Gets the rank (number of dimensions) of the array.">xtd::basic_array::rank</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates methods to get the length of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a06fe84abedf478ba9a5059c08b7ff020" name="a06fe84abedf478ba9a5059c08b7ff020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fe84abedf478ba9a5059c08b7ff020">&#9670;&#160;</a></span>get_long_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_long_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>A zero-based dimension of the array whose length needs to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit integer that represents the total number of elements in all the dimensions of the array; zero if there are no elements in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`dimension` is equal to or greater than <a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73" title="Gets the rank (number of dimensions) of the array.">xtd::basic_array::rank</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates methods to get the length of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6ac6c2f6144b73e261745e2bec9f6771" name="a6ac6c2f6144b73e261745e2bec9f6771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac6c2f6144b73e261745e2bec9f6771">&#9670;&#160;</a></span>get_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the lower bound of the specified dimension in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>A zero-based dimension of the array whose lower bound needs to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lower bound of the specified dimension in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`dimension` is equal to or greater than <a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73" title="Gets the rank (number of dimensions) of the array.">xtd::basic_array::rank</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example uses <a class="el" href="#a6ac6c2f6144b73e261745e2bec9f6771">xtd::array::get_lower_bound</a> and <a class="el" href="#ab74ed5a54361b742c7e27ff7b180a986">xtd::array::get_upper_bound</a> to initialize a one-dimensional array and a multidimensional array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab74ed5a54361b742c7e27ff7b180a986" name="ab74ed5a54361b742c7e27ff7b180a986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74ed5a54361b742c7e27ff7b180a986">&#9670;&#160;</a></span>get_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the upper bound of the specified dimension in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>A zero-based dimension of the array whose upper bound needs to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The upper bound of the specified dimension in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`dimension` is equal to or greater than <a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73" title="Gets the rank (number of dimensions) of the array.">xtd::basic_array::rank</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example uses <a class="el" href="#a6ac6c2f6144b73e261745e2bec9f6771">xtd::array::get_lower_bound</a> and <a class="el" href="#ab74ed5a54361b742c7e27ff7b180a986">xtd::array::get_upper_bound</a> to initialize a one-dimensional array and a multidimensional array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a21516522b32f0b1a6f92ab99d7cf271c" name="a21516522b32f0b1a6f92ab99d7cf271c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21516522b32f0b1a6f92ab99d7cf271c">&#9670;&#160;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indexes</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value at the specified position in the multidimensional array. The indexes are specified as 32-bit integers array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>An array that represents the position of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified position in the multidimensional array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `indexes` is outside the range of valid indexes for the corresponding dimension of the current array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63ff23cf9bbd59f42928e36dcc042425" name="a63ff23cf9bbd59f42928e36dcc042425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff23cf9bbd59f42928e36dcc042425">&#9670;&#160;</a></span>index_of() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const type_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the index of a specific item in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to locate in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of value if found in the array; otherwise, xtd::collections::generic::ilist::npos. </dd></dl>

</div>
</div>
<a id="a795fd3bff66d49a57311b81cf697953f" name="a795fd3bff66d49a57311b81cf697953f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795fd3bff66d49a57311b81cf697953f">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>new_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="#aaf70989e6cabeaccefd32e3b760753ef" title="Gets a size that represents the total number of elements in all the dimensions of the array.">length()</a>. / @param new_size The new size of the container. / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#af4ad72063824fdf6ac996a5b6cb041ec" title="Gets the total number of elements the internal data structure can hold without resizing.">xtd::collections::generic::list::capacity</a> is set to a value that is less than <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a9fc65d3d8c22e9fafb4b35265be9c438" title="Gets the number of elements contained in the xtd::collections::generic::list &lt;type_t&gt;.">xtd::collections::generic::list::count</a>. / @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. / @remarks If the current size is less than</code>count`, additional default-inserted elements are appended. void resize(size_type new_size) {resize(new_size, <a class="el" href="#a8a186922544d50c32678dbeead9d34fe" title="Represents the array value type.">value_type</a> {});}. </p>
<p>/ Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="#aaf70989e6cabeaccefd32e3b760753ef" title="Gets a size that represents the total number of elements in all the dimensions of the array.">length()</a>. @param new_size The new size of the container. @param value The value to initialize the new elements with. @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#af4ad72063824fdf6ac996a5b6cb041ec" title="Gets the total number of elements the internal data structure can hold without resizing.">xtd::collections::generic::list::capacity</a> is set to a value that is less than <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a9fc65d3d8c22e9fafb4b35265be9c438" title="Gets the number of elements contained in the xtd::collections::generic::list &lt;type_t&gt;.">xtd::collections::generic::list::count</a>. @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. @remarks If the current size is less than</code>count`, additional default-inserted elements are appended. </p>

</div>
</div>
<a id="a16b80cc0f2926f2b4fcfb5f5c1346eb7" name="a16b80cc0f2926f2b4fcfb5f5c1346eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b80cc0f2926f2b4fcfb5f5c1346eb7">&#9670;&#160;</a></span>set_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::set_value </td>
          <td>(</td>
          <td class="paramtype">const type_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indexes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a value to the element at the specified position in the multidimensional array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new value for the specified element. </td></tr>
    <tr><td class="paramname">indexes</td><td>An array that represents the position of the element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>Either `indexes` is outside the range of valid indexes for the current array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac29d8f865aaa14d1f3ce4ae201fdf1b5" name="ac29d8f865aaa14d1f3ce4ae201fdf1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29d8f865aaa14d1f3ce4ae201fdf1b5">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents and capacity of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </p>
<dl class="section remark"><dt>Remarks</dt><dd>All iterators and references remain valid. The <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a> iterator is invalidated. </dd></dl>

</div>
</div>
<a id="ac4ec27387ef0582948fc499fde1eba65" name="ac4ec27387ef0582948fc499fde1eba65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ec27387ef0582948fc499fde1eba65">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">xtd::string</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object. </p>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the current object. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates what to_string returns. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>examples {</div>
<div class="line">  <span class="keyword">namespace </span>object_test {</div>
<div class="line">    <span class="keyword">class </span>object1 : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  ptr&lt;object&gt; obj1 = new_ptr&lt;examples::object_test::object1&gt;();</div>
<div class="line">  console::write_line(obj1-&gt;to_string());</div>
<div class="line"> </div>
<div class="line">  ptr&lt;object&gt; obj2 = new_ptr&lt;date_time&gt;(1971, 1, 5, 23, 5, 0);</div>
<div class="line">  console::write_line(obj2-&gt;to_string());</div>
<div class="line"> </div>
<div class="line">  ptr&lt;object&gt; obj3 = new_ptr&lt;boolean_object&gt;();</div>
<div class="line">  console::write_line(obj3-&gt;to_string());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// examples::object_test::object1</span></div>
<div class="line"><span class="comment">// Tue Jan  5 23:05:00 1971</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
</div><!-- fragment --> </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">xtd::object</a>.</p>

</div>
</div>
<a id="a56e8d16cbfd4478600885c5ebbc0cb90" name="a56e8d16cbfd4478600885c5ebbc0cb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e8d16cbfd4478600885c5ebbc0cb90">&#9670;&#160;</a></span>index_of() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the index of a specific item in the array specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">value</td><td>The object to locate in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> The index of value if found in the array; otherwise, -1. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to determine the index of the first occurrence of a specified element. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad62d15bd70091aef74009040a66e96c7" name="ad62d15bd70091aef74009040a66e96c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62d15bd70091aef74009040a66e96c7">&#9670;&#160;</a></span>index_of() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the index of a specific item in the array specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">value</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">index</td><td>The zero-based starting index of the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> The index of value if found in the array; otherwise, -1. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>The parameters `index` is less than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to determine the index of the first occurrence of a specified element. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad5ce2959fbb235a756ad16dd2a3f343e" name="ad5ce2959fbb235a756ad16dd2a3f343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ce2959fbb235a756ad16dd2a3f343e">&#9670;&#160;</a></span>index_of() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the index of a specific item in the array specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">value</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">index</td><td>The zero-based starting index of the search. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the section to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">int32</a> The index of value if found in the array; otherwise, -1. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>The parameters `index` and `count` do not specify a valid section in the 'array'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to determine the index of the first occurrence of a specified element. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad1bc2546d5b6d814fdebcd0318d76e91" name="ad1bc2546d5b6d814fdebcd0318d76e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bc2546d5b6d814fdebcd0318d76e91">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the elements in the entire <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method uses std::reverse to reverse the order of the elements, such that the element at <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a> &lt;type_t&gt;[i], where <code>i</code> is any index within the range, moves to <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a> &lt;type_t&gt;[j], where <code>j</code> equals index plus index plus count minus <code>i</code> minus 1. </dd>
<dd>
This method is an O(n) operation, where n is <a class="el" href="#a2e50b538f5aa4913d3180fcee49499c2" title="Gets the number of elements contained in the xtd::array &lt;type_t&gt;.">xtd::basic_array::count</a>. </dd></dl>

</div>
</div>
<a id="af5089c1fc7d9e8010517893f5cf4a946" name="af5089c1fc7d9e8010517893f5cf4a946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5089c1fc7d9e8010517893f5cf4a946">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the elements in the specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The zero-based starting index of the range to reverse. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the range to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` and `count` do not denote a valid range of elements in the <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method uses std::reverse to reverse the order of the elements, such that the element at <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a> &lt;type_t&gt;[i], where <code>i</code> is any index within the range, moves to <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a> &lt;type_t&gt;[j], where <code>j</code> equals index plus index plus count minus <code>i</code> minus 1. </dd>
<dd>
This method is an O(n) operation, where n is <code>count</code>. </dd></dl>

</div>
</div>
<a id="ab88cfef04f0ae0cb609068f0a2ff0a25" name="ab88cfef04f0ae0cb609068f0a2ff0a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88cfef04f0ae0cb609068f0a2ff0a25">&#9670;&#160;</a></span>sort() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t &gt; &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::sort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the entire <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; using the default comparer. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>The default comparer <a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html#a9a8d918ad60fc9ba6aff540a7ef2b4b0">xtd::collections::generic::comparer::default_comparer</a> cannot find an implementation of the <a class="el" href="classxtd_1_1icomparable.html" title="Defines a generalized comparison method that a value type or class implements to create a type-specif...">xtd::icomparable</a> &lt;type_t&gt; generic interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a0bb5df6e3deeb7f5b0587fae9e95d960" title="Searches the entire sorted xtd::collections::generic::list &lt;type_t&gt; for an element using the default ...">xtd::collections::generic::list::binary_search</a> method overload is then used to search for two strings that are not in the list, and the xtd::collections::generic::list::insert method is used to insert them. The return value of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a0bb5df6e3deeb7f5b0587fae9e95d960" title="Searches the entire sorted xtd::collections::generic::list &lt;type_t&gt; for an element using the default ...">xtd::collections::generic::list::binary_search</a> method is gretaer than <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a9fc65d3d8c22e9fafb4b35265be9c438" title="Gets the number of elements contained in the xtd::collections::generic::list &lt;type_t&gt;.">xtd::collections::generic::list::count</a> in each case, because the strings are not in the list. Taking the bitwise complement of this negative number produces the index of the first element in the list that is larger than the search string, and inserting at this location preserves the sort order. The second search string is larger than any element in the list, so the insertion position is at the end of the list. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>example {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="keyword">auto</span> dinosaurs = list&lt;string&gt; {};</div>
<div class="line">    </div>
<div class="line">    dinosaurs.add(<span class="stringliteral">&quot;Pachycephalosaurus&quot;</span>);</div>
<div class="line">    dinosaurs.add(<span class="stringliteral">&quot;Amargasaurus&quot;</span>);</div>
<div class="line">    dinosaurs.add(<span class="stringliteral">&quot;Mamenchisaurus&quot;</span>);</div>
<div class="line">    dinosaurs.add(<span class="stringliteral">&quot;Deinonychus&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> dinosaur : dinosaurs)</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(dinosaur);</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;\nsort&quot;</span>);</div>
<div class="line">    dinosaurs.sort();</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> dinosaur : dinosaurs)</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(dinosaur);</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;\nbinary_search and insert \&quot;Coelophysis\&quot;:&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> index = dinosaurs.binary_search(<span class="stringliteral">&quot;Coelophysis&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (index &gt; dinosaurs.count()) dinosaurs.insert(~index, <span class="stringliteral">&quot;Coelophysis&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">string</span> dinosaur : dinosaurs)</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(dinosaur);</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;\nbinary_search and insert \&quot;Tyrannosaurus\&quot;:&quot;</span>);</div>
<div class="line">    index = dinosaurs.binary_search(<span class="stringliteral">&quot;Tyrannosaurus&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (index &gt; dinosaurs.count()) dinosaurs.insert(~index, <span class="stringliteral">&quot;Tyrannosaurus&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> dinosaur : dinosaurs)</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(dinosaur);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(example::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Pachycephalosaurus</span></div>
<div class="line"><span class="comment">// Amargasaurus</span></div>
<div class="line"><span class="comment">// Mamenchisaurus</span></div>
<div class="line"><span class="comment">// Deinonychus</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// sort</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Amargasaurus</span></div>
<div class="line"><span class="comment">// Deinonychus</span></div>
<div class="line"><span class="comment">// Mamenchisaurus</span></div>
<div class="line"><span class="comment">// Pachycephalosaurus</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// binary_search and insert &quot;Coelophysis&quot;:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Amargasaurus</span></div>
<div class="line"><span class="comment">// Coelophysis</span></div>
<div class="line"><span class="comment">// Deinonychus</span></div>
<div class="line"><span class="comment">// Mamenchisaurus</span></div>
<div class="line"><span class="comment">// Pachycephalosaurus</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// binary_search and insert &quot;Tyrannosaurus&quot;:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Amargasaurus</span></div>
<div class="line"><span class="comment">// Coelophysis</span></div>
<div class="line"><span class="comment">// Deinonychus</span></div>
<div class="line"><span class="comment">// Mamenchisaurus</span></div>
<div class="line"><span class="comment">// Pachycephalosaurus</span></div>
<div class="line"><span class="comment">// Tyrannosaurus</span></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.hpp:168</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method uses the default comparer <a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html#a9a8d918ad60fc9ba6aff540a7ef2b4b0">xtd::collections::generic::comparer::default_comparer</a> for type <code>type_t</code> to determine the order of list elements. The <a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html#a9a8d918ad60fc9ba6aff540a7ef2b4b0">xtd::collections::generic::comparer::default_comparer</a> property checks whether type <code>type_t</code> implements the <a class="el" href="classxtd_1_1icomparable.html" title="Defines a generalized comparison method that a value type or class implements to create a type-specif...">xtd::icomparable</a> &lt;type_t&gt; generic interface and uses that implementation, if available. If not, <a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html#a9a8d918ad60fc9ba6aff540a7ef2b4b0">xtd::collections::generic::comparer::default_comparer</a> checks whether type T implements the <a class="el" href="classxtd_1_1icomparable.html" title="Defines a generalized comparison method that a value type or class implements to create a type-specif...">xtd::icomparable</a> interface. If type <code>type_t</code> does not implement either interface, <a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html#a9a8d918ad60fc9ba6aff540a7ef2b4b0">xtd::collections::generic::comparer::default_comparer</a> throws an <a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a>. </dd>
<dd>
This method uses <a class="el" href="#ab88cfef04f0ae0cb609068f0a2ff0a25">xtd::array::sort</a>, which uses the QuickSort algorithm. This implementation performs an unstable sort; that is, if two elements are equal, their order might ! be preserved. In contrast, a stable sort preserves the order of elements that are equal. </dd>
<dd>
On average, this method is an O(n log n) operation, where n is <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a9fc65d3d8c22e9fafb4b35265be9c438" title="Gets the number of elements contained in the xtd::collections::generic::list &lt;type_t&gt;.">xtd::collections::generic::list::count</a>; in the worst case it is an O(n ^ 2) operation. </dd>
<dd>
The following code example demonstrates the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a076b57c56e4a397e1487beb7edf6310a" title="Sorts the elements in the entire xtd::collections::generic::list &lt;type_t&gt; using the default comparer.">xtd::collections::generic::list::sort</a> method overload and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a0bb5df6e3deeb7f5b0587fae9e95d960" title="Searches the entire sorted xtd::collections::generic::list &lt;type_t&gt; for an element using the default ...">xtd::collections::generic::list::binary_search</a> method overload. A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; of strings is created and populated with four strings, in no particular order. The list is displayed, sorted, and displayed again. </dd></dl>

</div>
</div>
<a id="a2bfc756583b9aac6e8851cc26a36ccf8" name="a2bfc756583b9aac6e8851cc26a36ccf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfc756583b9aac6e8851cc26a36ccf8">&#9670;&#160;</a></span>sort() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t &gt; &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">comparison_comparer</td>          <td class="paramname"><span class="paramname"><em>comparison</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the entire <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; using the specified <a class="el" href="group__delegates.html#ga6aa9a3d2680df2fc027c12383aa9e7cc" title="Represents the method that compares two objects of the same type.">xtd::comparison</a> &lt;type_t&gt;. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The implementation of comparison caused an error during the sort. For example, comparison might not return 0 when comparing an item with itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If comparison is provided, the elements of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; are sorted using the method represented by the delegate. </dd>
<dd>
This method uses <a class="el" href="#ab88cfef04f0ae0cb609068f0a2ff0a25">xtd::array::sort</a>, which uses the QuickSort algorithm. This implementation performs an unstable sort; that is, if two elements are equal, their order might ! be preserved. In contrast, a stable sort preserves the order of elements that are equal. </dd>
<dd>
On average, this method is an O(n log n) operation, where n is <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a9fc65d3d8c22e9fafb4b35265be9c438" title="Gets the number of elements contained in the xtd::collections::generic::list &lt;type_t&gt;.">xtd::collections::generic::list::count</a>; in the worst case it is an O(n ^ 2) operation. </dd></dl>

</div>
</div>
<a id="a3c1920205ef433c6639a21ed08b81bf7" name="a3c1920205ef433c6639a21ed08b81bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1920205ef433c6639a21ed08b81bf7">&#9670;&#160;</a></span>sort() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t &gt; &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1icomparer.html">xtd::collections::generic::icomparer</a>&lt; type_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the entire <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; using the specified comparer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1icomparer.html" title="Exposes a method that compares two objects.">xtd::collections::generic::icomparer</a> &lt;type_t&gt; implementation to use when comparing elements, or null to use the default comparer <a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html#a9a8d918ad60fc9ba6aff540a7ef2b4b0">xtd::collections::generic::comparer::default_comparer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The implementation of comparison caused an error during the sort. For example, comparison might not return 0 when comparing an item with itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If comparer is provided, the elements of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; are sorted using the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1icomparer.html" title="Exposes a method that compares two objects.">xtd::collections::generic::icomparer</a> &lt;type_t&gt; implementation. </dd>
<dd>
This method uses <a class="el" href="#ab88cfef04f0ae0cb609068f0a2ff0a25">xtd::array::sort</a>, which uses the QuickSort algorithm. This implementation performs an unstable sort; that is, if two elements are equal, their order might ! be preserved. In contrast, a stable sort preserves the order of elements that are equal. </dd>
<dd>
On average, this method is an O(n log n) operation, where n is <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a9fc65d3d8c22e9fafb4b35265be9c438" title="Gets the number of elements contained in the xtd::collections::generic::list &lt;type_t&gt;.">xtd::collections::generic::list::count</a>; in the worst case it is an O(n ^ 2) operation. </dd></dl>

</div>
</div>
<a id="abdd2289581f85c14ab799af32e51f9e3" name="abdd2289581f85c14ab799af32e51f9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd2289581f85c14ab799af32e51f9e3">&#9670;&#160;</a></span>sort() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t &gt; &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1icomparer.html">xtd::collections::generic::icomparer</a>&lt; type_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in a range of elements in <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; using the specified comparer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The zero-based starting index of the range to sort. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the range to sort. </td></tr>
    <tr><td class="paramname">comparer</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1icomparer.html" title="Exposes a method that compares two objects.">xtd::collections::generic::icomparer</a> &lt;type_t&gt; implementation to use when comparing elements, or null to use the default comparer <a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html#a9a8d918ad60fc9ba6aff540a7ef2b4b0">xtd::collections::generic::comparer::default_comparer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The implementation of comparison caused an error during the sort. For example, comparison might not return 0 when comparing an item with itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If comparer is provided, the elements of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; are sorted using the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1icomparer.html" title="Exposes a method that compares two objects.">xtd::collections::generic::icomparer</a> &lt;type_t&gt; implementation. </dd>
<dd>
This method uses <a class="el" href="#ab88cfef04f0ae0cb609068f0a2ff0a25">xtd::array::sort</a>, which uses the QuickSort algorithm. This implementation performs an unstable sort; that is, if two elements are equal, their order might ! be preserved. In contrast, a stable sort preserves the order of elements that are equal. </dd>
<dd>
On average, this method is an O(n log n) operation, where n is <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a9fc65d3d8c22e9fafb4b35265be9c438" title="Gets the number of elements contained in the xtd::collections::generic::list &lt;type_t&gt;.">xtd::collections::generic::list::count</a>; in the worst case it is an O(n ^ 2) operation. </dd></dl>

</div>
</div>
<a id="a9ca38a735b49019beb5e5f14ab8d4ac1" name="a9ca38a735b49019beb5e5f14ab8d4ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca38a735b49019beb5e5f14ab8d4ac1">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ab2ca7652bd75af5a950e375cad3ce53c" name="ab2ca7652bd75af5a950e375cad3ce53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ca7652bd75af5a950e375cad3ce53c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another base type container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ad4c8aa56257fec1b361de7c00c2222b5" name="ad4c8aa56257fec1b361de7c00c2222b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c8aa56257fec1b361de7c00c2222b5">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; type_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list ilist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>Initializer list to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ac5c62871eef03c2d45676040e137e604" name="ac5c62871eef03c2d45676040e137e604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c62871eef03c2d45676040e137e604">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If pos is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc74a419dc77ebae92d7a7aaa80c2249" name="afc74a419dc77ebae92d7a7aaa80c2249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc74a419dc77ebae92d7a7aaa80c2249">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49c15ccc5efbe20ca6656e87436036c3" name="a49c15ccc5efbe20ca6656e87436036c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c15ccc5efbe20ca6656e87436036c3">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator const <a class="el" href="#af65616e6a94b988a1346bce86b911595">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a3eac9b62b7209d7ef1bda73d4b77c8a7" name="a3eac9b62b7209d7ef1bda73d4b77c8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eac9b62b7209d7ef1bda73d4b77c8a7">&#9670;&#160;</a></span>operator base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator <a class="el" href="#af65616e6a94b988a1346bce86b911595">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="aee7c8053e686383179fc57895fc0d3d9" name="aee7c8053e686383179fc57895fc0d3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7c8053e686383179fc57895fc0d3d9">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">type_t &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indexes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>An array that represents the multidimension index of the array element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified position in the multidimensional array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>Either each index is outside the range of valid indexes for the corresponding dimension of the current array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use operator [] to list the elements of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab39c6f97b33ca7b85614188ce9443f72" name="ab39c6f97b33ca7b85614188ce9443f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39c6f97b33ca7b85614188ce9443f72">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type_t &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indexes</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>An array that represents the multidimension index of the array element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified position in the multidimensional array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>Either each index is outside the range of valid indexes for the corresponding dimension of the current array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use operator [] to list the elements of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/<a class="el" href="basic__array_8hpp_source.html">basic_array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 23 2025 10:21:10 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
