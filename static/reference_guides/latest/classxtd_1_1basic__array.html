<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::basic_array&lt; type_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1basic__array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::basic_array&lt; type_t, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::basic_array&lt; type_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1basic__array.png" usemap="#xtd::basic_5Farray_3C_20type_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::basic_5Farray_3C_20type_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::basic_5Farray_3C_20type_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1array__abstract__object.html" title="Abstract object that represent array." alt="xtd::array_abstract_object" shape="rect" coords="0,112,655,136"/>
<area href="classxtd_1_1abstract__object.html" title="Represent an abstract class." alt="xtd::abstract_object" shape="rect" coords="0,56,655,80"/>
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,655,24"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::string &gt;" shape="rect" coords="1330,224,1985,248"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::diagnostics::stack_frame &gt;" shape="rect" coords="1330,280,1985,304"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::drawing::color &gt;" shape="rect" coords="1330,336,1985,360"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::array&lt; bool &gt; &gt;" shape="rect" coords="1330,392,1985,416"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::drawing::point &gt;" shape="rect" coords="1330,448,1985,472"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::size &gt;" shape="rect" coords="1330,504,1985,528"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; item &gt;" shape="rect" coords="1330,560,1985,584"/>
<area href="classxtd_1_1array.html" alt="xtd::array&lt; xtd::forms::shadow &gt;" shape="rect" coords="1330,616,1985,640"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt;<br />
class xtd::basic_array&lt; type_t, allocator_t &gt;</div><p>Base object that represent array. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> type_t, <span class="keyword">class</span> allocator_t = xtd::collections::<span class="keyword">generic</span>::helpers::allocator&lt;type_t&gt;&gt;</div>
<div class="line"><span class="keyword">class </span>basic_array : <span class="keyword">public</span> xtd::array_object, <span class="keyword">public</span> xtd::collections::generic::ilist&lt;type_t&gt;, <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1iequatable.html">xtd::iequatable</a>&lt;basic_array&lt;type_t, allocator_t&gt;&gt;;</div>
<div class="ttc" id="aclassxtd_1_1iequatable_html"><div class="ttname"><a href="classxtd_1_1iequatable.html">xtd::iequatable</a></div><div class="ttdoc">Defines a generalized method that a value type or class implements to create a type-specific method f...</div><div class="ttdef"><b>Definition</b> iequatable.hpp:22</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:a8a186922544d50c32678dbeead9d34fe" id="r_a8a186922544d50c32678dbeead9d34fe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a></td></tr>
<tr class="memdesc:a8a186922544d50c32678dbeead9d34fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array value type.  <br /></td></tr>
<tr class="separator:a8a186922544d50c32678dbeead9d34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e03acd94629ea4815cebbe14df6ce91" id="r_a3e03acd94629ea4815cebbe14df6ce91"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e03acd94629ea4815cebbe14df6ce91">allocator_type</a></td></tr>
<tr class="memdesc:a3e03acd94629ea4815cebbe14df6ce91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array allocator type.  <br /></td></tr>
<tr class="separator:a3e03acd94629ea4815cebbe14df6ce91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad277de2a42b4b0aba1c24eadf2edbe24" id="r_ad277de2a42b4b0aba1c24eadf2edbe24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a></td></tr>
<tr class="memdesc:ad277de2a42b4b0aba1c24eadf2edbe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array base type.  <br /></td></tr>
<tr class="separator:ad277de2a42b4b0aba1c24eadf2edbe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b44083298196790c9d898bf520828a" id="r_af9b44083298196790c9d898bf520828a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td></tr>
<tr class="memdesc:af9b44083298196790c9d898bf520828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array size type (usually <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::size</a>).  <br /></td></tr>
<tr class="separator:af9b44083298196790c9d898bf520828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1c0a188f5cfd2673e9b90c0d300e3e" id="r_a2c1c0a188f5cfd2673e9b90c0d300e3e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c1c0a188f5cfd2673e9b90c0d300e3e">difference_type</a></td></tr>
<tr class="memdesc:a2c1c0a188f5cfd2673e9b90c0d300e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array difference type (usually <a class="el" href="group__types.html#gae3c4f13b0aabf2474d7c5b2e36aad317" title="Represent the signed integer type of the result of subtracting two pointers.">xtd::ptrdiff</a>).  <br /></td></tr>
<tr class="separator:a2c1c0a188f5cfd2673e9b90c0d300e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6054c9522c7a58c05453b86e0c6f1913" id="r_a6054c9522c7a58c05453b86e0c6f1913"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a></td></tr>
<tr class="memdesc:a6054c9522c7a58c05453b86e0c6f1913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reference of array value type.  <br /></td></tr>
<tr class="separator:a6054c9522c7a58c05453b86e0c6f1913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a0d032eb60a2a8f0bdf84ba3fe1204" id="r_a01a0d032eb60a2a8f0bdf84ba3fe1204"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a></td></tr>
<tr class="memdesc:a01a0d032eb60a2a8f0bdf84ba3fe1204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reference of array value type.  <br /></td></tr>
<tr class="separator:a01a0d032eb60a2a8f0bdf84ba3fe1204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58756d2450f08851d601a29456ba4273" id="r_a58756d2450f08851d601a29456ba4273"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58756d2450f08851d601a29456ba4273">pointer</a></td></tr>
<tr class="memdesc:a58756d2450f08851d601a29456ba4273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the pointer of array value type.  <br /></td></tr>
<tr class="separator:a58756d2450f08851d601a29456ba4273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52835b4b627c5d7783f5d523aa265927" id="r_a52835b4b627c5d7783f5d523aa265927"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52835b4b627c5d7783f5d523aa265927">const_pointer</a></td></tr>
<tr class="memdesc:a52835b4b627c5d7783f5d523aa265927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const pointer of array value type.  <br /></td></tr>
<tr class="separator:a52835b4b627c5d7783f5d523aa265927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a69b60fa4687e14ec5c1180f7d7553" id="r_ac5a69b60fa4687e14ec5c1180f7d7553"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a></td></tr>
<tr class="memdesc:ac5a69b60fa4687e14ec5c1180f7d7553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of array value type.  <br /></td></tr>
<tr class="separator:ac5a69b60fa4687e14ec5c1180f7d7553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d9a52e3c55ac56d32fd81c5d7d9cee" id="r_a27d9a52e3c55ac56d32fd81c5d7d9cee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a></td></tr>
<tr class="memdesc:a27d9a52e3c55ac56d32fd81c5d7d9cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of array value type.  <br /></td></tr>
<tr class="separator:a27d9a52e3c55ac56d32fd81c5d7d9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec840a621251f1d7ba5caab527f5e08" id="r_a4ec840a621251f1d7ba5caab527f5e08"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ec840a621251f1d7ba5caab527f5e08">reverse_iterator</a></td></tr>
<tr class="memdesc:a4ec840a621251f1d7ba5caab527f5e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reverse iterator of array value type.  <br /></td></tr>
<tr class="separator:a4ec840a621251f1d7ba5caab527f5e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0160c4ae793de2de4a97ed5d6a0351f1" id="r_a0160c4ae793de2de4a97ed5d6a0351f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a0160c4ae793de2de4a97ed5d6a0351f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reverse iterator of array value type.  <br /></td></tr>
<tr class="separator:a0160c4ae793de2de4a97ed5d6a0351f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Fields</h2></td></tr>
<tr class="memitem:a53b8d655a996e1eb424894548a9ed2da" id="r_a53b8d655a996e1eb424894548a9ed2da"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53b8d655a996e1eb424894548a9ed2da">npos</a></td></tr>
<tr class="memdesc:a53b8d655a996e1eb424894548a9ed2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the maximum value representable by the type <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::size</a>.  <br /></td></tr>
<tr class="separator:a53b8d655a996e1eb424894548a9ed2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:ad830194f7a76eec01d6bd96b1f3343bb" id="r_ad830194f7a76eec01d6bd96b1f3343bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad830194f7a76eec01d6bd96b1f3343bb">back</a> ()</td></tr>
<tr class="memdesc:ad830194f7a76eec01d6bd96b1f3343bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:ad830194f7a76eec01d6bd96b1f3343bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a1eac93ddf1500a9515fc560d7b572" id="r_a52a1eac93ddf1500a9515fc560d7b572"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52a1eac93ddf1500a9515fc560d7b572">back</a> () const</td></tr>
<tr class="memdesc:a52a1eac93ddf1500a9515fc560d7b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:a52a1eac93ddf1500a9515fc560d7b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb48e8ab13f64c2bbc8579286cdc33c" id="r_a7cb48e8ab13f64c2bbc8579286cdc33c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cb48e8ab13f64c2bbc8579286cdc33c">begin</a> () const noexcept override</td></tr>
<tr class="memdesc:a7cb48e8ab13f64c2bbc8579286cdc33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:a7cb48e8ab13f64c2bbc8579286cdc33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acd2ad2fa08cf8fb94d254f70c91de3" id="r_a7acd2ad2fa08cf8fb94d254f70c91de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">begin</a> () noexcept override</td></tr>
<tr class="memdesc:a7acd2ad2fa08cf8fb94d254f70c91de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:a7acd2ad2fa08cf8fb94d254f70c91de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4978aa1d73aaf5e204cac3841ea866" id="r_adb4978aa1d73aaf5e204cac3841ea866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb4978aa1d73aaf5e204cac3841ea866">cbegin</a> () const noexcept override</td></tr>
<tr class="memdesc:adb4978aa1d73aaf5e204cac3841ea866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:adb4978aa1d73aaf5e204cac3841ea866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23631ee443a12598cc846b128473312d" id="r_a23631ee443a12598cc846b128473312d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23631ee443a12598cc846b128473312d">cend</a> () const noexcept override</td></tr>
<tr class="memdesc:a23631ee443a12598cc846b128473312d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a23631ee443a12598cc846b128473312d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e50b538f5aa4913d3180fcee49499c2" id="r_a2e50b538f5aa4913d3180fcee49499c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e50b538f5aa4913d3180fcee49499c2">count</a> () const noexcept override</td></tr>
<tr class="memdesc:a2e50b538f5aa4913d3180fcee49499c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements contained in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a2e50b538f5aa4913d3180fcee49499c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95718ca09e080a530bb22ab7fc29928" id="r_af95718ca09e080a530bb22ab7fc29928"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af95718ca09e080a530bb22ab7fc29928">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:af95718ca09e080a530bb22ab7fc29928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>.  <br /></td></tr>
<tr class="separator:af95718ca09e080a530bb22ab7fc29928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14a4aeb972e3b0ad85bc83d4596dd03" id="r_ac14a4aeb972e3b0ad85bc83d4596dd03"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac14a4aeb972e3b0ad85bc83d4596dd03">crend</a> () const noexcept</td></tr>
<tr class="memdesc:ac14a4aeb972e3b0ad85bc83d4596dd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:ac14a4aeb972e3b0ad85bc83d4596dd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5a9ce8373768ab8c68b261b33d5b6f" id="r_a5b5a9ce8373768ab8c68b261b33d5b6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a58756d2450f08851d601a29456ba4273">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">data</a> () noexcept</td></tr>
<tr class="memdesc:a5b5a9ce8373768ab8c68b261b33d5b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <br /></td></tr>
<tr class="separator:a5b5a9ce8373768ab8c68b261b33d5b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1405502cc9db3c5decf3d44c99fda34b" id="r_a1405502cc9db3c5decf3d44c99fda34b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a52835b4b627c5d7783f5d523aa265927">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1405502cc9db3c5decf3d44c99fda34b">data</a> () const noexcept</td></tr>
<tr class="memdesc:a1405502cc9db3c5decf3d44c99fda34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <br /></td></tr>
<tr class="separator:a1405502cc9db3c5decf3d44c99fda34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecdfcec3616cd38223715dd6f4df224" id="r_a0ecdfcec3616cd38223715dd6f4df224"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ecdfcec3616cd38223715dd6f4df224">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a0ecdfcec3616cd38223715dd6f4df224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">xtd::array::begin()</a> == <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a>.  <br /></td></tr>
<tr class="separator:a0ecdfcec3616cd38223715dd6f4df224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c2af41aeaa2af9847c1d6567df83c6" id="r_a69c2af41aeaa2af9847c1d6567df83c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69c2af41aeaa2af9847c1d6567df83c6">end</a> () const noexcept override</td></tr>
<tr class="memdesc:a69c2af41aeaa2af9847c1d6567df83c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a69c2af41aeaa2af9847c1d6567df83c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb880053eba2eefbc54d5d312626586" id="r_aabb880053eba2eefbc54d5d312626586"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabb880053eba2eefbc54d5d312626586">end</a> () noexcept override</td></tr>
<tr class="memdesc:aabb880053eba2eefbc54d5d312626586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:aabb880053eba2eefbc54d5d312626586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8f87d8d029713510c61ba59d1858a0" id="r_a2d8f87d8d029713510c61ba59d1858a0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d8f87d8d029713510c61ba59d1858a0">front</a> ()</td></tr>
<tr class="memdesc:a2d8f87d8d029713510c61ba59d1858a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:a2d8f87d8d029713510c61ba59d1858a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac754e2b8fe8c218619603f807d2dede6" id="r_ac754e2b8fe8c218619603f807d2dede6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac754e2b8fe8c218619603f807d2dede6">front</a> () const</td></tr>
<tr class="memdesc:ac754e2b8fe8c218619603f807d2dede6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:ac754e2b8fe8c218619603f807d2dede6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb6f585d484eac04eb282dd0a5fe9fd" id="r_acdb6f585d484eac04eb282dd0a5fe9fd"><td class="memItemLeft" align="right" valign="top"><a id="acdb6f585d484eac04eb282dd0a5fe9fd" name="acdb6f585d484eac04eb282dd0a5fe9fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_fixed_size</b> () const noexcept override</td></tr>
<tr class="separator:acdb6f585d484eac04eb282dd0a5fe9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95524d29f8f4a218254d137c5046cb1" id="r_ad95524d29f8f4a218254d137c5046cb1"><td class="memItemLeft" align="right" valign="top"><a id="ad95524d29f8f4a218254d137c5046cb1" name="ad95524d29f8f4a218254d137c5046cb1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_read_only</b> () const noexcept override</td></tr>
<tr class="separator:ad95524d29f8f4a218254d137c5046cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbb0b954165a263596fe7fd433d6125" id="r_a5cbb0b954165a263596fe7fd433d6125"><td class="memItemLeft" align="right" valign="top"><a id="a5cbb0b954165a263596fe7fd433d6125" name="a5cbb0b954165a263596fe7fd433d6125"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_synchronized</b> () const noexcept override</td></tr>
<tr class="separator:a5cbb0b954165a263596fe7fd433d6125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d7c124db651f72d7f2b4971c5862f5" id="r_ab5d7c124db651f72d7f2b4971c5862f5"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5d7c124db651f72d7f2b4971c5862f5">items</a> () const noexcept</td></tr>
<tr class="memdesc:ab5d7c124db651f72d7f2b4971c5862f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:ab5d7c124db651f72d7f2b4971c5862f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb7eadaa77baa15c8193de6af45eaec" id="r_adfb7eadaa77baa15c8193de6af45eaec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb7eadaa77baa15c8193de6af45eaec">items</a> () noexcept</td></tr>
<tr class="memdesc:adfb7eadaa77baa15c8193de6af45eaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:adfb7eadaa77baa15c8193de6af45eaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf70989e6cabeaccefd32e3b760753ef" id="r_aaf70989e6cabeaccefd32e3b760753ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf70989e6cabeaccefd32e3b760753ef">length</a> () const noexcept</td></tr>
<tr class="memdesc:aaf70989e6cabeaccefd32e3b760753ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a size that represents the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:aaf70989e6cabeaccefd32e3b760753ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48551f7aa950699c881a79fdd70f4f39" id="r_a48551f7aa950699c881a79fdd70f4f39"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">xtd::int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48551f7aa950699c881a79fdd70f4f39">long_length</a> ()</td></tr>
<tr class="memdesc:a48551f7aa950699c881a79fdd70f4f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:a48551f7aa950699c881a79fdd70f4f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760f9d630aee4ee6076c5f1fb0ba412f" id="r_a760f9d630aee4ee6076c5f1fb0ba412f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760f9d630aee4ee6076c5f1fb0ba412f">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a760f9d630aee4ee6076c5f1fb0ba412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">xtd::array::begin()</a>, <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a>) for the largest container.  <br /></td></tr>
<tr class="separator:a760f9d630aee4ee6076c5f1fb0ba412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0e476086ae44f64d6ed64a8cfbfc73" id="r_a0f0e476086ae44f64d6ed64a8cfbfc73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73">rank</a> () const noexcept</td></tr>
<tr class="memdesc:a0f0e476086ae44f64d6ed64a8cfbfc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rank (number of dimensions) of the array.  <br /></td></tr>
<tr class="separator:a0f0e476086ae44f64d6ed64a8cfbfc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f34355f80375edca7538ed77d2bc431" id="r_a9f34355f80375edca7538ed77d2bc431"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a4ec840a621251f1d7ba5caab527f5e08">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f34355f80375edca7538ed77d2bc431">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a9f34355f80375edca7538ed77d2bc431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>.  <br /></td></tr>
<tr class="separator:a9f34355f80375edca7538ed77d2bc431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6f68bf56a69ac0b57970e6ba9441a2" id="r_a0d6f68bf56a69ac0b57970e6ba9441a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d6f68bf56a69ac0b57970e6ba9441a2">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a0d6f68bf56a69ac0b57970e6ba9441a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>.  <br /></td></tr>
<tr class="separator:a0d6f68bf56a69ac0b57970e6ba9441a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c8b33119f80c64566c9c4fe307be46" id="r_ab5c8b33119f80c64566c9c4fe307be46"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a4ec840a621251f1d7ba5caab527f5e08">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">rend</a> () noexcept</td></tr>
<tr class="memdesc:ab5c8b33119f80c64566c9c4fe307be46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:ab5c8b33119f80c64566c9c4fe307be46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3432941b86f8c8e7c78bcf7132843e6d" id="r_a3432941b86f8c8e7c78bcf7132843e6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3432941b86f8c8e7c78bcf7132843e6d">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a3432941b86f8c8e7c78bcf7132843e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a3432941b86f8c8e7c78bcf7132843e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ad3488e28e4140835dece83723e7eb" id="r_af2ad3488e28e4140835dece83723e7eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2ad3488e28e4140835dece83723e7eb">size</a> () const noexcept</td></tr>
<tr class="memdesc:af2ad3488e28e4140835dece83723e7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. std::distance(<a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">xtd::array::begin()</a>, <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a>).  <br /></td></tr>
<tr class="separator:af2ad3488e28e4140835dece83723e7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5a20a84786e5ae303364a521972609" id="r_aee5a20a84786e5ae303364a521972609"><td class="memItemLeft" align="right" valign="top"><a id="aee5a20a84786e5ae303364a521972609" name="aee5a20a84786e5ae303364a521972609"></a>
const <a class="el" href="classxtd_1_1object.html">xtd::object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sync_root</b> () const noexcept override</td></tr>
<tr class="separator:aee5a20a84786e5ae303364a521972609"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a34472044617550faf939f05c223b6227" id="r_a34472044617550faf939f05c223b6227"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34472044617550faf939f05c223b6227">at</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index)</td></tr>
<tr class="memdesc:a34472044617550faf939f05c223b6227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <br /></td></tr>
<tr class="separator:a34472044617550faf939f05c223b6227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadefb8b17214889a16b31088e0131431" id="r_aadefb8b17214889a16b31088e0131431"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadefb8b17214889a16b31088e0131431">at</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index) const</td></tr>
<tr class="memdesc:aadefb8b17214889a16b31088e0131431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <br /></td></tr>
<tr class="separator:aadefb8b17214889a16b31088e0131431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659906a6f1060c2205d787b49bb129fc" id="r_a659906a6f1060c2205d787b49bb129fc"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a659906a6f1060c2205d787b49bb129fc">contains</a> (const type_t &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a659906a6f1060c2205d787b49bb129fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an element is in the array.  <br /></td></tr>
<tr class="separator:a659906a6f1060c2205d787b49bb129fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6766e45b973a8659323055151b0cff9e" id="r_a6766e45b973a8659323055151b0cff9e"><td class="memItemLeft" align="right" valign="top"><a id="a6766e45b973a8659323055151b0cff9e" name="a6766e45b973a8659323055151b0cff9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_to</b> (<a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; type_t &gt; &amp;<a class="el" href="classxtd_1_1array.html">array</a>, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index) const override</td></tr>
<tr class="separator:a6766e45b973a8659323055151b0cff9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ff0322a96e0ed8a3c268fd8a3d4eca" id="r_a88ff0322a96e0ed8a3c268fd8a3d4eca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88ff0322a96e0ed8a3c268fd8a3d4eca">copy_to</a> (<a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; type_t &gt; &amp;<a class="el" href="classxtd_1_1array.html">array</a>, <a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">xtd::int64</a> index) const</td></tr>
<tr class="memdesc:a88ff0322a96e0ed8a3c268fd8a3d4eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 64-bit integer.  <br /></td></tr>
<tr class="separator:a88ff0322a96e0ed8a3c268fd8a3d4eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391534692d321eadc7a5810486c16650" id="r_a391534692d321eadc7a5810486c16650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a391534692d321eadc7a5810486c16650">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept override</td></tr>
<tr class="memdesc:a391534692d321eadc7a5810486c16650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a391534692d321eadc7a5810486c16650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b108d6bbebf0dde60afcbe2c7a1e0f" id="r_a93b108d6bbebf0dde60afcbe2c7a1e0f"><td class="memItemLeft" align="right" valign="top"><a id="a93b108d6bbebf0dde60afcbe2c7a1e0f" name="a93b108d6bbebf0dde60afcbe2c7a1e0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;rhs) const noexcept override</td></tr>
<tr class="separator:a93b108d6bbebf0dde60afcbe2c7a1e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ef003c8174b830377e38610e743e4f" id="r_a92ef003c8174b830377e38610e743e4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92ef003c8174b830377e38610e743e4f">fill</a> (const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a92ef003c8174b830377e38610e743e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value to all elements in the container.  <br /></td></tr>
<tr class="separator:a92ef003c8174b830377e38610e743e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6753ddfe99de81064d777312541cea34" id="r_a6753ddfe99de81064d777312541cea34"><td class="memItemLeft" align="right" valign="top"><a id="a6753ddfe99de81064d777312541cea34" name="a6753ddfe99de81064d777312541cea34"></a>
<a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">xtd::collections::generic::enumerator</a>&lt; <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_enumerator</b> () const noexcept override</td></tr>
<tr class="separator:a6753ddfe99de81064d777312541cea34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4132e3affe66da23dc58780f520124e2" id="r_a4132e3affe66da23dc58780f520124e2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4132e3affe66da23dc58780f520124e2">get_length</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:a4132e3affe66da23dc58780f520124e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:a4132e3affe66da23dc58780f520124e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe84abedf478ba9a5059c08b7ff020" id="r_a06fe84abedf478ba9a5059c08b7ff020"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">xtd::int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06fe84abedf478ba9a5059c08b7ff020">get_long_length</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:a06fe84abedf478ba9a5059c08b7ff020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:a06fe84abedf478ba9a5059c08b7ff020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac6c2f6144b73e261745e2bec9f6771" id="r_a6ac6c2f6144b73e261745e2bec9f6771"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ac6c2f6144b73e261745e2bec9f6771">get_lower_bound</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:a6ac6c2f6144b73e261745e2bec9f6771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower bound of the specified dimension in the array.  <br /></td></tr>
<tr class="separator:a6ac6c2f6144b73e261745e2bec9f6771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74ed5a54361b742c7e27ff7b180a986" id="r_ab74ed5a54361b742c7e27ff7b180a986"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab74ed5a54361b742c7e27ff7b180a986">get_upper_bound</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:ab74ed5a54361b742c7e27ff7b180a986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the upper bound of the specified dimension in the array.  <br /></td></tr>
<tr class="separator:ab74ed5a54361b742c7e27ff7b180a986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21516522b32f0b1a6f92ab99d7cf271c" id="r_a21516522b32f0b1a6f92ab99d7cf271c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21516522b32f0b1a6f92ab99d7cf271c">get_value</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes) const</td></tr>
<tr class="memdesc:a21516522b32f0b1a6f92ab99d7cf271c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the multidimensional array. The indexes are specified as 32-bit integers array.  <br /></td></tr>
<tr class="separator:a21516522b32f0b1a6f92ab99d7cf271c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff23cf9bbd59f42928e36dcc042425" id="r_a63ff23cf9bbd59f42928e36dcc042425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63ff23cf9bbd59f42928e36dcc042425">index_of</a> (const type_t &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a63ff23cf9bbd59f42928e36dcc042425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a63ff23cf9bbd59f42928e36dcc042425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795fd3bff66d49a57311b81cf697953f" id="r_a795fd3bff66d49a57311b81cf697953f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a795fd3bff66d49a57311b81cf697953f">resize</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> new_size, <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> value)</td></tr>
<tr class="memdesc:a795fd3bff66d49a57311b81cf697953f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>. / @param new_size The new size of the container. / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> If</code>new_size<code>is outside greather than <a class="el" href="#a760f9d630aee4ee6076c5f1fb0ba412f">xtd::array::max_size</a>. / @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. / @remarks If the current size is less than</code>count`, additional default-inserted elements are appended. void resize(size_type new_size) {resize(new_size, <a class="el" href="#a8a186922544d50c32678dbeead9d34fe" title="Represents the array value type.">value_type</a> {});}.  <br /></td></tr>
<tr class="separator:a795fd3bff66d49a57311b81cf697953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b80cc0f2926f2b4fcfb5f5c1346eb7" id="r_a16b80cc0f2926f2b4fcfb5f5c1346eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16b80cc0f2926f2b4fcfb5f5c1346eb7">set_value</a> (const type_t &amp;value, const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes)</td></tr>
<tr class="memdesc:a16b80cc0f2926f2b4fcfb5f5c1346eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the element at the specified position in the multidimensional array.  <br /></td></tr>
<tr class="separator:a16b80cc0f2926f2b4fcfb5f5c1346eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29d8f865aaa14d1f3ce4ae201fdf1b5" id="r_ac29d8f865aaa14d1f3ce4ae201fdf1b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac29d8f865aaa14d1f3ce4ae201fdf1b5">swap</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:ac29d8f865aaa14d1f3ce4ae201fdf1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents and capacity of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.  <br /></td></tr>
<tr class="separator:ac29d8f865aaa14d1f3ce4ae201fdf1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ec27387ef0582948fc499fde1eba65" id="r_ac4ec27387ef0582948fc499fde1eba65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__strings.html#ga2bd6ab53224f55d280a88872353123eb">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4ec27387ef0582948fc499fde1eba65">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:ac4ec27387ef0582948fc499fde1eba65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#ga2bd6ab53224f55d280a88872353123eb" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:ac4ec27387ef0582948fc499fde1eba65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:a9ca38a735b49019beb5e5f14ab8d4ac1" id="r_a9ca38a735b49019beb5e5f14ab8d4ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ca38a735b49019beb5e5f14ab8d4ac1">operator=</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a9ca38a735b49019beb5e5f14ab8d4ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of other.  <br /></td></tr>
<tr class="separator:a9ca38a735b49019beb5e5f14ab8d4ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ca7652bd75af5a950e375cad3ce53c" id="r_ab2ca7652bd75af5a950e375cad3ce53c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ca7652bd75af5a950e375cad3ce53c">operator=</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:ab2ca7652bd75af5a950e375cad3ce53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:ab2ca7652bd75af5a950e375cad3ce53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8aa56257fec1b361de7c00c2222b5" id="r_ad4c8aa56257fec1b361de7c00c2222b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4c8aa56257fec1b361de7c00c2222b5">operator=</a> (std::initializer_list&lt; type_t &gt; &amp;<a class="el" href="#ab5d7c124db651f72d7f2b4971c5862f5">items</a>)</td></tr>
<tr class="memdesc:ad4c8aa56257fec1b361de7c00c2222b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist.  <br /></td></tr>
<tr class="separator:ad4c8aa56257fec1b361de7c00c2222b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c62871eef03c2d45676040e137e604" id="r_ac5c62871eef03c2d45676040e137e604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5c62871eef03c2d45676040e137e604">operator[]</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index) const override</td></tr>
<tr class="memdesc:ac5c62871eef03c2d45676040e137e604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index.  <br /></td></tr>
<tr class="separator:ac5c62871eef03c2d45676040e137e604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc74a419dc77ebae92d7a7aaa80c2249" id="r_afc74a419dc77ebae92d7a7aaa80c2249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc74a419dc77ebae92d7a7aaa80c2249">operator[]</a> (<a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index) override</td></tr>
<tr class="memdesc:afc74a419dc77ebae92d7a7aaa80c2249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index.  <br /></td></tr>
<tr class="separator:afc74a419dc77ebae92d7a7aaa80c2249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c15ccc5efbe20ca6656e87436036c3" id="r_a49c15ccc5efbe20ca6656e87436036c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49c15ccc5efbe20ca6656e87436036c3">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:a49c15ccc5efbe20ca6656e87436036c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a49c15ccc5efbe20ca6656e87436036c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eac9b62b7209d7ef1bda73d4b77c8a7" id="r_a3eac9b62b7209d7ef1bda73d4b77c8a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3eac9b62b7209d7ef1bda73d4b77c8a7">operator base_type &amp;</a> () noexcept</td></tr>
<tr class="memdesc:a3eac9b62b7209d7ef1bda73d4b77c8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a3eac9b62b7209d7ef1bda73d4b77c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7c8053e686383179fc57895fc0d3d9" id="r_aee7c8053e686383179fc57895fc0d3d9"><td class="memItemLeft" align="right" valign="top">type_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee7c8053e686383179fc57895fc0d3d9">operator()</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes)</td></tr>
<tr class="memdesc:aee7c8053e686383179fc57895fc0d3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array.  <br /></td></tr>
<tr class="separator:aee7c8053e686383179fc57895fc0d3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39c6f97b33ca7b85614188ce9443f72" id="r_ab39c6f97b33ca7b85614188ce9443f72"><td class="memItemLeft" align="right" valign="top">const type_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab39c6f97b33ca7b85614188ce9443f72">operator()</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes) const</td></tr>
<tr class="memdesc:ab39c6f97b33ca7b85614188ce9443f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array.  <br /></td></tr>
<tr class="separator:ab39c6f97b33ca7b85614188ce9443f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:a56e8d16cbfd4478600885c5ebbc0cb90" id="r_a56e8d16cbfd4478600885c5ebbc0cb90"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56e8d16cbfd4478600885c5ebbc0cb90">index_of</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>, const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a56e8d16cbfd4478600885c5ebbc0cb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the array specified.  <br /></td></tr>
<tr class="separator:a56e8d16cbfd4478600885c5ebbc0cb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d15bd70091aef74009040a66e96c7" id="r_ad62d15bd70091aef74009040a66e96c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad62d15bd70091aef74009040a66e96c7">index_of</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>, const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index)</td></tr>
<tr class="memdesc:ad62d15bd70091aef74009040a66e96c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the array specified.  <br /></td></tr>
<tr class="separator:ad62d15bd70091aef74009040a66e96c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ce2959fbb235a756ad16dd2a3f343e" id="r_ad5ce2959fbb235a756ad16dd2a3f343e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5ce2959fbb235a756ad16dd2a3f343e">index_of</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>, const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="#a2e50b538f5aa4913d3180fcee49499c2">count</a>)</td></tr>
<tr class="memdesc:ad5ce2959fbb235a756ad16dd2a3f343e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the array specified.  <br /></td></tr>
<tr class="separator:ad5ce2959fbb235a756ad16dd2a3f343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc2546d5b6d814fdebcd0318d76e91" id="r_ad1bc2546d5b6d814fdebcd0318d76e91"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1bc2546d5b6d814fdebcd0318d76e91">reverse</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>) noexcept</td></tr>
<tr class="memdesc:ad1bc2546d5b6d814fdebcd0318d76e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the entire <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a>.  <br /></td></tr>
<tr class="separator:ad1bc2546d5b6d814fdebcd0318d76e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5089c1fc7d9e8010517893f5cf4a946" id="r_af5089c1fc7d9e8010517893f5cf4a946"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5089c1fc7d9e8010517893f5cf4a946">reverse</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="classxtd_1_1array.html">array</a>, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> index, <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="#a2e50b538f5aa4913d3180fcee49499c2">count</a>)</td></tr>
<tr class="memdesc:af5089c1fc7d9e8010517893f5cf4a946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the specified range.  <br /></td></tr>
<tr class="separator:af5089c1fc7d9e8010517893f5cf4a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd11aa88ce86568b701b33fd1b3e508" id="r_a6bd11aa88ce86568b701b33fd1b3e508"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a6bd11aa88ce86568b701b33fd1b3e508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a6bd11aa88ce86568b701b33fd1b3e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a701628e47b725c0bc15400085d714" id="r_ad7a701628e47b725c0bc15400085d714"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1abstract__object.html#ad7a701628e47b725c0bc15400085d714">abstract_object</a> ()=default</td></tr>
<tr class="memdesc:ad7a701628e47b725c0bc15400085d714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1abstract__object.html" title="Represent an abstract class.">xtd::abstract_object</a> class.  <br /></td></tr>
<tr class="separator:ad7a701628e47b725c0bc15400085d714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8a186922544d50c32678dbeead9d34fe" name="a8a186922544d50c32678dbeead9d34fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a186922544d50c32678dbeead9d34fe">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array value type. </p>

</div>
</div>
<a id="a3e03acd94629ea4815cebbe14df6ce91" name="a3e03acd94629ea4815cebbe14df6ce91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e03acd94629ea4815cebbe14df6ce91">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array allocator type. </p>

</div>
</div>
<a id="ad277de2a42b4b0aba1c24eadf2edbe24" name="ad277de2a42b4b0aba1c24eadf2edbe24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad277de2a42b4b0aba1c24eadf2edbe24">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::base_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array base type. </p>

</div>
</div>
<a id="af9b44083298196790c9d898bf520828a" name="af9b44083298196790c9d898bf520828a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b44083298196790c9d898bf520828a">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array size type (usually <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::size</a>). </p>

</div>
</div>
<a id="a2c1c0a188f5cfd2673e9b90c0d300e3e" name="a2c1c0a188f5cfd2673e9b90c0d300e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1c0a188f5cfd2673e9b90c0d300e3e">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array difference type (usually <a class="el" href="group__types.html#gae3c4f13b0aabf2474d7c5b2e36aad317" title="Represent the signed integer type of the result of subtracting two pointers.">xtd::ptrdiff</a>). </p>

</div>
</div>
<a id="a6054c9522c7a58c05453b86e0c6f1913" name="a6054c9522c7a58c05453b86e0c6f1913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6054c9522c7a58c05453b86e0c6f1913">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the reference of array value type. </p>

</div>
</div>
<a id="a01a0d032eb60a2a8f0bdf84ba3fe1204" name="a01a0d032eb60a2a8f0bdf84ba3fe1204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const reference of array value type. </p>

</div>
</div>
<a id="a58756d2450f08851d601a29456ba4273" name="a58756d2450f08851d601a29456ba4273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58756d2450f08851d601a29456ba4273">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the pointer of array value type. </p>

</div>
</div>
<a id="a52835b4b627c5d7783f5d523aa265927" name="a52835b4b627c5d7783f5d523aa265927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52835b4b627c5d7783f5d523aa265927">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const pointer of array value type. </p>

</div>
</div>
<a id="ac5a69b60fa4687e14ec5c1180f7d7553" name="ac5a69b60fa4687e14ec5c1180f7d7553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a69b60fa4687e14ec5c1180f7d7553">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the iterator of array value type. </p>

</div>
</div>
<a id="a27d9a52e3c55ac56d32fd81c5d7d9cee" name="a27d9a52e3c55ac56d32fd81c5d7d9cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const iterator of array value type. </p>

</div>
</div>
<a id="a4ec840a621251f1d7ba5caab527f5e08" name="a4ec840a621251f1d7ba5caab527f5e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec840a621251f1d7ba5caab527f5e08">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the reverse iterator of array value type. </p>

</div>
</div>
<a id="a0160c4ae793de2de4a97ed5d6a0351f1" name="a0160c4ae793de2de4a97ed5d6a0351f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0160c4ae793de2de4a97ed5d6a0351f1">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const reverse iterator of array value type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad830194f7a76eec01d6bd96b1f3343bb" name="ad830194f7a76eec01d6bd96b1f3343bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad830194f7a76eec01d6bd96b1f3343bb">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="a52a1eac93ddf1500a9515fc560d7b572" name="a52a1eac93ddf1500a9515fc560d7b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a1eac93ddf1500a9515fc560d7b572">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="a7cb48e8ab13f64c2bbc8579286cdc33c" name="a7cb48e8ab13f64c2bbc8579286cdc33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb48e8ab13f64c2bbc8579286cdc33c">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a7acd2ad2fa08cf8fb94d254f70c91de3" name="a7acd2ad2fa08cf8fb94d254f70c91de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acd2ad2fa08cf8fb94d254f70c91de3">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="adb4978aa1d73aaf5e204cac3841ea866" name="adb4978aa1d73aaf5e204cac3841ea866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4978aa1d73aaf5e204cac3841ea866">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a23631ee443a12598cc846b128473312d" name="a23631ee443a12598cc846b128473312d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23631ee443a12598cc846b128473312d">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a2e50b538f5aa4913d3180fcee49499c2" name="a2e50b538f5aa4913d3180fcee49499c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e50b538f5aa4913d3180fcee49499c2">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of elements contained in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements contained in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Retrieving the value of this property is an O(1) operation; setting the property is an O(n) operation, where n is the new capacity. </dd></dl>

</div>
</div>
<a id="af95718ca09e080a530bb22ab7fc29928" name="af95718ca09e080a530bb22ab7fc29928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95718ca09e080a530bb22ab7fc29928">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </dd></dl>

</div>
</div>
<a id="ac14a4aeb972e3b0ad85bc83d4596dd03" name="ac14a4aeb972e3b0ad85bc83d4596dd03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14a4aeb972e3b0ad85bc83d4596dd03">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a5b5a9ce8373768ab8c68b261b33d5b6f" name="a5b5a9ce8373768ab8c68b261b33d5b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5a9ce8373768ab8c68b261b33d5b6f">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a58756d2450f08851d601a29456ba4273">pointer</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, the returned pointer compares equal to the address of the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer is such that range [<a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a>, <a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a> + <a class="el" href="#af2ad3488e28e4140835dece83723e7eb">xtd::array::size()</a>) is always a valid range, even if the container is empty (<a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a> is not dereferenceable in that case). </dd></dl>

</div>
</div>
<a id="a1405502cc9db3c5decf3d44c99fda34b" name="a1405502cc9db3c5decf3d44c99fda34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1405502cc9db3c5decf3d44c99fda34b">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a52835b4b627c5d7783f5d523aa265927">const_pointer</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, the returned pointer compares equal to the address of the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer is such that range [<a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a>, <a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a> + <a class="el" href="#af2ad3488e28e4140835dece83723e7eb">xtd::array::size()</a>) is always a valid range, even if the container is empty (<a class="el" href="#a5b5a9ce8373768ab8c68b261b33d5b6f">xtd::array::data()</a> is not dereferenceable in that case). </dd></dl>

</div>
</div>
<a id="a0ecdfcec3616cd38223715dd6f4df224" name="a0ecdfcec3616cd38223715dd6f4df224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecdfcec3616cd38223715dd6f4df224">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">xtd::array::begin()</a> == <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a69c2af41aeaa2af9847c1d6567df83c6" name="a69c2af41aeaa2af9847c1d6567df83c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c2af41aeaa2af9847c1d6567df83c6">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d9a52e3c55ac56d32fd81c5d7d9cee">const_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="aabb880053eba2eefbc54d5d312626586" name="aabb880053eba2eefbc54d5d312626586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb880053eba2eefbc54d5d312626586">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac5a69b60fa4687e14ec5c1180f7d7553">iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a2d8f87d8d029713510c61ba59d1858a0" name="a2d8f87d8d029713510c61ba59d1858a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8f87d8d029713510c61ba59d1858a0">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="ac754e2b8fe8c218619603f807d2dede6" name="ac754e2b8fe8c218619603f807d2dede6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac754e2b8fe8c218619603f807d2dede6">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="ab5d7c124db651f72d7f2b4971c5862f5" name="ab5d7c124db651f72d7f2b4971c5862f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d7c124db651f72d7f2b4971c5862f5">&#9670;&#160;</a></span>items() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="adfb7eadaa77baa15c8193de6af45eaec" name="adfb7eadaa77baa15c8193de6af45eaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb7eadaa77baa15c8193de6af45eaec">&#9670;&#160;</a></span>items() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="aaf70989e6cabeaccefd32e3b760753ef" name="aaf70989e6cabeaccefd32e3b760753ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf70989e6cabeaccefd32e3b760753ef">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a size that represents the total number of elements in all the dimensions of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>A size that represents the total number of elements in all the dimensions of the array; zero if there are no elements in the array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Retrieving the value of this property is an O(1) operation. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates methods to get the length of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a48551f7aa950699c881a79fdd70f4f39" name="a48551f7aa950699c881a79fdd70f4f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48551f7aa950699c881a79fdd70f4f39">&#9670;&#160;</a></span>long_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">xtd::int64</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::long_length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f" title="Represents a 64-bit signed integer.">int64</a> A 64-bit integer that represents the total number of elements in all the dimensions of the array; zero if there are no elements in the array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Retrieving the value of this property is an O(1) operation. </dd></dl>

</div>
</div>
<a id="a760f9d630aee4ee6076c5f1fb0ba412f" name="a760f9d630aee4ee6076c5f1fb0ba412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760f9d630aee4ee6076c5f1fb0ba412f">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">xtd::array::begin()</a>, <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a>) for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

</div>
</div>
<a id="a0f0e476086ae44f64d6ed64a8cfbfc73" name="a0f0e476086ae44f64d6ed64a8cfbfc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0e476086ae44f64d6ed64a8cfbfc73">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rank </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the rank (number of dimensions) of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>The rank (number of dimensions) of the array. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates methods to get the rank of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

<p>Reimplemented in <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; type_t, rank_, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; byte &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; item &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; item &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; type_t, 1, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array_3_01type__t_00_011_00_01allocator__t_01_4.html#ad5324486e5498e9173e929f53dfe95f8">xtd::array&lt; type_t, 1, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; type_t, 2, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array_3_01type__t_00_012_00_01allocator__t_01_4.html#a5cfd24ddc397b46a08ea0cc1044bf390">xtd::array&lt; type_t, 2, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; type_t, 3, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array_3_01type__t_00_013_00_01allocator__t_01_4.html#a5dacc6a3783b27ebe998d4008e46b177">xtd::array&lt; type_t, 3, allocator_t &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; value_type &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::array&lt; bool &gt; &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::array&lt; bool &gt; &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::array&lt; xtd::byte &gt; &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::basic_string&lt; char &gt; &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::byte &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::diagnostics::stack_frame &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::diagnostics::stack_frame &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::color &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::color &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::imaging::encoder_parameter &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::point &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::drawing::point &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::forms::shadow &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::forms::shadow &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::net::ip_address &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::size &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::size &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::string &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::string &gt;</a>, <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt; xtd::uint16 &gt;</a>, and <a class="el" href="classxtd_1_1array.html#a2580a0452fad2d6279b669977324fe11">xtd::array&lt;&gt;</a>.</p>

</div>
</div>
<a id="a9f34355f80375edca7538ed77d2bc431" name="a9f34355f80375edca7538ed77d2bc431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f34355f80375edca7538ed77d2bc431">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a4ec840a621251f1d7ba5caab527f5e08">reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </dd></dl>

</div>
</div>
<a id="a0d6f68bf56a69ac0b57970e6ba9441a2" name="a0d6f68bf56a69ac0b57970e6ba9441a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6f68bf56a69ac0b57970e6ba9441a2">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="#ab5c8b33119f80c64566c9c4fe307be46">xtd::array::rend()</a>. </dd></dl>

</div>
</div>
<a id="ab5c8b33119f80c64566c9c4fe307be46" name="ab5c8b33119f80c64566c9c4fe307be46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c8b33119f80c64566c9c4fe307be46">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a4ec840a621251f1d7ba5caab527f5e08">reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a3432941b86f8c8e7c78bcf7132843e6d" name="a3432941b86f8c8e7c78bcf7132843e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3432941b86f8c8e7c78bcf7132843e6d">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="af2ad3488e28e4140835dece83723e7eb" name="af2ad3488e28e4140835dece83723e7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ad3488e28e4140835dece83723e7eb">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. std::distance(<a class="el" href="#a7acd2ad2fa08cf8fb94d254f70c91de3">xtd::array::begin()</a>, <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="default_trace_listener_8cpp-example.html#a0">default_trace_listener.cpp</a>, <a class="el" href="environment_exit_8cpp-example.html#a0">environment_exit.cpp</a>, <a class="el" href="environment_program_exit_8cpp-example.html#a2">environment_program_exit.cpp</a>, <a class="el" href="ip_address_8cpp-example.html#a0">ip_address.cpp</a>, and <a class="el" href="main_8cpp-example.html#a0">main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a34472044617550faf939f05c223b6227" name="a34472044617550faf939f05c223b6227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34472044617550faf939f05c223b6227">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadefb8b17214889a16b31088e0131431" name="aadefb8b17214889a16b31088e0131431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadefb8b17214889a16b31088e0131431">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a659906a6f1060c2205d787b49bb129fc" name="a659906a6f1060c2205d787b49bb129fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659906a6f1060c2205d787b49bb129fc">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const type_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether an element is in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to be added to the end of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ff0322a96e0ed8a3c268fd8a3d4eca" name="a88ff0322a96e0ed8a3c268fd8a3d4eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ff0322a96e0ed8a3c268fd8a3d4eca">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; type_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">xtd::int64</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 64-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The one-dimensional array that is the destination of the elements copied from the current array. </td></tr>
    <tr><td class="paramname">index</td><td>A 64-bit integer that represents the index in array at which copying begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`array` is multidimensional. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is outside the range of valid indexes for array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391534692d321eadc7a5810486c16650" name="a391534692d321eadc7a5810486c16650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391534692d321eadc7a5810486c16650">&#9670;&#160;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified object is equal to the current object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to compare with the current object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified object is equal to the current object. otherwise, <code>false</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example compares the current instance with another object. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> object1 = <a class="code hl_function" href="group__xtd__core.html#ga2fd68f03198b2bf84b1e93149494b685">new_ptr&lt;object&gt;</a>();</div>
<div class="line">  <span class="keyword">auto</span> object2 = <a class="code hl_function" href="group__xtd__core.html#ga2fd68f03198b2bf84b1e93149494b685">new_ptr&lt;object&gt;</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> object3 = object2;</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(object1-&gt;equals(*object3));</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(*object1 == *object3);</div>
<div class="line">  object3 = object1;</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(object1-&gt;equals(*object3));</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(*object1 == *object3);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="agroup__xtd__core_html_ga2fd68f03198b2bf84b1e93149494b685"><div class="ttname"><a href="group__xtd__core.html#ga2fd68f03198b2bf84b1e93149494b685">xtd::new_ptr</a></div><div class="ttdeci">ptr&lt; type_t &gt; new_ptr(args_t &amp;&amp;... args)</div><div class="ttdoc">The xtd::new_ptr operator creates a xtd::ptr object.</div><div class="ttdef"><b>Definition</b> new_ptr.hpp:24</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> abstract_object.hpp:8</div></div>
</div><!-- fragment --> </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">xtd::object</a>.</p>

</div>
</div>
<a id="a92ef003c8174b830377e38610e743e4f" name="a92ef003c8174b830377e38610e743e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ef003c8174b830377e38610e743e4f">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the value to all elements in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to assign to the elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4132e3affe66da23dc58780f520124e2" name="a4132e3affe66da23dc58780f520124e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4132e3affe66da23dc58780f520124e2">&#9670;&#160;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total number of elements in all the dimensions of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>A zero-based dimension of the array whose length needs to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of elements in all the dimensions of the array; zero if there are no elements in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`dimension` is equal to or greater than <a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73" title="Gets the rank (number of dimensions) of the array.">xtd::basic_array::rank</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates methods to get the length of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a06fe84abedf478ba9a5059c08b7ff020" name="a06fe84abedf478ba9a5059c08b7ff020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fe84abedf478ba9a5059c08b7ff020">&#9670;&#160;</a></span>get_long_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">xtd::int64</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_long_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>A zero-based dimension of the array whose length needs to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit integer that represents the total number of elements in all the dimensions of the array; zero if there are no elements in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`dimension` is equal to or greater than <a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73" title="Gets the rank (number of dimensions) of the array.">xtd::basic_array::rank</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates methods to get the length of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6ac6c2f6144b73e261745e2bec9f6771" name="a6ac6c2f6144b73e261745e2bec9f6771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac6c2f6144b73e261745e2bec9f6771">&#9670;&#160;</a></span>get_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the lower bound of the specified dimension in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>A zero-based dimension of the array whose lower bound needs to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lower bound of the specified dimension in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`dimension` is equal to or greater than <a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73" title="Gets the rank (number of dimensions) of the array.">xtd::basic_array::rank</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example uses <a class="el" href="#a6ac6c2f6144b73e261745e2bec9f6771">xtd::array::get_lower_bound</a> and <a class="el" href="#ab74ed5a54361b742c7e27ff7b180a986">xtd::array::get_upper_bound</a> to initialize a one-dimensional array and a multidimensional array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab74ed5a54361b742c7e27ff7b180a986" name="ab74ed5a54361b742c7e27ff7b180a986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74ed5a54361b742c7e27ff7b180a986">&#9670;&#160;</a></span>get_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the upper bound of the specified dimension in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>A zero-based dimension of the array whose upper bound needs to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The upper bound of the specified dimension in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`dimension` is equal to or greater than <a class="el" href="#a0f0e476086ae44f64d6ed64a8cfbfc73" title="Gets the rank (number of dimensions) of the array.">xtd::basic_array::rank</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example uses <a class="el" href="#a6ac6c2f6144b73e261745e2bec9f6771">xtd::array::get_lower_bound</a> and <a class="el" href="#ab74ed5a54361b742c7e27ff7b180a986">xtd::array::get_upper_bound</a> to initialize a one-dimensional array and a multidimensional array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a21516522b32f0b1a6f92ab99d7cf271c" name="a21516522b32f0b1a6f92ab99d7cf271c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21516522b32f0b1a6f92ab99d7cf271c">&#9670;&#160;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indexes</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value at the specified position in the multidimensional array. The indexes are specified as 32-bit integers array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>An array that represents the position of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified position in the multidimensional array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `indexes` is outside the range of valid indexes for the corresponding dimension of the current array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63ff23cf9bbd59f42928e36dcc042425" name="a63ff23cf9bbd59f42928e36dcc042425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff23cf9bbd59f42928e36dcc042425">&#9670;&#160;</a></span>index_of() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const type_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the index of a specific item in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to locate in the <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of value if found in the array; otherwise, xtd::collections::generic::ilist::npos. </dd></dl>

</div>
</div>
<a id="a795fd3bff66d49a57311b81cf697953f" name="a795fd3bff66d49a57311b81cf697953f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795fd3bff66d49a57311b81cf697953f">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>new_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>. / @param new_size The new size of the container. / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> If</code>new_size<code>is outside greather than <a class="el" href="#a760f9d630aee4ee6076c5f1fb0ba412f">xtd::array::max_size</a>. / @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. / @remarks If the current size is less than</code>count`, additional default-inserted elements are appended. void resize(size_type new_size) {resize(new_size, <a class="el" href="#a8a186922544d50c32678dbeead9d34fe" title="Represents the array value type.">value_type</a> {});}. </p>
<p>/ Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>. @param new_size The new size of the container. @param value The value to initialize the new elements with. @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> If</code>new_size<code>is outside greather than <a class="el" href="#a760f9d630aee4ee6076c5f1fb0ba412f">xtd::array::max_size</a>. @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. @remarks If the current size is less than</code>count`, additional default-inserted elements are appended. </p>

</div>
</div>
<a id="a16b80cc0f2926f2b4fcfb5f5c1346eb7" name="a16b80cc0f2926f2b4fcfb5f5c1346eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b80cc0f2926f2b4fcfb5f5c1346eb7">&#9670;&#160;</a></span>set_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::set_value </td>
          <td>(</td>
          <td class="paramtype">const type_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indexes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a value to the element at the specified position in the multidimensional array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new value for the specified element. </td></tr>
    <tr><td class="paramname">indexes</td><td>An array that represents the position of the element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>Either `indexes` is outside the range of valid indexes for the current array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac29d8f865aaa14d1f3ce4ae201fdf1b5" name="ac29d8f865aaa14d1f3ce4ae201fdf1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29d8f865aaa14d1f3ce4ae201fdf1b5">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents and capacity of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </p>
<dl class="section remark"><dt>Remarks</dt><dd>All iterators and references remain valid. The <a class="el" href="#aabb880053eba2eefbc54d5d312626586">xtd::array::end()</a> iterator is invalidated. </dd></dl>

</div>
</div>
<a id="ac4ec27387ef0582948fc499fde1eba65" name="ac4ec27387ef0582948fc499fde1eba65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ec27387ef0582948fc499fde1eba65">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__strings.html#ga2bd6ab53224f55d280a88872353123eb">xtd::string</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="group__strings.html#ga2bd6ab53224f55d280a88872353123eb" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object. </p>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the current object. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates what to_string returns. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>examples {</div>
<div class="line">  <span class="keyword">namespace </span>object_test {</div>
<div class="line">    <span class="keyword">class </span>object1 : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_typedef" href="group__types.html#gabe4e3c1a0746e729140994ae7098d6e9">ptr&lt;object&gt;</a> obj1 = <a class="code hl_function" href="group__xtd__core.html#ga2fd68f03198b2bf84b1e93149494b685">new_ptr&lt;examples::object_test::object1&gt;</a>();</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(obj1-&gt;to_string());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="group__types.html#gabe4e3c1a0746e729140994ae7098d6e9">ptr&lt;object&gt;</a> obj2 = <a class="code hl_function" href="group__xtd__core.html#ga2fd68f03198b2bf84b1e93149494b685">new_ptr&lt;date_time&gt;</a>(1971, 1, 5, 23, 5, 0);</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(obj2-&gt;to_string());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="group__types.html#gabe4e3c1a0746e729140994ae7098d6e9">ptr&lt;object&gt;</a> obj3 = <a class="code hl_function" href="group__xtd__core.html#ga2fd68f03198b2bf84b1e93149494b685">new_ptr&lt;boolean_object&gt;</a>();</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(obj3-&gt;to_string());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// examples::object_test::object1</span></div>
<div class="line"><span class="comment">// Tue Jan  5 23:05:00 1971</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
<div class="ttc" id="agroup__types_html_gabe4e3c1a0746e729140994ae7098d6e9"><div class="ttname"><a href="group__types.html#gabe4e3c1a0746e729140994ae7098d6e9">xtd::ptr</a></div><div class="ttdeci">xtd::sptr&lt; type_t &gt; ptr</div><div class="ttdoc">The xtd::ptr object is a shared pointer.</div><div class="ttdef"><b>Definition</b> ptr.hpp:27</div></div>
</div><!-- fragment --> </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">xtd::object</a>.</p>

</div>
</div>
<a id="a56e8d16cbfd4478600885c5ebbc0cb90" name="a56e8d16cbfd4478600885c5ebbc0cb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e8d16cbfd4478600885c5ebbc0cb90">&#9670;&#160;</a></span>index_of() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the index of a specific item in the array specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">value</td><td>The object to locate in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> The index of value if found in the array; otherwise, -1. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to determine the index of the first occurrence of a specified element. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad62d15bd70091aef74009040a66e96c7" name="ad62d15bd70091aef74009040a66e96c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62d15bd70091aef74009040a66e96c7">&#9670;&#160;</a></span>index_of() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the index of a specific item in the array specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">value</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">index</td><td>The zero-based starting index of the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> The index of value if found in the array; otherwise, -1. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>The parameters `index` is less than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to determine the index of the first occurrence of a specified element. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad5ce2959fbb235a756ad16dd2a3f343e" name="ad5ce2959fbb235a756ad16dd2a3f343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ce2959fbb235a756ad16dd2a3f343e">&#9670;&#160;</a></span>index_of() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the index of a specific item in the array specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">value</td><td>The object to locate in the array. </td></tr>
    <tr><td class="paramname">index</td><td>The zero-based starting index of the search. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the section to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> The index of value if found in the array; otherwise, -1. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>The parameters `index` and `count` do not specify a valid section in the 'array'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to determine the index of the first occurrence of a specified element. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad1bc2546d5b6d814fdebcd0318d76e91" name="ad1bc2546d5b6d814fdebcd0318d76e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bc2546d5b6d814fdebcd0318d76e91">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the elements in the entire <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method uses std::reverse to reverse the order of the elements, such that the element at <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a> &lt;type_t&gt;[i], where <code>i</code> is any index within the range, moves to <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a> &lt;type_t&gt;[j], where <code>j</code> equals index plus index plus count minus <code>i</code> minus 1. </dd>
<dd>
This method is an O(n) operation, where n is <a class="el" href="#a2e50b538f5aa4913d3180fcee49499c2" title="Gets the number of elements contained in the xtd::array &lt;type_t&gt;.">xtd::basic_array::count</a>. </dd></dl>

</div>
</div>
<a id="af5089c1fc7d9e8010517893f5cf4a946" name="af5089c1fc7d9e8010517893f5cf4a946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5089c1fc7d9e8010517893f5cf4a946">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the elements in the specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The zero-based starting index of the range to reverse. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the range to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` and `count` do not denote a valid range of elements in the <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method uses std::reverse to reverse the order of the elements, such that the element at <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a> &lt;type_t&gt;[i], where <code>i</code> is any index within the range, moves to <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a> &lt;type_t&gt;[j], where <code>j</code> equals index plus index plus count minus <code>i</code> minus 1. </dd>
<dd>
This method is an O(n) operation, where n is <code>count</code>. </dd></dl>

</div>
</div>
<a id="a9ca38a735b49019beb5e5f14ab8d4ac1" name="a9ca38a735b49019beb5e5f14ab8d4ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca38a735b49019beb5e5f14ab8d4ac1">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ab2ca7652bd75af5a950e375cad3ce53c" name="ab2ca7652bd75af5a950e375cad3ce53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ca7652bd75af5a950e375cad3ce53c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a>&lt; type_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another base type container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ad4c8aa56257fec1b361de7c00c2222b5" name="ad4c8aa56257fec1b361de7c00c2222b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c8aa56257fec1b361de7c00c2222b5">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; type_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list ilist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>Initializer list to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ac5c62871eef03c2d45676040e137e604" name="ac5c62871eef03c2d45676040e137e604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c62871eef03c2d45676040e137e604">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If pos is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc74a419dc77ebae92d7a7aaa80c2249" name="afc74a419dc77ebae92d7a7aaa80c2249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc74a419dc77ebae92d7a7aaa80c2249">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6054c9522c7a58c05453b86e0c6f1913">reference</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49c15ccc5efbe20ca6656e87436036c3" name="a49c15ccc5efbe20ca6656e87436036c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c15ccc5efbe20ca6656e87436036c3">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator const <a class="el" href="#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a3eac9b62b7209d7ef1bda73d4b77c8a7" name="a3eac9b62b7209d7ef1bda73d4b77c8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eac9b62b7209d7ef1bda73d4b77c8a7">&#9670;&#160;</a></span>operator base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator <a class="el" href="#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="aee7c8053e686383179fc57895fc0d3d9" name="aee7c8053e686383179fc57895fc0d3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7c8053e686383179fc57895fc0d3d9">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">type_t &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indexes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>An array that represents the multidimension index of the array element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified position in the multidimensional array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>Either each index is outside the range of valid indexes for the corresponding dimension of the current array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use operator [] to list the elements of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab39c6f97b33ca7b85614188ce9443f72" name="ab39c6f97b33ca7b85614188ce9443f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39c6f97b33ca7b85614188ce9443f72">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const type_t &amp; <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indexes</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>An array that represents the multidimension index of the array element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified position in the multidimensional array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>Either each index is outside the range of valid indexes for the corresponding dimension of the current array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use operator [] to list the elements of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a53b8d655a996e1eb424894548a9ed2da" name="a53b8d655a996e1eb424894548a9ed2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b8d655a996e1eb424894548a9ed2da">&#9670;&#160;</a></span>npos</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t, class allocator_t = xtd::collections::generic::helpers::allocator&lt;type_to_array_t&lt;type_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9b44083298196790c9d898bf520828a">size_type</a> <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::npos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a special value equal to the maximum value representable by the type <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::size</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/<a class="el" href="basic__array_8hpp_source.html">basic_array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 17 2025 21:22:58 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
