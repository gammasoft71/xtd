<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections.html">collections</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections_1_1generic.html">generic</a></li><li class="navelem"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classxtd_1_1collections_1_1generic_1_1dictionary-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__collections.html">collections</a> &raquo; <a class="el" href="group__generic__collections.html">generic</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1collections_1_1generic_1_1dictionary.png" usemap="#xtd::collections::generic::dictionary_3C_20key_5Ft_2C_20value_5Ft_2C_20hasher_5Ft_2C_20equator_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::collections::generic::dictionary_3C_20key_5Ft_2C_20value_5Ft_2C_20hasher_5Ft_2C_20equator_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::collections::generic::dictionary_3C_20key_5Ft_2C_20value_5Ft_2C_20hasher_5Ft_2C_20equator_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,56,558,80"/>
<area href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs." alt="xtd::collections::generic::idictionary&lt; key_t, value_t &gt;" shape="rect" coords="568,56,1126,80"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt;<br />
class xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;</div><p>Represents a collection of keys and values. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> key_t, <span class="keyword">class</span> value_t, <span class="keyword">class</span> hasher_t = xtd::collections::<span class="keyword">generic</span>::helpers::hasher&lt;key_t&gt;, <span class="keyword">class </span>equator_t = <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1helpers_1_1equator.html">xtd::collections::generic::helpers::equator&lt;key_t&gt;</a>, <span class="keyword">class </span>allocator_t = <a class="code hl_typedef" href="group__helpers__generic__collections.html#gab599dabbf34e1e5238de4589ab6614b9">xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;</a>&gt;&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a>, <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;key_t, value_t&gt;;</div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html_a50b15016f1b91a266a8beec12ab89584"><div class="ttname"><a href="#a50b15016f1b91a266a8beec12ab89584">xtd::collections::generic::dictionary::dictionary</a></div><div class="ttdeci">dictionary() noexcept=default</div><div class="ttdoc">Initializes a new instance of the xtd::collections::generic::dictionary &lt;key_t, value_t&gt; class that i...</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1idictionary_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a></div><div class="ttdoc">Represents a generic collection of key/value pairs.</div><div class="ttdef"><b>Definition</b> idictionary.hpp:44</div></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
<div class="ttc" id="agroup__helpers__generic__collections_html_gab599dabbf34e1e5238de4589ab6614b9"><div class="ttname"><a href="group__helpers__generic__collections.html#gab599dabbf34e1e5238de4589ab6614b9">xtd::collections::generic::helpers::allocator</a></div><div class="ttdeci">std::allocator&lt; type_t &gt; allocator</div><div class="ttdoc">Represent an allocator alias.</div><div class="ttdef"><b>Definition</b> allocator.hpp:38</div></div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1helpers_1_1equator_html"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1helpers_1_1equator.html">xtd::collections::generic::helpers::equator</a></div><div class="ttdoc">Implements a function object for performing comparisons. Unless specialised, invokes operator== on ty...</div><div class="ttdef"><b>Definition</b> equator.hpp:38</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/dictionary&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1collections_1_1generic.html" title="The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...">xtd::collections::generic</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example creates an empty <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; of strings with string keys and uses the Add method to add some elements. The example demonstrates that the <a class="el" href="#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method throws an <a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a> when attempting to add a duplicate key.</dd></dl>
<p>The example uses the xtd::collections::generic::dictionary::operator [] to retrieve values, demonstrating that a <a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a> is thrown when a requested key is not present, and showing that the value associated with a key can be replaced.</p>
<p>The example shows how to use the xtd::collections::generic::dictionary::try_get_vValue method as a more efficient way to retrieve values if a program often must try key values that are not in the dictionary, and it shows how to use the <a class="el" href="#acf27b6ece343e1dd7450de296277f892" title="Determines whether the xtd::collections::generic::dictionary &lt;key_t, value_t&gt; contains the specified ...">xtd::collections::generic::dictionary::contains_key</a> method to test whether a key exists before calling the <a class="el" href="#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method.</p>
<p>The example shows how to enumerate the keys and values in the dictionary and how to enumerate the keys and values alone using the <a class="el" href="#ac2a9b4d312798abd41548c6c97ee3312" title="Gets a collection containing the keys in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::keys</a> property and the <a class="el" href="#aa5519d6518ce9849e89b90fd573839f2" title="Gets a collection containing the values in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::values</a> property.</p>
<p>Finally, the example demonstrates the <a class="el" href="#a73cb9a204619fd297fb77f09b86b4b29" title="Removes the value with the specified key from the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::remove</a> method. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>example {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="comment">// Create a new dictionary of strings, with string keys.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keyword">auto</span> open_with = <a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary&lt;string, string&gt;</a> {};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add some elements to the dictionary. There are no</span></div>
<div class="line">    <span class="comment">// duplicate keys, but some of the values are duplicates.</span></div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;notepad.exe&quot;</span>);</div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;bmp&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;dib&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;rtf&quot;</span>, <span class="stringliteral">&quot;wordpad.exe&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The Add method throws an exception if the new key is</span></div>
<div class="line">    <span class="comment">// already in the dictionary.</span></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      open_with.add(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;winword.exe&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1argument__exception.html">argument_exception</a>&amp;) {</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;An element with key = \&quot;txt\&quot; already exists.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The operator [] is another name for the indexer, so you</span></div>
<div class="line">    <span class="comment">// can omit its name when accessing elements.</span></div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;For key = \&quot;rtf\&quot;, value = {0}.&quot;</span>, open_with[<span class="stringliteral">&quot;rtf&quot;</span>]);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The indexer can be used to change the value associated with a key.</span></div>
<div class="line">    open_with[<span class="stringliteral">&quot;rtf&quot;</span>] = <span class="stringliteral">&quot;winword.exe&quot;</span>;</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;For key = \&quot;rtf\&quot;, value = {0}.&quot;</span>, open_with[<span class="stringliteral">&quot;rtf&quot;</span>]);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// If a key does not exist, setting the indexer for that key</span></div>
<div class="line">    <span class="comment">// adds a new key/value pair.</span></div>
<div class="line">    open_with[<span class="stringliteral">&quot;doc&quot;</span>] = <span class="stringliteral">&quot;winword.exe&quot;</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The indexer throws an exception if the requested key is not in the dictionary.</span></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;For key = \&quot;tif\&quot;, value = {0}.&quot;</span>, open_with[<span class="stringliteral">&quot;tif&quot;</span>]);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html">key_not_found_exception</a>&amp;) {</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;key = \&quot;tif\&quot; is not found.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// When a program often has to try keys that turn out not to</span></div>
<div class="line">    <span class="comment">// be in the dictionary, try_get_value can be a more efficient</span></div>
<div class="line">    <span class="comment">// way to retrieve values.</span></div>
<div class="line">    <span class="keyword">auto</span> value = <span class="stringliteral">&quot;&quot;</span>_s;</div>
<div class="line">    <span class="keywordflow">if</span> (open_with.try_get_value(<span class="stringliteral">&quot;tif&quot;</span>, value))</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;For key = \&quot;tif\&quot;, value = {0}.&quot;</span>, value);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;key = \&quot;tif\&quot; is not found.&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// contains_key can be used to test keys before inserting them.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!open_with.contains_key(<span class="stringliteral">&quot;ht&quot;</span>)) {</div>
<div class="line">      open_with.add(<span class="stringliteral">&quot;ht&quot;</span>, <span class="stringliteral">&quot;hypertrm.exe&quot;</span>);</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;value added for key = \&quot;ht\&quot;: {0}&quot;</span>, open_with[<span class="stringliteral">&quot;ht&quot;</span>]);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// When you use for each to enumerate dictionary elements,</span></div>
<div class="line">    <span class="comment">// the elements are retrieved as key_value_pair objects.</span></div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> key_value_pair&lt;string, string&gt;&amp; kvp : open_with)</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;key = {0}, value = {1}&quot;</span>, kvp.key(), kvp.value());</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// To get the values alone, use the values property.</span></div>
<div class="line">    dictionary&lt;string, string&gt;::value_collection values = open_with.values();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The elements of the value_collection are strongly typed</span></div>
<div class="line">    <span class="comment">// with the type that was specified for dictionary values.</span></div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : values)</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;value = {0}&quot;</span>, s);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// To get the keys alone, use the keys property.</span></div>
<div class="line">    dictionary&lt;string, string&gt;::key_collection <a class="code hl_enumeration" href="group__xtd__forms.html#ga2f00c1ad108efaddc951106e768970de">keys</a> = open_with.keys();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The elements of the key_collection are strongly typed</span></div>
<div class="line">    <span class="comment">// with the type that was specified for dictionary keys.</span></div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; s : keys)</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;key = {0}&quot;</span>, s);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Use the remove method to remove a key/value pair.</span></div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;\nRemove(\&quot;doc\&quot;)&quot;</span>);</div>
<div class="line">    open_with.remove(<span class="stringliteral">&quot;doc&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (!open_with.contains_key(<span class="stringliteral">&quot;doc&quot;</span>))</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;key \&quot;doc\&quot; is not found.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(example::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// An element with key = &quot;txt&quot; already exists.</span></div>
<div class="line"><span class="comment">// For key = &quot;rtf&quot;, value = wordpad.exe.</span></div>
<div class="line"><span class="comment">// For key = &quot;rtf&quot;, value = winword.exe.</span></div>
<div class="line"><span class="comment">// key = &quot;tif&quot; is not found.</span></div>
<div class="line"><span class="comment">// key = &quot;tif&quot; is not found.</span></div>
<div class="line"><span class="comment">// value added for key = &quot;ht&quot;: hypertrm.exe</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// key = doc, value = winword.exe</span></div>
<div class="line"><span class="comment">// key = rtf, value = winword.exe</span></div>
<div class="line"><span class="comment">// key = bmp, value = paint.exe</span></div>
<div class="line"><span class="comment">// key = ht, value = hypertrm.exe</span></div>
<div class="line"><span class="comment">// key = dib, value = paint.exe</span></div>
<div class="line"><span class="comment">// key = txt, value = notepad.exe</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// value = winword.exe</span></div>
<div class="line"><span class="comment">// value = winword.exe</span></div>
<div class="line"><span class="comment">// value = paint.exe</span></div>
<div class="line"><span class="comment">// value = hypertrm.exe</span></div>
<div class="line"><span class="comment">// value = paint.exe</span></div>
<div class="line"><span class="comment">// value = notepad.exe</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// key = doc</span></div>
<div class="line"><span class="comment">// key = rtf</span></div>
<div class="line"><span class="comment">// key = bmp</span></div>
<div class="line"><span class="comment">// key = ht</span></div>
<div class="line"><span class="comment">// key = dib</span></div>
<div class="line"><span class="comment">// key = txt</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Remove(&quot;doc&quot;)</span></div>
<div class="line"><span class="comment">// key &quot;doc&quot; is not found.</span></div>
<div class="ttc" id="aclassxtd_1_1argument__exception_html"><div class="ttname"><a href="classxtd_1_1argument__exception.html">xtd::argument_exception</a></div><div class="ttdoc">The exception that is thrown when one of the arguments provided to a method is not valid.</div><div class="ttdef"><b>Definition</b> argument_exception.hpp:23</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1key__not__found__exception_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html">xtd::collections::generic::key_not_found_exception</a></div><div class="ttdoc">The exception that is thrown when the key specified for accessing an element in a collection does not...</div><div class="ttdef"><b>Definition</b> key_not_found_exception.hpp:31</div></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.hpp:168</div></div>
<div class="ttc" id="agroup__xtd__forms_html_ga2f00c1ad108efaddc951106e768970de"><div class="ttname"><a href="group__xtd__forms.html#ga2f00c1ad108efaddc951106e768970de">xtd::forms::keys</a></div><div class="ttdeci">keys</div><div class="ttdoc">Specifies key codes and modifiers.</div><div class="ttdef"><b>Definition</b> keys.hpp:77</div></div>
<div class="ttc" id="anamespacextd_1_1collections_1_1generic_html"><div class="ttname"><a href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a></div><div class="ttdoc">The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...</div><div class="ttdef"><b>Definition</b> comparer.hpp:16</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> abstract_object.hpp:8</div></div>
</div><!-- fragment --> <dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; generic class provides a mapping from a set of keys to a set of values. Each addition to the dictionary consists of a value and its associated key. Retrieving a value by using its key is very fast, close to O(1), because the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class is implemented as a hash table. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The speed of retrieval depends on the quality of the hashing algorithm of the type specified for <code>key_t</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>As long as an object is used as a key in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, it must not change in any way that affects its hash value. Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the dictionary's equality comparer. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. You can specify an implementation of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; generic interface by using a constructor that accepts a comparer parameter; if you do not specify an implementation, the default generic equality comparer <a class="el" href="classxtd_1_1collections_1_1generic_1_1equality__comparer.html#a5849423379f7c39750a1713ba8c44e35" title="Gets the default equality comparer for the type specified by the generic argument.">xtd::collections::generic::equality_comparer&lt;type_t&gt;::default_equality_comparer</a> is used. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For example, you can use the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga9ced0825ee1591c057bcf9460a74348f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class to create dictionaries with case-insensitive string keys. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can hold. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
For purposes of enumeration, each item in the dictionary is treated as a <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> &lt;key_t, value_t&gt; structure representing a value and its key. The order in which the items are returned is undefined. </dd>
<dd>
The for each statement returns an object of the type of the elements in the collection. Since the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is a collection of keys and values, the element type is not the type of the key or the type of the value. Instead, the element type is a <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> &lt;key_t, value_t&gt; of the key type and the value type. For example: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair&lt;string, string&gt;</a>&amp; kvp : my_dictionary)</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;key = {}, value = {}&quot;</span>, kvp.key(), kvp.value());</div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1key__value__pair_html"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a></div><div class="ttdoc">Defines a key/value pair that can be set or retrieved.</div><div class="ttdef"><b>Definition</b> key_value_pair.hpp:37</div></div>
</div><!-- fragment --> </dd>
<dd>
Or with <code>auto</code> key type and the value type. For example: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [key, value] : my_dictionary)</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;key = {}, value = {}&quot;</span>, key, value);</div>
</div><!-- fragment --> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1equator.html">equator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary equator type.  <a href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1equator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html">hasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary hasher type.  <a href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:a01385837c5b1f6254a863510f5e490f1" id="r_a01385837c5b1f6254a863510f5e490f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01385837c5b1f6254a863510f5e490f1">key_type</a></td></tr>
<tr class="memdesc:a01385837c5b1f6254a863510f5e490f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary key type.  <br /></td></tr>
<tr class="separator:a01385837c5b1f6254a863510f5e490f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef5542e936e56a3a8fd89f05f83c80f" id="r_adef5542e936e56a3a8fd89f05f83c80f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adef5542e936e56a3a8fd89f05f83c80f">mapped_type</a></td></tr>
<tr class="memdesc:adef5542e936e56a3a8fd89f05f83c80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary mapped type.  <br /></td></tr>
<tr class="separator:adef5542e936e56a3a8fd89f05f83c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2299afc830434c0a0ea06da8c6ce163" id="r_ae2299afc830434c0a0ea06da8c6ce163"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a></td></tr>
<tr class="memdesc:ae2299afc830434c0a0ea06da8c6ce163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary value type.  <br /></td></tr>
<tr class="separator:ae2299afc830434c0a0ea06da8c6ce163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af564e40d9fd72f4ad84f8e5ae62f4610" id="r_af564e40d9fd72f4ad84f8e5ae62f4610"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td></tr>
<tr class="memdesc:af564e40d9fd72f4ad84f8e5ae62f4610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary size type.  <br /></td></tr>
<tr class="separator:af564e40d9fd72f4ad84f8e5ae62f4610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f561b6c8f20e4e5f9c8cf73dfbbcc5" id="r_ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6f561b6c8f20e4e5f9c8cf73dfbbcc5">difference_type</a></td></tr>
<tr class="memdesc:ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary difference type.  <br /></td></tr>
<tr class="separator:ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6112bd0a235323e439c6a230e3fb76" id="r_a1d6112bd0a235323e439c6a230e3fb76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d6112bd0a235323e439c6a230e3fb76">key_equal</a></td></tr>
<tr class="memdesc:a1d6112bd0a235323e439c6a230e3fb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary <a class="el" href="#a1d6112bd0a235323e439c6a230e3fb76" title="Represents the dictionary key_equal type.">key_equal</a> type.  <br /></td></tr>
<tr class="separator:a1d6112bd0a235323e439c6a230e3fb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d7f951247c504df41d30e51f987394" id="r_ad1d7f951247c504df41d30e51f987394"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a></td></tr>
<tr class="memdesc:ad1d7f951247c504df41d30e51f987394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary allocator type.  <br /></td></tr>
<tr class="separator:ad1d7f951247c504df41d30e51f987394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57e3de24c35cf6d309f983e5f907a3e" id="r_aa57e3de24c35cf6d309f983e5f907a3e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a></td></tr>
<tr class="memdesc:aa57e3de24c35cf6d309f983e5f907a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary base value type.  <br /></td></tr>
<tr class="separator:aa57e3de24c35cf6d309f983e5f907a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4635f1586a55cca04619e6b4d25322f2" id="r_a4635f1586a55cca04619e6b4d25322f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4635f1586a55cca04619e6b4d25322f2">base_type</a></td></tr>
<tr class="memdesc:a4635f1586a55cca04619e6b4d25322f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary base type.  <br /></td></tr>
<tr class="separator:a4635f1586a55cca04619e6b4d25322f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f55af09de680f0014615c3d4c4a2915" id="r_a1f55af09de680f0014615c3d4c4a2915"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f55af09de680f0014615c3d4c4a2915">reference</a></td></tr>
<tr class="memdesc:a1f55af09de680f0014615c3d4c4a2915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary reference type.  <br /></td></tr>
<tr class="separator:a1f55af09de680f0014615c3d4c4a2915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b6e59722145f09a8b59f06d94c9601" id="r_ad8b6e59722145f09a8b59f06d94c9601"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8b6e59722145f09a8b59f06d94c9601">const_reference</a></td></tr>
<tr class="memdesc:ad8b6e59722145f09a8b59f06d94c9601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary const reference type.  <br /></td></tr>
<tr class="separator:ad8b6e59722145f09a8b59f06d94c9601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d6778084f8d0bca3efbbeb5c08829e" id="r_ad7d6778084f8d0bca3efbbeb5c08829e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7d6778084f8d0bca3efbbeb5c08829e">pointer</a></td></tr>
<tr class="memdesc:ad7d6778084f8d0bca3efbbeb5c08829e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary pointer type.  <br /></td></tr>
<tr class="separator:ad7d6778084f8d0bca3efbbeb5c08829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bd4b302354f97388d4e4e80fa07e6a" id="r_ad2bd4b302354f97388d4e4e80fa07e6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2bd4b302354f97388d4e4e80fa07e6a">const_pointer</a></td></tr>
<tr class="memdesc:ad2bd4b302354f97388d4e4e80fa07e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary const pointer type.  <br /></td></tr>
<tr class="separator:ad2bd4b302354f97388d4e4e80fa07e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792954eea61dc2cf8315606d042dd18d" id="r_a792954eea61dc2cf8315606d042dd18d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a></td></tr>
<tr class="memdesc:a792954eea61dc2cf8315606d042dd18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:a792954eea61dc2cf8315606d042dd18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbff355e29f8facb171c94084884625" id="r_abbbff355e29f8facb171c94084884625"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td></tr>
<tr class="memdesc:abbbff355e29f8facb171c94084884625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:abbbff355e29f8facb171c94084884625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc966a9b4269ce145604c61eace7f57c" id="r_adc966a9b4269ce145604c61eace7f57c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc966a9b4269ce145604c61eace7f57c">local_iterator</a></td></tr>
<tr class="memdesc:adc966a9b4269ce145604c61eace7f57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the local iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:adc966a9b4269ce145604c61eace7f57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259c368e0dff747a4e4687d94d0ca8e0" id="r_a259c368e0dff747a4e4687d94d0ca8e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a></td></tr>
<tr class="memdesc:a259c368e0dff747a4e4687d94d0ca8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const local iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:a259c368e0dff747a4e4687d94d0ca8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ebfcd509b5c4d473ec9ab61bed6e85" id="r_a09ebfcd509b5c4d473ec9ab61bed6e85"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a></td></tr>
<tr class="memdesc:a09ebfcd509b5c4d473ec9ab61bed6e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary node type.  <br /></td></tr>
<tr class="separator:a09ebfcd509b5c4d473ec9ab61bed6e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e88bf6f5031a8e127a56adb37ec848d" id="r_a7e88bf6f5031a8e127a56adb37ec848d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e88bf6f5031a8e127a56adb37ec848d">insert_return_type</a></td></tr>
<tr class="memdesc:a7e88bf6f5031a8e127a56adb37ec848d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary insert return type.  <br /></td></tr>
<tr class="separator:a7e88bf6f5031a8e127a56adb37ec848d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c53bc1eb8f0a9125e21fbcd592052a" id="r_ad1c53bc1eb8f0a9125e21fbcd592052a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1c53bc1eb8f0a9125e21fbcd592052a">key_collection</a></td></tr>
<tr class="memdesc:ad1c53bc1eb8f0a9125e21fbcd592052a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary key collection type.  <br /></td></tr>
<tr class="separator:ad1c53bc1eb8f0a9125e21fbcd592052a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1d9778d3ed181b8295027c6ce4e1d3" id="r_a0c1d9778d3ed181b8295027c6ce4e1d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c1d9778d3ed181b8295027c6ce4e1d3">value_collection</a></td></tr>
<tr class="memdesc:a0c1d9778d3ed181b8295027c6ce4e1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary value collection type.  <br /></td></tr>
<tr class="separator:a0c1d9778d3ed181b8295027c6ce4e1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:a50b15016f1b91a266a8beec12ab89584" id="r_a50b15016f1b91a266a8beec12ab89584"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a> () noexcept=default</td></tr>
<tr class="memdesc:a50b15016f1b91a266a8beec12ab89584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the default equality comparer for the key type.  <br /></td></tr>
<tr class="separator:a50b15016f1b91a266a8beec12ab89584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd88350f974f41a0c131db83cbf72290" id="r_afd88350f974f41a0c131db83cbf72290"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd88350f974f41a0c131db83cbf72290">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">idictionary</a>&lt; key_t, value_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>)</td></tr>
<tr class="memdesc:afd88350f974f41a0c131db83cbf72290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs.">xtd::collections::generic::idictionary</a> &lt;key_t, value_t&gt; and uses the default equality comparer for the key type.  <br /></td></tr>
<tr class="separator:afd88350f974f41a0c131db83cbf72290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ddf7990763fbea30e0c6e38b5ae659" id="r_ae7ddf7990763fbea30e0c6e38b5ae659"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7ddf7990763fbea30e0c6e38b5ae659">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &gt; &amp;collection)</td></tr>
<tr class="memdesc:ae7ddf7990763fbea30e0c6e38b5ae659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ae7ddf7990763fbea30e0c6e38b5ae659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1d7beda0f8576d701cd22e9e3a12d8" id="r_acd1d7beda0f8576d701cd22e9e3a12d8"><td class="memTemplParams" colspan="2">template&lt;class equality_comparer_t&gt; </td></tr>
<tr class="memitem:acd1d7beda0f8576d701cd22e9e3a12d8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd1d7beda0f8576d701cd22e9e3a12d8">dictionary</a> (const equality_comparer_t &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>)</td></tr>
<tr class="memdesc:acd1d7beda0f8576d701cd22e9e3a12d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer&lt;type_t&gt;</a>.  <br /></td></tr>
<tr class="separator:acd1d7beda0f8576d701cd22e9e3a12d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43f677d6205a77520b4601206429243" id="r_ae43f677d6205a77520b4601206429243"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae43f677d6205a77520b4601206429243">dictionary</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash=hasher_t {}, const equator_t &amp;equal=equator_t {}, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {}) noexcept</td></tr>
<tr class="memdesc:ae43f677d6205a77520b4601206429243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:ae43f677d6205a77520b4601206429243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933f2c0b545c0485ecf052ec431db7a4" id="r_a933f2c0b545c0485ecf052ec431db7a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a933f2c0b545c0485ecf052ec431db7a4">dictionary</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a933f2c0b545c0485ecf052ec431db7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a933f2c0b545c0485ecf052ec431db7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab609bca970bff889772b49d51f204487" id="r_ab609bca970bff889772b49d51f204487"><td class="memTemplParams" colspan="2">template&lt;class equality_comparer_t&gt; </td></tr>
<tr class="memitem:ab609bca970bff889772b49d51f204487"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab609bca970bff889772b49d51f204487">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">idictionary</a>&lt; key_t, value_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>, const equality_comparer_t &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>)</td></tr>
<tr class="memdesc:ab609bca970bff889772b49d51f204487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ab609bca970bff889772b49d51f204487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e18164c1d61bd817872588bd77c6789" id="r_a2e18164c1d61bd817872588bd77c6789"><td class="memTemplParams" colspan="2">template&lt;class equality_comparer_t&gt; </td></tr>
<tr class="memitem:a2e18164c1d61bd817872588bd77c6789"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e18164c1d61bd817872588bd77c6789">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &gt; &amp;collection, const equality_comparer_t &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>)</td></tr>
<tr class="memdesc:a2e18164c1d61bd817872588bd77c6789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a2e18164c1d61bd817872588bd77c6789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349de516d0b938124c175ce956b3ac28" id="r_a349de516d0b938124c175ce956b3ac28"><td class="memTemplParams" colspan="2">template&lt;class equality_comparer_t&gt; </td></tr>
<tr class="memitem:a349de516d0b938124c175ce956b3ac28"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a349de516d0b938124c175ce956b3ac28">dictionary</a> (size_t <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3">capacity</a>, const equality_comparer_t &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>)</td></tr>
<tr class="memdesc:a349de516d0b938124c175ce956b3ac28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the specified initial capacity, and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a349de516d0b938124c175ce956b3ac28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fb45416d0a2a0b1d27082b7912878b" id="r_a78fb45416d0a2a0b1d27082b7912878b"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t&gt; </td></tr>
<tr class="memitem:a78fb45416d0a2a0b1d27082b7912878b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78fb45416d0a2a0b1d27082b7912878b">dictionary</a> (input_iterator_t <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, input_iterator_t <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>, <a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>=0, const hasher_t &amp;hash=hasher_t {}, const equator_t &amp;equal=equator_t {}, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {})</td></tr>
<tr class="memdesc:a78fb45416d0a2a0b1d27082b7912878b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a78fb45416d0a2a0b1d27082b7912878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a1e3057a72c385fc731c20b21e9606" id="r_a85a1e3057a72c385fc731c20b21e9606"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t&gt; </td></tr>
<tr class="memitem:a85a1e3057a72c385fc731c20b21e9606"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a85a1e3057a72c385fc731c20b21e9606">dictionary</a> (input_iterator_t <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, input_iterator_t <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>, <a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a85a1e3057a72c385fc731c20b21e9606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a85a1e3057a72c385fc731c20b21e9606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d7fe8271b0f7dd1776a8a99de3b1d0" id="r_a45d7fe8271b0f7dd1776a8a99de3b1d0"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t&gt; </td></tr>
<tr class="memitem:a45d7fe8271b0f7dd1776a8a99de3b1d0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45d7fe8271b0f7dd1776a8a99de3b1d0">dictionary</a> (input_iterator_t <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, input_iterator_t <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>, <a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a45d7fe8271b0f7dd1776a8a99de3b1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a45d7fe8271b0f7dd1776a8a99de3b1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa953d39916161c5551072ee7685d48dc" id="r_aa953d39916161c5551072ee7685d48dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa953d39916161c5551072ee7685d48dc">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aa953d39916161c5551072ee7685d48dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:aa953d39916161c5551072ee7685d48dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cea1264d53956ff616c99322bd744a" id="r_a27cea1264d53956ff616c99322bd744a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27cea1264d53956ff616c99322bd744a">dictionary</a> (const std::unordered_map&lt; key_t, value_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a27cea1264d53956ff616c99322bd744a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a27cea1264d53956ff616c99322bd744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5202127b516af4f37f86d4a3f472ddc6" id="r_a5202127b516af4f37f86d4a3f472ddc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5202127b516af4f37f86d4a3f472ddc6">dictionary</a> (const std::unordered_map&lt; key_t, value_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a5202127b516af4f37f86d4a3f472ddc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a5202127b516af4f37f86d4a3f472ddc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b758a73f04808f26eee3fa8ce363ef" id="r_a07b758a73f04808f26eee3fa8ce363ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07b758a73f04808f26eee3fa8ce363ef">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:a07b758a73f04808f26eee3fa8ce363ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a07b758a73f04808f26eee3fa8ce363ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c24d7c8b5165f2e3814e21c8ad0231" id="r_ab1c24d7c8b5165f2e3814e21c8ad0231"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1c24d7c8b5165f2e3814e21c8ad0231">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:ab1c24d7c8b5165f2e3814e21c8ad0231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:ab1c24d7c8b5165f2e3814e21c8ad0231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153be4b6329ddb7d86bfedd03db85ca8" id="r_a153be4b6329ddb7d86bfedd03db85ca8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a153be4b6329ddb7d86bfedd03db85ca8">dictionary</a> (std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a153be4b6329ddb7d86bfedd03db85ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a153be4b6329ddb7d86bfedd03db85ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260ac3aa16033a8c92bbb9a71c7ede0" id="r_a6260ac3aa16033a8c92bbb9a71c7ede0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6260ac3aa16033a8c92bbb9a71c7ede0">dictionary</a> (std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a6260ac3aa16033a8c92bbb9a71c7ede0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a6260ac3aa16033a8c92bbb9a71c7ede0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457a42aa23639faa8590bdb23f2d346a" id="r_a457a42aa23639faa8590bdb23f2d346a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a457a42aa23639faa8590bdb23f2d346a">dictionary</a> (std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt; init, <a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>=0, const hasher_t &amp;hash=hasher_t {}, const equator_t &amp;equal=equator_t {}, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {})</td></tr>
<tr class="memdesc:a457a42aa23639faa8590bdb23f2d346a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a457a42aa23639faa8590bdb23f2d346a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1e2bddbc888c451b97e6cd2f760250" id="r_acd1e2bddbc888c451b97e6cd2f760250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd1e2bddbc888c451b97e6cd2f760250">dictionary</a> (std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt; init, <a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:acd1e2bddbc888c451b97e6cd2f760250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:acd1e2bddbc888c451b97e6cd2f760250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db2868740c4f2c5e70bb845654d31cf" id="r_a0db2868740c4f2c5e70bb845654d31cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0db2868740c4f2c5e70bb845654d31cf">dictionary</a> (std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt; init, <a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a0db2868740c4f2c5e70bb845654d31cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a0db2868740c4f2c5e70bb845654d31cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f5f06c57ba2d50fffe837ff8dde852" id="r_af8f5f06c57ba2d50fffe837ff8dde852"><td class="memTemplParams" colspan="2">template&lt;class init_key_t, class init_value_t&gt; </td></tr>
<tr class="memitem:af8f5f06c57ba2d50fffe837ff8dde852"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8f5f06c57ba2d50fffe837ff8dde852">dictionary</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; init, <a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>=0, const hasher_t &amp;hash=hasher_t {}, const equator_t &amp;equal=equator_t {}, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {})</td></tr>
<tr class="memdesc:af8f5f06c57ba2d50fffe837ff8dde852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:af8f5f06c57ba2d50fffe837ff8dde852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b272479748bbf823035dc716d9dad1d" id="r_a8b272479748bbf823035dc716d9dad1d"><td class="memTemplParams" colspan="2">template&lt;class init_key_t, class init_value_t&gt; </td></tr>
<tr class="memitem:a8b272479748bbf823035dc716d9dad1d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b272479748bbf823035dc716d9dad1d">dictionary</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; init, <a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a8b272479748bbf823035dc716d9dad1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a8b272479748bbf823035dc716d9dad1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ad7bfb943fd88490c08ae70251968" id="r_a144ad7bfb943fd88490c08ae70251968"><td class="memTemplParams" colspan="2">template&lt;class init_key_t, class init_value_t&gt; </td></tr>
<tr class="memitem:a144ad7bfb943fd88490c08ae70251968"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a144ad7bfb943fd88490c08ae70251968">dictionary</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; init, <a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash, const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a144ad7bfb943fd88490c08ae70251968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a144ad7bfb943fd88490c08ae70251968"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:a5fb05a4d36ada3a05639760bbef1866f" id="r_a5fb05a4d36ada3a05639760bbef1866f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb05a4d36ada3a05639760bbef1866f">begin</a> () const noexcept override</td></tr>
<tr class="memdesc:a5fb05a4d36ada3a05639760bbef1866f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:a5fb05a4d36ada3a05639760bbef1866f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43461af42f40fafcba6c351b8915909" id="r_ad43461af42f40fafcba6c351b8915909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad43461af42f40fafcba6c351b8915909">begin</a> () noexcept override</td></tr>
<tr class="memdesc:ad43461af42f40fafcba6c351b8915909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:ad43461af42f40fafcba6c351b8915909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51c920c156b8cc6863e143972f5c11b" id="r_ad51c920c156b8cc6863e143972f5c11b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:ad51c920c156b8cc6863e143972f5c11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of buckets in the container.  <br /></td></tr>
<tr class="separator:ad51c920c156b8cc6863e143972f5c11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ebcb226f6bc8869c35bf9e1d634ff3" id="r_a24ebcb226f6bc8869c35bf9e1d634ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a24ebcb226f6bc8869c35bf9e1d634ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total numbers of elements the internal data structure can hold without resizing.  <br /></td></tr>
<tr class="separator:a24ebcb226f6bc8869c35bf9e1d634ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375db294d333e09891584e2a0956e1d" id="r_ac375db294d333e09891584e2a0956e1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac375db294d333e09891584e2a0956e1d">cbegin</a> () const noexcept override</td></tr>
<tr class="memdesc:ac375db294d333e09891584e2a0956e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumerable.  <br /></td></tr>
<tr class="separator:ac375db294d333e09891584e2a0956e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63291ea36f70c7ded93799d6890847e" id="r_ad63291ea36f70c7ded93799d6890847e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad63291ea36f70c7ded93799d6890847e">cend</a> () const noexcept override</td></tr>
<tr class="memdesc:ad63291ea36f70c7ded93799d6890847e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:ad63291ea36f70c7ded93799d6890847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2826f22b8d56568081a760c9f6d594da" id="r_a2826f22b8d56568081a760c9f6d594da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2826f22b8d56568081a760c9f6d594da">comparer</a> () const noexcept</td></tr>
<tr class="memdesc:a2826f22b8d56568081a760c9f6d594da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the td::collections::generic::iequality_comparer &lt;type_t&gt; that is used to determine equality of keys for the dictionary.  <br /></td></tr>
<tr class="separator:a2826f22b8d56568081a760c9f6d594da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92f9b1f02bf864a69a46230f9b53c62" id="r_af92f9b1f02bf864a69a46230f9b53c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62">count</a> () const noexcept override</td></tr>
<tr class="memdesc:af92f9b1f02bf864a69a46230f9b53c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:af92f9b1f02bf864a69a46230f9b53c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55611e5c2304788bf7a281fc5b75e1cb" id="r_a55611e5c2304788bf7a281fc5b75e1cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55611e5c2304788bf7a281fc5b75e1cb">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a55611e5c2304788bf7a281fc5b75e1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <code><a class="el" href="#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumerable.">begin()</a> == <a class="el" href="#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumerable.">end()</a></code>.  <br /></td></tr>
<tr class="separator:a55611e5c2304788bf7a281fc5b75e1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bcbef97b1acb696d8b444988530830" id="r_a84bcbef97b1acb696d8b444988530830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84bcbef97b1acb696d8b444988530830">end</a> () const noexcept override</td></tr>
<tr class="memdesc:a84bcbef97b1acb696d8b444988530830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:a84bcbef97b1acb696d8b444988530830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e062f26b355616dce3110a815645e7d" id="r_a8e062f26b355616dce3110a815645e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e062f26b355616dce3110a815645e7d">end</a> () noexcept override</td></tr>
<tr class="memdesc:a8e062f26b355616dce3110a815645e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumerable.  <br /></td></tr>
<tr class="separator:a8e062f26b355616dce3110a815645e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2181745ec5b125827735336ea9ada43" id="r_af2181745ec5b125827735336ea9ada43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2181745ec5b125827735336ea9ada43">is_read_only</a> () const noexcept override</td></tr>
<tr class="memdesc:af2181745ec5b125827735336ea9ada43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether the xtd::collections::generic::icollection &lt;type_t&gt; is read-only.  <br /></td></tr>
<tr class="separator:af2181745ec5b125827735336ea9ada43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9798bb3a3f89e6dd45d5783d42957550" id="r_a9798bb3a3f89e6dd45d5783d42957550"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9798bb3a3f89e6dd45d5783d42957550">is_synchronized</a> () const noexcept override</td></tr>
<tr class="memdesc:a9798bb3a3f89e6dd45d5783d42957550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether access to the xtd::collections::generic::icollection &lt;type_t&gt; is synchronized (thread safe).  <br /></td></tr>
<tr class="separator:a9798bb3a3f89e6dd45d5783d42957550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f9fa62ba008a290c60f795e768d74f" id="r_ac5f9fa62ba008a290c60f795e768d74f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="#a4635f1586a55cca04619e6b4d25322f2">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f9fa62ba008a290c60f795e768d74f">items</a> () const noexcept</td></tr>
<tr class="memdesc:ac5f9fa62ba008a290c60f795e768d74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:ac5f9fa62ba008a290c60f795e768d74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb58202461ac49407519756acca9ed12" id="r_aeb58202461ac49407519756acca9ed12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a4635f1586a55cca04619e6b4d25322f2">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb58202461ac49407519756acca9ed12">items</a> () noexcept</td></tr>
<tr class="memdesc:aeb58202461ac49407519756acca9ed12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:aeb58202461ac49407519756acca9ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a9b4d312798abd41548c6c97ee3312" id="r_ac2a9b4d312798abd41548c6c97ee3312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad1c53bc1eb8f0a9125e21fbcd592052a">key_collection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2a9b4d312798abd41548c6c97ee3312">keys</a> () const noexcept override</td></tr>
<tr class="memdesc:ac2a9b4d312798abd41548c6c97ee3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a collection containing the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:ac2a9b4d312798abd41548c6c97ee3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fed9d70080e18e58e5f678ff8fce0" id="r_ad12fed9d70080e18e58e5f678ff8fce0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad12fed9d70080e18e58e5f678ff8fce0">load_factor</a> () const</td></tr>
<tr class="memdesc:ad12fed9d70080e18e58e5f678ff8fce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the average number of elements per bucket, that is, <a class="el" href="#a9b8a36cd363866ea458b74960e5d68eb" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::size</a> divided by <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a>.  <br /></td></tr>
<tr class="separator:ad12fed9d70080e18e58e5f678ff8fce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4c1821576c7fba7fdd4dea0f2c512" id="r_ad9e4c1821576c7fba7fdd4dea0f2c512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9e4c1821576c7fba7fdd4dea0f2c512">max_bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:ad9e4c1821576c7fba7fdd4dea0f2c512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of buckets the container is able to hold due to system or library implementation limitations.  <br /></td></tr>
<tr class="separator:ad9e4c1821576c7fba7fdd4dea0f2c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ebdfacb702aad8221aa1b77817cdbd" id="r_af4ebdfacb702aad8221aa1b77817cdbd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd">max_load_factor</a> () const</td></tr>
<tr class="memdesc:af4ebdfacb702aad8221aa1b77817cdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.  <br /></td></tr>
<tr class="separator:af4ebdfacb702aad8221aa1b77817cdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f7acfa0c36a187bd76efe62d87581c" id="r_ad7f7acfa0c36a187bd76efe62d87581c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7f7acfa0c36a187bd76efe62d87581c">max_load_factor</a> (float value) const</td></tr>
<tr class="memdesc:ad7f7acfa0c36a187bd76efe62d87581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.  <br /></td></tr>
<tr class="separator:ad7f7acfa0c36a187bd76efe62d87581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070747ad0686a9136f66dfc5e3b19aa9" id="r_a070747ad0686a9136f66dfc5e3b19aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a070747ad0686a9136f66dfc5e3b19aa9">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a070747ad0686a9136f66dfc5e3b19aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumerable.">begin()</a>, <a class="el" href="#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumerable.">end()</a>)</code> for the largest container.  <br /></td></tr>
<tr class="separator:a070747ad0686a9136f66dfc5e3b19aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8a36cd363866ea458b74960e5d68eb" id="r_a9b8a36cd363866ea458b74960e5d68eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b8a36cd363866ea458b74960e5d68eb">size</a> () const noexcept</td></tr>
<tr class="memdesc:a9b8a36cd363866ea458b74960e5d68eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a9b8a36cd363866ea458b74960e5d68eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0784fa1eee73f0061df828986a5ae52d" id="r_a0784fa1eee73f0061df828986a5ae52d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1object.html">xtd::object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0784fa1eee73f0061df828986a5ae52d">sync_root</a> () const noexcept override</td></tr>
<tr class="memdesc:a0784fa1eee73f0061df828986a5ae52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an object that can be used to synchronize access to the the xtd::collections::generic::icollection &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a0784fa1eee73f0061df828986a5ae52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5519d6518ce9849e89b90fd573839f2" id="r_aa5519d6518ce9849e89b90fd573839f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a0c1d9778d3ed181b8295027c6ce4e1d3">value_collection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5519d6518ce9849e89b90fd573839f2">values</a> () const noexcept override</td></tr>
<tr class="memdesc:aa5519d6518ce9849e89b90fd573839f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a collection containing the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:aa5519d6518ce9849e89b90fd573839f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a8e4b572d70b69d4b688a2835a3258522" id="r_a8e4b572d70b69d4b688a2835a3258522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e4b572d70b69d4b688a2835a3258522">add</a> (const key_t &amp;key, const value_t value) override</td></tr>
<tr class="memdesc:a8e4b572d70b69d4b688a2835a3258522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element with the provided key and value to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a8e4b572d70b69d4b688a2835a3258522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f323cd7289784e6380117b8bfadf8b" id="r_a22f323cd7289784e6380117b8bfadf8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22f323cd7289784e6380117b8bfadf8b">add</a> (const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;item) override</td></tr>
<tr class="memdesc:a22f323cd7289784e6380117b8bfadf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the xtd::collections::generic::icollection &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a22f323cd7289784e6380117b8bfadf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56664bbd826ba01e34ff35477064db2d" id="r_a56664bbd826ba01e34ff35477064db2d"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56664bbd826ba01e34ff35477064db2d">at</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a56664bbd826ba01e34ff35477064db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element with the specified key.  <br /></td></tr>
<tr class="separator:a56664bbd826ba01e34ff35477064db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32980a15b7ef803c1ba5c8d69f1dbb84" id="r_a32980a15b7ef803c1ba5c8d69f1dbb84"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32980a15b7ef803c1ba5c8d69f1dbb84">at</a> (const key_t &amp;key)</td></tr>
<tr class="memdesc:a32980a15b7ef803c1ba5c8d69f1dbb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element with the specified key.  <br /></td></tr>
<tr class="separator:a32980a15b7ef803c1ba5c8d69f1dbb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3e8fd61595d88e72199205dbf976b5" id="r_a8d3e8fd61595d88e72199205dbf976b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adc966a9b4269ce145604c61eace7f57c">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d3e8fd61595d88e72199205dbf976b5">begin</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>)</td></tr>
<tr class="memdesc:a8d3e8fd61595d88e72199205dbf976b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the specified bucket.  <br /></td></tr>
<tr class="separator:a8d3e8fd61595d88e72199205dbf976b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772b3aff980ea2b05d5bf8ce5cbdd9f1" id="r_a772b3aff980ea2b05d5bf8ce5cbdd9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a772b3aff980ea2b05d5bf8ce5cbdd9f1">begin</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const</td></tr>
<tr class="memdesc:a772b3aff980ea2b05d5bf8ce5cbdd9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the specified bucket.  <br /></td></tr>
<tr class="separator:a772b3aff980ea2b05d5bf8ce5cbdd9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b83cb5cb0fa23c7b4ff7c2c447419aa" id="r_a3b83cb5cb0fa23c7b4ff7c2c447419aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b83cb5cb0fa23c7b4ff7c2c447419aa">bucket</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a3b83cb5cb0fa23c7b4ff7c2c447419aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket.  <br /></td></tr>
<tr class="separator:a3b83cb5cb0fa23c7b4ff7c2c447419aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce1e7684c03c73e9980372eceb779a2" id="r_a8ce1e7684c03c73e9980372eceb779a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ce1e7684c03c73e9980372eceb779a2">bucket_size</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const noexcept</td></tr>
<tr class="memdesc:a8ce1e7684c03c73e9980372eceb779a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the bucket with index <code>n</code>.  <br /></td></tr>
<tr class="separator:a8ce1e7684c03c73e9980372eceb779a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d0ef8dbeb149776a600386b13a9c6" id="r_a325d0ef8dbeb149776a600386b13a9c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a325d0ef8dbeb149776a600386b13a9c6">cbegin</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const</td></tr>
<tr class="memdesc:a325d0ef8dbeb149776a600386b13a9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the specified bucket.  <br /></td></tr>
<tr class="separator:a325d0ef8dbeb149776a600386b13a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38876c6b918c241ca74f597089606c1" id="r_ab38876c6b918c241ca74f597089606c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab38876c6b918c241ca74f597089606c1">cend</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const</td></tr>
<tr class="memdesc:ab38876c6b918c241ca74f597089606c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the specified bucket.  <br /></td></tr>
<tr class="separator:ab38876c6b918c241ca74f597089606c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50385c2da2442292164bc4f65c84ee76" id="r_a50385c2da2442292164bc4f65c84ee76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50385c2da2442292164bc4f65c84ee76">clear</a> () noexcept override</td></tr>
<tr class="memdesc:a50385c2da2442292164bc4f65c84ee76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all keys and values from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a50385c2da2442292164bc4f65c84ee76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db129cddf553ee484a09e6d39bb87a0" id="r_a7db129cddf553ee484a09e6d39bb87a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7db129cddf553ee484a09e6d39bb87a0">contains</a> (const key_t &amp;key) const noexcept</td></tr>
<tr class="memdesc:a7db129cddf553ee484a09e6d39bb87a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container contains element with specific key.  <br /></td></tr>
<tr class="separator:a7db129cddf553ee484a09e6d39bb87a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19c1aca5cdab0045940d70246b37093" id="r_ac19c1aca5cdab0045940d70246b37093"><td class="memTemplParams" colspan="2">template&lt;class contains_key_t&gt; </td></tr>
<tr class="memitem:ac19c1aca5cdab0045940d70246b37093"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac19c1aca5cdab0045940d70246b37093">contains</a> (const contains_key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) const</td></tr>
<tr class="memdesc:ac19c1aca5cdab0045940d70246b37093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container contains element with specific key.  <br /></td></tr>
<tr class="separator:ac19c1aca5cdab0045940d70246b37093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b87fe3db85b2c9f55ac59544070e20" id="r_a90b87fe3db85b2c9f55ac59544070e20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90b87fe3db85b2c9f55ac59544070e20">contains</a> (const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;item) const noexcept override</td></tr>
<tr class="memdesc:a90b87fe3db85b2c9f55ac59544070e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an element is in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a90b87fe3db85b2c9f55ac59544070e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf27b6ece343e1dd7450de296277f892" id="r_acf27b6ece343e1dd7450de296277f892"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf27b6ece343e1dd7450de296277f892">contains_key</a> (const key_t &amp;key) const noexcept override</td></tr>
<tr class="memdesc:acf27b6ece343e1dd7450de296277f892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains the specified key.  <br /></td></tr>
<tr class="separator:acf27b6ece343e1dd7450de296277f892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135b9e8d0789a85bd120b3c25af1102e" id="r_a135b9e8d0789a85bd120b3c25af1102e"><td class="memItemLeft" align="right" valign="top"><a id="a135b9e8d0789a85bd120b3c25af1102e" name="a135b9e8d0789a85bd120b3c25af1102e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains_value</b> (const value_t &amp;value) const noexcept</td></tr>
<tr class="separator:a135b9e8d0789a85bd120b3c25af1102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d231addcc65486d9ad0abee23ada3ac" id="r_a3d231addcc65486d9ad0abee23ada3ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d231addcc65486d9ad0abee23ada3ac">copy_to</a> (<a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &gt; &amp;<a class="el" href="classxtd_1_1array.html">array</a>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> array_index) const override</td></tr>
<tr class="memdesc:a3d231addcc65486d9ad0abee23ada3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements of the xtd::collections::generic::icollection &lt;type_t&gt; to an <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a>, starting at a particular <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> index.  <br /></td></tr>
<tr class="separator:a3d231addcc65486d9ad0abee23ada3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62388a5a93af71eb55d9f509420d1acb" id="r_a62388a5a93af71eb55d9f509420d1acb"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:a62388a5a93af71eb55d9f509420d1acb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62388a5a93af71eb55d9f509420d1acb">emplace</a> (args_t &amp;&amp;...args)</td></tr>
<tr class="memdesc:a62388a5a93af71eb55d9f509420d1acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs element in-place.  <br /></td></tr>
<tr class="separator:a62388a5a93af71eb55d9f509420d1acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fad4302a8e0c5a82892df5bef0504" id="r_a657fad4302a8e0c5a82892df5bef0504"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:a657fad4302a8e0c5a82892df5bef0504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a657fad4302a8e0c5a82892df5bef0504">emplace_hint</a> (<a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> hint, args_t &amp;&amp;...args)</td></tr>
<tr class="memdesc:a657fad4302a8e0c5a82892df5bef0504"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs elements in-place using a hint  <br /></td></tr>
<tr class="separator:a657fad4302a8e0c5a82892df5bef0504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cefc1b2c8027b4257647fccda518f71" id="r_a0cefc1b2c8027b4257647fccda518f71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adc966a9b4269ce145604c61eace7f57c">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cefc1b2c8027b4257647fccda518f71">end</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>)</td></tr>
<tr class="memdesc:a0cefc1b2c8027b4257647fccda518f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the specified bucket.  <br /></td></tr>
<tr class="separator:a0cefc1b2c8027b4257647fccda518f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26ad005233fb7741a285d791e56db19" id="r_aa26ad005233fb7741a285d791e56db19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa26ad005233fb7741a285d791e56db19">end</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const</td></tr>
<tr class="memdesc:aa26ad005233fb7741a285d791e56db19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the specified bucket.  <br /></td></tr>
<tr class="separator:aa26ad005233fb7741a285d791e56db19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460da2f9004cddf41f14d23d1fa09a25" id="r_a460da2f9004cddf41f14d23d1fa09a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a460da2f9004cddf41f14d23d1fa09a25">ensure_capacity</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3">capacity</a>) noexcept</td></tr>
<tr class="memdesc:a460da2f9004cddf41f14d23d1fa09a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the dictionary can hold up to a specified number of entries without any further expansion of its backing storage.  <br /></td></tr>
<tr class="separator:a460da2f9004cddf41f14d23d1fa09a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7192082480f0412da88dfa004dca3c3b" id="r_a7192082480f0412da88dfa004dca3c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7192082480f0412da88dfa004dca3c3b">equal_range</a> (const key_t &amp;key)</td></tr>
<tr class="memdesc:a7192082480f0412da88dfa004dca3c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range of elements matching a specific key.  <br /></td></tr>
<tr class="separator:a7192082480f0412da88dfa004dca3c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e8a1a164d50122468d84a0d31c0724" id="r_a85e8a1a164d50122468d84a0d31c0724"><td class="memTemplParams" colspan="2">template&lt;class equal_range_key_t&gt; </td></tr>
<tr class="memitem:a85e8a1a164d50122468d84a0d31c0724"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>, <a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a85e8a1a164d50122468d84a0d31c0724">equal_range</a> (const equal_range_key_t &amp;key) const</td></tr>
<tr class="memdesc:a85e8a1a164d50122468d84a0d31c0724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range of elements matching a specific key.  <br /></td></tr>
<tr class="separator:a85e8a1a164d50122468d84a0d31c0724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94931223079f91ec84fd48de20d2c3e8" id="r_a94931223079f91ec84fd48de20d2c3e8"><td class="memTemplParams" colspan="2">template&lt;class equal_range_key_t&gt; </td></tr>
<tr class="memitem:a94931223079f91ec84fd48de20d2c3e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94931223079f91ec84fd48de20d2c3e8">equal_range</a> (const equal_range_key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>)</td></tr>
<tr class="memdesc:a94931223079f91ec84fd48de20d2c3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range of elements matching a specific key.  <br /></td></tr>
<tr class="separator:a94931223079f91ec84fd48de20d2c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a7786db2622f4e3c0cab7f64b6ff58" id="r_a60a7786db2622f4e3c0cab7f64b6ff58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>, <a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60a7786db2622f4e3c0cab7f64b6ff58">equal_range</a> (const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) const</td></tr>
<tr class="memdesc:a60a7786db2622f4e3c0cab7f64b6ff58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range of elements matching a specific key.  <br /></td></tr>
<tr class="separator:a60a7786db2622f4e3c0cab7f64b6ff58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eab79e42511efe5dd18c64f470a6bd" id="r_a05eab79e42511efe5dd18c64f470a6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05eab79e42511efe5dd18c64f470a6bd">erase</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a05eab79e42511efe5dd18c64f470a6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases elements.  <br /></td></tr>
<tr class="separator:a05eab79e42511efe5dd18c64f470a6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e499b3634ee1402b59a6742fc817e1" id="r_a51e499b3634ee1402b59a6742fc817e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e499b3634ee1402b59a6742fc817e1">erase</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, <a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>)</td></tr>
<tr class="memdesc:a51e499b3634ee1402b59a6742fc817e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases elements.  <br /></td></tr>
<tr class="separator:a51e499b3634ee1402b59a6742fc817e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a6184442c9b335e7984d655f722e0d" id="r_aa7a6184442c9b335e7984d655f722e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7a6184442c9b335e7984d655f722e0d">erase</a> (const key_t &amp;key)</td></tr>
<tr class="memdesc:aa7a6184442c9b335e7984d655f722e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases elements.  <br /></td></tr>
<tr class="separator:aa7a6184442c9b335e7984d655f722e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7934e22726ecf3f3e3ddbe7ae6dbe4b5" id="r_a7934e22726ecf3f3e3ddbe7ae6dbe4b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7934e22726ecf3f3e3ddbe7ae6dbe4b5">extract</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> position) noexcept</td></tr>
<tr class="memdesc:a7934e22726ecf3f3e3ddbe7ae6dbe4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts nodes from the container.  <br /></td></tr>
<tr class="separator:a7934e22726ecf3f3e3ddbe7ae6dbe4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248ff4fbc36fb649ca0ef6a682b37c6c" id="r_a248ff4fbc36fb649ca0ef6a682b37c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a248ff4fbc36fb649ca0ef6a682b37c6c">extract</a> (const key_t <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>)</td></tr>
<tr class="memdesc:a248ff4fbc36fb649ca0ef6a682b37c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts nodes from the container.  <br /></td></tr>
<tr class="separator:a248ff4fbc36fb649ca0ef6a682b37c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b99ac9d6af11fda53cb838f611a0ec" id="r_a15b99ac9d6af11fda53cb838f611a0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15b99ac9d6af11fda53cb838f611a0ec">find</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a15b99ac9d6af11fda53cb838f611a0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds element with specific key.  <br /></td></tr>
<tr class="separator:a15b99ac9d6af11fda53cb838f611a0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae181d2502d73a096dd98bef746081251" id="r_ae181d2502d73a096dd98bef746081251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae181d2502d73a096dd98bef746081251">find</a> (const key_t &amp;key)</td></tr>
<tr class="memdesc:ae181d2502d73a096dd98bef746081251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds element with specific key.  <br /></td></tr>
<tr class="separator:ae181d2502d73a096dd98bef746081251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e712574f32c4ee5baf17502c9d89991" id="r_a4e712574f32c4ee5baf17502c9d89991"><td class="memTemplParams" colspan="2">template&lt;class find_key_t&gt; </td></tr>
<tr class="memitem:a4e712574f32c4ee5baf17502c9d89991"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e712574f32c4ee5baf17502c9d89991">find</a> (const find_key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) const</td></tr>
<tr class="memdesc:a4e712574f32c4ee5baf17502c9d89991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds element with specific key.  <br /></td></tr>
<tr class="separator:a4e712574f32c4ee5baf17502c9d89991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba5c1ca5b7f05e3035ba70ca10c1ae0" id="r_a6ba5c1ca5b7f05e3035ba70ca10c1ae0"><td class="memTemplParams" colspan="2">template&lt;class find_key_t&gt; </td></tr>
<tr class="memitem:a6ba5c1ca5b7f05e3035ba70ca10c1ae0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ba5c1ca5b7f05e3035ba70ca10c1ae0">find</a> (const find_key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>)</td></tr>
<tr class="memdesc:a6ba5c1ca5b7f05e3035ba70ca10c1ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds element with specific key.  <br /></td></tr>
<tr class="separator:a6ba5c1ca5b7f05e3035ba70ca10c1ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f30a82dc96ded7a4145c3d0533e3a7" id="r_ae3f30a82dc96ded7a4145c3d0533e3a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3f30a82dc96ded7a4145c3d0533e3a7">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:ae3f30a82dc96ded7a4145c3d0533e3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <br /></td></tr>
<tr class="separator:ae3f30a82dc96ded7a4145c3d0533e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab937a31d8ae4cb896ab25baf67330225" id="r_ab937a31d8ae4cb896ab25baf67330225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">enumerator</a>&lt; <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab937a31d8ae4cb896ab25baf67330225">get_enumerator</a> () const noexcept override</td></tr>
<tr class="memdesc:ab937a31d8ae4cb896ab25baf67330225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that iterates through the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:ab937a31d8ae4cb896ab25baf67330225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c1f0dd1e8ac7f753d0f56e05fa5a8c" id="r_a14c1f0dd1e8ac7f753d0f56e05fa5a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14c1f0dd1e8ac7f753d0f56e05fa5a8c">hash_function</a> () const</td></tr>
<tr class="memdesc:a14c1f0dd1e8ac7f753d0f56e05fa5a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns function used to hash the keys.  <br /></td></tr>
<tr class="separator:a14c1f0dd1e8ac7f753d0f56e05fa5a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2536af020316364a5f3e053dbc02feb7" id="r_a2536af020316364a5f3e053dbc02feb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2536af020316364a5f3e053dbc02feb7">insert</a> (const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a2536af020316364a5f3e053dbc02feb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a2536af020316364a5f3e053dbc02feb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbab4055f21c2b4f292408e2fe681e8" id="r_a4bbab4055f21c2b4f292408e2fe681e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bbab4055f21c2b4f292408e2fe681e8">insert</a> (<a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a4bbab4055f21c2b4f292408e2fe681e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a4bbab4055f21c2b4f292408e2fe681e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ad0f3139526c64cf06412b65feae9e" id="r_a18ad0f3139526c64cf06412b65feae9e"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:a18ad0f3139526c64cf06412b65feae9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18ad0f3139526c64cf06412b65feae9e">insert</a> (type_t &amp;&amp;value)</td></tr>
<tr class="memdesc:a18ad0f3139526c64cf06412b65feae9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a18ad0f3139526c64cf06412b65feae9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380d38c18d0aa2a9d14309adfc143b53" id="r_a380d38c18d0aa2a9d14309adfc143b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a380d38c18d0aa2a9d14309adfc143b53">insert</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> hint, const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a380d38c18d0aa2a9d14309adfc143b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a380d38c18d0aa2a9d14309adfc143b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18df0c230fef405f5748b1bc0e499128" id="r_a18df0c230fef405f5748b1bc0e499128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18df0c230fef405f5748b1bc0e499128">insert</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> hint, <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a18df0c230fef405f5748b1bc0e499128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a18df0c230fef405f5748b1bc0e499128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7128e65ca299ec54ac3141117d0a6215" id="r_a7128e65ca299ec54ac3141117d0a6215"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:a7128e65ca299ec54ac3141117d0a6215"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7128e65ca299ec54ac3141117d0a6215">insert</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> hint, type_t &amp;&amp;value)</td></tr>
<tr class="memdesc:a7128e65ca299ec54ac3141117d0a6215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a7128e65ca299ec54ac3141117d0a6215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85007cea09c65235fd258adcc3a5a28d" id="r_a85007cea09c65235fd258adcc3a5a28d"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t&gt; </td></tr>
<tr class="memitem:a85007cea09c65235fd258adcc3a5a28d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a85007cea09c65235fd258adcc3a5a28d">insert</a> (input_iterator_t <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, input_iterator_t <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>)</td></tr>
<tr class="memdesc:a85007cea09c65235fd258adcc3a5a28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a85007cea09c65235fd258adcc3a5a28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f13f08d0a8068edeec540cd55b2656e" id="r_a2f13f08d0a8068edeec540cd55b2656e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f13f08d0a8068edeec540cd55b2656e">insert</a> (std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:a2f13f08d0a8068edeec540cd55b2656e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a2f13f08d0a8068edeec540cd55b2656e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03539711e3e6f86380a893e725b95d3" id="r_ab03539711e3e6f86380a893e725b95d3"><td class="memTemplParams" colspan="2">template&lt;class init_key_t, class init_value_t&gt; </td></tr>
<tr class="memitem:ab03539711e3e6f86380a893e725b95d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab03539711e3e6f86380a893e725b95d3">insert</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; ilist)</td></tr>
<tr class="memdesc:ab03539711e3e6f86380a893e725b95d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:ab03539711e3e6f86380a893e725b95d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe7e8e7ea1b539e1b77cb2e67f3d56b" id="r_a1fe7e8e7ea1b539e1b77cb2e67f3d56b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7e88bf6f5031a8e127a56adb37ec848d">insert_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fe7e8e7ea1b539e1b77cb2e67f3d56b">insert</a> (<a class="el" href="#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;nh)</td></tr>
<tr class="memdesc:a1fe7e8e7ea1b539e1b77cb2e67f3d56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a1fe7e8e7ea1b539e1b77cb2e67f3d56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c488877537c9281e341e04cc2836c4b" id="r_a5c488877537c9281e341e04cc2836c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c488877537c9281e341e04cc2836c4b">insert</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> hint, <a class="el" href="#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;nh)</td></tr>
<tr class="memdesc:a5c488877537c9281e341e04cc2836c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a5c488877537c9281e341e04cc2836c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9003b85acdd5f58ba98601126fb7e5e" id="r_ad9003b85acdd5f58ba98601126fb7e5e"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:ad9003b85acdd5f58ba98601126fb7e5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9003b85acdd5f58ba98601126fb7e5e">insert_or_assign</a> (const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:ad9003b85acdd5f58ba98601126fb7e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:ad9003b85acdd5f58ba98601126fb7e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc83f5a5d14fd0c9c164a3bffcffe128" id="r_acc83f5a5d14fd0c9c164a3bffcffe128"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acc83f5a5d14fd0c9c164a3bffcffe128">insert_or_assign</a> (key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddd73ed7023f733638e9fda6246ed4" id="r_addddd73ed7023f733638e9fda6246ed4"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:addddd73ed7023f733638e9fda6246ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#addddd73ed7023f733638e9fda6246ed4">insert_or_assign</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> hint, const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:addddd73ed7023f733638e9fda6246ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:addddd73ed7023f733638e9fda6246ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286f0cc1a6f5f3ea0e07728043b80038" id="r_a286f0cc1a6f5f3ea0e07728043b80038"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:a286f0cc1a6f5f3ea0e07728043b80038"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a286f0cc1a6f5f3ea0e07728043b80038">insert_or_assign</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> hint, key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:a286f0cc1a6f5f3ea0e07728043b80038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:a286f0cc1a6f5f3ea0e07728043b80038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f3e826724a20670a5b310e1eda5542" id="r_a64f3e826724a20670a5b310e1eda5542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1d6112bd0a235323e439c6a230e3fb76">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64f3e826724a20670a5b310e1eda5542">key_eq</a> () const</td></tr>
<tr class="memdesc:a64f3e826724a20670a5b310e1eda5542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function used to compare keys for equality.  <br /></td></tr>
<tr class="separator:a64f3e826724a20670a5b310e1eda5542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa575c136bf1a37de24a5a7ce7f552b6e" id="r_aa575c136bf1a37de24a5a7ce7f552b6e"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t, class source_equator_t&gt; </td></tr>
<tr class="memitem:aa575c136bf1a37de24a5a7ce7f552b6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa575c136bf1a37de24a5a7ce7f552b6e">merge</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;source)</td></tr>
<tr class="memdesc:aa575c136bf1a37de24a5a7ce7f552b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:aa575c136bf1a37de24a5a7ce7f552b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5befc63a3053f4602f9440418e6e553b" id="r_a5befc63a3053f4602f9440418e6e553b"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t, class source_equator_t&gt; </td></tr>
<tr class="memitem:a5befc63a3053f4602f9440418e6e553b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5befc63a3053f4602f9440418e6e553b">merge</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;source)</td></tr>
<tr class="memdesc:a5befc63a3053f4602f9440418e6e553b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:a5befc63a3053f4602f9440418e6e553b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e63cb0057bab0fe25d0b0496cebdab" id="r_ab4e63cb0057bab0fe25d0b0496cebdab"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t, class source_equator_t&gt; </td></tr>
<tr class="memitem:ab4e63cb0057bab0fe25d0b0496cebdab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4e63cb0057bab0fe25d0b0496cebdab">merge</a> (std::unordered_map&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;source)</td></tr>
<tr class="memdesc:ab4e63cb0057bab0fe25d0b0496cebdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:ab4e63cb0057bab0fe25d0b0496cebdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b3061b4dbf74c837b28315279242bf" id="r_a05b3061b4dbf74c837b28315279242bf"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t, class source_equator_t&gt; </td></tr>
<tr class="memitem:a05b3061b4dbf74c837b28315279242bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05b3061b4dbf74c837b28315279242bf">merge</a> (std::unordered_map&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;source)</td></tr>
<tr class="memdesc:a05b3061b4dbf74c837b28315279242bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:a05b3061b4dbf74c837b28315279242bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b8b13d8c3160f93641eaa1ccda8968" id="r_ac7b8b13d8c3160f93641eaa1ccda8968"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t, class source_equator_t&gt; </td></tr>
<tr class="memitem:ac7b8b13d8c3160f93641eaa1ccda8968"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7b8b13d8c3160f93641eaa1ccda8968">merge</a> (std::unordered_multimap&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;source)</td></tr>
<tr class="memdesc:ac7b8b13d8c3160f93641eaa1ccda8968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:ac7b8b13d8c3160f93641eaa1ccda8968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d725740942e0a175b87d23e8228dce" id="r_ad3d725740942e0a175b87d23e8228dce"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t, class source_equator_t&gt; </td></tr>
<tr class="memitem:ad3d725740942e0a175b87d23e8228dce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad3d725740942e0a175b87d23e8228dce">merge</a> (std::unordered_multimap&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;source)</td></tr>
<tr class="memdesc:ad3d725740942e0a175b87d23e8228dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:ad3d725740942e0a175b87d23e8228dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f150f182b8abc8caaf5914dbbba8eb" id="r_a73f150f182b8abc8caaf5914dbbba8eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73f150f182b8abc8caaf5914dbbba8eb">rehash</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62">count</a>)</td></tr>
<tr class="memdesc:a73f150f182b8abc8caaf5914dbbba8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves at least the specified number of buckets and regenerates the hash table.  <br /></td></tr>
<tr class="separator:a73f150f182b8abc8caaf5914dbbba8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cb9a204619fd297fb77f09b86b4b29" id="r_a73cb9a204619fd297fb77f09b86b4b29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73cb9a204619fd297fb77f09b86b4b29">remove</a> (const key_t &amp;key) noexcept override</td></tr>
<tr class="memdesc:a73cb9a204619fd297fb77f09b86b4b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the value with the specified key from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a73cb9a204619fd297fb77f09b86b4b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b135339b414dd74f28dd0644fc255f3" id="r_a5b135339b414dd74f28dd0644fc255f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b135339b414dd74f28dd0644fc255f3">remove</a> (const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;item) noexcept override</td></tr>
<tr class="memdesc:a5b135339b414dd74f28dd0644fc255f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first occurrence of a specific object from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a5b135339b414dd74f28dd0644fc255f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8a911620f4d683e1ddab2edb518310" id="r_a0a8a911620f4d683e1ddab2edb518310"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a8a911620f4d683e1ddab2edb518310">remove</a> (const key_t &amp;key, value_t &amp;value) noexcept</td></tr>
<tr class="memdesc:a0a8a911620f4d683e1ddab2edb518310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the value with the specified key from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, and copies the element to the <code>value</code> parameter.  <br /></td></tr>
<tr class="separator:a0a8a911620f4d683e1ddab2edb518310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f59aa65bc93ff2771d7c1163e221368" id="r_a3f59aa65bc93ff2771d7c1163e221368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f59aa65bc93ff2771d7c1163e221368">reserve</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62">count</a>)</td></tr>
<tr class="memdesc:a3f59aa65bc93ff2771d7c1163e221368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for at least the specified number of elements and regenerates the hash table.  <br /></td></tr>
<tr class="separator:a3f59aa65bc93ff2771d7c1163e221368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4477fff561437e9a5487120b57055dd5" id="r_a4477fff561437e9a5487120b57055dd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4477fff561437e9a5487120b57055dd5">swap</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a4477fff561437e9a5487120b57055dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents.  <br /></td></tr>
<tr class="separator:a4477fff561437e9a5487120b57055dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae995c559f83b9915daf53430f2ccc95e" id="r_ae995c559f83b9915daf53430f2ccc95e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae995c559f83b9915daf53430f2ccc95e">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:ae995c559f83b9915daf53430f2ccc95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string that represents the current object.  <br /></td></tr>
<tr class="separator:ae995c559f83b9915daf53430f2ccc95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039c4cc5a88a74481047772f8dc30980" id="r_a039c4cc5a88a74481047772f8dc30980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a039c4cc5a88a74481047772f8dc30980">trim_excess</a> (<a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3">capacity</a>)</td></tr>
<tr class="memdesc:a039c4cc5a88a74481047772f8dc30980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the capacity of this dictionary to hold up a specified number of entries without any further expansion of its backing storage.  <br /></td></tr>
<tr class="separator:a039c4cc5a88a74481047772f8dc30980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e33a4f0c0ff75219a24c4e17dd96798" id="r_a7e33a4f0c0ff75219a24c4e17dd96798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e33a4f0c0ff75219a24c4e17dd96798">trim_excess</a> ()</td></tr>
<tr class="memdesc:a7e33a4f0c0ff75219a24c4e17dd96798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries.  <br /></td></tr>
<tr class="separator:a7e33a4f0c0ff75219a24c4e17dd96798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5609a2b1e1555fe690d1b86368f36a64" id="r_a5609a2b1e1555fe690d1b86368f36a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5609a2b1e1555fe690d1b86368f36a64">try_add</a> (const key_t &amp;key, const value_t value) noexcept</td></tr>
<tr class="memdesc:a5609a2b1e1555fe690d1b86368f36a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to add the specified key and value to the dictionary.  <br /></td></tr>
<tr class="separator:a5609a2b1e1555fe690d1b86368f36a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f68a0c5f67be81a1de0390a4f44ada" id="r_af3f68a0c5f67be81a1de0390a4f44ada"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:af3f68a0c5f67be81a1de0390a4f44ada"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3f68a0c5f67be81a1de0390a4f44ada">try_emplace</a> (const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:af3f68a0c5f67be81a1de0390a4f44ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.  <br /></td></tr>
<tr class="separator:af3f68a0c5f67be81a1de0390a4f44ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2701181224b009ca6d91700273f56ab0" id="r_a2701181224b009ca6d91700273f56ab0"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:a2701181224b009ca6d91700273f56ab0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2701181224b009ca6d91700273f56ab0">try_emplace</a> (key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2701181224b009ca6d91700273f56ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.  <br /></td></tr>
<tr class="separator:a2701181224b009ca6d91700273f56ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6e71848f61306f161e00ef6abbcba1" id="r_a0a6e71848f61306f161e00ef6abbcba1"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:a0a6e71848f61306f161e00ef6abbcba1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a6e71848f61306f161e00ef6abbcba1">try_emplace</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> hint, const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0a6e71848f61306f161e00ef6abbcba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.  <br /></td></tr>
<tr class="separator:a0a6e71848f61306f161e00ef6abbcba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04620bd4ec2d7f3b5d0df030f5a1d9f" id="r_aa04620bd4ec2d7f3b5d0df030f5a1d9f"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:aa04620bd4ec2d7f3b5d0df030f5a1d9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa04620bd4ec2d7f3b5d0df030f5a1d9f">try_emplace</a> (<a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> hint, key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa04620bd4ec2d7f3b5d0df030f5a1d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.  <br /></td></tr>
<tr class="separator:aa04620bd4ec2d7f3b5d0df030f5a1d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86c4dc2cfd6286bc7543d33f99a695d" id="r_ac86c4dc2cfd6286bc7543d33f99a695d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac86c4dc2cfd6286bc7543d33f99a695d">try_get_value</a> (const key_t &amp;key, value_t &amp;value) const override</td></tr>
<tr class="memdesc:ac86c4dc2cfd6286bc7543d33f99a695d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value associated with the specified key.  <br /></td></tr>
<tr class="separator:ac86c4dc2cfd6286bc7543d33f99a695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:a82c683da2de29870afa991f4445dac29" id="r_a82c683da2de29870afa991f4445dac29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82c683da2de29870afa991f4445dac29">operator=</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a82c683da2de29870afa991f4445dac29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a82c683da2de29870afa991f4445dac29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f2116e984d8e567f334c97e84f4bc8" id="r_a34f2116e984d8e567f334c97e84f4bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34f2116e984d8e567f334c97e84f4bc8">operator=</a> (std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a34f2116e984d8e567f334c97e84f4bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a34f2116e984d8e567f334c97e84f4bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8af37e930bc671470277333004815c6" id="r_aa8af37e930bc671470277333004815c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8af37e930bc671470277333004815c6">operator=</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:aa8af37e930bc671470277333004815c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:aa8af37e930bc671470277333004815c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93aa4cf42b1c7c83d3b01dafe6deac1" id="r_aa93aa4cf42b1c7c83d3b01dafe6deac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa93aa4cf42b1c7c83d3b01dafe6deac1">operator=</a> (const std::unordered_map&lt; key_t, value_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aa93aa4cf42b1c7c83d3b01dafe6deac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:aa93aa4cf42b1c7c83d3b01dafe6deac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ceb0d680fe9a5d5d6c2f02e4bdcd60" id="r_a14ceb0d680fe9a5d5d6c2f02e4bdcd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14ceb0d680fe9a5d5d6c2f02e4bdcd60">operator=</a> (std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:a14ceb0d680fe9a5d5d6c2f02e4bdcd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a14ceb0d680fe9a5d5d6c2f02e4bdcd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d7bdef948dda8ae4029da1ea3b398a" id="r_a14d7bdef948dda8ae4029da1ea3b398a"><td class="memTemplParams" colspan="2">template&lt;class init_key_t, class init_value_t&gt; </td></tr>
<tr class="memitem:a14d7bdef948dda8ae4029da1ea3b398a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14d7bdef948dda8ae4029da1ea3b398a">operator=</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; ilist)</td></tr>
<tr class="memdesc:a14d7bdef948dda8ae4029da1ea3b398a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a14d7bdef948dda8ae4029da1ea3b398a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8d5edb392d4da50dfa18ff778b9aec" id="r_a0e8d5edb392d4da50dfa18ff778b9aec"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e8d5edb392d4da50dfa18ff778b9aec">operator[]</a> (const key_t &amp;key) const override</td></tr>
<tr class="memdesc:a0e8d5edb392d4da50dfa18ff778b9aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element with the specified key.  <br /></td></tr>
<tr class="separator:a0e8d5edb392d4da50dfa18ff778b9aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bf80a6988e9d62a6e57df4f12e00c2" id="r_a03bf80a6988e9d62a6e57df4f12e00c2"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03bf80a6988e9d62a6e57df4f12e00c2">operator[]</a> (const key_t &amp;key) override</td></tr>
<tr class="memdesc:a03bf80a6988e9d62a6e57df4f12e00c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element with the specified key.  <br /></td></tr>
<tr class="separator:a03bf80a6988e9d62a6e57df4f12e00c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b0f390c2eef3a3bc08a06c74134c7b" id="r_a04b0f390c2eef3a3bc08a06c74134c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04b0f390c2eef3a3bc08a06c74134c7b">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:a04b0f390c2eef3a3bc08a06c74134c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a04b0f390c2eef3a3bc08a06c74134c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2128516be272bac5e5a5561d1ad55eff" id="r_a2128516be272bac5e5a5561d1ad55eff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2128516be272bac5e5a5561d1ad55eff">operator base_type &amp;</a> () noexcept</td></tr>
<tr class="memdesc:a2128516be272bac5e5a5561d1ad55eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a2128516be272bac5e5a5561d1ad55eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:a7d3fdc16ef498f8c7a4bc8e625ef8d92" id="r_a7d3fdc16ef498f8c7a4bc8e625ef8d92"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a7d3fdc16ef498f8c7a4bc8e625ef8d92">key_type</a></td></tr>
<tr class="memdesc:a7d3fdc16ef498f8c7a4bc8e625ef8d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary key type.  <br /></td></tr>
<tr class="separator:a7d3fdc16ef498f8c7a4bc8e625ef8d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d8c36814a04e88a2c3765254402fea" id="r_ab9d8c36814a04e88a2c3765254402fea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ab9d8c36814a04e88a2c3765254402fea">mapped_type</a></td></tr>
<tr class="memdesc:ab9d8c36814a04e88a2c3765254402fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary mapped type.  <br /></td></tr>
<tr class="separator:ab9d8c36814a04e88a2c3765254402fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9362cfeeb7a17c1018617465eebb312" id="r_ac9362cfeeb7a17c1018617465eebb312"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ac9362cfeeb7a17c1018617465eebb312">value_type</a></td></tr>
<tr class="memdesc:ac9362cfeeb7a17c1018617465eebb312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs.">xtd::collections::generic::idictionary</a> value type.  <br /></td></tr>
<tr class="separator:ac9362cfeeb7a17c1018617465eebb312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966d5c58830c823e37b4d2e227d989af" id="r_a966d5c58830c823e37b4d2e227d989af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a966d5c58830c823e37b4d2e227d989af">iterator</a></td></tr>
<tr class="memdesc:a966d5c58830c823e37b4d2e227d989af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a966d5c58830c823e37b4d2e227d989af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445bda4f9b1bfde0cbb4f77b6b6b1ec9" id="r_a445bda4f9b1bfde0cbb4f77b6b6b1ec9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a445bda4f9b1bfde0cbb4f77b6b6b1ec9">const_iterator</a></td></tr>
<tr class="memdesc:a445bda4f9b1bfde0cbb4f77b6b6b1ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a445bda4f9b1bfde0cbb4f77b6b6b1ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f7bfc73fd451652caf2f96af00442" id="r_a348f7bfc73fd451652caf2f96af00442"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a348f7bfc73fd451652caf2f96af00442">key_collection</a></td></tr>
<tr class="memdesc:a348f7bfc73fd451652caf2f96af00442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary key collection type.  <br /></td></tr>
<tr class="separator:a348f7bfc73fd451652caf2f96af00442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0389edc8c5aa120ac731815b4cd96805" id="r_a0389edc8c5aa120ac731815b4cd96805"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a0389edc8c5aa120ac731815b4cd96805">value_collection</a></td></tr>
<tr class="memdesc:a0389edc8c5aa120ac731815b4cd96805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary value collection type.  <br /></td></tr>
<tr class="separator:a0389edc8c5aa120ac731815b4cd96805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b" id="r_a2743b6f75405882c28eebe2456f3837b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd11aa88ce86568b701b33fd1b3e508" id="r_a6bd11aa88ce86568b701b33fd1b3e508"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a6bd11aa88ce86568b701b33fd1b3e508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a6bd11aa88ce86568b701b33fd1b3e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a01385837c5b1f6254a863510f5e490f1" name="a01385837c5b1f6254a863510f5e490f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01385837c5b1f6254a863510f5e490f1">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary key type. </p>

</div>
</div>
<a id="adef5542e936e56a3a8fd89f05f83c80f" name="adef5542e936e56a3a8fd89f05f83c80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef5542e936e56a3a8fd89f05f83c80f">&#9670;&#160;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::mapped_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary mapped type. </p>

</div>
</div>
<a id="ae2299afc830434c0a0ea06da8c6ce163" name="ae2299afc830434c0a0ea06da8c6ce163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2299afc830434c0a0ea06da8c6ce163">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary value type. </p>

</div>
</div>
<a id="af564e40d9fd72f4ad84f8e5ae62f4610" name="af564e40d9fd72f4ad84f8e5ae62f4610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af564e40d9fd72f4ad84f8e5ae62f4610">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary size type. </p>

</div>
</div>
<a id="ad6f561b6c8f20e4e5f9c8cf73dfbbcc5" name="ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f561b6c8f20e4e5f9c8cf73dfbbcc5">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary difference type. </p>

</div>
</div>
<a id="a1d6112bd0a235323e439c6a230e3fb76" name="a1d6112bd0a235323e439c6a230e3fb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6112bd0a235323e439c6a230e3fb76">&#9670;&#160;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_equal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary <a class="el" href="#a1d6112bd0a235323e439c6a230e3fb76" title="Represents the dictionary key_equal type.">key_equal</a> type. </p>

</div>
</div>
<a id="ad1d7f951247c504df41d30e51f987394" name="ad1d7f951247c504df41d30e51f987394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d7f951247c504df41d30e51f987394">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary allocator type. </p>

</div>
</div>
<a id="aa57e3de24c35cf6d309f983e5f907a3e" name="aa57e3de24c35cf6d309f983e5f907a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57e3de24c35cf6d309f983e5f907a3e">&#9670;&#160;</a></span>base_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::base_value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary base value type. </p>

</div>
</div>
<a id="a4635f1586a55cca04619e6b4d25322f2" name="a4635f1586a55cca04619e6b4d25322f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4635f1586a55cca04619e6b4d25322f2">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::base_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary base type. </p>

</div>
</div>
<a id="a1f55af09de680f0014615c3d4c4a2915" name="a1f55af09de680f0014615c3d4c4a2915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f55af09de680f0014615c3d4c4a2915">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary reference type. </p>

</div>
</div>
<a id="ad8b6e59722145f09a8b59f06d94c9601" name="ad8b6e59722145f09a8b59f06d94c9601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b6e59722145f09a8b59f06d94c9601">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary const reference type. </p>

</div>
</div>
<a id="ad7d6778084f8d0bca3efbbeb5c08829e" name="ad7d6778084f8d0bca3efbbeb5c08829e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d6778084f8d0bca3efbbeb5c08829e">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary pointer type. </p>

</div>
</div>
<a id="ad2bd4b302354f97388d4e4e80fa07e6a" name="ad2bd4b302354f97388d4e4e80fa07e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2bd4b302354f97388d4e4e80fa07e6a">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary const pointer type. </p>

</div>
</div>
<a id="a792954eea61dc2cf8315606d042dd18d" name="a792954eea61dc2cf8315606d042dd18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792954eea61dc2cf8315606d042dd18d">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the iterator of dictionary value type. </p>

</div>
</div>
<a id="abbbff355e29f8facb171c94084884625" name="abbbff355e29f8facb171c94084884625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbff355e29f8facb171c94084884625">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const iterator of dictionary value type. </p>

</div>
</div>
<a id="adc966a9b4269ce145604c61eace7f57c" name="adc966a9b4269ce145604c61eace7f57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc966a9b4269ce145604c61eace7f57c">&#9670;&#160;</a></span>local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the local iterator of dictionary value type. </p>

</div>
</div>
<a id="a259c368e0dff747a4e4687d94d0ca8e0" name="a259c368e0dff747a4e4687d94d0ca8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259c368e0dff747a4e4687d94d0ca8e0">&#9670;&#160;</a></span>const_local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const local iterator of dictionary value type. </p>

</div>
</div>
<a id="a09ebfcd509b5c4d473ec9ab61bed6e85" name="a09ebfcd509b5c4d473ec9ab61bed6e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ebfcd509b5c4d473ec9ab61bed6e85">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary node type. </p>

</div>
</div>
<a id="a7e88bf6f5031a8e127a56adb37ec848d" name="a7e88bf6f5031a8e127a56adb37ec848d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e88bf6f5031a8e127a56adb37ec848d">&#9670;&#160;</a></span>insert_return_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_return_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary insert return type. </p>

</div>
</div>
<a id="ad1c53bc1eb8f0a9125e21fbcd592052a" name="ad1c53bc1eb8f0a9125e21fbcd592052a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c53bc1eb8f0a9125e21fbcd592052a">&#9670;&#160;</a></span>key_collection</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_collection</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the idictionary key collection type. </p>

</div>
</div>
<a id="a0c1d9778d3ed181b8295027c6ce4e1d3" name="a0c1d9778d3ed181b8295027c6ce4e1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1d9778d3ed181b8295027c6ce4e1d3">&#9670;&#160;</a></span>value_collection</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::value_collection</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the idictionary value collection type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a50b15016f1b91a266a8beec12ab89584" name="a50b15016f1b91a266a8beec12ab89584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b15016f1b91a266a8beec12ab89584">&#9670;&#160;</a></span>dictionary() <span class="overload">[1/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the default equality comparer for the key type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the default equality comparer. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. This constructor uses the default generic equality comparer, equality_comparer::default. If type <code>key_t</code> implements the xtd::equatable &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. Alternatively, you can specify an implementation of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">iequality_comparer</a> &lt;typer_t&gt; generic interface by using a constructor that accepts a comparer parameter. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you can estimate the size of the collection, using a constructor that specifies the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd>
<dd>
This constructor is an O(1) operation. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example creates an empty <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; of strings with string keys and uses the Add method to add some elements. The example demonstrates that the <a class="el" href="#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">dictionary::add</a> method throws an <a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a> when attempting to add a duplicate key.</dd></dl>
<p>This code example is part of a larger example provided for the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class. </p><div class="fragment"><div class="line"><span class="comment">// Create a new dictionary of strings, with string keys.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">auto</span> open_with = <a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary&lt;string, string&gt;</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add some elements to the dictionary. There are no</span></div>
<div class="line"><span class="comment">// duplicate keys, but some of the values are duplicates.</span></div>
<div class="line">open_with.add(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;notepad.exe&quot;</span>);</div>
<div class="line">open_with.add(<span class="stringliteral">&quot;bmp&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">open_with.add(<span class="stringliteral">&quot;dib&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">open_with.add(<span class="stringliteral">&quot;rtf&quot;</span>, <span class="stringliteral">&quot;wordpad.exe&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The add method throws an exception if the new key is</span></div>
<div class="line"><span class="comment">// already in the dictionary.</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  open_with.add(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;winword.exe&quot;</span>);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1argument__exception.html">argument_exception</a>&amp;) {</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;An element with key = \&quot;txt\&quot; already exists.&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afd88350f974f41a0c131db83cbf72290" name="afd88350f974f41a0c131db83cbf72290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd88350f974f41a0c131db83cbf72290">&#9670;&#160;</a></span>dictionary() <span class="overload">[2/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">idictionary</a>&lt; key_t, value_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dictionary</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs.">xtd::collections::generic::idictionary</a> &lt;key_t, value_t&gt; and uses the default equality comparer for the key type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dictionary</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs.">xtd::collections::generic::idictionary</a> &lt;key_t, value_t&gt; whose elements are copied to the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the default equality comparer; likewise, every key in the source <code>dictionary</code> must also be unique according to the default equality comparer. </dd>
<dd>
The initial capacity of the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is large enough to contain all the elements in dictionary. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. This constructor uses the default generic equality comparer, <a class="el" href="classxtd_1_1collections_1_1generic_1_1equality__comparer.html#a5849423379f7c39750a1713ba8c44e35" title="Gets the default equality comparer for the type specified by the generic argument.">xtd::collections::generic::equality_comparer::default_equality_comparer</a>. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. Alternatively, you can specify an implementation of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; generic interface by using a constructor that accepts a comparer parameter. </dd>
<dd>
This constructor is an O(n) operation, where n is the number of elements in dictionary. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;(<a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;key_t&gt;) constructor to initialize a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; with sorted content from another dictionary. The code example creates a <a class="el" href="group__generic__collections.html#ga49fc8f84e06c44f96cbc96b8d7705a5b" title="Represents a collection of key/value pairs that are sorted on the key.">xtd::collections::generic::sorted_dictionary</a> &lt;key_t, value_t&gt; and populates it with data in random order, then passes the <a class="el" href="group__generic__collections.html#ga49fc8f84e06c44f96cbc96b8d7705a5b" title="Represents a collection of key/value pairs that are sorted on the key.">xtd::collections::generic::sorted_dictionary</a> &lt;key_t, value_t&gt; to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;(<a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;key_t&gt;) constructor, creating a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; that is sorted. This is useful if you need to build a sorted dictionary that at some point becomes static; copying the data from a <a class="el" href="group__generic__collections.html#ga49fc8f84e06c44f96cbc96b8d7705a5b" title="Represents a collection of key/value pairs that are sorted on the key.">xtd::collections::generic::sorted_dictionary</a> &lt;key_t, value_t&gt; to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; improves retrieval speed. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>example {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="comment">// Create a new sorted dictionary of strings, with string keys.</span></div>
<div class="line">    <span class="keyword">auto</span> open_with = <a class="code hl_typedef" href="group__generic__collections.html#ga49fc8f84e06c44f96cbc96b8d7705a5b">sorted_dictionary&lt;string, string&gt;</a> {};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add some elements to the dictionary.</span></div>
<div class="line">    open_with.insert({<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;notepad.exe&quot;</span>});</div>
<div class="line">    open_with.insert({<span class="stringliteral">&quot;bmp&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>});</div>
<div class="line">    open_with.insert({<span class="stringliteral">&quot;dib&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>});</div>
<div class="line">    open_with.insert({<span class="stringliteral">&quot;rtf&quot;</span>, <span class="stringliteral">&quot;wordpad.exe&quot;</span>});</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create a dictionary of strings with string keys, and</span></div>
<div class="line">    <span class="comment">// initialize it with the contents of the sorted dictionary.</span></div>
<div class="line">    <span class="keyword">auto</span> copy = dictionary&lt;string, string&gt;(open_with.begin(), open_with.end());</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// List the contents of the copy.</span></div>
<div class="line">    console::write_line();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> key_value_pair&lt;string, string&gt;&amp; kvp : copy)</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;key = {0}, value = {1}&quot;</span>, kvp.key(), kvp.value());</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(example::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code can produce the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// key = txt, value = notepad.exe</span></div>
<div class="line"><span class="comment">// key = bmp, value = paint.exe</span></div>
<div class="line"><span class="comment">// key = dib, value = paint.exe</span></div>
<div class="line"><span class="comment">// key = rtf, value = wordpad.exe</span></div>
<div class="ttc" id="agroup__generic__collections_html_ga49fc8f84e06c44f96cbc96b8d7705a5b"><div class="ttname"><a href="group__generic__collections.html#ga49fc8f84e06c44f96cbc96b8d7705a5b">xtd::collections::generic::sorted_dictionary</a></div><div class="ttdeci">std::map&lt; key_t, value_t, lesser_t, allocator_t &gt; sorted_dictionary</div><div class="ttdoc">Represents a collection of key/value pairs that are sorted on the key.</div><div class="ttdef"><b>Definition</b> sorted_dictionary.hpp:38</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae7ddf7990763fbea30e0c6e38b5ae659" name="ae7ddf7990763fbea30e0c6e38b5ae659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ddf7990763fbea30e0c6e38b5ae659">&#9670;&#160;</a></span>dictionary() <span class="overload">[3/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>collection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are copied to the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd1d7beda0f8576d701cd22e9e3a12d8" name="acd1d7beda0f8576d701cd22e9e3a12d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1d7beda0f8576d701cd22e9e3a12d8">&#9670;&#160;</a></span>dictionary() <span class="overload">[4/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equality_comparer_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const equality_comparer_t &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer&lt;type_t&gt;</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer&lt;type_t&gt;</a> implementation to use when comparing keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use this constructor with the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga9ced0825ee1591c057bcf9460a74348f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class to create dictionaries with case-insensitive string keys. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd></dl>

</div>
</div>
<a id="ae43f677d6205a77520b4601206429243" name="ae43f677d6205a77520b4601206429243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43f677d6205a77520b4601206429243">&#9670;&#160;</a></span>dictionary() <span class="overload">[5/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">hasher_t&#160;{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equator_t &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">equator_t&#160;{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer. </dd>
<dd>
The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that can be added to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; before resizing is necessary. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a933f2c0b545c0485ecf052ec431db7a4" name="a933f2c0b545c0485ecf052ec431db7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933f2c0b545c0485ecf052ec431db7a4">&#9670;&#160;</a></span>dictionary() <span class="overload">[6/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer. </dd>
<dd>
The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that can be added to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; before resizing is necessary. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="ab609bca970bff889772b49d51f204487" name="ab609bca970bff889772b49d51f204487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab609bca970bff889772b49d51f204487">&#9670;&#160;</a></span>dictionary() <span class="overload">[7/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equality_comparer_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">idictionary</a>&lt; key_t, value_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dictionary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equality_comparer_t &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dictionary</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; whose elements are copied to the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
    <tr><td class="paramname">comparer</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; implementation to use when comparing keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use this constructor with the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga9ced0825ee1591c057bcf9460a74348f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class to create dictionaries with case-insensitive string keys. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer; likewise, every key in the source <code>dictionary</code> must also be unique according to the specified comparer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For example, duplicate keys can occur if <code>comparer</code> is one of the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga9ced0825ee1591c057bcf9460a74348f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class and <code>dictionary</code> does not use a case-insensitive comparer key. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The initial capacity of the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is large enough to contain all the elements in <code>dictionary</code>. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd>
<dd>
This constructor is an O(n) operation, where n is the number of elements in dictionary. </dd></dl>

</div>
</div>
<a id="a2e18164c1d61bd817872588bd77c6789" name="a2e18164c1d61bd817872588bd77c6789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e18164c1d61bd817872588bd77c6789">&#9670;&#160;</a></span>dictionary() <span class="overload">[8/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equality_comparer_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>collection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equality_comparer_t &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are copied to the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
    <tr><td class="paramname">comparer</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; implementation to use when comparing keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a349de516d0b938124c175ce956b3ac28" name="a349de516d0b938124c175ce956b3ac28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349de516d0b938124c175ce956b3ac28">&#9670;&#160;</a></span>dictionary() <span class="overload">[9/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equality_comparer_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equality_comparer_t &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the specified initial capacity, and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The initial number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can contain. </td></tr>
    <tr><td class="paramname">comparer</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; implementation to use when comparing keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use this constructor with the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga9ced0825ee1591c057bcf9460a74348f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class to create dictionaries with case-insensitive string keys. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer; likewise, every key in the source <code>dictionary</code> must also be unique according to the specified comparer. </dd>
<dd>
The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that can be added to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; before resizing is necessary. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type TKey implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd>
<dd>
This constructor is an O(1) operation. </dd>
<dd>
<a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> and <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a78fb45416d0a2a0b1d27082b7912878b" name="a78fb45416d0a2a0b1d27082b7912878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fb45416d0a2a0b1d27082b7912878b">&#9670;&#160;</a></span>dictionary() <span class="overload">[10/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">hasher_t&#160;{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equator_t &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">equator_t&#160;{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The fist iterator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>Thaae last itezrator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs the container with the contents of the range [first, last). Sets <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>. </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a85a1e3057a72c385fc731c20b21e9606" name="a85a1e3057a72c385fc731c20b21e9606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a1e3057a72c385fc731c20b21e9606">&#9670;&#160;</a></span>dictionary() <span class="overload">[11/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The fist iterator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>Thaae last itezrator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs the container with the contents of the range [first, last). Sets <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>. </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a45d7fe8271b0f7dd1776a8a99de3b1d0" name="a45d7fe8271b0f7dd1776a8a99de3b1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d7fe8271b0f7dd1776a8a99de3b1d0">&#9670;&#160;</a></span>dictionary() <span class="overload">[12/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The fist iterator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>Thaae last itezrator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs the container with the contents of the range [first, last). Sets <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>. </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="aa953d39916161c5551072ee7685d48dc" name="aa953d39916161c5551072ee7685d48dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa953d39916161c5551072ee7685d48dc">&#9670;&#160;</a></span>dictionary() <span class="overload">[13/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
<div class="ttc" id="agroup__xtd__core_html_ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf"><div class="ttname"><a href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">xtd::platform_id::other</a></div><div class="ttdeci">@ other</div><div class="ttdoc">The operating system is other.</div><div class="ttdef"><b>Definition</b> platform_id.hpp:58</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a27cea1264d53956ff616c99322bd744a" name="a27cea1264d53956ff616c99322bd744a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cea1264d53956ff616c99322bd744a">&#9670;&#160;</a></span>dictionary() <span class="overload">[14/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; key_t, value_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5202127b516af4f37f86d4a3f472ddc6" name="a5202127b516af4f37f86d4a3f472ddc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5202127b516af4f37f86d4a3f472ddc6">&#9670;&#160;</a></span>dictionary() <span class="overload">[15/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; key_t, value_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a07b758a73f04808f26eee3fa8ce363ef" name="a07b758a73f04808f26eee3fa8ce363ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b758a73f04808f26eee3fa8ce363ef">&#9670;&#160;</a></span>dictionary() <span class="overload">[16/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="ab1c24d7c8b5165f2e3814e21c8ad0231" name="ab1c24d7c8b5165f2e3814e21c8ad0231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c24d7c8b5165f2e3814e21c8ad0231">&#9670;&#160;</a></span>dictionary() <span class="overload">[17/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="a153be4b6329ddb7d86bfedd03db85ca8" name="a153be4b6329ddb7d86bfedd03db85ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153be4b6329ddb7d86bfedd03db85ca8">&#9670;&#160;</a></span>dictionary() <span class="overload">[18/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="a6260ac3aa16033a8c92bbb9a71c7ede0" name="a6260ac3aa16033a8c92bbb9a71c7ede0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6260ac3aa16033a8c92bbb9a71c7ede0">&#9670;&#160;</a></span>dictionary() <span class="overload">[19/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="a457a42aa23639faa8590bdb23f2d346a" name="a457a42aa23639faa8590bdb23f2d346a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457a42aa23639faa8590bdb23f2d346a">&#9670;&#160;</a></span>dictionary() <span class="overload">[20/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">hasher_t&#160;{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equator_t &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">equator_t&#160;{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acd1e2bddbc888c451b97e6cd2f760250" name="acd1e2bddbc888c451b97e6cd2f760250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1e2bddbc888c451b97e6cd2f760250">&#9670;&#160;</a></span>dictionary() <span class="overload">[21/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a0db2868740c4f2c5e70bb845654d31cf" name="a0db2868740c4f2c5e70bb845654d31cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db2868740c4f2c5e70bb845654d31cf">&#9670;&#160;</a></span>dictionary() <span class="overload">[22/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="af8f5f06c57ba2d50fffe837ff8dde852" name="af8f5f06c57ba2d50fffe837ff8dde852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f5f06c57ba2d50fffe837ff8dde852">&#9670;&#160;</a></span>dictionary() <span class="overload">[23/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t, class init_value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">hasher_t&#160;{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equator_t &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">equator_t&#160;{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a8b272479748bbf823035dc716d9dad1d" name="a8b272479748bbf823035dc716d9dad1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b272479748bbf823035dc716d9dad1d">&#9670;&#160;</a></span>dictionary() <span class="overload">[24/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t, class init_value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a144ad7bfb943fd88490c08ae70251968" name="a144ad7bfb943fd88490c08ae70251968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144ad7bfb943fd88490c08ae70251968">&#9670;&#160;</a></span>dictionary() <span class="overload">[25/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t, class init_value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>bucket_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5fb05a4d36ada3a05639760bbef1866f" name="a5fb05a4d36ada3a05639760bbef1866f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb05a4d36ada3a05639760bbef1866f">&#9670;&#160;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="ad43461af42f40fafcba6c351b8915909" name="ad43461af42f40fafcba6c351b8915909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43461af42f40fafcba6c351b8915909">&#9670;&#160;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="ad51c920c156b8cc6863e143972f5c11b" name="ad51c920c156b8cc6863e143972f5c11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51c920c156b8cc6863e143972f5c11b">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of buckets in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of buckets in the container. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a24ebcb226f6bc8869c35bf9e1d634ff3" name="a24ebcb226f6bc8869c35bf9e1d634ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ebcb226f6bc8869c35bf9e1d634ff3">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total numbers of elements the internal data structure can hold without resizing. </p>
<dl class="section return"><dt>Returns</dt><dd>The total numbers of elements the internal data structure can hold without resizing. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> and <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="ac375db294d333e09891584e2a0956e1d" name="ac375db294d333e09891584e2a0956e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac375db294d333e09891584e2a0956e1d">&#9670;&#160;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="ad63291ea36f70c7ded93799d6890847e" name="ad63291ea36f70c7ded93799d6890847e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63291ea36f70c7ded93799d6890847e">&#9670;&#160;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a2826f22b8d56568081a760c9f6d594da" name="a2826f22b8d56568081a760c9f6d594da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2826f22b8d56568081a760c9f6d594da">&#9670;&#160;</a></span>comparer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::comparer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the td::collections::generic::iequality_comparer &lt;type_t&gt; that is used to determine equality of keys for the dictionary. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; generic interface implementation that is used to determine equality of keys for the current <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; and to provide hash values for the keys. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. You can specify an implementation of the td::collections::generic::iequality_comparer &lt;type_t&gt; generic interface by using a constructor that accepts a comparer parameter; if you do not specify one, the default generic equality comparer td::collections::generic::equality_comparer::default_equality_comparer is used. </dd></dl>

</div>
</div>
<a id="af92f9b1f02bf864a69a46230f9b53c62" name="af92f9b1f02bf864a69a46230f9b53c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92f9b1f02bf864a69a46230f9b53c62">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can store. The <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> property is the number of elements that are actually in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
The capacity is always greater than or equal to <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a>. If <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> exceeds the capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

</div>
</div>
<a id="a55611e5c2304788bf7a281fc5b75e1cb" name="a55611e5c2304788bf7a281fc5b75e1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55611e5c2304788bf7a281fc5b75e1cb">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <code><a class="el" href="#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumerable.">begin()</a> == <a class="el" href="#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumerable.">end()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty; otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a84bcbef97b1acb696d8b444988530830" name="a84bcbef97b1acb696d8b444988530830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bcbef97b1acb696d8b444988530830">&#9670;&#160;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a8e062f26b355616dce3110a815645e7d" name="a8e062f26b355616dce3110a815645e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e062f26b355616dce3110a815645e7d">&#9670;&#160;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="af2181745ec5b125827735336ea9ada43" name="af2181745ec5b125827735336ea9ada43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2181745ec5b125827735336ea9ada43">&#9670;&#160;</a></span>is_read_only()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::is_read_only </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating whether the xtd::collections::generic::icollection &lt;type_t&gt; is read-only. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the xtd::collections::generic::icollection &lt;type_t&gt; is read-only; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A collection that is read-only does not allow the addition or removal of elements after the collection is created. Note that read-only in this context does not indicate whether individual elements of the collection can be modified, since the xtd::collections::generic::icollection &lt;type_t&gt; interface only supports addition and removal operations. For example, the IsReadOnly property of an array that is cast or converted to an xtd::collections::generic::icollection &lt;type_t&gt; object returns <code>true</code>, even though individual array elements can be modified. </dd></dl>

</div>
</div>
<a id="a9798bb3a3f89e6dd45d5783d42957550" name="a9798bb3a3f89e6dd45d5783d42957550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9798bb3a3f89e6dd45d5783d42957550">&#9670;&#160;</a></span>is_synchronized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::is_synchronized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating whether access to the xtd::collections::generic::icollection &lt;type_t&gt; is synchronized (thread safe). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if access to the xtd::collections::generic::icollection &lt;type_t&gt; is synchronized (thread safe); otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>xtd::collections::generic::icollection::sync_root returns an object, which can be used to synchronize access to the xtd::collections::generic::icollection &lt;type_t&gt;. </dd>
<dd>
Most collection classes in the <a class="el" href="namespacextd_1_1collections.html" title="The xtd::collections namespace contains interfaces and classes that define various collections of obj...">xtd::collections</a> namespace also implement a <code>synchronized</code> method, which provides a synchronized wrapper around the underlying collection. </dd>
<dd>
Enumerating through a collection is intrinsically not a thread-safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads. </dd>
<dd>
The following code example shows how to lock the collection using the xtd::collections::generic::icollection::sync_root property during the entire enumeration. <div class="fragment"><div class="line">icollection&amp; my_collection = some_collection;</div>
<div class="line"><a class="code hl_define" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a>(my_collection.sync_root()) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> item : my_collection) {</div>
<div class="line">    <span class="comment">// Insert your code here.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__keywords_html_gacd9906b29d877eb1eb0a8c7bc4ab774a"><div class="ttname"><a href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a></div><div class="ttdeci">#define lock_(object)</div><div class="ttdoc">The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...</div><div class="ttdef"><b>Definition</b> lock.hpp:85</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac5f9fa62ba008a290c60f795e768d74f" name="ac5f9fa62ba008a290c60f795e768d74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f9fa62ba008a290c60f795e768d74f">&#9670;&#160;</a></span>items() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="#a4635f1586a55cca04619e6b4d25322f2">base_type</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="aeb58202461ac49407519756acca9ed12" name="aeb58202461ac49407519756acca9ed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb58202461ac49407519756acca9ed12">&#9670;&#160;</a></span>items() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a4635f1586a55cca04619e6b4d25322f2">base_type</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="ac2a9b4d312798abd41548c6c97ee3312" name="ac2a9b4d312798abd41548c6c97ee3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a9b4d312798abd41548c6c97ee3312">&#9670;&#160;</a></span>keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad1c53bc1eb8f0a9125e21fbcd592052a">key_collection</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::keys </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a collection containing the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="#ad1c53bc1eb8f0a9125e21fbcd592052a" title="Represents the idictionary key collection type.">xtd::collections::generic::dictionary::key_collection</a> containing the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the keys in the <a class="el" href="#ad1c53bc1eb8f0a9125e21fbcd592052a" title="Represents the idictionary key collection type.">xtd::collections::generic::dictionary::key_collection</a> is unspecified, but it is the same order as the associated values in the <a class="el" href="#a0c1d9778d3ed181b8295027c6ce4e1d3" title="Represents the idictionary value collection type.">xtd::collections::generic::dictionary::value_collection</a> returned by the <a class="el" href="#aa5519d6518ce9849e89b90fd573839f2" title="Gets a collection containing the values in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::values</a> property. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a6784f23fccd9a8021528e645b0d73e22">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="ad12fed9d70080e18e58e5f678ff8fce0" name="ad12fed9d70080e18e58e5f678ff8fce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fed9d70080e18e58e5f678ff8fce0">&#9670;&#160;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the average number of elements per bucket, that is, <a class="el" href="#a9b8a36cd363866ea458b74960e5d68eb" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::size</a> divided by <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Average number of elements per bucket. </dd></dl>

</div>
</div>
<a id="ad9e4c1821576c7fba7fdd4dea0f2c512" name="ad9e4c1821576c7fba7fdd4dea0f2c512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e4c1821576c7fba7fdd4dea0f2c512">&#9670;&#160;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of buckets the container is able to hold due to system or library implementation limitations. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of buckets. </dd></dl>

</div>
</div>
<a id="af4ebdfacb702aad8221aa1b77817cdbd" name="af4ebdfacb702aad8221aa1b77817cdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ebdfacb702aad8221aa1b77817cdbd">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold. </p>
<dl class="section return"><dt>Returns</dt><dd>The current maximum load factor. </dd></dl>

</div>
</div>
<a id="ad7f7acfa0c36a187bd76efe62d87581c" name="ad7f7acfa0c36a187bd76efe62d87581c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f7acfa0c36a187bd76efe62d87581c">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new maximum load factor setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a070747ad0686a9136f66dfc5e3b19aa9" name="a070747ad0686a9136f66dfc5e3b19aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070747ad0686a9136f66dfc5e3b19aa9">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumerable.">begin()</a>, <a class="el" href="#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumerable.">end()</a>)</code> for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This value typically reflects the theoretical limit on the size of the container, at most <code><a class="el" href="classxtd_1_1box__integer.html#a21847edbb248c1b0d07a35e2a8c08232">xtd::ptrdiff_object::max_value</a></code> or <code>std::numeric_limits&lt;<a class="el" href="#ad6f561b6c8f20e4e5f9c8cf73dfbbcc5" title="Represents the dictionary difference type.">difference_type</a>&gt;::max()</code>. At runtime, the size of the container may be limited to a value smaller than <a class="el" href="#a070747ad0686a9136f66dfc5e3b19aa9" title="Gets the maximum number of elements the container is able to hold due to system or library implementa...">max_size()</a> by the amount of RAM available. </dd></dl>

</div>
</div>
<a id="a9b8a36cd363866ea458b74960e5d68eb" name="a9b8a36cd363866ea458b74960e5d68eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8a36cd363866ea458b74960e5d68eb">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can store. The <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> property is the number of elements that are actually in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
The capacity is always greater than or equal to <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a>. If <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> exceeds the capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

</div>
</div>
<a id="a0784fa1eee73f0061df828986a5ae52d" name="a0784fa1eee73f0061df828986a5ae52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0784fa1eee73f0061df828986a5ae52d">&#9670;&#160;</a></span>sync_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1object.html">xtd::object</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::sync_root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an object that can be used to synchronize access to the the xtd::collections::generic::icollection &lt;type_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>An object that can be used to synchronize access to the the xtd::collections::generic::icollection &lt;type_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For collections whose underlying store is not publicly available, the expected implementation is to return the current instance. Note that the pointer to the current instance might not be sufficient for collections that wrap other collections; those should return the underlying collection's <code>sync_root</code> property. </dd>
<dd>
Most collection classes in the xts::.collections namespace also implement a <code>synchronized</code> method, which provides a synchronized wrapper around the underlying collection. However, derived classes can provide their own synchronized version of the collection using the xtd::collections::generic::icollection::sync_root property. The synchronizing code must perform operations on the xtd::collections::generic::icollection::sync_root property of the collection, not directly on the collection. This ensures proper operation of collections that are derived from other objects. Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection instance. </dd>
<dd>
In the absence of a <code>synchronized</code> method on a collection, the expected usage for the xtd::collections::generic::icollection::sync_root looks as follows: <div class="fragment"><div class="line">icollection&amp; my_collection = some_collection;</div>
<div class="line"><a class="code hl_define" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a>(my_collection.sync_root()) {</div>
<div class="line">  <span class="comment">// Some operation on the collection, which is now thread safe.</span></div>
<div class="line">}</div>
<div class="line">@encode</div>
<div class="line">@remarks Enumerating through <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a> collection <a class="code hl_function" href="group__xtd__core.html#ga8419620dc289ac0d790372a1616e993f">is</a> intrinsically not <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a> thread-safe procedure. Even when <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a> collection <a class="code hl_function" href="group__xtd__core.html#ga8419620dc289ac0d790372a1616e993f">is</a> <span class="keyword">synchronized</span>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a> threads can still modify the collection, which causes the <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">enumerator</a> to <span class="keywordflow">throw</span> an <a class="code hl_class" href="classxtd_1_1exception.html">exception</a>. To guarantee thread safety during enumeration, you can either <a class="code hl_typedef" href="group__threading.html#ga69b2e366d61bebf3fd9e94f83d51eb77">lock</a> the collection during the entire enumeration or <span class="keywordflow">catch</span> the exceptions resulting from changes made by <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a> threads.</div>
<div class="line">@remarks The following code example shows how to <a class="code hl_typedef" href="group__threading.html#ga69b2e366d61bebf3fd9e94f83d51eb77">lock</a> the collection <span class="keyword">using </span>the xtd::collections::generic::icollection::sync_root <span class="keyword">property</span> during the entire enumeration.</div>
<div class="line">@code</div>
<div class="line">icollection&amp; my_collection = some_collection;</div>
<div class="line"><a class="code hl_define" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a>(my_collection.sync_root()) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> item : my_collection) {</div>
<div class="line">    <span class="comment">// Insert your code here.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassxtd_1_1exception_html"><div class="ttname"><a href="classxtd_1_1exception.html">xtd::exception</a></div><div class="ttdoc">Defines the base class for predefined exceptions in the xtd namespace.</div><div class="ttdef"><b>Definition</b> exception.hpp:30</div></div>
<div class="ttc" id="agroup__threading_html_ga69b2e366d61bebf3fd9e94f83d51eb77"><div class="ttname"><a href="group__threading.html#ga69b2e366d61bebf3fd9e94f83d51eb77">xtd::lock</a></div><div class="ttdeci">xtd::threading::lock_guard lock</div><div class="ttdoc">Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.</div><div class="ttdef"><b>Definition</b> lock.hpp:22</div></div>
<div class="ttc" id="agroup__xtd__core_html_ga8419620dc289ac0d790372a1616e993f"><div class="ttname"><a href="group__xtd__core.html#ga8419620dc289ac0d790372a1616e993f">xtd::is</a></div><div class="ttdeci">bool is(xtd::any value)</div><div class="ttdoc">Checks if the result of an expression is compatible with a given type.</div><div class="ttdef"><b>Definition</b> is.hpp:485</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">xtd::console_key::a</a></div><div class="ttdeci">@ a</div><div class="ttdoc">The A key.</div><div class="ttdef"><b>Definition</b> console_key.hpp:88</div></div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1enumerator_html"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1enumerator.html">xtd::collections::generic::enumerator</a></div><div class="ttdoc">Supports a simple iteration over a generic collection.</div><div class="ttdef"><b>Definition</b> enumerator.hpp:38</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa5519d6518ce9849e89b90fd573839f2" name="aa5519d6518ce9849e89b90fd573839f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5519d6518ce9849e89b90fd573839f2">&#9670;&#160;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a0c1d9778d3ed181b8295027c6ce4e1d3">value_collection</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::values </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a collection containing the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="#a0c1d9778d3ed181b8295027c6ce4e1d3" title="Represents the idictionary value collection type.">xtd::collections::generic::dictionary::value_collection</a> containing the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the values in the <a class="el" href="#a0c1d9778d3ed181b8295027c6ce4e1d3" title="Represents the idictionary value collection type.">xtd::collections::generic::dictionary::value_collection</a> is unspecified, but it is the same order as the associated keys in the <a class="el" href="#ad1c53bc1eb8f0a9125e21fbcd592052a" title="Represents the idictionary key collection type.">xtd::collections::generic::dictionary::key_collection</a> returned by the <a class="el" href="#ac2a9b4d312798abd41548c6c97ee3312" title="Gets a collection containing the keys in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::keys</a> property. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ab9b17f2c004a86dc970ccb5a95e60151">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a8e4b572d70b69d4b688a2835a3258522" name="a8e4b572d70b69d4b688a2835a3258522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4b572d70b69d4b688a2835a3258522">&#9670;&#160;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element with the provided key and value to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The object to use as the key of the element to add. </td></tr>
    <tr><td class="paramname">value</td><td>The object to use as the value of the element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>An element with the same key already exists in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>You can also use the <code>operator []</code> to add new elements by setting the value of a key that does not exist in the dictionary; for example, <code>my_collection["my_nonexistent_key"] = my_value</code>. However, if the specified key already exists in the dictionary, setting the <code>operator []</code> overwrites the old value. In contrast, the <a class="el" href="#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method does not modify existing elements. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ae5306bbad7df56d8b4ce4089b78befdc">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a22f323cd7289784e6380117b8bfadf8b" name="a22f323cd7289784e6380117b8bfadf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f323cd7289784e6380117b8bfadf8b">&#9670;&#160;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an item to the xtd::collections::generic::icollection &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The object to add to the xtd::collections::generic::icollection &lt;type_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The xtd::collections::generic::icollection &lt;type_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56664bbd826ba01e34ff35477064db2d" name="a56664bbd826ba01e34ff35477064db2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56664bbd826ba01e34ff35477064db2d">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a></td><td>The property is retrieved and key is not found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32980a15b7ef803c1ba5c8d69f1dbb84" name="a32980a15b7ef803c1ba5c8d69f1dbb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32980a15b7ef803c1ba5c8d69f1dbb84">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a></td><td>The property is retrieved and key is not found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d3e8fd61595d88e72199205dbf976b5" name="a8d3e8fd61595d88e72199205dbf976b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3e8fd61595d88e72199205dbf976b5">&#9670;&#160;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adc966a9b4269ce145604c61eace7f57c">local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the first element of the bucket with index <code>n</code>. </dd></dl>

</div>
</div>
<a id="a772b3aff980ea2b05d5bf8ce5cbdd9f1" name="a772b3aff980ea2b05d5bf8ce5cbdd9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772b3aff980ea2b05d5bf8ce5cbdd9f1">&#9670;&#160;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the first element of the bucket with index <code>n</code>. </dd></dl>

</div>
</div>
<a id="a3b83cb5cb0fa23c7b4ff7c2c447419aa" name="a3b83cb5cb0fa23c7b4ff7c2c447419aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b83cb5cb0fa23c7b4ff7c2c447419aa">&#9670;&#160;</a></span>bucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The value of the key to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bucket index for the requested key. </dd></dl>

</div>
</div>
<a id="a8ce1e7684c03c73e9980372eceb779a2" name="a8ce1e7684c03c73e9980372eceb779a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce1e7684c03c73e9980372eceb779a2">&#9670;&#160;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the bucket with index <code>n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the bucket <code>n</code>. </dd></dl>

</div>
</div>
<a id="a325d0ef8dbeb149776a600386b13a9c6" name="a325d0ef8dbeb149776a600386b13a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325d0ef8dbeb149776a600386b13a9c6">&#9670;&#160;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the first element of the bucket with index <code>n</code>. </dd></dl>

</div>
</div>
<a id="ab38876c6b918c241ca74f597089606c1" name="ab38876c6b918c241ca74f597089606c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38876c6b918c241ca74f597089606c1">&#9670;&#160;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the element following the last element of the bucket with index <code>n</code>. This element acts as a placeholder, attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a50385c2da2442292164bc4f65c84ee76" name="a50385c2da2442292164bc4f65c84ee76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50385c2da2442292164bc4f65c84ee76">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all keys and values from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> property is set to 0, and references to other objects from elements of the collection are also released. The capacity remains unchanged. </dd></dl>

</div>
</div>
<a id="a7db129cddf553ee484a09e6d39bb87a0" name="a7db129cddf553ee484a09e6d39bb87a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db129cddf553ee484a09e6d39bb87a0">&#9670;&#160;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container contains element with specific key. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Checks if there is an element with <code>key</code> equivalent to key in the container. </dd></dl>

</div>
</div>
<a id="ac19c1aca5cdab0045940d70246b37093" name="ac19c1aca5cdab0045940d70246b37093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19c1aca5cdab0045940d70246b37093">&#9670;&#160;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class contains_key_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const contains_key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container contains element with specific key. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Checks if there is an element with key that compares equivalent to the value <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such <code>hasher_t</code> is callable with both <code>contains_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>key_t</code>. </dd></dl>

</div>
</div>
<a id="a90b87fe3db85b2c9f55ac59544070e20" name="a90b87fe3db85b2c9f55ac59544070e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b87fe3db85b2c9f55ac59544070e20">&#9670;&#160;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether an element is in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The object to be added to the end of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains an element with the specified <code>item</code> ; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="acf27b6ece343e1dd7450de296277f892" name="acf27b6ece343e1dd7450de296277f892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf27b6ece343e1dd7450de296277f892">&#9670;&#160;</a></span>contains_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::contains_key </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>key to locate in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains an element with the specified <code>key</code> ; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method approaches an O(1) operation. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#aad1ca9a4fd67aecfd518cf2a2df6f73d">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a3d231addcc65486d9ad0abee23ada3ac" name="a3d231addcc65486d9ad0abee23ada3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d231addcc65486d9ad0abee23ada3ac">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>array_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements of the xtd::collections::generic::icollection &lt;type_t&gt; to an <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a>, starting at a particular <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The one-dimensional <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> that is the destination of the elements copied from xtd::collections::generic::icollection &lt;type_t&gt;. The <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> must have zero-based indexing. </td></tr>
    <tr><td class="paramname">array_index</td><td>The zero-based index in <code>array</code> at which copying begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The number of elements in the source xtd::collections::generic::icollection &lt;type_t&gt; is greater than the available space from `array_index` to the end of the destination `array`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62388a5a93af71eb55d9f509420d1acb" name="a62388a5a93af71eb55d9f509420d1acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62388a5a93af71eb55d9f509420d1acb">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">args_t &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs element in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container. </dd>
<dd>
The constructor of the new element (i.e. <code>std::pair&lt;const key_t, value_t&gt;)</code> is called with exactly the same arguments as supplied to emplace, forwarded via <code>std::forward&lt;args_t&gt;(args)....</code> The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately (see <a class="el" href="#af3f68a0c5f67be81a1de0390a4f44ada" title="Inserts in-place if the key does not exist, does nothing if the key exists.">xtd::collections::generic::dictionary::try_emplace</a> if this behavior is undesirable). </dd>
<dd>
Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a657fad4302a8e0c5a82892df5bef0504" name="a657fad4302a8e0c5a82892df5bef0504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657fad4302a8e0c5a82892df5bef0504">&#9670;&#160;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs elements in-place using a hint </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the new element. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts a new element into the container, using <code>hint</code> as a suggestion where the element should go. </dd>
<dd>
The constructor of the element type (<a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a>, that is, <code>std::pair&lt;const key_t, value_t&gt;</code>) is called with exactly the same arguments as supplied to the function, forwarded with <code>std::forward&lt;args_t&gt;(args)...</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a0cefc1b2c8027b4257647fccda518f71" name="a0cefc1b2c8027b4257647fccda518f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cefc1b2c8027b4257647fccda518f71">&#9670;&#160;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adc966a9b4269ce145604c61eace7f57c">local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the element following the last element of the bucket with index <code>n</code>. This element acts as a placeholder, attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="aa26ad005233fb7741a285d791e56db19" name="aa26ad005233fb7741a285d791e56db19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26ad005233fb7741a285d791e56db19">&#9670;&#160;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the element following the last element of the bucket with index <code>n</code>. This element acts as a placeholder, attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a460da2f9004cddf41f14d23d1fa09a25" name="a460da2f9004cddf41f14d23d1fa09a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460da2f9004cddf41f14d23d1fa09a25">&#9670;&#160;</a></span>ensure_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::ensure_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the dictionary can hold up to a specified number of entries without any further expansion of its backing storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The number of entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>

</div>
</div>
<a id="a7192082480f0412da88dfa004dca3c3b" name="a7192082480f0412da88dfa004dca3c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7192082480f0412da88dfa004dca3c3b">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range of elements matching a specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value to compare the elements to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a>) iterators are returned as both elements of the pair. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns a range containing all elements with key <code>key</code> in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range. </dd></dl>

</div>
</div>
<a id="a85e8a1a164d50122468d84a0d31c0724" name="a85e8a1a164d50122468d84a0d31c0724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e8a1a164d50122468d84a0d31c0724">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equal_range_key_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>, <a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const equal_range_key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range of elements matching a specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value to compare the elements to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a>) iterators are returned as both elements of the pair. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns a range containing all elements with key <code>key</code> in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range. </dd></dl>

</div>
</div>
<a id="a94931223079f91ec84fd48de20d2c3e8" name="a94931223079f91ec84fd48de20d2c3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94931223079f91ec84fd48de20d2c3e8">&#9670;&#160;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equal_range_key_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const equal_range_key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range of elements matching a specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value of any type that can be transparently compared with a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a>) iterators are returned as both elements of the pair. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns a range containing all elements in the container with key equivalent to <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such Hash is callable with both <code>equal_range_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>equal_range_key_t</code>. </dd></dl>

</div>
</div>
<a id="a60a7786db2622f4e3c0cab7f64b6ff58" name="a60a7786db2622f4e3c0cab7f64b6ff58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a7786db2622f4e3c0cab7f64b6ff58">&#9670;&#160;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a>, <a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range of elements matching a specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value of any type that can be transparently compared with a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a>) iterators are returned as both elements of the pair. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns a range containing all elements in the container with key equivalent to <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such Hash is callable with both <code>equal_range_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>key_t</code>. </dd></dl>

</div>
</div>
<a id="a05eab79e42511efe5dd18c64f470a6bd" name="a05eab79e42511efe5dd18c64f470a6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eab79e42511efe5dd18c64f470a6bd">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator to the element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator following the last removed element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes specified elements from the container. The order of the remaining elements is preserved. (This makes it possible to erase individual elements while iterating through the container.) </dd>
<dd>
Removes the element at <code>pos</code>. </dd>
<dd>
References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated. </dd>
<dd>
The iterator <code>pos</code> must be valid and dereferenceable. Thus the <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for <code>pos</code>. </dd></dl>

</div>
</div>
<a id="a51e499b3634ee1402b59a6742fc817e1" name="a51e499b3634ee1402b59a6742fc817e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e499b3634ee1402b59a6742fc817e1">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of the range of elements to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator of the range of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator following the last removed element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes specified elements from the container. The order of the remaining elements is preserved. (This makes it possible to erase individual elements while iterating through the container.) </dd>
<dd>
Removes the elements in the range [<code>first</code>, <code>last</code>), which must be a valid range in <code>*this</code>. </dd>
<dd>
References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated. </dd>
<dd>
The iterator <code>pos</code> must be valid and dereferenceable. Thus the <a class="el" href="#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for <code>pos</code>. </dd></dl>

</div>
</div>
<a id="aa7a6184442c9b335e7984d655f722e0d" name="aa7a6184442c9b335e7984d655f722e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a6184442c9b335e7984d655f722e0d">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value of the elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements removed (0 or 1). </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes specified elements from the container. The order of the remaining elements is preserved. (This makes it possible to erase individual elements while iterating through the container.) </dd>
<dd>
Removes the element (if one exists) with the key equivalent to <code>key</code>. </dd>
<dd>
References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated. </dd>
<dd>
The iterator <code>pos</code> must be valid and dereferenceable. Thus the <a class="el" href="#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for <code>pos</code>. </dd></dl>

</div>
</div>
<a id="a7934e22726ecf3f3e3ddbe7ae6dbe4b5" name="a7934e22726ecf3f3e3ddbe7ae6dbe4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7934e22726ecf3f3e3ddbe7ae6dbe4b5">&#9670;&#160;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts nodes from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A valid iterator into this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a> that owns the extracted element, or empty node handle in case the element is not found in. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlinks the node that contains the element pointed to by position and returns a <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a> that owns it. </dd>
<dd>
In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed. </dd>
<dd>
Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container. </dd></dl>

</div>
</div>
<a id="a248ff4fbc36fb649ca0ef6a682b37c6c" name="a248ff4fbc36fb649ca0ef6a682b37c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248ff4fbc36fb649ca0ef6a682b37c6c">&#9670;&#160;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">const key_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts nodes from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>A key to identify the node to be extracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a> that owns the extracted element, or empty node handle in case the element is not found in. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the container has an element with key equivalent to k, unlinks the node that contains that element from the container and returns a <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a> that owns it. Otherwise, returns an empty node handle. </dd>
<dd>
In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed. </dd>
<dd>
Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container. </dd></dl>

</div>
</div>
<a id="a15b99ac9d6af11fda53cb838f611a0ec" name="a15b99ac9d6af11fda53cb838f611a0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b99ac9d6af11fda53cb838f611a0ec">&#9670;&#160;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds element with specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value of the element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the requested element. If no such element is found, past-the-end (see <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a>) iterator is returned. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds an element with key equivalent to <code>key</code>. </dd></dl>

</div>
</div>
<a id="ae181d2502d73a096dd98bef746081251" name="ae181d2502d73a096dd98bef746081251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae181d2502d73a096dd98bef746081251">&#9670;&#160;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds element with specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value of the element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the requested element. If no such element is found, past-the-end (see <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a>) iterator is returned. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds an element with key equivalent to <code>key</code>. </dd></dl>

</div>
</div>
<a id="a4e712574f32c4ee5baf17502c9d89991" name="a4e712574f32c4ee5baf17502c9d89991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e712574f32c4ee5baf17502c9d89991">&#9670;&#160;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class find_key_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const find_key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds element with specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value of any type that can be transparently compared with a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the requested element. If no such element is found, past-the-end (see <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a>) iterator is returned. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds an element with key that compares equivalent to the value <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such <code>hasher_t</code> is callable with both <code>find_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>key_t</code>. </dd></dl>

</div>
</div>
<a id="a6ba5c1ca5b7f05e3035ba70ca10c1ae0" name="a6ba5c1ca5b7f05e3035ba70ca10c1ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba5c1ca5b7f05e3035ba70ca10c1ae0">&#9670;&#160;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class find_key_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const find_key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds element with specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value of any type that can be transparently compared with a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds an element with key that compares equivalent to the value <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such <code>hasher_t</code> is callable with both <code>find_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>key_t</code>. </dd></dl>

</div>
</div>
<a id="ae3f30a82dc96ded7a4145c3d0533e3a7" name="ae3f30a82dc96ded7a4145c3d0533e3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f30a82dc96ded7a4145c3d0533e3a7">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad1d7f951247c504df41d30e51f987394">allocator_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="ab937a31d8ae4cb896ab25baf67330225" name="ab937a31d8ae4cb896ab25baf67330225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab937a31d8ae4cb896ab25baf67330225">&#9670;&#160;</a></span>get_enumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">enumerator</a>&lt; <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::get_enumerator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerator that iterates through the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="group__collections.html#ga2633655cae697fc737d19f6a541167d7" title="Supports a simple iteration over a non-generic collection.">xtd::collections::enumerator</a> structure for the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>

</div>
</div>
<a id="a14c1f0dd1e8ac7f753d0f56e05fa5a8c" name="a14c1f0dd1e8ac7f753d0f56e05fa5a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c1f0dd1e8ac7f753d0f56e05fa5a8c">&#9670;&#160;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html">hasher</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns function used to hash the keys. </p>
<dl class="section return"><dt>Returns</dt><dd>The hash function. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the function that hashes the keys. </dd></dl>

</div>
</div>
<a id="a2536af020316364a5f3e053dbc02feb7" name="a2536af020316364a5f3e053dbc02feb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2536af020316364a5f3e053dbc02feb7">&#9670;&#160;</a></span>insert() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a4bbab4055f21c2b4f292408e2fe681e8" name="a4bbab4055f21c2b4f292408e2fe681e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbab4055f21c2b4f292408e2fe681e8">&#9670;&#160;</a></span>insert() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a18ad0f3139526c64cf06412b65feae9e" name="a18ad0f3139526c64cf06412b65feae9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ad0f3139526c64cf06412b65feae9e">&#9670;&#160;</a></span>insert() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">type_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>. </dd>
<dd>
Is equivalent to <code>emplace(std::forward&lt;P&gt;(value))</code> and only participates in overload resolution if <code>std::is_constructible&lt;<a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a>, P&amp;&amp;&gt;::value == true</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a380d38c18d0aa2a9d14309adfc143b53" name="a380d38c18d0aa2a9d14309adfc143b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380d38c18d0aa2a9d14309adfc143b53">&#9670;&#160;</a></span>insert() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a18df0c230fef405f5748b1bc0e499128" name="a18df0c230fef405f5748b1bc0e499128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18df0c230fef405f5748b1bc0e499128">&#9670;&#160;</a></span>insert() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a7128e65ca299ec54ac3141117d0a6215" name="a7128e65ca299ec54ac3141117d0a6215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7128e65ca299ec54ac3141117d0a6215">&#9670;&#160;</a></span>insert() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start. </dd>
<dd>
Is equivalent to <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code> and only participates in overload resolution if <code>std::is_constructible&lt;<a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a>, P&amp;&amp;&gt;::value == true</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a85007cea09c65235fd258adcc3a5a28d" name="a85007cea09c65235fd258adcc3a5a28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85007cea09c65235fd258adcc3a5a28d">&#9670;&#160;</a></span>insert() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of the range of elements to insert. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator of the range of elements to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from range [<code>first</code>, <code>last</code>). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>). </dd>
<dd>
If [<code>first</code>, <code>last</code>) is not a valid range, or <code>first</code> and/or <code>last</code> are iterators into <code>*this</code>, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a2f13f08d0a8068edeec540cd55b2656e" name="a2f13f08d0a8068edeec540cd55b2656e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f13f08d0a8068edeec540cd55b2656e">&#9670;&#160;</a></span>insert() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to insert the values from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>). </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="ab03539711e3e6f86380a893e725b95d3" name="ab03539711e3e6f86380a893e725b95d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03539711e3e6f86380a893e725b95d3">&#9670;&#160;</a></span>insert() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t, class init_value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to insert the values from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>). </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a1fe7e8e7ea1b539e1b77cb2e67f3d56b" name="a1fe7e8e7ea1b539e1b77cb2e67f3d56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe7e8e7ea1b539e1b77cb2e67f3d56b">&#9670;&#160;</a></span>insert() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7e88bf6f5031a8e127a56adb37ec848d">insert_return_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>nh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nh</td><td>A compatible <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object of <a class="el" href="#a7e88bf6f5031a8e127a56adb37ec848d" title="Represents the dictionary insert return type.">xtd::collections::generic::dictionary::insert_return_type</a> with the members initialized as follows:<ul>
<li>If <code>nh</code> is empty, inserted is <code>false</code>, position is <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a>, and node is empty.</li>
<li>Otherwise if the insertion took place, inserted is <code>true</code>, position points to the inserted element, and node is empty.</li>
<li>If the insertion failed, inserted is <code>false</code>, node has the previous value of <code>nh</code>, and position points to an element with a key equivalent to <code>nh.key()</code>. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>nh</code> is an empty <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>, does nothing. Otherwise, inserts the element owned by nh into the container , if the container doesn't already contain an element with a key equivalent to <code>nh.key()</code>. The behavior is undefined if <code>nh</code> is not empty and <code><a class="el" href="#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != nh.get_allocator()</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a5c488877537c9281e341e04cc2836c4b" name="a5c488877537c9281e341e04cc2836c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c488877537c9281e341e04cc2836c4b">&#9670;&#160;</a></span>insert() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>nh</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">nh</td><td>A compatible <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator if <code>nh</code> was empty, iterator pointing to the inserted element if insertion took place, and iterator pointing to an element with a key equivalent to <code>nh.key()</code> if it failed. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>nh</code> is an empty <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>, does nothing and returns the end iterator. Otherwise, inserts the element owned by nh into the container, if the container doesn't already contain an element with a key equivalent to <code>nh.key()</code>, and returns the iterator pointing to the element with key equivalent to <code>nh.key()</code>(regardless of whether the insert succeeded or failed). If the insertion succeeds, <code>nh</code> is moved from, otherwise it retains ownership of the element. <code>hint</code> is used as a non-binding suggestion to where the search should start. The behavior is undefined if <code>nh</code> is not empty and <code><a class="el" href="#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != nh.get_allocator()</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="ad9003b85acdd5f58ba98601126fb7e5e" name="ad9003b85acdd5f58ba98601126fb7e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9003b85acdd5f58ba98601126fb7e5e">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="#adef5542e936e56a3a8fd89f05f83c80f" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code><a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a>(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="acc83f5a5d14fd0c9c164a3bffcffe128" name="acc83f5a5d14fd0c9c164a3bffcffe128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc83f5a5d14fd0c9c164a3bffcffe128">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">key_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="#adef5542e936e56a3a8fd89f05f83c80f" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code><a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a>(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="addddd73ed7023f733638e9fda6246ed4" name="addddd73ed7023f733638e9fda6246ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addddd73ed7023f733638e9fda6246ed4">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="#adef5542e936e56a3a8fd89f05f83c80f" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code><a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a>(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a286f0cc1a6f5f3ea0e07728043b80038" name="a286f0cc1a6f5f3ea0e07728043b80038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286f0cc1a6f5f3ea0e07728043b80038">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="#adef5542e936e56a3a8fd89f05f83c80f" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code><a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a>(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a64f3e826724a20670a5b310e1eda5542" name="a64f3e826724a20670a5b310e1eda5542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f3e826724a20670a5b310e1eda5542">&#9670;&#160;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1d6112bd0a235323e439c6a230e3fb76">key_equal</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function used to compare keys for equality. </p>
<dl class="section return"><dt>Returns</dt><dd>The key comparison function. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the function that compares keys for equality. </dd></dl>

</div>
</div>
<a id="aa575c136bf1a37de24a5a7ce7f552b6e" name="aa575c136bf1a37de24a5a7ce7f552b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa575c136bf1a37de24a5a7ce7f552b6e">&#9670;&#160;</a></span>merge() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t, class source_equator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="a5befc63a3053f4602f9440418e6e553b" name="a5befc63a3053f4602f9440418e6e553b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5befc63a3053f4602f9440418e6e553b">&#9670;&#160;</a></span>merge() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t, class source_equator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="ab4e63cb0057bab0fe25d0b0496cebdab" name="ab4e63cb0057bab0fe25d0b0496cebdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e63cb0057bab0fe25d0b0496cebdab">&#9670;&#160;</a></span>merge() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t, class source_equator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="a05b3061b4dbf74c837b28315279242bf" name="a05b3061b4dbf74c837b28315279242bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b3061b4dbf74c837b28315279242bf">&#9670;&#160;</a></span>merge() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t, class source_equator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="ac7b8b13d8c3160f93641eaa1ccda8968" name="ac7b8b13d8c3160f93641eaa1ccda8968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b8b13d8c3160f93641eaa1ccda8968">&#9670;&#160;</a></span>merge() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t, class source_equator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">std::unordered_multimap&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="ad3d725740942e0a175b87d23e8228dce" name="ad3d725740942e0a175b87d23e8228dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d725740942e0a175b87d23e8228dce">&#9670;&#160;</a></span>merge() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t, class source_equator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">std::unordered_multimap&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="a73f150f182b8abc8caaf5914dbbba8eb" name="a73f150f182b8abc8caaf5914dbbba8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f150f182b8abc8caaf5914dbbba8eb">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves at least the specified number of buckets and regenerates the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The lower bound for the new number of buckets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Changes the number of buckets to a value n that is not less than <code>count</code> and satisfies <code>n &gt;= <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> / <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">max_load_factor()</a></code>, then rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>rehash(0)</code> may be used to force an unconditional rehash, such as after suspension of automatic rehashing by temporarily increasing <code><a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">max_load_factor()</a></code>. </dd></dl>

</div>
</div>
<a id="a73cb9a204619fd297fb77f09b86b4b29" name="a73cb9a204619fd297fb77f09b86b4b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cb9a204619fd297fb77f09b86b4b29">&#9670;&#160;</a></span>remove() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the value with the specified key from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the element is successfully found and removed; otherwise, <code>false</code>. This method returns <code>false</code> if key is not found in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; does not contain an element with the specified key, the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; remains unchanged. No exception is thrown. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a350ca7a421a2515680c138c2a093b7bc">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a5b135339b414dd74f28dd0644fc255f3" name="a5b135339b414dd74f28dd0644fc255f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b135339b414dd74f28dd0644fc255f3">&#9670;&#160;</a></span>remove() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first occurrence of a specific object from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The object to remove from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item is successfully removed; otherwise, <code>false</code>. This method also returns <code>false</code> if item value was not found in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>

</div>
</div>
<a id="a0a8a911620f4d683e1ddab2edb518310" name="a0a8a911620f4d683e1ddab2edb518310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8a911620f4d683e1ddab2edb518310">&#9670;&#160;</a></span>remove() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the value with the specified key from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, and copies the element to the <code>value</code> parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to remove. </td></tr>
    <tr><td class="paramname">value</td><td>The removed element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f59aa65bc93ff2771d7c1163e221368" name="a3f59aa65bc93ff2771d7c1163e221368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f59aa65bc93ff2771d7c1163e221368">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space for at least the specified number of elements and regenerates the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new capacity of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Sets the number of buckets to the number needed to accommodate at least <code>count</code> elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls <code>rehash(std::ceil(count / <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">max_load_factor()</a>))</code>. </dd></dl>

</div>
</div>
<a id="a4477fff561437e9a5487120b57055dd5" name="a4477fff561437e9a5487120b57055dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4477fff561437e9a5487120b57055dd5">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>container to exchange the contents with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </dd>
<dd>
All iterators and references remain valid. The <a class="el" href="#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumerable.">xtd::collections::generic::dictionary::end</a> iterator is invalidated. The <code>hasher_t</code> and <code>equator_t</code> objects must be <a href="https://en.cppreference.com/w/cpp/named_req/Swappable">Swappable</a>, and they are exchanged using unqualified calls to non-member swap. </dd></dl>

</div>
</div>
<a id="ae995c559f83b9915daf53430f2ccc95e" name="ae995c559f83b9915daf53430f2ccc95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae995c559f83b9915daf53430f2ccc95e">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">xtd::string</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a string that represents the current object. </p>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the current object. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">xtd::object</a>.</p>

</div>
</div>
<a id="a039c4cc5a88a74481047772f8dc30980" name="a039c4cc5a88a74481047772f8dc30980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039c4cc5a88a74481047772f8dc30980">&#9670;&#160;</a></span>trim_excess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::trim_excess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the capacity of this dictionary to hold up a specified number of entries without any further expansion of its backing storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The new capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`capacity` is less than <a class="el" href="#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method can be used to minimize the memory overhead once it is known that no new elements will be added. </dd></dl>

</div>
</div>
<a id="a7e33a4f0c0ff75219a24c4e17dd96798" name="a7e33a4f0c0ff75219a24c4e17dd96798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e33a4f0c0ff75219a24c4e17dd96798">&#9670;&#160;</a></span>trim_excess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::trim_excess </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method can be used to minimize memory overhead once it is known that no new elements will be added to the dictionary. To allocate a minimum size storage array, execute the following statements: <div class="fragment"><div class="line"><a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a>.clear();</div>
<div class="line"><a class="code hl_function" href="#a50b15016f1b91a266a8beec12ab89584">dictionary</a>.trim_excess();</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5609a2b1e1555fe690d1b86368f36a64" name="a5609a2b1e1555fe690d1b86368f36a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5609a2b1e1555fe690d1b86368f36a64">&#9670;&#160;</a></span>try_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_add </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to add the specified key and value to the dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to add. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the key/value pair was added to the dictionary successfully; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike the <a class="el" href="#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method, this method doesn't throw an exception if the element with the given key exists in the dictionary. Unlike the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> indexer (operator []), <a class="el" href="#a5609a2b1e1555fe690d1b86368f36a64" title="Attempts to add the specified key and value to the dictionary.">xtd::collections::generic::dictionary::try_add</a> doesn't override the element if the element with the given key exists in the dictionary. If the key already exists, <a class="el" href="#a5609a2b1e1555fe690d1b86368f36a64" title="Attempts to add the specified key and value to the dictionary.">xtd::collections::generic::dictionary::try_add</a> does nothing and returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="af3f68a0c5f67be81a1de0390a4f44ada" name="af3f68a0c5f67be81a1de0390a4f44ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f68a0c5f67be81a1de0390a4f44ada">&#9670;&#160;</a></span>try_emplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a> is not <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible">EmplaceConstructible</a> into unordered_map from the corresponding expression, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a2701181224b009ca6d91700273f56ab0" name="a2701181224b009ca6d91700273f56ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2701181224b009ca6d91700273f56ab0">&#9670;&#160;</a></span>try_emplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">key_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a> is not <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible">EmplaceConstructible</a> into unordered_map from the corresponding expression, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a0a6e71848f61306f161e00ef6abbcba1" name="a0a6e71848f61306f161e00ef6abbcba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6e71848f61306f161e00ef6abbcba1">&#9670;&#160;</a></span>try_emplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a> is not <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible">EmplaceConstructible</a> into unordered_map from the corresponding expression, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="aa04620bd4ec2d7f3b5d0df030f5a1d9f" name="aa04620bd4ec2d7f3b5d0df030f5a1d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04620bd4ec2d7f3b5d0df030f5a1d9f">&#9670;&#160;</a></span>try_emplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a792954eea61dc2cf8315606d042dd18d">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abbbff355e29f8facb171c94084884625">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="#ae2299afc830434c0a0ea06da8c6ce163" title="Represents the dictionary value type.">value_type</a> is not <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible">EmplaceConstructible</a> into unordered_map from the corresponding expression, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="ac86c4dc2cfd6286bc7543d33f99a695d" name="ac86c4dc2cfd6286bc7543d33f99a695d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86c4dc2cfd6286bc7543d33f99a695d">&#9670;&#160;</a></span>try_get_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_get_value </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value associated with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the value to get. </td></tr>
    <tr><td class="paramname">value</td><td>When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains an element with the specified key; otherwise, <code>false</code>. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a4126d8c6dd5d5dbc84926aaf5198770e">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a82c683da2de29870afa991f4445dac29" name="a82c683da2de29870afa991f4445dac29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c683da2de29870afa991f4445dac29">&#9670;&#160;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a34f2116e984d8e567f334c97e84f4bc8" name="a34f2116e984d8e567f334c97e84f4bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f2116e984d8e567f334c97e84f4bc8">&#9670;&#160;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa8af37e930bc671470277333004815c6" name="aa8af37e930bc671470277333004815c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8af37e930bc671470277333004815c6">&#9670;&#160;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa93aa4cf42b1c7c83d3b01dafe6deac1" name="aa93aa4cf42b1c7c83d3b01dafe6deac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93aa4cf42b1c7c83d3b01dafe6deac1">&#9670;&#160;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; key_t, value_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a14ceb0d680fe9a5d5d6c2f02e4bdcd60" name="a14ceb0d680fe9a5d5d6c2f02e4bdcd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ceb0d680fe9a5d5d6c2f02e4bdcd60">&#9670;&#160;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#aa57e3de24c35cf6d309f983e5f907a3e">base_value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a14d7bdef948dda8ae4029da1ea3b398a" name="a14d7bdef948dda8ae4029da1ea3b398a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d7bdef948dda8ae4029da1ea3b398a">&#9670;&#160;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t, class init_value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a0e8d5edb392d4da50dfa18ff778b9aec" name="a0e8d5edb392d4da50dfa18ff778b9aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8d5edb392d4da50dfa18ff778b9aec">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a></td><td>The property is retrieved and key is not found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property provides the ability to access a specific element in the collection by using the following syntax: <code>my_collection[key]</code>. </dd>
<dd>
You can also use the <code>operator []</code> to add new elements by setting the value of a key that does not exist in the dictionary; for example, <code>my_collection["my_nonexistent_key"] = my_value</code>. However, if the specified key already exists in the dictionary, setting the <code>operator []</code> overwrites the old value. In contrast, the <a class="el" href="#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method does not modify existing elements. </dd></dl>

</div>
</div>
<a id="a03bf80a6988e9d62a6e57df4f12e00c2" name="a03bf80a6988e9d62a6e57df4f12e00c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bf80a6988e9d62a6e57df4f12e00c2">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property provides the ability to access a specific element in the collection by using the following syntax: <code>my_collection[key]</code>. </dd>
<dd>
You can also use the <code>operator []</code> to add new elements by setting the value of a key that does not exist in the dictionary; for example, <code>my_collection["my_nonexistent_key"] = my_value</code>. However, if the specified key already exists in the dictionary, setting the <code>operator []</code> overwrites the old value. In contrast, the <a class="el" href="#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method does not modify existing elements. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a1428322c2f912bd597f667bd1aec0bdc">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a04b0f390c2eef3a3bc08a06c74134c7b" name="a04b0f390c2eef3a3bc08a06c74134c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b0f390c2eef3a3bc08a06c74134c7b">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator const <a class="el" href="#a4635f1586a55cca04619e6b4d25322f2">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a2128516be272bac5e5a5561d1ad55eff" name="a2128516be272bac5e5a5561d1ad55eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2128516be272bac5e5a5561d1ad55eff">&#9670;&#160;</a></span>operator base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t &gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator <a class="el" href="#a4635f1586a55cca04619e6b4d25322f2">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/collections/generic/<a class="el" href="dictionary_8hpp_source.html">dictionary.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 25 2025 19:05:10 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
