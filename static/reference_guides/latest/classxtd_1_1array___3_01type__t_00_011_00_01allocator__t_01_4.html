<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::array_&lt; type_t, 1, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html">array_&lt; type_t, 1, allocator_t &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::array_&lt; type_t, 1, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::array_&lt; type_t, 1, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.png" usemap="#xtd::array_5F_3C_20type_5Ft_2C_201_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::array_5F_3C_20type_5Ft_2C_201_2C_20allocator_5Ft_20_3E_map" name="xtd::array_5F_3C_20type_5Ft_2C_201_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1basic__array.html" alt="xtd::basic_array&lt; type_t, allocator_t &gt;" shape="rect" coords="650,224,1290,248"/>
<area href="classxtd_1_1array__abstract__object.html" title="Abstract object that represent array." alt="xtd::array_abstract_object" shape="rect" coords="0,168,640,192"/>
<area href="classxtd_1_1collections_1_1generic_1_1ilist.html" title="Represents a collection of objects that can be individually accessed by index." alt="xtd::collections::generic::ilist&lt; type_t &gt;" shape="rect" coords="650,168,1290,192"/>
<area href="classxtd_1_1iequatable.html" alt="xtd::iequatable&lt; basic_array&lt; type_t, allocator_t &gt; &gt;" shape="rect" coords="1625,168,2265,192"/>
<area href="classxtd_1_1abstract__object.html" title="Represent an abstract class." alt="xtd::abstract_object" shape="rect" coords="0,112,640,136"/>
<area href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections." alt="xtd::collections::generic::icollection&lt; type_t &gt;" shape="rect" coords="650,112,1290,136"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="1300,112,1940,136"/>
<area href="classxtd_1_1equality__operators.html" title="Internal comparable operators definition." alt="xtd::equality_operators&lt; type_t, equatable_t &gt;" shape="rect" coords="1950,112,2590,136"/>
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,56,640,80"/>
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type." alt="xtd::collections::generic::ienumerable&lt; type_t &gt;" shape="rect" coords="650,56,1290,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="325,0,965,24"/>
<area href="classxtd_1_1collections_1_1generic_1_1enumerable__iterators.html" alt="xtd::collections::generic::enumerable_iterators&lt; type_t, ienumerable&lt; type_t &gt; &gt;" shape="rect" coords="975,0,1615,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename type_t, typename allocator_t&gt;<br />
class xtd::array_&lt; type_t, 1, allocator_t &gt;</div><p>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_t, xtd::size rank_, <span class="keyword">typename</span> allocator_t&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_typedef" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;;</div>
<div class="ttc" id="aclassxtd_1_1basic__array_html"><div class="ttname"><a href="classxtd_1_1basic__array.html">xtd::basic_array</a></div><div class="ttdoc">Base object that represent array.</div><div class="ttdef"><b>Definition</b> basic_array.h:27</div></div>
<div class="ttc" id="anamespacextd_html_a23ad3a72b3c9da7418d0b2020076a40a"><div class="ttname"><a href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a></div><div class="ttdeci">std::vector&lt; type_t &gt; array</div><div class="ttdef"><b>Definition</b> __array_definition.h:18</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> class is not part of the <a class="el" href="namespacextd_1_1collections.html" title="The xtd::collections namespace contains interfaces and classes that define various collections of obj...">xtd::collections</a> namespaces. However, it is still considered a collection because it is based on the <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html" title="Represents a collection of objects that can be individually accessed by index.">xtd::collections::generic::ilist</a> interface. </dd>
<dd>
An element is a value in an <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a>. The length of an <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> is the total number of elements it can contain. The lower bound of an v is the index of its first element. An <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> can have any lower bound, but it has a lower bound of zero by default. A different lower bound can be defined when creating an instance of the <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> class using xtd::array::create_instance. A multidimensional <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> can have different bounds for each dimension. An array can have a maximum of 32 dimensions. </dd>
<dd>
Unlike the classes in the <a class="el" href="namespacextd_1_1collections.html" title="The xtd::collections namespace contains interfaces and classes that define various collections of obj...">xtd::collections</a> namespaces, <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> has a fixed capacity. To increase the capacity, you must create a new <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> object with the required capacity, copy the elements from the old <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> object to the new one, and delete the old <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a>. </dd>
<dd>
The <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> class implements the <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html" title="Represents a collection of objects that can be individually accessed by index.">xtd::collections::generic::ilist</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a>, and <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> generic interfaces. The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> class. In addition, there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations). The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a>. </dd>
<dd>
The xtd::array::copy method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically. </dd>
<dd>
Some methods, such as xtd::array::create_instance, xtd::array::copy, xtd::array::copy_to, xtd::array::get_value, and xtd::array::set_value, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays. xtd::array::long_length and xtd::array::get_long_length return 64-bit integers indicating the length of the array. </dd>
<dd>
The <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> is not guaranteed to be sorted. You must sort the <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> prior to performing operations (such as xtd::array::binary_search) that require the <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> to be sorted. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates different methods to create an array. <div class="fragment"></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example creates and initializes an Array and displays its properties and its elements. <div class="fragment"></div><!-- fragment --> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:af78de29eb35b65d12290dd578c9ae8ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> = type_t</td></tr>
<tr class="memdesc:af78de29eb35b65d12290dd578c9ae8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array value type.  <br /></td></tr>
<tr class="separator:af78de29eb35b65d12290dd578c9ae8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81776bbaaef91ea91cfc96ed7e632848"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a81776bbaaef91ea91cfc96ed7e632848">allocator_type</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::allocator_type</td></tr>
<tr class="memdesc:a81776bbaaef91ea91cfc96ed7e632848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array allocator type.  <br /></td></tr>
<tr class="separator:a81776bbaaef91ea91cfc96ed7e632848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542030e1f490232cf241d523d74e1362"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a542030e1f490232cf241d523d74e1362">base_type</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::base_type</td></tr>
<tr class="memdesc:a542030e1f490232cf241d523d74e1362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array base type.  <br /></td></tr>
<tr class="separator:a542030e1f490232cf241d523d74e1362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3aecaad661a6c5c7c669b29da9b6b86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::size_type</td></tr>
<tr class="memdesc:af3aecaad661a6c5c7c669b29da9b6b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array size type (usually <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>).  <br /></td></tr>
<tr class="separator:af3aecaad661a6c5c7c669b29da9b6b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25ba84f558a98c6b387c2c5e4aedc05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#aa25ba84f558a98c6b387c2c5e4aedc05">difference_type</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::difference_type</td></tr>
<tr class="memdesc:aa25ba84f558a98c6b387c2c5e4aedc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array difference type (usually <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca" title="Represent the signed integer type of the result of subtracting two pointers.">xtd::ptrdiff</a>).  <br /></td></tr>
<tr class="separator:aa25ba84f558a98c6b387c2c5e4aedc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8859ac4fb2dad5f76ead9714d38f0e37"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a8859ac4fb2dad5f76ead9714d38f0e37">reference</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reference</td></tr>
<tr class="memdesc:a8859ac4fb2dad5f76ead9714d38f0e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reference of array value type.  <br /></td></tr>
<tr class="separator:a8859ac4fb2dad5f76ead9714d38f0e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad980ad2f2d71b6244de010687e7c4b6f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#ad980ad2f2d71b6244de010687e7c4b6f">const_reference</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_reference</td></tr>
<tr class="memdesc:ad980ad2f2d71b6244de010687e7c4b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reference of array value type.  <br /></td></tr>
<tr class="separator:ad980ad2f2d71b6244de010687e7c4b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5681b9b117a13f547ab0e272adc211"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a7b5681b9b117a13f547ab0e272adc211">pointer</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::pointer</td></tr>
<tr class="memdesc:a7b5681b9b117a13f547ab0e272adc211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the pointer of array value type.  <br /></td></tr>
<tr class="separator:a7b5681b9b117a13f547ab0e272adc211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab6b35eb6d00b18df27855624d81c34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a3ab6b35eb6d00b18df27855624d81c34">const_pointer</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_pointer</td></tr>
<tr class="memdesc:a3ab6b35eb6d00b18df27855624d81c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const pointer of array value type.  <br /></td></tr>
<tr class="separator:a3ab6b35eb6d00b18df27855624d81c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9840c29cf4b8b42775a91f6165193d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#ad9840c29cf4b8b42775a91f6165193d2">iterator</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::iterator</td></tr>
<tr class="memdesc:ad9840c29cf4b8b42775a91f6165193d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of array value type.  <br /></td></tr>
<tr class="separator:ad9840c29cf4b8b42775a91f6165193d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f0cc66bfe0443f0fdca2d717775092"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a01f0cc66bfe0443f0fdca2d717775092">const_iterator</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_iterator</td></tr>
<tr class="memdesc:a01f0cc66bfe0443f0fdca2d717775092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of array value type.  <br /></td></tr>
<tr class="separator:a01f0cc66bfe0443f0fdca2d717775092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4420301e5829ffe117d0f143ebbd0d5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a4420301e5829ffe117d0f143ebbd0d5b">reverse_iterator</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::reverse_iterator</td></tr>
<tr class="memdesc:a4420301e5829ffe117d0f143ebbd0d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reverse iterator of array value type.  <br /></td></tr>
<tr class="separator:a4420301e5829ffe117d0f143ebbd0d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8caa8c9c41ca61cf8391690c460362"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a2b8caa8c9c41ca61cf8391690c460362">const_reverse_iterator</a> = typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt; type_t, allocator_t &gt;::const_reverse_iterator</td></tr>
<tr class="memdesc:a2b8caa8c9c41ca61cf8391690c460362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reverse iterator of array value type.  <br /></td></tr>
<tr class="separator:a2b8caa8c9c41ca61cf8391690c460362"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:ad5ebe4ef445d0a64641973d4991ed4fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#ad5ebe4ef445d0a64641973d4991ed4fc">array_</a> ()=default</td></tr>
<tr class="memdesc:ad5ebe4ef445d0a64641973d4991ed4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the Array class that is empty.  <br /></td></tr>
<tr class="separator:ad5ebe4ef445d0a64641973d4991ed4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22755ee396683024671d23cab87d2e5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a22755ee396683024671d23cab87d2e5e">array_</a> (const <a class="el" href="classxtd_1_1array__.html">array_</a> &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>)</td></tr>
<tr class="memdesc:a22755ee396683024671d23cab87d2e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with specified array.  <br /></td></tr>
<tr class="separator:a22755ee396683024671d23cab87d2e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4adb22e06ce4d081d992104891dbbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a3d4adb22e06ce4d081d992104891dbbd">array_</a> (const <a class="el" href="classxtd_1_1array__.html">array_</a> &amp;&amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>)</td></tr>
<tr class="memdesc:a3d4adb22e06ce4d081d992104891dbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with specified array.  <br /></td></tr>
<tr class="separator:a3d4adb22e06ce4d081d992104891dbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c141b33e9dca1f5dc0d1a2e2ec856a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a50c141b33e9dca1f5dc0d1a2e2ec856a">array_</a> (const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a542030e1f490232cf241d523d74e1362">base_type</a> &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>)</td></tr>
<tr class="memdesc:a50c141b33e9dca1f5dc0d1a2e2ec856a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with specified base type array.  <br /></td></tr>
<tr class="separator:a50c141b33e9dca1f5dc0d1a2e2ec856a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e892d95353bed583a2a3e085220660f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a8e892d95353bed583a2a3e085220660f">array_</a> (<a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a542030e1f490232cf241d523d74e1362">base_type</a> &amp;&amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>)</td></tr>
<tr class="memdesc:a8e892d95353bed583a2a3e085220660f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with specified base type array.  <br /></td></tr>
<tr class="separator:a8e892d95353bed583a2a3e085220660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab06285f651cee425dfea4b3a15199fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#aab06285f651cee425dfea4b3a15199fd">array_</a> (<a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> <a class="el" href="classxtd_1_1basic__array.html#aaf70989e6cabeaccefd32e3b760753ef">length</a>)</td></tr>
<tr class="memdesc:aab06285f651cee425dfea4b3a15199fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the array class with lengths for each rank specified.  <br /></td></tr>
<tr class="separator:aab06285f651cee425dfea4b3a15199fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6fd9ef8e192186b82d56269fa9f9e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a8c6fd9ef8e192186b82d56269fa9f9e3">array_</a> (std::initializer_list&lt; type_t &gt; <a class="el" href="classxtd_1_1basic__array.html#ab5d7c124db651f72d7f2b4971c5862f5">items</a>)</td></tr>
<tr class="memdesc:a8c6fd9ef8e192186b82d56269fa9f9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:a8c6fd9ef8e192186b82d56269fa9f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b953d740c2767b2c3c989d0d6b8edb0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> length&gt; </td></tr>
<tr class="memitem:a5b953d740c2767b2c3c989d0d6b8edb0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a5b953d740c2767b2c3c989d0d6b8edb0">array_</a> (const type_t(&amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>)[<a class="el" href="classxtd_1_1basic__array.html#aaf70989e6cabeaccefd32e3b760753ef">length</a>])</td></tr>
<tr class="memdesc:a5b953d740c2767b2c3c989d0d6b8edb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the array and copy array[] type_t.  <br /></td></tr>
<tr class="separator:a5b953d740c2767b2c3c989d0d6b8edb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa2c0e5ee8436914ba92d70a66289bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a5fa2c0e5ee8436914ba92d70a66289bd">array_</a> (const type_t *<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>, <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> <a class="el" href="classxtd_1_1basic__array.html#aaf70989e6cabeaccefd32e3b760753ef">length</a>)</td></tr>
<tr class="memdesc:a5fa2c0e5ee8436914ba92d70a66289bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the array and copy array[] type_t with length specified.  <br /></td></tr>
<tr class="separator:a5fa2c0e5ee8436914ba92d70a66289bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85c5199e027e2e95426e3148731b0e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#ae85c5199e027e2e95426e3148731b0e8">array_</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; type_t &gt; &amp;enumerable)</td></tr>
<tr class="memdesc:ae85c5199e027e2e95426e3148731b0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the array and copy array array specified.  <br /></td></tr>
<tr class="separator:ae85c5199e027e2e95426e3148731b0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2f763b214f2dab9515c1ff6cb5352c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a8d2f763b214f2dab9515c1ff6cb5352c">array_</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">xtd::collections::generic::ilist</a>&lt; type_t &gt; &amp;list)</td></tr>
<tr class="memdesc:a8d2f763b214f2dab9515c1ff6cb5352c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the array and copy array array specified.  <br /></td></tr>
<tr class="separator:a8d2f763b214f2dab9515c1ff6cb5352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493b5fffc563b787c0bbf5491edd96c0"><td class="memTemplParams" colspan="2">template&lt;typename iterator_t &gt; </td></tr>
<tr class="memitem:a493b5fffc563b787c0bbf5491edd96c0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a493b5fffc563b787c0bbf5491edd96c0">array_</a> (iterator_t first, iterator_t last)</td></tr>
<tr class="memdesc:a493b5fffc563b787c0bbf5491edd96c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <br /></td></tr>
<tr class="separator:a493b5fffc563b787c0bbf5491edd96c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:a4a24846c3bb7be098b8f309133793fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a4a24846c3bb7be098b8f309133793fcf">rank</a> () const noexcept override</td></tr>
<tr class="memdesc:a4a24846c3bb7be098b8f309133793fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rank (number of dimensions) of the array.  <br /></td></tr>
<tr class="separator:a4a24846c3bb7be098b8f309133793fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a199a1c6c5c8f85495fcfe0619321c594"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a199a1c6c5c8f85495fcfe0619321c594">copy_to</a> (<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a>&lt; type_t &gt; &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>, <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> index) const override</td></tr>
<tr class="memdesc:a199a1c6c5c8f85495fcfe0619321c594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 32-bit integer.  <br /></td></tr>
<tr class="separator:a199a1c6c5c8f85495fcfe0619321c594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3949d32661662103f1e5abbff8bfe1d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3949d32661662103f1e5abbff8bfe1d">get_value</a> (<a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> index) const</td></tr>
<tr class="memdesc:af3949d32661662103f1e5abbff8bfe1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer.  <br /></td></tr>
<tr class="separator:af3949d32661662103f1e5abbff8bfe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964258b5fff46ee925d837907032fd70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a964258b5fff46ee925d837907032fd70">set_value</a> (const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp;value, <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> index)</td></tr>
<tr class="memdesc:a964258b5fff46ee925d837907032fd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the element at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer.  <br /></td></tr>
<tr class="separator:a964258b5fff46ee925d837907032fd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:aac8a61ad907f0a2a17172b03cab74d95"><td class="memItemLeft" align="right" valign="top"><a id="aac8a61ad907f0a2a17172b03cab74d95" name="aac8a61ad907f0a2a17172b03cab74d95"></a>
<a class="el" href="classxtd_1_1array__.html">array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classxtd_1_1array__.html">array_</a> &amp;)=default</td></tr>
<tr class="separator:aac8a61ad907f0a2a17172b03cab74d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60671c2c0ea4d511f2e60c5042356979"><td class="memItemLeft" align="right" valign="top"><a id="a60671c2c0ea4d511f2e60c5042356979" name="a60671c2c0ea4d511f2e60c5042356979"></a>
<a class="el" href="classxtd_1_1array__.html">array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classxtd_1_1array__.html">array_</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a60671c2c0ea4d511f2e60c5042356979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54c1baaef4b4ccdb28b7e5d235e70cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#ab54c1baaef4b4ccdb28b7e5d235e70cd">operator()</a> (<a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> index)</td></tr>
<tr class="memdesc:ab54c1baaef4b4ccdb28b7e5d235e70cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the element at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer.  <br /></td></tr>
<tr class="separator:ab54c1baaef4b4ccdb28b7e5d235e70cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bbfbc0ff10bde0998d4d0df73cba27"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a14bbfbc0ff10bde0998d4d0df73cba27">operator()</a> (<a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> index) const</td></tr>
<tr class="memdesc:a14bbfbc0ff10bde0998d4d0df73cba27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer.  <br /></td></tr>
<tr class="separator:a14bbfbc0ff10bde0998d4d0df73cba27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6a7d47afc9df774584f7fd0c4750b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a2f6a7d47afc9df774584f7fd0c4750b8">operator[]</a> (<a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> index) override</td></tr>
<tr class="memdesc:a2f6a7d47afc9df774584f7fd0c4750b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the element at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer.  <br /></td></tr>
<tr class="separator:a2f6a7d47afc9df774584f7fd0c4750b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38b5caa7ccf01a144b2368979733d30"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af38b5caa7ccf01a144b2368979733d30">operator[]</a> (<a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a> index) const override</td></tr>
<tr class="memdesc:af38b5caa7ccf01a144b2368979733d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element at the specified index.  <br /></td></tr>
<tr class="separator:af38b5caa7ccf01a144b2368979733d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classxtd_1_1basic__array"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1basic__array')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array&lt; type_t, allocator_t &gt;</a></td></tr>
<tr class="memitem:a8a186922544d50c32678dbeead9d34fe inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> = type_t</td></tr>
<tr class="memdesc:a8a186922544d50c32678dbeead9d34fe inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array value type.  <br /></td></tr>
<tr class="separator:a8a186922544d50c32678dbeead9d34fe inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e03acd94629ea4815cebbe14df6ce91 inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a3e03acd94629ea4815cebbe14df6ce91">allocator_type</a> = <a class="el" href="group__helpers__generic__collections.html#gac7dc24539787a344466014161f2d39af">xtd::collections::generic::helpers::allocator</a>&lt; typename std::conditional&lt; std::is_same&lt; bool, <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &gt;::value, <a class="el" href="group__types.html#gabb9d3031d62e3725b4265c7e5d2a98e1">xtd::byte</a>, <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &gt;::type &gt;</td></tr>
<tr class="memdesc:a3e03acd94629ea4815cebbe14df6ce91 inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array allocator type.  <br /></td></tr>
<tr class="separator:a3e03acd94629ea4815cebbe14df6ce91 inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad277de2a42b4b0aba1c24eadf2edbe24 inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a> = std::vector&lt; typename std::conditional&lt; std::is_same&lt; bool, <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &gt;::value, <a class="el" href="group__types.html#gabb9d3031d62e3725b4265c7e5d2a98e1">xtd::byte</a>, <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &gt;::type, <a class="el" href="classxtd_1_1basic__array.html#a3e03acd94629ea4815cebbe14df6ce91">allocator_type</a> &gt;</td></tr>
<tr class="memdesc:ad277de2a42b4b0aba1c24eadf2edbe24 inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array base type.  <br /></td></tr>
<tr class="separator:ad277de2a42b4b0aba1c24eadf2edbe24 inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b44083298196790c9d898bf520828a inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> = <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a></td></tr>
<tr class="memdesc:af9b44083298196790c9d898bf520828a inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array size type (usually <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>).  <br /></td></tr>
<tr class="separator:af9b44083298196790c9d898bf520828a inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1c0a188f5cfd2673e9b90c0d300e3e inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a2c1c0a188f5cfd2673e9b90c0d300e3e">difference_type</a> = <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca">xtd::ptrdiff</a></td></tr>
<tr class="memdesc:a2c1c0a188f5cfd2673e9b90c0d300e3e inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the array difference type (usually <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca" title="Represent the signed integer type of the result of subtracting two pointers.">xtd::ptrdiff</a>).  <br /></td></tr>
<tr class="separator:a2c1c0a188f5cfd2673e9b90c0d300e3e inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6054c9522c7a58c05453b86e0c6f1913 inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a6054c9522c7a58c05453b86e0c6f1913">reference</a> = <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td></tr>
<tr class="memdesc:a6054c9522c7a58c05453b86e0c6f1913 inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reference of array value type.  <br /></td></tr>
<tr class="separator:a6054c9522c7a58c05453b86e0c6f1913 inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a0d032eb60a2a8f0bdf84ba3fe1204 inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a> = const <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;</td></tr>
<tr class="memdesc:a01a0d032eb60a2a8f0bdf84ba3fe1204 inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reference of array value type.  <br /></td></tr>
<tr class="separator:a01a0d032eb60a2a8f0bdf84ba3fe1204 inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58756d2450f08851d601a29456ba4273 inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a58756d2450f08851d601a29456ba4273">pointer</a> = <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> *</td></tr>
<tr class="memdesc:a58756d2450f08851d601a29456ba4273 inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the pointer of array value type.  <br /></td></tr>
<tr class="separator:a58756d2450f08851d601a29456ba4273 inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52835b4b627c5d7783f5d523aa265927 inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a52835b4b627c5d7783f5d523aa265927">const_pointer</a> = const <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> *</td></tr>
<tr class="memdesc:a52835b4b627c5d7783f5d523aa265927 inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const pointer of array value type.  <br /></td></tr>
<tr class="separator:a52835b4b627c5d7783f5d523aa265927 inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d7e5f059d85010c0351292e3c95f3e inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a14d7e5f059d85010c0351292e3c95f3e">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">xtd::collections::generic::ilist</a>&lt; type_t &gt;::iterator</td></tr>
<tr class="memdesc:a14d7e5f059d85010c0351292e3c95f3e inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of array value type.  <br /></td></tr>
<tr class="separator:a14d7e5f059d85010c0351292e3c95f3e inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3321bf399b37b67bd1d690b828b046d3 inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a3321bf399b37b67bd1d690b828b046d3">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">xtd::collections::generic::ilist</a>&lt; type_t &gt;::const_iterator</td></tr>
<tr class="memdesc:a3321bf399b37b67bd1d690b828b046d3 inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of array value type.  <br /></td></tr>
<tr class="separator:a3321bf399b37b67bd1d690b828b046d3 inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec840a621251f1d7ba5caab527f5e08 inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a4ec840a621251f1d7ba5caab527f5e08">reverse_iterator</a> = typename base_type::reverse_iterator</td></tr>
<tr class="memdesc:a4ec840a621251f1d7ba5caab527f5e08 inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reverse iterator of array value type.  <br /></td></tr>
<tr class="separator:a4ec840a621251f1d7ba5caab527f5e08 inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0160c4ae793de2de4a97ed5d6a0351f1 inherit pub_types_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a> = typename base_type::const_reverse_iterator</td></tr>
<tr class="memdesc:a0160c4ae793de2de4a97ed5d6a0351f1 inherit pub_types_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reverse iterator of array value type.  <br /></td></tr>
<tr class="separator:a0160c4ae793de2de4a97ed5d6a0351f1 inherit pub_types_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1ilist"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1ilist')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">xtd::collections::generic::ilist&lt; type_t &gt;</a></td></tr>
<tr class="memitem:a192132ce093e3a233f34095a389b4236 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ilist"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html#a192132ce093e3a233f34095a389b4236">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">icollection</a>&lt; type_t &gt;::iterator</td></tr>
<tr class="memdesc:a192132ce093e3a233f34095a389b4236 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ilist"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a192132ce093e3a233f34095a389b4236 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ilist"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0527f45d40666d178eb5dd97067f36 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ilist"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html#a2d0527f45d40666d178eb5dd97067f36">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">icollection</a>&lt; type_t &gt;::const_iterator</td></tr>
<tr class="memdesc:a2d0527f45d40666d178eb5dd97067f36 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ilist"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a2d0527f45d40666d178eb5dd97067f36 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ilist"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1icollection')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection&lt; type_t &gt;</a></td></tr>
<tr class="memitem:ae03aec8810a74286ec16e7c12c7ea36a inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#ae03aec8810a74286ec16e7c12c7ea36a">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; type_t &gt;::iterator</td></tr>
<tr class="memdesc:ae03aec8810a74286ec16e7c12c7ea36a inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:ae03aec8810a74286ec16e7c12c7ea36a inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3ef4f4d07b613ae49e9124d6c77698 inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#adb3ef4f4d07b613ae49e9124d6c77698">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; type_t &gt;::const_iterator</td></tr>
<tr class="memdesc:adb3ef4f4d07b613ae49e9124d6c77698 inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:adb3ef4f4d07b613ae49e9124d6c77698 inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable&lt; type_t &gt;</a></td></tr>
<tr class="memitem:afc56db5ef5a8996ff05e4e88775f9368 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#afc56db5ef5a8996ff05e4e88775f9368">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1enumerable__iterators.html">enumerable_iterators</a>&lt; type_t, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; type_t &gt; &gt;::iterator</td></tr>
<tr class="memdesc:afc56db5ef5a8996ff05e4e88775f9368 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:afc56db5ef5a8996ff05e4e88775f9368 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b54b517dad29751cce354ab5e53e4d inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a63b54b517dad29751cce354ab5e53e4d">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1enumerable__iterators.html">enumerable_iterators</a>&lt; type_t, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; type_t &gt; &gt;::const_iterator</td></tr>
<tr class="memdesc:a63b54b517dad29751cce354ab5e53e4d inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a63b54b517dad29751cce354ab5e53e4d inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1enumerable__iterators.html">xtd::collections::generic::enumerable_iterators&lt; type_t, ienumerable&lt; type_t &gt; &gt;</a></td></tr>
<tr class="memitem:a9ca985b3072ba671c95968cd46841180 inherit pub_types_classxtd_1_1collections_1_1generic_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1enumerable__iterators.html#a9ca985b3072ba671c95968cd46841180">const_iterator</a> = const iterator</td></tr>
<tr class="memdesc:a9ca985b3072ba671c95968cd46841180 inherit pub_types_classxtd_1_1collections_1_1generic_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of enumarable value type.  <br /></td></tr>
<tr class="separator:a9ca985b3072ba671c95968cd46841180 inherit pub_types_classxtd_1_1collections_1_1generic_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classxtd_1_1basic__array"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classxtd_1_1basic__array')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array&lt; type_t, allocator_t &gt;</a></td></tr>
<tr class="memitem:a53b8d655a996e1eb424894548a9ed2da inherit pub_static_attribs_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a53b8d655a996e1eb424894548a9ed2da">npos</a></td></tr>
<tr class="memdesc:a53b8d655a996e1eb424894548a9ed2da inherit pub_static_attribs_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the maximum value representable by the type <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>.  <br /></td></tr>
<tr class="separator:a53b8d655a996e1eb424894548a9ed2da inherit pub_static_attribs_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classxtd_1_1collections_1_1generic_1_1ilist"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classxtd_1_1collections_1_1generic_1_1ilist')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">xtd::collections::generic::ilist&lt; type_t &gt;</a></td></tr>
<tr class="memitem:a029b16e1ccb68bbcfb0c7f85de7706d5 inherit pub_static_attribs_classxtd_1_1collections_1_1generic_1_1ilist"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html#a029b16e1ccb68bbcfb0c7f85de7706d5">npos</a></td></tr>
<tr class="memdesc:a029b16e1ccb68bbcfb0c7f85de7706d5 inherit pub_static_attribs_classxtd_1_1collections_1_1generic_1_1ilist"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the maximum value representable by the type <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>.  <br /></td></tr>
<tr class="separator:a029b16e1ccb68bbcfb0c7f85de7706d5 inherit pub_static_attribs_classxtd_1_1collections_1_1generic_1_1ilist"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1basic__array"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1basic__array')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array&lt; type_t, allocator_t &gt;</a></td></tr>
<tr class="memitem:ad830194f7a76eec01d6bd96b1f3343bb inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ad830194f7a76eec01d6bd96b1f3343bb">back</a> ()</td></tr>
<tr class="memdesc:ad830194f7a76eec01d6bd96b1f3343bb inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:ad830194f7a76eec01d6bd96b1f3343bb inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a1eac93ddf1500a9515fc560d7b572 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a52a1eac93ddf1500a9515fc560d7b572">back</a> () const</td></tr>
<tr class="memdesc:a52a1eac93ddf1500a9515fc560d7b572 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:a52a1eac93ddf1500a9515fc560d7b572 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb48e8ab13f64c2bbc8579286cdc33c inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#a3321bf399b37b67bd1d690b828b046d3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a7cb48e8ab13f64c2bbc8579286cdc33c">begin</a> () const noexcept override</td></tr>
<tr class="memdesc:a7cb48e8ab13f64c2bbc8579286cdc33c inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:a7cb48e8ab13f64c2bbc8579286cdc33c inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acd2ad2fa08cf8fb94d254f70c91de3 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#a14d7e5f059d85010c0351292e3c95f3e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a7acd2ad2fa08cf8fb94d254f70c91de3">begin</a> () noexcept override</td></tr>
<tr class="memdesc:a7acd2ad2fa08cf8fb94d254f70c91de3 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:a7acd2ad2fa08cf8fb94d254f70c91de3 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4978aa1d73aaf5e204cac3841ea866 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#a3321bf399b37b67bd1d690b828b046d3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#adb4978aa1d73aaf5e204cac3841ea866">cbegin</a> () const noexcept override</td></tr>
<tr class="memdesc:adb4978aa1d73aaf5e204cac3841ea866 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:adb4978aa1d73aaf5e204cac3841ea866 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23631ee443a12598cc846b128473312d inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#a3321bf399b37b67bd1d690b828b046d3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a23631ee443a12598cc846b128473312d">cend</a> () const noexcept override</td></tr>
<tr class="memdesc:a23631ee443a12598cc846b128473312d inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a23631ee443a12598cc846b128473312d inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e50b538f5aa4913d3180fcee49499c2 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a2e50b538f5aa4913d3180fcee49499c2">count</a> () const noexcept override</td></tr>
<tr class="memdesc:a2e50b538f5aa4913d3180fcee49499c2 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements contained in the <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a2e50b538f5aa4913d3180fcee49499c2 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95718ca09e080a530bb22ab7fc29928 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#af95718ca09e080a530bb22ab7fc29928">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:af95718ca09e080a530bb22ab7fc29928 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to xtd::array::rend().  <br /></td></tr>
<tr class="separator:af95718ca09e080a530bb22ab7fc29928 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14a4aeb972e3b0ad85bc83d4596dd03 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ac14a4aeb972e3b0ad85bc83d4596dd03">crend</a> () const noexcept</td></tr>
<tr class="memdesc:ac14a4aeb972e3b0ad85bc83d4596dd03 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:ac14a4aeb972e3b0ad85bc83d4596dd03 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5a9ce8373768ab8c68b261b33d5b6f inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a58756d2450f08851d601a29456ba4273">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a5b5a9ce8373768ab8c68b261b33d5b6f">data</a> () noexcept</td></tr>
<tr class="memdesc:a5b5a9ce8373768ab8c68b261b33d5b6f inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <br /></td></tr>
<tr class="separator:a5b5a9ce8373768ab8c68b261b33d5b6f inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1405502cc9db3c5decf3d44c99fda34b inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a52835b4b627c5d7783f5d523aa265927">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a1405502cc9db3c5decf3d44c99fda34b">data</a> () const noexcept</td></tr>
<tr class="memdesc:a1405502cc9db3c5decf3d44c99fda34b inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <br /></td></tr>
<tr class="separator:a1405502cc9db3c5decf3d44c99fda34b inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecdfcec3616cd38223715dd6f4df224 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a0ecdfcec3616cd38223715dd6f4df224">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a0ecdfcec3616cd38223715dd6f4df224 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether xtd::array::begin() == xtd::array::end().  <br /></td></tr>
<tr class="separator:a0ecdfcec3616cd38223715dd6f4df224 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c2af41aeaa2af9847c1d6567df83c6 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#a3321bf399b37b67bd1d690b828b046d3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a69c2af41aeaa2af9847c1d6567df83c6">end</a> () const noexcept override</td></tr>
<tr class="memdesc:a69c2af41aeaa2af9847c1d6567df83c6 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a69c2af41aeaa2af9847c1d6567df83c6 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb880053eba2eefbc54d5d312626586 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#a14d7e5f059d85010c0351292e3c95f3e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#aabb880053eba2eefbc54d5d312626586">end</a> () noexcept override</td></tr>
<tr class="memdesc:aabb880053eba2eefbc54d5d312626586 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:aabb880053eba2eefbc54d5d312626586 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8f87d8d029713510c61ba59d1858a0 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a2d8f87d8d029713510c61ba59d1858a0">front</a> ()</td></tr>
<tr class="memdesc:a2d8f87d8d029713510c61ba59d1858a0 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:a2d8f87d8d029713510c61ba59d1858a0 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac754e2b8fe8c218619603f807d2dede6 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ac754e2b8fe8c218619603f807d2dede6">front</a> () const</td></tr>
<tr class="memdesc:ac754e2b8fe8c218619603f807d2dede6 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:ac754e2b8fe8c218619603f807d2dede6 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb6f585d484eac04eb282dd0a5fe9fd inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#acdb6f585d484eac04eb282dd0a5fe9fd">is_fixed_size</a> () const noexcept override</td></tr>
<tr class="memdesc:acdb6f585d484eac04eb282dd0a5fe9fd inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether the <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html" title="Represents a collection of objects that can be individually accessed by index.">xtd::collections::generic::ilist</a> &lt;type_t&gt; has a fixed size.  <br /></td></tr>
<tr class="separator:acdb6f585d484eac04eb282dd0a5fe9fd inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95524d29f8f4a218254d137c5046cb1 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ad95524d29f8f4a218254d137c5046cb1">is_read_only</a> () const noexcept override</td></tr>
<tr class="memdesc:ad95524d29f8f4a218254d137c5046cb1 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is read-only.  <br /></td></tr>
<tr class="separator:ad95524d29f8f4a218254d137c5046cb1 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbb0b954165a263596fe7fd433d6125 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a5cbb0b954165a263596fe7fd433d6125">is_synchronized</a> () const noexcept override</td></tr>
<tr class="memdesc:a5cbb0b954165a263596fe7fd433d6125 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether access to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is synchronized (thread safe).  <br /></td></tr>
<tr class="separator:a5cbb0b954165a263596fe7fd433d6125 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d7c124db651f72d7f2b4971c5862f5 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classxtd_1_1basic__array.html#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ab5d7c124db651f72d7f2b4971c5862f5">items</a> () const noexcept</td></tr>
<tr class="memdesc:ab5d7c124db651f72d7f2b4971c5862f5 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:ab5d7c124db651f72d7f2b4971c5862f5 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb7eadaa77baa15c8193de6af45eaec inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#ad277de2a42b4b0aba1c24eadf2edbe24">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#adfb7eadaa77baa15c8193de6af45eaec">items</a> () noexcept</td></tr>
<tr class="memdesc:adfb7eadaa77baa15c8193de6af45eaec inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:adfb7eadaa77baa15c8193de6af45eaec inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf70989e6cabeaccefd32e3b760753ef inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#aaf70989e6cabeaccefd32e3b760753ef">length</a> () const noexcept</td></tr>
<tr class="memdesc:aaf70989e6cabeaccefd32e3b760753ef inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a size that represents the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:aaf70989e6cabeaccefd32e3b760753ef inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48551f7aa950699c881a79fdd70f4f39 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a48551f7aa950699c881a79fdd70f4f39">long_length</a> ()</td></tr>
<tr class="memdesc:a48551f7aa950699c881a79fdd70f4f39 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:a48551f7aa950699c881a79fdd70f4f39 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760f9d630aee4ee6076c5f1fb0ba412f inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a760f9d630aee4ee6076c5f1fb0ba412f">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a760f9d630aee4ee6076c5f1fb0ba412f inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(xtd::array::begin(), xtd::array::end()) for the largest container.  <br /></td></tr>
<tr class="separator:a760f9d630aee4ee6076c5f1fb0ba412f inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f34355f80375edca7538ed77d2bc431 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a4ec840a621251f1d7ba5caab527f5e08">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a9f34355f80375edca7538ed77d2bc431">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a9f34355f80375edca7538ed77d2bc431 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to xtd::array::rend().  <br /></td></tr>
<tr class="separator:a9f34355f80375edca7538ed77d2bc431 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6f68bf56a69ac0b57970e6ba9441a2 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a0d6f68bf56a69ac0b57970e6ba9441a2">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a0d6f68bf56a69ac0b57970e6ba9441a2 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to xtd::array::rend().  <br /></td></tr>
<tr class="separator:a0d6f68bf56a69ac0b57970e6ba9441a2 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c8b33119f80c64566c9c4fe307be46 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a4ec840a621251f1d7ba5caab527f5e08">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ab5c8b33119f80c64566c9c4fe307be46">rend</a> () noexcept</td></tr>
<tr class="memdesc:ab5c8b33119f80c64566c9c4fe307be46 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:ab5c8b33119f80c64566c9c4fe307be46 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3432941b86f8c8e7c78bcf7132843e6d inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a0160c4ae793de2de4a97ed5d6a0351f1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a3432941b86f8c8e7c78bcf7132843e6d">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a3432941b86f8c8e7c78bcf7132843e6d inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a3432941b86f8c8e7c78bcf7132843e6d inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ad3488e28e4140835dece83723e7eb inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#af2ad3488e28e4140835dece83723e7eb">size</a> () const noexcept</td></tr>
<tr class="memdesc:af2ad3488e28e4140835dece83723e7eb inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. std::distance(xtd::array::begin(), xtd::array::end()).  <br /></td></tr>
<tr class="separator:af2ad3488e28e4140835dece83723e7eb inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5a20a84786e5ae303364a521972609 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1object.html">xtd::object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#aee5a20a84786e5ae303364a521972609">sync_root</a> () const noexcept override</td></tr>
<tr class="memdesc:aee5a20a84786e5ae303364a521972609 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an object that can be used to synchronize access to the the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:aee5a20a84786e5ae303364a521972609 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34472044617550faf939f05c223b6227 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a34472044617550faf939f05c223b6227">at</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> index)</td></tr>
<tr class="memdesc:a34472044617550faf939f05c223b6227 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <br /></td></tr>
<tr class="separator:a34472044617550faf939f05c223b6227 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadefb8b17214889a16b31088e0131431 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1basic__array.html#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#aadefb8b17214889a16b31088e0131431">at</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> index) const</td></tr>
<tr class="memdesc:aadefb8b17214889a16b31088e0131431 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <br /></td></tr>
<tr class="separator:aadefb8b17214889a16b31088e0131431 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659906a6f1060c2205d787b49bb129fc inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a659906a6f1060c2205d787b49bb129fc">contains</a> (const type_t &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a659906a6f1060c2205d787b49bb129fc inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an element is in the array.  <br /></td></tr>
<tr class="separator:a659906a6f1060c2205d787b49bb129fc inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6766e45b973a8659323055151b0cff9e inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a6766e45b973a8659323055151b0cff9e">copy_to</a> (<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a>&lt; type_t &gt; &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>, <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> index) const override</td></tr>
<tr class="memdesc:a6766e45b973a8659323055151b0cff9e inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; to an <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a>, starting at a particular <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> index.  <br /></td></tr>
<tr class="separator:a6766e45b973a8659323055151b0cff9e inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ff0322a96e0ed8a3c268fd8a3d4eca inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a88ff0322a96e0ed8a3c268fd8a3d4eca">copy_to</a> (<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a>&lt; type_t &gt; &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>, <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> index) const</td></tr>
<tr class="memdesc:a88ff0322a96e0ed8a3c268fd8a3d4eca inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 64-bit integer.  <br /></td></tr>
<tr class="separator:a88ff0322a96e0ed8a3c268fd8a3d4eca inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391534692d321eadc7a5810486c16650 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a391534692d321eadc7a5810486c16650">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept override</td></tr>
<tr class="memdesc:a391534692d321eadc7a5810486c16650 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a391534692d321eadc7a5810486c16650 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b108d6bbebf0dde60afcbe2c7a1e0f inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a93b108d6bbebf0dde60afcbe2c7a1e0f">equals</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;rhs) const noexcept override</td></tr>
<tr class="separator:a93b108d6bbebf0dde60afcbe2c7a1e0f inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ef003c8174b830377e38610e743e4f inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a92ef003c8174b830377e38610e743e4f">fill</a> (const <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a92ef003c8174b830377e38610e743e4f inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value to all elements in the container.  <br /></td></tr>
<tr class="separator:a92ef003c8174b830377e38610e743e4f inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6753ddfe99de81064d777312541cea34 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1enumerator.html">xtd::collections::generic::enumerator</a>&lt; <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a6753ddfe99de81064d777312541cea34">get_enumerator</a> () const noexcept override</td></tr>
<tr class="memdesc:a6753ddfe99de81064d777312541cea34 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that iterates through a collection.  <br /></td></tr>
<tr class="separator:a6753ddfe99de81064d777312541cea34 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4132e3affe66da23dc58780f520124e2 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a4132e3affe66da23dc58780f520124e2">get_length</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:a4132e3affe66da23dc58780f520124e2 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:a4132e3affe66da23dc58780f520124e2 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe84abedf478ba9a5059c08b7ff020 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a06fe84abedf478ba9a5059c08b7ff020">get_long_length</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:a06fe84abedf478ba9a5059c08b7ff020 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the array.  <br /></td></tr>
<tr class="separator:a06fe84abedf478ba9a5059c08b7ff020 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac6c2f6144b73e261745e2bec9f6771 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a6ac6c2f6144b73e261745e2bec9f6771">get_lower_bound</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:a6ac6c2f6144b73e261745e2bec9f6771 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower bound of the specified dimension in the array.  <br /></td></tr>
<tr class="separator:a6ac6c2f6144b73e261745e2bec9f6771 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74ed5a54361b742c7e27ff7b180a986 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ab74ed5a54361b742c7e27ff7b180a986">get_upper_bound</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> dimension) const</td></tr>
<tr class="memdesc:ab74ed5a54361b742c7e27ff7b180a986 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the upper bound of the specified dimension in the array.  <br /></td></tr>
<tr class="separator:ab74ed5a54361b742c7e27ff7b180a986 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7241f2c62089b168c5796d57e323798 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ab7241f2c62089b168c5796d57e323798">get_value</a> (const <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes) const</td></tr>
<tr class="memdesc:ab7241f2c62089b168c5796d57e323798 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the multidimensional array. The indexes are specified as 32-bit integers array.  <br /></td></tr>
<tr class="separator:ab7241f2c62089b168c5796d57e323798 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff23cf9bbd59f42928e36dcc042425 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a63ff23cf9bbd59f42928e36dcc042425">index_of</a> (const type_t &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a63ff23cf9bbd59f42928e36dcc042425 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a63ff23cf9bbd59f42928e36dcc042425 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388eccad9eb3e3645fa5f8341014c9e7 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a388eccad9eb3e3645fa5f8341014c9e7">resize</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> new_size)</td></tr>
<tr class="memdesc:a388eccad9eb3e3645fa5f8341014c9e7 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>. @param new_size The new size of the container. @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> If</code>new_size<code>is outside greather than xtd::array::max_size. @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. @remarks If the current size is less than</code>count`, additional default-inserted elements are appended.  <br /></td></tr>
<tr class="separator:a388eccad9eb3e3645fa5f8341014c9e7 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795fd3bff66d49a57311b81cf697953f inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a795fd3bff66d49a57311b81cf697953f">resize</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> new_size, <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> value)</td></tr>
<tr class="memdesc:a795fd3bff66d49a57311b81cf697953f inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>. @param new_size The new size of the container. @param value The value to initialize the new elements with. @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> If</code>new_size<code>is outside greather than xtd::array::max_size. @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. @remarks If the current size is less than</code>count`, additional default-inserted elements are appended.  <br /></td></tr>
<tr class="separator:a795fd3bff66d49a57311b81cf697953f inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ccd2da9fa829ff222758a05f112006 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a36ccd2da9fa829ff222758a05f112006">set_value</a> (const type_t &amp;value, const <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes)</td></tr>
<tr class="memdesc:a36ccd2da9fa829ff222758a05f112006 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to the element at the specified position in the multidimensional array.  <br /></td></tr>
<tr class="separator:a36ccd2da9fa829ff222758a05f112006 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29d8f865aaa14d1f3ce4ae201fdf1b5 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ac29d8f865aaa14d1f3ce4ae201fdf1b5">swap</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ac29d8f865aaa14d1f3ce4ae201fdf1b5 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents and capacity of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.  <br /></td></tr>
<tr class="separator:ac29d8f865aaa14d1f3ce4ae201fdf1b5 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ec27387ef0582948fc499fde1eba65 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ac4ec27387ef0582948fc499fde1eba65">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:ac4ec27387ef0582948fc499fde1eba65 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:ac4ec27387ef0582948fc499fde1eba65 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca38a735b49019beb5e5f14ab8d4ac1 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a9ca38a735b49019beb5e5f14ab8d4ac1">operator=</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;other)</td></tr>
<tr class="memdesc:a9ca38a735b49019beb5e5f14ab8d4ac1 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of other.  <br /></td></tr>
<tr class="separator:a9ca38a735b49019beb5e5f14ab8d4ac1 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ca7652bd75af5a950e375cad3ce53c inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ab2ca7652bd75af5a950e375cad3ce53c">operator=</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:ab2ca7652bd75af5a950e375cad3ce53c inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:ab2ca7652bd75af5a950e375cad3ce53c inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8aa56257fec1b361de7c00c2222b5 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ad4c8aa56257fec1b361de7c00c2222b5">operator=</a> (std::initializer_list&lt; type_t &gt; &amp;items)</td></tr>
<tr class="memdesc:ad4c8aa56257fec1b361de7c00c2222b5 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist.  <br /></td></tr>
<tr class="separator:ad4c8aa56257fec1b361de7c00c2222b5 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c62871eef03c2d45676040e137e604 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#a01a0d032eb60a2a8f0bdf84ba3fe1204">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ac5c62871eef03c2d45676040e137e604">operator[]</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> index) const override</td></tr>
<tr class="memdesc:ac5c62871eef03c2d45676040e137e604 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index.  <br /></td></tr>
<tr class="separator:ac5c62871eef03c2d45676040e137e604 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc74a419dc77ebae92d7a7aaa80c2249 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__array.html#a6054c9522c7a58c05453b86e0c6f1913">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#afc74a419dc77ebae92d7a7aaa80c2249">operator[]</a> (<a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> index) override</td></tr>
<tr class="memdesc:afc74a419dc77ebae92d7a7aaa80c2249 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index.  <br /></td></tr>
<tr class="separator:afc74a419dc77ebae92d7a7aaa80c2249 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c15ccc5efbe20ca6656e87436036c3 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a49c15ccc5efbe20ca6656e87436036c3">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:a49c15ccc5efbe20ca6656e87436036c3 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a49c15ccc5efbe20ca6656e87436036c3 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eac9b62b7209d7ef1bda73d4b77c8a7 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a3eac9b62b7209d7ef1bda73d4b77c8a7">operator base_type &amp;</a> () noexcept</td></tr>
<tr class="memdesc:a3eac9b62b7209d7ef1bda73d4b77c8a7 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a3eac9b62b7209d7ef1bda73d4b77c8a7 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69e36f4325b1dd1bb954cd2dc5ae854 inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">type_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ac69e36f4325b1dd1bb954cd2dc5ae854">operator()</a> (const <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes)</td></tr>
<tr class="memdesc:ac69e36f4325b1dd1bb954cd2dc5ae854 inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array.  <br /></td></tr>
<tr class="separator:ac69e36f4325b1dd1bb954cd2dc5ae854 inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89069f26f2d946327f78dbece0dce8b inherit pub_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">const type_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ac89069f26f2d946327f78dbece0dce8b">operator()</a> (const <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> &gt; &amp;indexes) const</td></tr>
<tr class="memdesc:ac89069f26f2d946327f78dbece0dce8b inherit pub_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the specified position in the multidimensional array. The indexes are specified as a 32-bit integer array.  <br /></td></tr>
<tr class="separator:ac89069f26f2d946327f78dbece0dce8b inherit pub_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga4ac188feb2d52b21e188417441519bb2">xtd::uptr</a>&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#abb9700deaba669584080178e391d97c4">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1ilist"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1ilist')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">xtd::collections::generic::ilist&lt; type_t &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1icollection')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection&lt; type_t &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1ienumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1ienumerable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable&lt; type_t &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1enumerable__iterators.html">xtd::collections::generic::enumerable_iterators&lt; type_t, ienumerable&lt; type_t &gt; &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1iequatable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1iequatable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1iequatable.html">xtd::iequatable&lt; basic_array&lt; type_t, allocator_t &gt; &gt;</a></td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1basic__array"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1basic__array')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array&lt; type_t, allocator_t &gt;</a></td></tr>
<tr class="memitem:a56e8d16cbfd4478600885c5ebbc0cb90 inherit pub_static_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#a56e8d16cbfd4478600885c5ebbc0cb90">index_of</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>, const <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a56e8d16cbfd4478600885c5ebbc0cb90 inherit pub_static_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the array specified.  <br /></td></tr>
<tr class="separator:a56e8d16cbfd4478600885c5ebbc0cb90 inherit pub_static_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d15bd70091aef74009040a66e96c7 inherit pub_static_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ad62d15bd70091aef74009040a66e96c7">index_of</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>, const <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value, <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> index)</td></tr>
<tr class="memdesc:ad62d15bd70091aef74009040a66e96c7 inherit pub_static_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the array specified.  <br /></td></tr>
<tr class="separator:ad62d15bd70091aef74009040a66e96c7 inherit pub_static_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ce2959fbb235a756ad16dd2a3f343e inherit pub_static_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ad5ce2959fbb235a756ad16dd2a3f343e">index_of</a> (const <a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>, const <a class="el" href="classxtd_1_1basic__array.html#a8a186922544d50c32678dbeead9d34fe">value_type</a> &amp;value, <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> index, <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> count)</td></tr>
<tr class="memdesc:ad5ce2959fbb235a756ad16dd2a3f343e inherit pub_static_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the index of a specific item in the array specified.  <br /></td></tr>
<tr class="separator:ad5ce2959fbb235a756ad16dd2a3f343e inherit pub_static_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc2546d5b6d814fdebcd0318d76e91 inherit pub_static_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#ad1bc2546d5b6d814fdebcd0318d76e91">reverse</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>) noexcept</td></tr>
<tr class="memdesc:ad1bc2546d5b6d814fdebcd0318d76e91 inherit pub_static_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the entire <a class="el" href="classxtd_1_1basic__array.html" title="Base object that represent array.">xtd::basic_array</a>.  <br /></td></tr>
<tr class="separator:ad1bc2546d5b6d814fdebcd0318d76e91 inherit pub_static_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5089c1fc7d9e8010517893f5cf4a946 inherit pub_static_methods_classxtd_1_1basic__array"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__array.html#af5089c1fc7d9e8010517893f5cf4a946">reverse</a> (<a class="el" href="classxtd_1_1basic__array.html">basic_array</a> &amp;<a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">array</a>, <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> index, <a class="el" href="classxtd_1_1basic__array.html#af9b44083298196790c9d898bf520828a">size_type</a> count)</td></tr>
<tr class="memdesc:af5089c1fc7d9e8010517893f5cf4a946 inherit pub_static_methods_classxtd_1_1basic__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the specified range.  <br /></td></tr>
<tr class="separator:af5089c1fc7d9e8010517893f5cf4a946 inherit pub_static_methods_classxtd_1_1basic__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t &gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t &gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classxtd_1_1abstract__object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classxtd_1_1abstract__object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classxtd_1_1abstract__object.html">xtd::abstract_object</a></td></tr>
<tr class="memitem:ad7a701628e47b725c0bc15400085d714 inherit pro_methods_classxtd_1_1abstract__object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1abstract__object.html#ad7a701628e47b725c0bc15400085d714">abstract_object</a> ()=default</td></tr>
<tr class="memdesc:ad7a701628e47b725c0bc15400085d714 inherit pro_methods_classxtd_1_1abstract__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1abstract__object.html" title="Represent an abstract class.">xtd::abstract_object</a> class.  <br /></td></tr>
<tr class="separator:ad7a701628e47b725c0bc15400085d714 inherit pro_methods_classxtd_1_1abstract__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af78de29eb35b65d12290dd578c9ae8ba" name="af78de29eb35b65d12290dd578c9ae8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78de29eb35b65d12290dd578c9ae8ba">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::value_type =  type_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array value type. </p>

</div>
</div>
<a id="a81776bbaaef91ea91cfc96ed7e632848" name="a81776bbaaef91ea91cfc96ed7e632848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81776bbaaef91ea91cfc96ed7e632848">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::allocator_type =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array allocator type. </p>

</div>
</div>
<a id="a542030e1f490232cf241d523d74e1362" name="a542030e1f490232cf241d523d74e1362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542030e1f490232cf241d523d74e1362">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::base_type =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::base_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array base type. </p>

</div>
</div>
<a id="af3aecaad661a6c5c7c669b29da9b6b86" name="af3aecaad661a6c5c7c669b29da9b6b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3aecaad661a6c5c7c669b29da9b6b86">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::size_type =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array size type (usually <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>). </p>

</div>
</div>
<a id="aa25ba84f558a98c6b387c2c5e4aedc05" name="aa25ba84f558a98c6b387c2c5e4aedc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25ba84f558a98c6b387c2c5e4aedc05">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::difference_type =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the array difference type (usually <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca" title="Represent the signed integer type of the result of subtracting two pointers.">xtd::ptrdiff</a>). </p>

</div>
</div>
<a id="a8859ac4fb2dad5f76ead9714d38f0e37" name="a8859ac4fb2dad5f76ead9714d38f0e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8859ac4fb2dad5f76ead9714d38f0e37">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::reference =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the reference of array value type. </p>

</div>
</div>
<a id="ad980ad2f2d71b6244de010687e7c4b6f" name="ad980ad2f2d71b6244de010687e7c4b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad980ad2f2d71b6244de010687e7c4b6f">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::const_reference =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const reference of array value type. </p>

</div>
</div>
<a id="a7b5681b9b117a13f547ab0e272adc211" name="a7b5681b9b117a13f547ab0e272adc211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5681b9b117a13f547ab0e272adc211">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::pointer =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the pointer of array value type. </p>

</div>
</div>
<a id="a3ab6b35eb6d00b18df27855624d81c34" name="a3ab6b35eb6d00b18df27855624d81c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab6b35eb6d00b18df27855624d81c34">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::const_pointer =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const pointer of array value type. </p>

</div>
</div>
<a id="ad9840c29cf4b8b42775a91f6165193d2" name="ad9840c29cf4b8b42775a91f6165193d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9840c29cf4b8b42775a91f6165193d2">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::iterator =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the iterator of array value type. </p>

</div>
</div>
<a id="a01f0cc66bfe0443f0fdca2d717775092" name="a01f0cc66bfe0443f0fdca2d717775092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f0cc66bfe0443f0fdca2d717775092">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::const_iterator =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const iterator of array value type. </p>

</div>
</div>
<a id="a4420301e5829ffe117d0f143ebbd0d5b" name="a4420301e5829ffe117d0f143ebbd0d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4420301e5829ffe117d0f143ebbd0d5b">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::reverse_iterator =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the reverse iterator of array value type. </p>

</div>
</div>
<a id="a2b8caa8c9c41ca61cf8391690c460362" name="a2b8caa8c9c41ca61cf8391690c460362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8caa8c9c41ca61cf8391690c460362">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::const_reverse_iterator =  typename <a class="el" href="classxtd_1_1basic__array.html">xtd::basic_array</a>&lt;type_t, allocator_t&gt;::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const reverse iterator of array value type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad5ebe4ef445d0a64641973d4991ed4fc" name="ad5ebe4ef445d0a64641973d4991ed4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ebe4ef445d0a64641973d4991ed4fc">&#9670;&#160;</a></span>array_() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the Array class that is empty. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The Array class is not thread safe. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates different methods to create an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a22755ee396683024671d23cab87d2e5e" name="a22755ee396683024671d23cab87d2e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22755ee396683024671d23cab87d2e5e">&#9670;&#160;</a></span>array_() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array__.html">array_</a>&lt; type_t, 1, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with specified array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> which elements will be inserted from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d4adb22e06ce4d081d992104891dbbd" name="a3d4adb22e06ce4d081d992104891dbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4adb22e06ce4d081d992104891dbbd">&#9670;&#160;</a></span>array_() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array__.html">array_</a>&lt; type_t, 1, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with specified array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The <a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a> which elements will be inserted from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50c141b33e9dca1f5dc0d1a2e2ec856a" name="a50c141b33e9dca1f5dc0d1a2e2ec856a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c141b33e9dca1f5dc0d1a2e2ec856a">&#9670;&#160;</a></span>array_() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a542030e1f490232cf241d523d74e1362">base_type</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with specified base type array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The xtd::array::base_type which elements will be inserted from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e892d95353bed583a2a3e085220660f" name="a8e892d95353bed583a2a3e085220660f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e892d95353bed583a2a3e085220660f">&#9670;&#160;</a></span>array_() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#a542030e1f490232cf241d523d74e1362">base_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with specified base type array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The xtd::array::base_type which elements will be moved from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab06285f651cee425dfea4b3a15199fd" name="aab06285f651cee425dfea4b3a15199fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab06285f651cee425dfea4b3a15199fd">&#9670;&#160;</a></span>array_() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the array class with lengths for each rank specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length for the first rank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The array class is not thread safe. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates different methods to create an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8c6fd9ef8e192186b82d56269fa9f9e3" name="a8c6fd9ef8e192186b82d56269fa9f9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6fd9ef8e192186b82d56269fa9f9e3">&#9670;&#160;</a></span>array_() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; type_t &gt;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>The initializer list to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b953d740c2767b2c3c989d0d6b8edb0" name="a5b953d740c2767b2c3c989d0d6b8edb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b953d740c2767b2c3c989d0d6b8edb0">&#9670;&#160;</a></span>array_() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> length&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype">const type_t(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[length]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the array and copy array[] type_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The array class is not thread safe. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates different methods to create an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5fa2c0e5ee8436914ba92d70a66289bd" name="a5fa2c0e5ee8436914ba92d70a66289bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa2c0e5ee8436914ba92d70a66289bd">&#9670;&#160;</a></span>array_() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype">const type_t *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the array and copy array[] type_t with length specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array to copy. </td></tr>
    <tr><td class="paramname">length</td><td>length of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The array class is not thread safe. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates different methods to create an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae85c5199e027e2e95426e3148731b0e8" name="ae85c5199e027e2e95426e3148731b0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85c5199e027e2e95426e3148731b0e8">&#9670;&#160;</a></span>array_() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; type_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the array and copy array array specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The array class is not thread safe. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates different methods to create an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8d2f763b214f2dab9515c1ff6cb5352c" name="a8d2f763b214f2dab9515c1ff6cb5352c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2f763b214f2dab9515c1ff6cb5352c">&#9670;&#160;</a></span>array_() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">xtd::collections::generic::ilist</a>&lt; type_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the array and copy array array specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The array class is not thread safe. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates different methods to create an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a493b5fffc563b787c0bbf5491edd96c0" name="a493b5fffc563b787c0bbf5491edd96c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493b5fffc563b787c0bbf5491edd96c0">&#9670;&#160;</a></span>array_() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<div class="memtemplate">
template&lt;typename iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::array_ </td>
          <td>(</td>
          <td class="paramtype">iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator the range to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator the range to copy the elements from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4a24846c3bb7be098b8f309133793fcf" name="a4a24846c3bb7be098b8f309133793fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a24846c3bb7be098b8f309133793fcf">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the rank (number of dimensions) of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>The rank (number of dimensions) of the array. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates methods to get the rank of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1basic__array.html#a0f0e476086ae44f64d6ed64a8cfbfc73">xtd::basic_array&lt; type_t, allocator_t &gt;</a>.</p>

</div>
</div>
<a id="a199a1c6c5c8f85495fcfe0619321c594" name="a199a1c6c5c8f85495fcfe0619321c594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199a1c6c5c8f85495fcfe0619321c594">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacextd.html#a23ad3a72b3c9da7418d0b2020076a40a">xtd::array</a>&lt; type_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 32-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The one-dimensional array that is the destination of the elements copied from the current array. </td></tr>
    <tr><td class="paramname">index</td><td>The index in array at which copying begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>index is less than the lower bound of array. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>array is multidimensional. -or- The number of elements in the source array is greater than the available number of elements from index to the end of the destination array. </td></tr>
    <tr><td class="paramname">ArrayTypeMismatchException</td><td>The type of the source Array cannot be cast automatically to the type of the destination array. </td></tr>
    <tr><td class="paramname">RankException</td><td>The source array is multidimensional. </td></tr>
    <tr><td class="paramname">InvalidCastException</td><td>At least one element in the source Array cannot be cast to the type of destination array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method copies all the elements of the current array instance to the array destination array, starting at index index. The array destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements. Otherwise, the method throws an exception. </dd>
<dd>
This method supports the System.Collections.ICollection interface. If implementing System.Collections.ICollection is not explicitly required, use Copy to avoid an extra indirection. </dd>
<dd>
If this method throws an exception while copying, the state of array is undefined. </dd>
<dd>
This method is an O(n) operation, where n is Length.It performs a shallow copy only. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to copy an Array to another native Array. <div class="fragment"></div><!-- fragment --> </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a5395bfa3efc35df844dc5c1d3197621c">xtd::collections::generic::icollection&lt; type_t &gt;</a>.</p>

</div>
</div>
<a id="af3949d32661662103f1e5abbff8bfe1d" name="af3949d32661662103f1e5abbff8bfe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3949d32661662103f1e5abbff8bfe1d">&#9670;&#160;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp; <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::get_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the Array element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified position in the one-dimensional Array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The current Array does ! have exactly one dimension. </td></tr>
    <tr><td class="paramname">IndexOutOfRangeException</td><td>index is outside the range of valid indexes for the current Array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a964258b5fff46ee925d837907032fd70" name="a964258b5fff46ee925d837907032fd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964258b5fff46ee925d837907032fd70">&#9670;&#160;</a></span>set_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::set_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a value to the element at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new value for the specified element. </td></tr>
    <tr><td class="paramname">index</td><td>The position of the Array element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The current Array does ! have exactly one dimension. </td></tr>
    <tr><td class="paramname">IndexOutOfRangeException</td><td>index is outside the range of valid indexes for the current Array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab54c1baaef4b4ccdb28b7e5d235e70cd" name="ab54c1baaef4b4ccdb28b7e5d235e70cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54c1baaef4b4ccdb28b7e5d235e70cd">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp; <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a value to the element at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new value for the specified element. </td></tr>
    <tr><td class="paramname">index</td><td>A 32-bit integer that represents the position of the Array element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The current Array does ! have exactly one dimension. </td></tr>
    <tr><td class="paramname">IndexOutOfRangeException</td><td>index is outside the range of valid indexes for the current Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use operator () to list the elements of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a14bbfbc0ff10bde0998d4d0df73cba27" name="a14bbfbc0ff10bde0998d4d0df73cba27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bbfbc0ff10bde0998d4d0df73cba27">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp; <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A 32-bit integer that represents the position of the Array element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified position in the one-dimensional Array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The current Array does ! have exactly one dimension. </td></tr>
    <tr><td class="paramname">IndexOutOfRangeException</td><td>index is outside the range of valid indexes for the current Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use operator () to list the elements of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2f6a7d47afc9df774584f7fd0c4750b8" name="a2f6a7d47afc9df774584f7fd0c4750b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6a7d47afc9df774584f7fd0c4750b8">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp; <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a value to the element at the specified position in the one-dimensional Array. The index is specified as a 32-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new value for the specified element. </td></tr>
    <tr><td class="paramname">index</td><td>A 32-bit integer that represents the position of the Array element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The current Array does ! have exactly one dimension. </td></tr>
    <tr><td class="paramname">IndexOutOfRangeException</td><td>index is outside the range of valid indexes for the current Array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use operator [] to list the elements of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html#a52963baff21f5a49b9268e7963bcd372">xtd::collections::generic::ilist&lt; type_t &gt;</a>.</p>

</div>
</div>
<a id="af38b5caa7ccf01a144b2368979733d30" name="af38b5caa7ccf01a144b2368979733d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38b5caa7ccf01a144b2368979733d30">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t , typename allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af78de29eb35b65d12290dd578c9ae8ba">value_type</a> &amp; <a class="el" href="classxtd_1_1array__.html">xtd::array_</a>&lt; type_t, 1, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array___3_01type__t_00_011_00_01allocator__t_01_4.html#af3aecaad661a6c5c7c669b29da9b6b86">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The zero-based index of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the specified position in the one-dimensional Array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The current Array does ! have exactly one dimension. </td></tr>
    <tr><td class="paramname">IndexOutOfRangeException</td><td>index is less than 0 or index is equal to or greater than Count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use operator [] to list the elements of an array. <div class="fragment"></div><!-- fragment --> </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html#acc73a982e30f9421421f8265415bfab3">xtd::collections::generic::ilist&lt; type_t &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/<a class="el" href="array__1_8h_source.html">array_1.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 25 2024 17:42:08 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
