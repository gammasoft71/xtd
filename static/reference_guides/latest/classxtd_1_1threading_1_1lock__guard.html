<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::lock_guard Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1lock__guard.html">lock_guard</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1threading_1_1lock__guard-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::lock_guard Class Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::lock_guard:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1lock__guard.png" usemap="#xtd::threading::lock_5Fguard_map" alt=""/>
  <map id="xtd::threading::lock_5Fguard_map" name="xtd::threading::lock_5Fguard_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,156,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a mechanism that synchronizes access to objects with <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a>. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_class" href="classxtd_1_1threading_1_1lock__guard.html">lock_guard</a> final : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.h:32</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1lock__guard_html"><div class="ttname"><a href="classxtd_1_1threading_1_1lock__guard.html">xtd::threading::lock_guard</a></div><div class="ttdoc">Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.</div><div class="ttdef"><b>Definition</b> lock_guard.h:31</div></div>
<div class="ttc" id="agroup__keywords_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.h:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> â†’ xtd::lock_guard </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/lock_guard&gt;</span> </div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example uses the <a class="el" href="classxtd_1_1threading_1_1lock__guard.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock_guard</a> class to synchronize access to a single instance of a random number generator represented by the <a class="el" href="classxtd_1_1random.html" title="Represents a pseudo-random number generator, a device that produces a sequence of numbers that meet c...">xtd::random</a> class. The example creates ten threads, each of which executes asynchronously on a thread pool thread. Each thread generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum. After all threads have executed, these two values are then used to calculate the overall mean. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/interlocked&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/lock_guard&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/literals&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/random&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/startup&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1threading.html">xtd::threading</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>lock_guard_example {</div>
<div class="line">  <span class="keyword">class </span>program {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">      <span class="keyword">auto</span> threads = std::vector&lt;thread&gt; {};</div>
<div class="line">      <span class="keyword">auto</span> rnd = <a class="code hl_class" href="classxtd_1_1random.html">xtd::random</a> {};</div>
<div class="line">      <span class="keyword">auto</span> total = 0_s64;</div>
<div class="line">      <span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a> = 0;</div>
<div class="line">      </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> thread_ctr = 0; thread_ctr &lt; 10; ++thread_ctr)</div>
<div class="line">        threads.push_back(thread::start_new([&amp;] {</div>
<div class="line">          auto values = std::array&lt;int, 10000&gt; {};</div>
<div class="line">          <span class="keyword">auto</span> thread_total = 0;</div>
<div class="line">          <span class="keyword">auto</span> thread_n = 0;</div>
<div class="line">          <span class="keyword">auto</span> ctr = 0;</div>
<div class="line">          <a class="code hl_define" href="group__keywords.html#ga73249a3d4ad48e36724bccf5f3e48f2f">using_</a>(<a class="code hl_class" href="classxtd_1_1threading_1_1lock__guard.html">lock_guard</a> lock {rnd}) {</div>
<div class="line">            <span class="comment">// Generate 10,000 random integers</span></div>
<div class="line">            <span class="keywordflow">for</span> (ctr = 0; ctr &lt; 10000; ++ctr)</div>
<div class="line">              values[ctr] = rnd.next(0, 1001);</div>
<div class="line">          }</div>
<div class="line">          thread_n = ctr;</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keyword">auto</span> value : values)</div>
<div class="line">            thread_total += value;</div>
<div class="line">          </div>
<div class="line">          console::write_line(<span class="stringliteral">&quot;Mean for task {0,2}: {1:N2} (N={2:N0})&quot;</span>,</div>
<div class="line">                              thread::current_thread().managed_thread_id(),</div>
<div class="line">                              (thread_total * 1.0) / thread_n, thread_n);</div>
<div class="line">          interlocked::add(n, thread_n);</div>
<div class="line">          interlocked::add(total, thread_total);</div>
<div class="line">        }));</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a> : threads)</div>
<div class="line">          <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a>.join();</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;\nMean for all tasks: {0:N2} (N={1:N0})&quot;</span>,</div>
<div class="line">                            (total * 1.0)/n, n);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1system__exception.html">system_exception</a>&amp; e) {</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;{0}: {1}&quot;</span>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.get_type().name(), <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.message());</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(lock_guard_example::program::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example produces output similar to the following:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Mean for task  4: 498.90 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  2: 499.92 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  7: 503.12 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  5: 499.41 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  3: 498.58 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  8: 496.71 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task 10: 501.49 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  6: 498.84 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  9: 502.72 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task 11: 498.69 (N=10000)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Mean for all tasks: 499.84 (N=100000)</span></div>
<div class="ttc" id="aclassxtd_1_1random_html"><div class="ttname"><a href="classxtd_1_1random.html">xtd::random</a></div><div class="ttdoc">Represents a pseudo-random number generator, a device that produces a sequence of numbers that meet c...</div><div class="ttdef"><b>Definition</b> random.h:37</div></div>
<div class="ttc" id="aclassxtd_1_1system__exception_html"><div class="ttname"><a href="classxtd_1_1system__exception.html">xtd::system_exception</a></div><div class="ttdoc">Defines the base class for predefined exceptions in the xtd namespace.</div><div class="ttdef"><b>Definition</b> system_exception.h:24</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html">xtd::threading::thread</a></div><div class="ttdoc">Creates and controls a thread, sets its priority, and gets its status.</div><div class="ttdef"><b>Definition</b> thread.h:42</div></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.h:162</div></div>
<div class="ttc" id="agroup__keywords_html_ga73249a3d4ad48e36724bccf5f3e48f2f"><div class="ttname"><a href="group__keywords.html#ga73249a3d4ad48e36724bccf5f3e48f2f">using_</a></div><div class="ttdeci">#define using_(...)</div><div class="ttdoc">The specified expression is cleared automatically when the scope is ended.</div><div class="ttdef"><b>Definition</b> using.h:34</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">xtd::console_key::n</a></div><div class="ttdeci">@ n</div><div class="ttdoc">The N key.</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">xtd::console_key::e</a></div><div class="ttdeci">@ e</div><div class="ttdoc">The E key.</div></div>
<div class="ttc" id="anamespacextd_1_1threading_html"><div class="ttname"><a href="namespacextd_1_1threading.html">xtd::threading</a></div><div class="ttdoc">The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....</div><div class="ttdef"><b>Definition</b> abandoned_mutex_exception.h:10</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> system_report.h:17</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>See <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> for more information. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors</h2></td></tr>
<tr class="memitem:af4f2657650e8d292ff5285b4a360d289"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:af4f2657650e8d292ff5285b4a360d289"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1lock__guard.html#af4f2657650e8d292ff5285b4a360d289">lock_guard</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:af4f2657650e8d292ff5285b4a360d289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a xtd::threaing::lock_guard object and acquires an exclusive lock on the specified obj.  <br /></td></tr>
<tr class="separator:af4f2657650e8d292ff5285b4a360d289"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods</h2></td></tr>
<tr class="memitem:acc1e78b8f74b92ec8c9fd2a8b7f347fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1lock__guard.html#acc1e78b8f74b92ec8c9fd2a8b7f347fb">pulse</a> ()</td></tr>
<tr class="memdesc:acc1e78b8f74b92ec8c9fd2a8b7f347fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a thread in the waiting queue of a change in the locked object's state.  <br /></td></tr>
<tr class="separator:acc1e78b8f74b92ec8c9fd2a8b7f347fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aba512c9a75ac2321c5b766054a1068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1lock__guard.html#a2aba512c9a75ac2321c5b766054a1068">pulse_all</a> ()</td></tr>
<tr class="memdesc:a2aba512c9a75ac2321c5b766054a1068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies all waiting threads of a change in the object's state.  <br /></td></tr>
<tr class="separator:a2aba512c9a75ac2321c5b766054a1068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dc768050a0e500b3e73116dd4a4ed7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1lock__guard.html#ab1dc768050a0e500b3e73116dd4a4ed7">wait</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:ab1dc768050a0e500b3e73116dd4a4ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.  <br /></td></tr>
<tr class="separator:ab1dc768050a0e500b3e73116dd4a4ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f30bcc5c13fcc88f8cf40d567943198"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1lock__guard.html#a7f30bcc5c13fcc88f8cf40d567943198">wait</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a7f30bcc5c13fcc88f8cf40d567943198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.  <br /></td></tr>
<tr class="separator:a7f30bcc5c13fcc88f8cf40d567943198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab175e644396ff4ed80c114c46a911ea4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1lock__guard.html#ab175e644396ff4ed80c114c46a911ea4">wait</a> ()</td></tr>
<tr class="memdesc:ab175e644396ff4ed80c114c46a911ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on an object and blocks the current thread until it reacquires the lock.  <br /></td></tr>
<tr class="separator:ab175e644396ff4ed80c114c46a911ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#aa8027c211754118c30ccf7e52557fd7a">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af734e36ea583a842339d7c4444fb6d86">memberwise_clone</a> () const noexcept</td></tr>
<tr class="memdesc:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sxd::ustring that represents the current object.  <br /></td></tr>
<tr class="separator:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a75cb9ed56172fb088ca6697d5d836b13">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1ee13700465eead7934f450749b952d7">reference_equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af4f2657650e8d292ff5285b4a360d289" name="af4f2657650e8d292ff5285b4a360d289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f2657650e8d292ff5285b4a360d289">&#9670;&#160;</a></span>lock_guard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::lock_guard::lock_guard </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a xtd::threaing::lock_guard object and acquires an exclusive lock on the specified obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the monitor lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When the <a class="el" href="classxtd_1_1threading_1_1lock__guard.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock_guard</a> destroyed it releases the exclusive lock specified in the constructor. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acc1e78b8f74b92ec8c9fd2a8b7f347fb" name="acc1e78b8f74b92ec8c9fd2a8b7f347fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1e78b8f74b92ec8c9fd2a8b7f347fb">&#9670;&#160;</a></span>pulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::lock_guard::pulse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies a thread in the waiting queue of a change in the locked object's state. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only the current owner of the lock can signal a waiting object using <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock. Upon receiving the pulse, the waiting thread is moved to the ready queue. When the thread that invoked <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class does not maintain state indicating that the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method has been called. Thus, if you call <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> when no threads are waiting, the next thread that calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> blocks as if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> had never been called. If two threads are using <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> and <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> to interact, this could result in a deadlock. Contrast this with the behavior of the <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> class: If you signal an <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> by calling its <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c" title="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">xtd::threading::event_wait_handle::set</a> method, and there are no threads waiting, the <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> remains in a signaled state until a thread calls <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87" title="Blocks the current thread until the current xtd::threading::wait_handle receives a signal.">xtd::threading::wait_handle::wait_one</a>, <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a>, or <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a217129669f17b6f14201dccd0405450c" title="Waits for all the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_all</a>. The <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> releases that thread and returns to the unsignaled state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd>
<dd>
The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> methods must be invoked from within a synchronized block of code. </dd>
<dd>
To signal multiple threads, use the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. </dd></dl>

</div>
</div>
<a id="a2aba512c9a75ac2321c5b766054a1068" name="a2aba512c9a75ac2321c5b766054a1068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aba512c9a75ac2321c5b766054a1068">&#9670;&#160;</a></span>pulse_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::lock_guard::pulse_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies all waiting threads of a change in the object's state. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object. After the signal is sent, the waiting threads are moved to the ready queue. When the thread that invoked xtd::threading::monitor::xtd::threading::monitor::pulse_all releases the lock, the next thread in the ready queue acquires the lock. </dd>
<dd>
Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd>
<dd>
The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, xtd::threading::monitor::xtd::threading::monitor::pulse_all, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd>
<dd>
To signal a single thread, use the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method. </dd></dl>

</div>
</div>
<a id="ab175e644396ff4ed80c114c46a911ea4" name="ab175e644396ff4ed80c114c46a911ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab175e644396ff4ed80c114c46a911ea4">&#9670;&#160;</a></span>wait() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::lock_guard::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::synchronization_lock_exception</a></td><td><a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> is not invoked from within a synchronized block of code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method does not return until it reacquires an exclusive lock on the obj parameter. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations. </dd>
<dd>
The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method again. </dd>
<dd>
When a thread calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, or it is the next in the queue and a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. However, if milliseconds_timeout elapses before another thread invokes this object's <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method, the original thread is moved to the ready queue in order to regain the lock. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> is specified for the milliseconds_timeout parameter, this method blocks indefinitely unless the holder of the lock calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>. If milliseconds_timeout equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller executes <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> once, regardless of the number of times <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> on the object and invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> as many times as necessary to restore the saved <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> count for the caller. Calling <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd></dl>

</div>
</div>
<a id="a7f30bcc5c13fcc88f8cf40d567943198" name="a7f30bcc5c13fcc88f8cf40d567943198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f30bcc5c13fcc88f8cf40d567943198">&#9670;&#160;</a></span>wait() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::lock_guard::wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> representing the amount of time to wait before the thread enters the ready queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::synchronization_lock_exception</a></td><td><a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> is not invoked from within a synchronized block of code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method does not return until it reacquires an exclusive lock on the obj parameter. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations. </dd>
<dd>
The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method again. </dd>
<dd>
When a thread calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, or it is the next in the queue and a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. However, if milliseconds_timeout elapses before another thread invokes this object's <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method, the original thread is moved to the ready queue in order to regain the lock. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> is specified for the milliseconds_timeout parameter, this method blocks indefinitely unless the holder of the lock calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>. If milliseconds_timeout equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller executes <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> once, regardless of the number of times <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> on the object and invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> as many times as necessary to restore the saved <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> count for the caller. Calling <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd></dl>

</div>
</div>
<a id="ab1dc768050a0e500b3e73116dd4a4ed7" name="ab1dc768050a0e500b3e73116dd4a4ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dc768050a0e500b3e73116dd4a4ed7">&#9670;&#160;</a></span>wait() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::lock_guard::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to wait. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait before the thread enters the ready queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::synchronization_lock_exception</a></td><td><a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> is not invoked from within a synchronized block of code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method does not return until it reacquires an exclusive lock on the obj parameter. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations. </dd>
<dd>
The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method again. </dd>
<dd>
When a thread calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, or it is the next in the queue and a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. However, if milliseconds_timeout elapses before another thread invokes this object's <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method, the original thread is moved to the ready queue in order to regain the lock. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> is specified for the milliseconds_timeout parameter, this method blocks indefinitely unless the holder of the lock calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>. If milliseconds_timeout equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller executes <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> once, regardless of the number of times <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> on the object and invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> as many times as necessary to restore the saved <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> count for the caller. Calling <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="lock__guard_8h_source.html">lock_guard.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 11 2023 22:09:55 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
