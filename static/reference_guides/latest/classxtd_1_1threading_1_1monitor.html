<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::monitor Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1monitor.html">monitor</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1threading_1_1monitor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::monitor Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">﹡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::monitor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1monitor.png" usemap="#xtd::threading::monitor_map" alt=""/>
  <map id="xtd::threading::monitor_map" name="xtd::threading::monitor_map">
<area href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted)." alt="xtd::static_object" shape="rect" coords="0,0,134,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a mechanism that synchronizes access to objects. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_class" href="classxtd_1_1threading_1_1monitor.html">monitor</a> <a class="code hl_define" href="group__keywords.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1monitor_html"><div class="ttname"><a href="classxtd_1_1threading_1_1monitor.html">xtd::threading::monitor</a></div><div class="ttdoc">Provides a mechanism that synchronizes access to objects.</div><div class="ttdef"><b>Definition</b> monitor.hpp:129</div></div>
<div class="ttc" id="agroup__keywords_html_ga28796443ec37b938df7072c79595e3f6"><div class="ttname"><a href="group__keywords.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div><div class="ttdeci">#define static_</div><div class="ttdoc">This keyword is use to represent a static object. A static object can&#39;t be instantiated (constructors...</div><div class="ttdef"><b>Definition</b> static.hpp:37</div></div>
<div class="ttc" id="agroup__keywords_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.hpp:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted).">xtd::static_object</a> → <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/monitor&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example uses the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class to synchronize access to a single instance of a random number generator represented by the <a class="el" href="classxtd_1_1random.html" title="Represents a pseudo-random number generator, a device that produces a sequence of numbers that meet c...">xtd::random</a> class. The example creates ten threads, each of which executes asynchronously on a thread pool thread. Each thread generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum. After all threads have executed, these two values are then used to calculate the overall mean. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/interlocked&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/monitor&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/random&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/startup&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1threading.html">xtd::threading</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>monitor_example {</div>
<div class="line">  <span class="keyword">class </span>program {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">      <span class="keyword">auto</span> threads = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;thread&gt;</a> {};</div>
<div class="line">      <span class="keyword">auto</span> rnd = <a class="code hl_class" href="classxtd_1_1random.html">xtd::random</a> {};</div>
<div class="line">      <span class="keyword">auto</span> total = 0_s64;</div>
<div class="line">      <span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a> = 0;</div>
<div class="line">      </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> thread_ctr = 0; thread_ctr &lt; 10; ++thread_ctr)</div>
<div class="line">        threads.push_back(<a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a42a6bb9b87bc4bd70c1714a1933711b4">thread::start_new</a>([&amp;] {</div>
<div class="line">          auto values = std::array&lt;int, 10000&gt; {};</div>
<div class="line">          <span class="keyword">auto</span> thread_total = 0;</div>
<div class="line">          <span class="keyword">auto</span> thread_n = 0;</div>
<div class="line">          <span class="keyword">auto</span> ctr = 0;</div>
<div class="line">          <a class="code hl_function" href="#afabaf5361f6d4dd04701dd1973d0a0f9">monitor::enter</a>(rnd);</div>
<div class="line">          <span class="comment">// Generate 10,000 random integers</span></div>
<div class="line">          for (ctr = 0; ctr &lt; 10000; ++ctr)</div>
<div class="line">            values[ctr] = rnd.next(0, 1001);</div>
<div class="line">          <a class="code hl_function" href="#a511fd1ffb8c451222fe4071f7a19f243">monitor::exit</a>(rnd);</div>
<div class="line">          thread_n = ctr;</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keyword">auto</span> value : values)</div>
<div class="line">            thread_total += value;</div>
<div class="line">          </div>
<div class="line">          <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Mean for task {0,2}: {1:N2} (N={2:N0})&quot;</span>,</div>
<div class="line">                              <a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a278b3fabeade100cbc012968115792fd">thread::current_thread</a>().managed_thread_id(),</div>
<div class="line">                              (thread_total * 1.0) / thread_n, thread_n);</div>
<div class="line">          <a class="code hl_function" href="classxtd_1_1threading_1_1interlocked.html#a35d4d7219315784e960dfc7667181f3d">interlocked::add</a>(<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>, thread_n);</div>
<div class="line">          <a class="code hl_function" href="classxtd_1_1threading_1_1interlocked.html#a35d4d7219315784e960dfc7667181f3d">interlocked::add</a>(total, thread_total);</div>
<div class="line">        }));</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a> : threads)</div>
<div class="line">          <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a>.<a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a65fc3f1079b67eb775925c7f1cb69a56">join</a>();</div>
<div class="line">        <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;\nMean for all tasks: {0:N2} (N={1:N0})&quot;</span>,</div>
<div class="line">                            (total * 1.0)/<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">catch</span> (<span class="keyword">const</span> system_exception&amp; e) {</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;{0}: {1}&quot;</span>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.get_type().name(), <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.message());</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(monitor_example::program::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example produces output similar to the following:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Mean for task  4: 498.90 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  2: 499.92 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  7: 503.12 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  5: 499.41 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  3: 498.58 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  8: 496.71 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task 10: 501.49 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  6: 498.84 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  9: 502.72 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task 11: 498.69 (N=10000)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Mean for all tasks: 499.84 (N=100000)</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1list_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a></div><div class="ttdoc">Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...</div><div class="ttdef"><b>Definition</b> list.hpp:79</div></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="aclassxtd_1_1random_html"><div class="ttname"><a href="classxtd_1_1random.html">xtd::random</a></div><div class="ttdoc">Represents a pseudo-random number generator, a device that produces a sequence of numbers that meet c...</div><div class="ttdef"><b>Definition</b> random.hpp:44</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1interlocked_html_a35d4d7219315784e960dfc7667181f3d"><div class="ttname"><a href="classxtd_1_1threading_1_1interlocked.html#a35d4d7219315784e960dfc7667181f3d">xtd::threading::interlocked::add</a></div><div class="ttdeci">static int32 add(int32 &amp;location, int32 value) noexcept</div><div class="ttdoc">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1monitor_html_a511fd1ffb8c451222fe4071f7a19f243"><div class="ttname"><a href="#a511fd1ffb8c451222fe4071f7a19f243">xtd::threading::monitor::exit</a></div><div class="ttdeci">static void exit(const object_t &amp;obj)</div><div class="ttdoc">Releases an exclusive lock on the specified obj.</div><div class="ttdef"><b>Definition</b> monitor.hpp:175</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1monitor_html_afabaf5361f6d4dd04701dd1973d0a0f9"><div class="ttname"><a href="#afabaf5361f6d4dd04701dd1973d0a0f9">xtd::threading::monitor::enter</a></div><div class="ttdeci">static void enter(const object_t &amp;obj)</div><div class="ttdoc">Acquires an exclusive lock on the specified obj.</div><div class="ttdef"><b>Definition</b> monitor.hpp:145</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html">xtd::threading::thread</a></div><div class="ttdoc">Creates and controls a thread, sets its priority, and gets its status.</div><div class="ttdef"><b>Definition</b> thread.hpp:45</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html_a278b3fabeade100cbc012968115792fd"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html#a278b3fabeade100cbc012968115792fd">xtd::threading::thread::current_thread</a></div><div class="ttdeci">static thread &amp; current_thread() noexcept</div><div class="ttdoc">Gets the currently running thread.</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html_a42a6bb9b87bc4bd70c1714a1933711b4"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html#a42a6bb9b87bc4bd70c1714a1933711b4">xtd::threading::thread::start_new</a></div><div class="ttdeci">static thread start_new(const xtd::threading::thread_start &amp;start)</div><div class="ttdoc">Create and immedialtely start a xtd::threading::thread with specified method.</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html_a65fc3f1079b67eb775925c7f1cb69a56"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html#a65fc3f1079b67eb775925c7f1cb69a56">xtd::threading::thread::join</a></div><div class="ttdeci">void join()</div><div class="ttdoc">Blocks the calling thread until this thread object terminates, while continuing to perform standard C...</div></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.hpp:167</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">xtd::console_key::n</a></div><div class="ttdeci">@ n</div><div class="ttdoc">The N key.</div><div class="ttdef"><b>Definition</b> console_key.hpp:114</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">xtd::console_key::e</a></div><div class="ttdeci">@ e</div><div class="ttdoc">The E key.</div><div class="ttdef"><b>Definition</b> console_key.hpp:96</div></div>
<div class="ttc" id="anamespacextd_1_1collections_1_1generic_html"><div class="ttname"><a href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a></div><div class="ttdoc">The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...</div><div class="ttdef"><b>Definition</b> comparer.hpp:16</div></div>
<div class="ttc" id="anamespacextd_1_1threading_html"><div class="ttname"><a href="namespacextd_1_1threading.html">xtd::threading</a></div><div class="ttdoc">The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....</div><div class="ttdef"><b>Definition</b> abandoned_mutex_exception.hpp:10</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> abstract_object.hpp:8</div></div>
</div><!-- fragment --> Because they can be accessed from any task running on a thread pool thread, access to the variables total and n must also be synchronized. The <a class="el" href="classxtd_1_1threading_1_1interlocked.html#a35d4d7219315784e960dfc7667181f3d" title="Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.">xtd::threading::interlocked::add</a> method is used for this purpose. <br  />
<br  />
The following example demonstrates the combined use of the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class (implemented with the <a class="el" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a" title="The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...">lock_</a> keyword), the <a class="el" href="classxtd_1_1threading_1_1interlocked.html" title="Provides atomic operations for variables that are shared by multiple threads.">xtd::threading::interlocked</a> class, and the <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> class. It defines two classes, sync_resource and un_sync_resource, that respectively provide synchronized and unsynchronized access to a resource. To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <a class="el" href="classxtd_1_1threading_1_1thread.html#a5a65a2da3e743b8d710749633e10eacc" title="Gets a unique identifier for the current managed thread.">xtd::threading::thread::managed_thread_id</a> property is even, the method calls <a class="el" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2" title="Suspends the current thread for a specified time.">xtd::threading::thread::sleep</a> to introduce a delay of 2,000 milliseconds. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/auto_reset_event&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/interlocked&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread_pool&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/lock&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/startup&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1threading.html">xtd::threading</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>monitor_lock_example {</div>
<div class="line">  <span class="keyword">class </span>sync_resource : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Use a monitor to enforce synchronization.</span></div>
<div class="line">    <span class="keywordtype">void</span> access() {</div>
<div class="line">      <a class="code hl_define" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a>(*<span class="keyword">this</span>) {</div>
<div class="line">        <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Starting synchronized resource access on thread #{0}&quot;</span>,</div>
<div class="line">                            <a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a278b3fabeade100cbc012968115792fd">thread::current_thread</a>().managed_thread_id());</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a278b3fabeade100cbc012968115792fd">thread::current_thread</a>().managed_thread_id() % 2 == 0)</div>
<div class="line">          <a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2">thread::sleep</a>(2000);</div>
<div class="line">        </div>
<div class="line">        <a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2">thread::sleep</a>(200);</div>
<div class="line">        <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Stopping synchronized resource access on thread #{0}&quot;</span>,</div>
<div class="line">                            <a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a278b3fabeade100cbc012968115792fd">thread::current_thread</a>().managed_thread_id());</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">class </span>un_sync_resource : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Do not enforce synchronization.</span></div>
<div class="line">    <span class="keywordtype">void</span> access() {</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Starting unsynchronized resource access on Thread #{0}&quot;</span>,</div>
<div class="line">                          <a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a278b3fabeade100cbc012968115792fd">thread::current_thread</a>().managed_thread_id());</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a278b3fabeade100cbc012968115792fd">thread::current_thread</a>().managed_thread_id() % 2 == 0)</div>
<div class="line">        <a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2">thread::sleep</a>(2000);</div>
<div class="line">      </div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2">thread::sleep</a>(200);</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Stopping unsynchronized resource access on thread #{0}&quot;</span>,</div>
<div class="line">                          <a class="code hl_function" href="classxtd_1_1threading_1_1thread.html#a278b3fabeade100cbc012968115792fd">thread::current_thread</a>().managed_thread_id());</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">class </span>app {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> num_ops = 0;</div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> auto_reset_event ops_are_done {<span class="keyword">false</span>};</div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> sync_resource sync_res;</div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> un_sync_resource un_sync_res;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">      <span class="comment">// Set the number of synchronized calls.</span></div>
<div class="line">      num_ops = 5;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ctr = 0; ctr &lt;= 4; ++ctr)</div>
<div class="line">        thread_pool::queue_user_work_item(sync_update_resource);</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Wait until this WaitHandle is signaled.</span></div>
<div class="line">      ops_are_done.wait_one();</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;\t\nAll synchronized operations have completed.\n&quot;</span>);</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Reset the count for unsynchronized calls.</span></div>
<div class="line">      num_ops = 5;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ctr = 0; ctr &lt;= 4; ctr++)</div>
<div class="line">        thread_pool::queue_user_work_item(un_sync_update_resource);</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Wait until this WaitHandle is signaled.</span></div>
<div class="line">      ops_are_done.wait_one();</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;\t\nAll unsynchronized thread operations have completed.\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> sync_update_resource(std::any state) {</div>
<div class="line">      <span class="comment">// Call the internal synchronized method.</span></div>
<div class="line">      sync_res.access();</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Ensure that only one thread can decrement the counter at a time.</span></div>
<div class="line">      <span class="keywordflow">if</span> (interlocked::decrement(num_ops) == 0)</div>
<div class="line">        <span class="comment">// Announce to Main that in fact all thread calls are done.</span></div>
<div class="line">        ops_are_done.set();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> un_sync_update_resource(std::any state) {</div>
<div class="line">      <span class="comment">// Call the unsynchronized method.</span></div>
<div class="line">      un_sync_res.access();</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Ensure that only one thread can decrement the counter at a time.</span></div>
<div class="line">      <span class="keywordflow">if</span> (interlocked::decrement(num_ops) == 0)</div>
<div class="line">        <span class="comment">// Announce to Main that in fact all thread calls are done.</span></div>
<div class="line">        ops_are_done.set();</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(monitor_lock_example::app::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example produces output similar to the following:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Starting synchronized resource access on thread #6</span></div>
<div class="line"><span class="comment">// Stopping synchronized resource access on thread #6</span></div>
<div class="line"><span class="comment">// Starting synchronized resource access on thread #9</span></div>
<div class="line"><span class="comment">// Stopping synchronized resource access on thread #9</span></div>
<div class="line"><span class="comment">// Starting synchronized resource access on thread #2</span></div>
<div class="line"><span class="comment">// Stopping synchronized resource access on thread #2</span></div>
<div class="line"><span class="comment">// Starting synchronized resource access on thread #3</span></div>
<div class="line"><span class="comment">// Stopping synchronized resource access on thread #3</span></div>
<div class="line"><span class="comment">// Starting synchronized resource access on thread #8</span></div>
<div class="line"><span class="comment">// Stopping synchronized resource access on thread #8</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// All synchronized operations have completed.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Starting unsynchronized resource access on Thread #9</span></div>
<div class="line"><span class="comment">// Starting unsynchronized resource access on Thread #2</span></div>
<div class="line"><span class="comment">// Starting unsynchronized resource access on Thread #11</span></div>
<div class="line"><span class="comment">// Starting unsynchronized resource access on Thread #6</span></div>
<div class="line"><span class="comment">// Starting unsynchronized resource access on Thread #4</span></div>
<div class="line"><span class="comment">// Stopping unsynchronized resource access on thread #9</span></div>
<div class="line"><span class="comment">// Stopping unsynchronized resource access on thread #11</span></div>
<div class="line"><span class="comment">// Stopping unsynchronized resource access on thread #6</span></div>
<div class="line"><span class="comment">// Stopping unsynchronized resource access on thread #2</span></div>
<div class="line"><span class="comment">// Stopping unsynchronized resource access on thread #4</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// All unsynchronized thread operations have completed.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html_a42bc6e2bb805f928e50ae73d243b95f2"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2">xtd::threading::thread::sleep</a></div><div class="ttdeci">static void sleep(int32 milliseconds_timeout)</div><div class="ttdoc">Suspends the current thread for a specified time.</div></div>
<div class="ttc" id="agroup__keywords_html_gacd9906b29d877eb1eb0a8c7bc4ab774a"><div class="ttname"><a href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a></div><div class="ttdeci">#define lock_(object)</div><div class="ttdoc">The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...</div><div class="ttdef"><b>Definition</b> lock.hpp:85</div></div>
</div><!-- fragment --> The example defines a variable, num_ops, that defines the number of threads that will attempt to access the resource. The application thread calls the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a6e1d511cd1dbe0a07b98128042118f3c" title="Queues a method for execution. The method executes when a thread pool thread becomes available.">xtd::threading::thread_pool::queue_user_work_item</a> method for synchronized and unsynchronized access five times each. The <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a6e1d511cd1dbe0a07b98128042118f3c" title="Queues a method for execution. The method executes when a thread pool thread becomes available.">xtd::threading::thread_pool::queue_user_work_item</a> method has a single parameter, a delegate that accepts no parameters and returns no value. For synchronized access, it invokes the sync_update_resource method; for unsynchronized access, it invokes the un_sync_update_resource method. After each set of method calls, the application thread calls the xtd::thrrading::auto_reset_event::wait_one method so that it blocks until the <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> instance is signaled. <br  />
<br  />
Each call to the sync_update_resource method calls the sync_resource::access method and then calls the <a class="el" href="classxtd_1_1threading_1_1interlocked.html#a87dc180d9e778435f75b8314c2139792" title="Decrements a specified variable and stores the result, as an atomic operation.">xtd::threading::interlocked::decrement</a> method to decrement the num_ops counter. The <a class="el" href="classxtd_1_1threading_1_1interlocked.html#a87dc180d9e778435f75b8314c2139792" title="Decrements a specified variable and stores the result, as an atomic operation.">xtd::threading::interlocked::decrement</a> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable. When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the syncUpdate_resource method calls the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c" title="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">xtd::threading::event_wait_handle::set</a> method, which signals the main thread to continue execution. <br  />
<br  />
Each call to the un_sync_update_resource method calls the un_syncResource::access method and then calls the <a class="el" href="classxtd_1_1threading_1_1interlocked.html#a87dc180d9e778435f75b8314c2139792" title="Decrements a specified variable and stores the result, as an atomic operation.">xtd::threading::interlocked::decrement</a> method to decrement the num_ops counter. Once again, the <a class="el" href="classxtd_1_1threading_1_1interlocked.html#a87dc180d9e778435f75b8314c2139792" title="Decrements a specified variable and stores the result, as an atomic operation.">xtd::threading::interlocked::decrement</a> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable. When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the un_sync_update_resource method calls the <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c" title="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">xtd::threading::event_wait_handle::set</a> method, which signals the main thread to continue execution. <br  />
<br  />
As the output from the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor. On the other hand, without the lock, the un_sync_resource::access method is called in the order in which threads reach it. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a>, <a class="el" href="#a2d6c3abf3a67c1ea400c2c63002ffd1d" title="Attempts to acquire an exclusive lock on the specified object.">xtd::threading::monitor::try_enter</a>, and <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> methods. Object locks provide the ability to restrict access to a block of code, commonly called a critical section. While a thread owns the lock for an object, no other thread can acquire that lock. You can also use the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object. Because the xtd::threading::monotor class has thread affinity, the thread that acquired a lock must release the lock by calling the xtd::threading::monotor::exit method. </dd></dl>
<dl class="section user"><dt>The xtd::threading::monitor class: An overview</dt><dd>xtd::threading::monotor has the following features:<ul>
<li>It is associated with an object on demand.</li>
<li>It is unbound, which means it can be called directly from any context.</li>
<li>An instance of the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class cannot be created; the methods of the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class are all static. Each method is passed the synchronized object that controls access to the critical section. The following table describes the actions that can be taken by threads that access synchronized objects: <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Action   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a>, <a class="el" href="#a2d6c3abf3a67c1ea400c2c63002ffd1d" title="Attempts to acquire an exclusive lock on the specified object.">xtd::threading::monitor::try_enter</a>   </td><td class="markdownTableBodyNone">Acquires a lock for an object. This action also marks the beginning of a critical section. No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>   </td><td class="markdownTableBodyNone">Releases the lock on an object in order to permit other threads to lock and access the object. The calling thread waits while another thread accesses the object. <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> signals are used to notify waiting threads about changes to an object's state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>   </td><td class="markdownTableBodyNone">Sends a signal to one or more waiting threads. The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock. The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object. Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a>   </td><td class="markdownTableBodyNone">Releases the lock on an object. This action also marks the end of a critical section protected by the locked object.   </td></tr>
</table>
There are two sets of overloads for the <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> and <a class="el" href="#a2d6c3abf3a67c1ea400c2c63002ffd1d" title="Attempts to acquire an exclusive lock on the specified object.">xtd::threading::monitor::try_enter</a> methods. One set of overloads has a boolean parameter that is atomically set to <code>true</code> if the lock is acquired, even if an exception is thrown when acquiring the lock. Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>The lock object</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class consists of static methods that operate on an object that controls access to the critical section. The following information is maintained for each synchronized object:<ul>
<li>A reference to the thread that currently holds the lock.</li>
<li>A reference to a ready queue, which contains the threads that are ready to obtain the lock.</li>
<li>A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>The critical section</dt><dd>Use the <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> and <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> methods to mark the beginning and end of a critical section. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The functionality provided by the <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> and <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> methods is identical to that provided by the <a class="el" href="classxtd_1_1threading_1_1lock__guard.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock_guard</a> object and the <a class="el" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a" title="The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...">lock_</a> keyword, except that with the xtd class: :<a class="el" href="classxtd_1_1threading_1_1lock__guard.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">threading::lock_guard</a> class and the <a class="el" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a" title="The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...">lock_</a> keyword, the <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> method and the <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> method are always called, even if an exception has occurred. </dd>
<dd>
It is therefore advisable to use the <a class="el" href="classxtd_1_1threading_1_1lock__guard.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock_guard</a> class or the <a class="el" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a" title="The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...">lock_</a> keyword instead of calling the <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> and <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> methods, to ensure that no critical sections remain in the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class. </dd></dl>
<dl class="section user"><dt></dt><dd>The folowing code shows the use use of xtd:threading::<a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">monitor::enter</a> and xtd:threading::<a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">monitor::exit</a> when an exception occured : <div class="fragment"><div class="line"><span class="comment">// Define the lock object.</span></div>
<div class="line"><span class="keyword">auto</span> obj = <span class="keywordtype">object</span> {};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  <span class="comment">// Define the critical section.</span></div>
<div class="line">  <a class="code hl_function" href="#afabaf5361f6d4dd04701dd1973d0a0f9">monitor::enter</a>(obj);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Code to execute one thread at a time.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Define the end of the critical section.</span></div>
<div class="line">  <a class="code hl_function" href="#a511fd1ffb8c451222fe4071f7a19f243">monitor::exit</a>(obj);</div>
<div class="line">} <span class="keywordflow">catch</span>(...) {</div>
<div class="line">  <span class="comment">// You also need to define the end of the critical section.</span></div>
<div class="line">  <a class="code hl_function" href="#a511fd1ffb8c451222fe4071f7a19f243">monitor::exit</a>(obj);</div>
<div class="line">}</div>
</div><!-- fragment --> <br  />
The same code with the <a class="el" href="classxtd_1_1threading_1_1lock__guard.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock_guard</a> class : <div class="fragment"><div class="line"><span class="comment">// Define the lock object.</span></div>
<div class="line"><span class="keyword">auto</span> obj = <span class="keywordtype">object</span> {};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  <span class="comment">// Define the critical section.</span></div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1threading_1_1lock__guard.html">lock_guard</a> <a class="code hl_typedef" href="group__threading.html#ga69b2e366d61bebf3fd9e94f83d51eb77">lock</a> {obj};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Code to execute one thread at a time.</span></div>
<div class="line"> </div>
<div class="line">} <span class="keywordflow">catch</span>(...) {</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclassxtd_1_1threading_1_1lock__guard_html"><div class="ttname"><a href="classxtd_1_1threading_1_1lock__guard.html">xtd::threading::lock_guard</a></div><div class="ttdoc">Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.</div><div class="ttdef"><b>Definition</b> lock_guard.hpp:32</div></div>
<div class="ttc" id="agroup__threading_html_ga69b2e366d61bebf3fd9e94f83d51eb77"><div class="ttname"><a href="group__threading.html#ga69b2e366d61bebf3fd9e94f83d51eb77">xtd::lock</a></div><div class="ttdeci">xtd::threading::lock_guard lock</div><div class="ttdoc">Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.</div><div class="ttdef"><b>Definition</b> lock.hpp:22</div></div>
</div><!-- fragment --> <br  />
The same code with the <a class="el" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a" title="The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...">lock_</a> keyword : <div class="fragment"><div class="line"><span class="comment">// Define the lock object.</span></div>
<div class="line"><span class="keyword">auto</span> obj = <span class="keywordtype">object</span> {};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  <span class="comment">// Define the critical section.</span></div>
<div class="line">  <a class="code hl_define" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a>(obj) {</div>
<div class="line">    <span class="comment">// Code to execute one thread at a time.</span></div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">catch</span>(...) {</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>pulse, pulse_all, and wait</dt><dd>Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, and <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> methods. <br  />
<br  />
When the thread that holds the lock calls <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, the lock is released and the thread is added to the waiting queue of the synchronized object. The first thread in the ready queue, if any, acquires the lock and enters the critical section. The thread that called Wait is moved from the waiting queue to the ready queue when either the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or the <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method is called by the thread that holds the lock (to be moved, the thread must be at the head of the waiting queue). The <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method returns when the calling thread reacquires the lock. <br  />
<br  />
When the thread that holds the lock calls <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, the thread at the head of the waiting queue is moved to the ready queue. The call to the <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method moves all the threads from the waiting queue to the ready queue. </dd></dl>
<dl class="section user"><dt>Monitors and wait handles</dt><dd>It is important to note the distinction between the use of the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class and <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> objects.<ul>
<li>The <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</li>
<li><a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once. </li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:afabaf5361f6d4dd04701dd1973d0a0f9" id="r_afabaf5361f6d4dd04701dd1973d0a0f9"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:afabaf5361f6d4dd04701dd1973d0a0f9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9">enter</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:afabaf5361f6d4dd04701dd1973d0a0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires an exclusive lock on the specified obj.  <br /></td></tr>
<tr class="separator:afabaf5361f6d4dd04701dd1973d0a0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad2ab8bb155091207b7d5ad4ff1280c" id="r_afad2ab8bb155091207b7d5ad4ff1280c"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:afad2ab8bb155091207b7d5ad4ff1280c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afad2ab8bb155091207b7d5ad4ff1280c">enter</a> (const object_t &amp;obj, bool &amp;lock_taken)</td></tr>
<tr class="memdesc:afad2ab8bb155091207b7d5ad4ff1280c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires an exclusive lock on the specified obj.  <br /></td></tr>
<tr class="separator:afad2ab8bb155091207b7d5ad4ff1280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511fd1ffb8c451222fe4071f7a19f243" id="r_a511fd1ffb8c451222fe4071f7a19f243"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a511fd1ffb8c451222fe4071f7a19f243"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243">exit</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:a511fd1ffb8c451222fe4071f7a19f243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an exclusive lock on the specified obj.  <br /></td></tr>
<tr class="separator:a511fd1ffb8c451222fe4071f7a19f243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bbf98eb3c316c3ca6db252d41ff57e" id="r_a53bbf98eb3c316c3ca6db252d41ff57e"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a53bbf98eb3c316c3ca6db252d41ff57e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53bbf98eb3c316c3ca6db252d41ff57e">is_entered</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:a53bbf98eb3c316c3ca6db252d41ff57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the current thread holds the lock on the specified object.  <br /></td></tr>
<tr class="separator:a53bbf98eb3c316c3ca6db252d41ff57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02075512c6dc3fb73840910466cca815" id="r_a02075512c6dc3fb73840910466cca815"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a02075512c6dc3fb73840910466cca815"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02075512c6dc3fb73840910466cca815">pulse</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:a02075512c6dc3fb73840910466cca815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a thread in the waiting queue of a change in the locked object's state.  <br /></td></tr>
<tr class="separator:a02075512c6dc3fb73840910466cca815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362df17ae1c2d6e99ae2d272805c2dcb" id="r_a362df17ae1c2d6e99ae2d272805c2dcb"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a362df17ae1c2d6e99ae2d272805c2dcb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb">pulse_all</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:a362df17ae1c2d6e99ae2d272805c2dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies all waiting threads of a change in the object's state.  <br /></td></tr>
<tr class="separator:a362df17ae1c2d6e99ae2d272805c2dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6c3abf3a67c1ea400c2c63002ffd1d" id="r_a2d6c3abf3a67c1ea400c2c63002ffd1d"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a2d6c3abf3a67c1ea400c2c63002ffd1d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d6c3abf3a67c1ea400c2c63002ffd1d">try_enter</a> (const object_t &amp;obj) noexcept</td></tr>
<tr class="memdesc:a2d6c3abf3a67c1ea400c2c63002ffd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a2d6c3abf3a67c1ea400c2c63002ffd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3e78c724e33a7573d95e7c262961e" id="r_afbb3e78c724e33a7573d95e7c262961e"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:afbb3e78c724e33a7573d95e7c262961e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbb3e78c724e33a7573d95e7c262961e">try_enter</a> (const object_t &amp;obj, bool &amp;lock_taken) noexcept</td></tr>
<tr class="memdesc:afbb3e78c724e33a7573d95e7c262961e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:afbb3e78c724e33a7573d95e7c262961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e596d515e48f52e357ee7b87b258048" id="r_a7e596d515e48f52e357ee7b87b258048"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a7e596d515e48f52e357ee7b87b258048"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e596d515e48f52e357ee7b87b258048">try_enter</a> (const object_t &amp;obj, <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a> milliseconds_timeout) noexcept</td></tr>
<tr class="memdesc:a7e596d515e48f52e357ee7b87b258048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a7e596d515e48f52e357ee7b87b258048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebb588113749b4905385f1c40b8b383" id="r_a3ebb588113749b4905385f1c40b8b383"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a3ebb588113749b4905385f1c40b8b383"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ebb588113749b4905385f1c40b8b383">try_enter</a> (const object_t &amp;obj, <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a> milliseconds_timeout, bool &amp;lock_taken) noexcept</td></tr>
<tr class="memdesc:a3ebb588113749b4905385f1c40b8b383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a3ebb588113749b4905385f1c40b8b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6f9c0d2fb7cd11d4fad2c1750a1bb7" id="r_afd6f9c0d2fb7cd11d4fad2c1750a1bb7"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:afd6f9c0d2fb7cd11d4fad2c1750a1bb7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd6f9c0d2fb7cd11d4fad2c1750a1bb7">try_enter</a> (const object_t &amp;obj, <a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">int64</a> milliseconds_timeout) noexcept</td></tr>
<tr class="memdesc:afd6f9c0d2fb7cd11d4fad2c1750a1bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:afd6f9c0d2fb7cd11d4fad2c1750a1bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbf60d0c81756e2c34d1dc5336dc31c" id="r_a2bbf60d0c81756e2c34d1dc5336dc31c"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a2bbf60d0c81756e2c34d1dc5336dc31c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2bbf60d0c81756e2c34d1dc5336dc31c">try_enter</a> (const object_t &amp;obj, <a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">int64</a> milliseconds_timeout, bool &amp;lock_taken) noexcept</td></tr>
<tr class="memdesc:a2bbf60d0c81756e2c34d1dc5336dc31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a2bbf60d0c81756e2c34d1dc5336dc31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9c4422ca36bc1af1de59aa68c5e795" id="r_a2f9c4422ca36bc1af1de59aa68c5e795"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a2f9c4422ca36bc1af1de59aa68c5e795"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f9c4422ca36bc1af1de59aa68c5e795">try_enter</a> (const object_t &amp;obj, const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>) noexcept</td></tr>
<tr class="memdesc:a2f9c4422ca36bc1af1de59aa68c5e795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a2f9c4422ca36bc1af1de59aa68c5e795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02a91612d5aff072456943c35716549" id="r_aa02a91612d5aff072456943c35716549"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:aa02a91612d5aff072456943c35716549"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa02a91612d5aff072456943c35716549">try_enter</a> (const object_t &amp;obj, const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>, bool &amp;lock_taken) noexcept</td></tr>
<tr class="memdesc:aa02a91612d5aff072456943c35716549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:aa02a91612d5aff072456943c35716549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd63dcb3bbf83741c9bdfe9f6d074b8d" id="r_acd63dcb3bbf83741c9bdfe9f6d074b8d"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:acd63dcb3bbf83741c9bdfe9f6d074b8d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d">wait</a> (const object_t &amp;obj, <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:acd63dcb3bbf83741c9bdfe9f6d074b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.  <br /></td></tr>
<tr class="separator:acd63dcb3bbf83741c9bdfe9f6d074b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7c9a4617cb310ee2027ffa125f3021" id="r_a3e7c9a4617cb310ee2027ffa125f3021"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a3e7c9a4617cb310ee2027ffa125f3021"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e7c9a4617cb310ee2027ffa125f3021">wait</a> (const object_t &amp;obj, const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a3e7c9a4617cb310ee2027ffa125f3021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.  <br /></td></tr>
<tr class="separator:a3e7c9a4617cb310ee2027ffa125f3021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3a658dbdaf189b220095f17a1f3acd" id="r_a3e3a658dbdaf189b220095f17a1f3acd"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a3e3a658dbdaf189b220095f17a1f3acd"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e3a658dbdaf189b220095f17a1f3acd">wait</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:a3e3a658dbdaf189b220095f17a1f3acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on an object and blocks the current thread until it reacquires the lock.  <br /></td></tr>
<tr class="separator:a3e3a658dbdaf189b220095f17a1f3acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afabaf5361f6d4dd04701dd1973d0a0f9" name="afabaf5361f6d4dd04701dd1973d0a0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabaf5361f6d4dd04701dd1973d0a0f9">&#9670;&#160;</a></span>enter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires an exclusive lock on the specified obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the monitor lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use xtd::threading::monotor::enter to acquire the xtd::threading::monotor on the object passed as the parameter. If another thread has executed an xtd::threading::monotor::enter on the object, but has not yet executed the corresponding <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a>, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke xtd::threading::monotor::enter more than once without it blocking; however, an equal number of <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> calls must be invoked before other threads waiting on the object will unblock. </dd></dl>

</div>
</div>
<a id="afad2ab8bb155091207b7d5ad4ff1280c" name="afad2ab8bb155091207b7d5ad4ff1280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad2ab8bb155091207b7d5ad4ff1280c">&#9670;&#160;</a></span>enter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>lock_taken</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires an exclusive lock on the specified obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the monitor lock. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be <code>false</code>. The output is <code>true</code> if the lock is acquired; otherwise, the output is <code>false</code>. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always <code>true</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use xtd::threading::monotor::enter to acquire the xtd::threading::monotor on the object passed as the parameter. If another thread has executed an xtd::threading::monotor::enter on the object, but has not yet executed the corresponding <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a>, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke xtd::threading::monotor::enter more than once without it blocking; however, an equal number of <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> calls must be invoked before other threads waiting on the object will unblock. </dd></dl>

</div>
</div>
<a id="a511fd1ffb8c451222fe4071f7a19f243" name="a511fd1ffb8c451222fe4071f7a19f243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511fd1ffb8c451222fe4071f7a19f243">&#9670;&#160;</a></span>exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::exit </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases an exclusive lock on the specified obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to release the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The calling thread must own the lock on the obj parameter. If the calling thread owns the lock on the specified object, and has made an equal number of <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> and xtd::threading::monotor::enter calls for the object, then the lock is released. If the calling thread has not invoked <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as xtd::threading::monotor::enter, the lock is not released. </dd>
<dd>
If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock. If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a>. To move one or more waiting threads into the ready queue, call <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::xtd::threading::monitor::pulse_all</a> before invoking <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a>. </dd></dl>

</div>
</div>
<a id="a53bbf98eb3c316c3ca6db252d41ff57e" name="a53bbf98eb3c316c3ca6db252d41ff57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bbf98eb3c316c3ca6db252d41ff57e">&#9670;&#160;</a></span>is_entered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::is_entered </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the current thread holds the lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current thread holds the lock on obj; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method works only for locks that are acquired by using the methods of the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class, or the <a class="el" href="classxtd_1_1threading_1_1lock__guard.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock_guard</a> class, or by using the <a class="el" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a" title="The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...">lock_</a> keyword, which are implemented with <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a>. </dd>
<dd>
Use this method with diagnostic tools, such as the xtd::diagnostics::debug::assert method, to debug locking issues that involve the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class. </dd></dl>

</div>
</div>
<a id="a02075512c6dc3fb73840910466cca815" name="a02075512c6dc3fb73840910466cca815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02075512c6dc3fb73840910466cca815">&#9670;&#160;</a></span>pulse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::pulse </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a thread in the waiting queue of a change in the locked object's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object a thread is waiting for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td>The calling thread does not own the lock for the specified object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only the current owner of the lock can signal a waiting object using <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock. Upon receiving the pulse, the waiting thread is moved to the ready queue. When the thread that invoked <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class does not maintain state indicating that the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method has been called. Thus, if you call <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> when no threads are waiting, the next thread that calls <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> blocks as if <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> had never been called. If two threads are using <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> and <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> to interact, this could result in a deadlock. Contrast this with the behavior of the <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> class: If you signal an <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> by calling its <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c" title="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">xtd::threading::event_wait_handle::set</a> method, and there are no threads waiting, the <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> remains in a signaled state until a thread calls <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87" title="Blocks the current thread until the current xtd::threading::wait_handle receives a signal.">xtd::threading::wait_handle::wait_one</a>, <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a>, or <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a217129669f17b6f14201dccd0405450c" title="Waits for all the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_all</a>. The <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> releases that thread and returns to the unsignaled state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd>
<dd>
The <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> methods must be invoked from within a synchronized block of code. </dd>
<dd>
To signal multiple threads, use the <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. </dd></dl>

</div>
</div>
<a id="a362df17ae1c2d6e99ae2d272805c2dcb" name="a362df17ae1c2d6e99ae2d272805c2dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362df17ae1c2d6e99ae2d272805c2dcb">&#9670;&#160;</a></span>pulse_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::pulse_all </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies all waiting threads of a change in the object's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object a thread is waiting for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td>The calling thread does not own the lock for the specified object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object. After the signal is sent, the waiting threads are moved to the ready queue. When the thread that invoked <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::xtd::threading::monitor::pulse_all</a> releases the lock, the next thread in the ready queue acquires the lock. </dd>
<dd>
Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd>
<dd>
The <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd>
<dd>
To signal a single thread, use the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method. </dd></dl>

</div>
</div>
<a id="a2d6c3abf3a67c1ea400c2c63002ffd1d" name="a2d6c3abf3a67c1ea400c2c63002ffd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6c3abf3a67c1ea400c2c63002ffd1d">&#9670;&#160;</a></span>try_enter() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if the current thread acquires the lock; otherwise, <code>false</code> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If successful, this method acquires an exclusive lock on the obj parameter. This method returns immediately, whether or not the lock is available. </dd>
<dd>
This method is similar to xtd::threading::monotor::enter, but it will never block. If the thread cannot enter without blocking, the method returns <code>false</code>, and the thread does not enter the critical section. </dd></dl>

</div>
</div>
<a id="afbb3e78c724e33a7573d95e7c262961e" name="afbb3e78c724e33a7573d95e7c262961e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb3e78c724e33a7573d95e7c262961e">&#9670;&#160;</a></span>try_enter() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>lock_taken</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be <code>false</code>. The output is <code>true</code> if the lock is acquired; otherwise, the output is <code>false</code>. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always <code>true</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if the current thread acquires the lock; otherwise, <code>false</code> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If successful, this method acquires an exclusive lock on the obj parameter. This method returns immediately, whether or not the lock is available. </dd>
<dd>
This method is similar to xtd::threading::monotor::enter, but it will never block. If the thread cannot enter without blocking, the method returns <code>false</code>, and the thread does not enter the critical section. </dd></dl>

</div>
</div>
<a id="a7e596d515e48f52e357ee7b87b258048" name="a7e596d515e48f52e357ee7b87b258048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e596d515e48f52e357ee7b87b258048">&#9670;&#160;</a></span>try_enter() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if the current thread acquires the lock; otherwise, <code>false</code> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the milliseconds_timeout parameter equals Timeout::Infinite, this method is equivalent to xtd::threading::monotor::enter. If milliseconds_timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="a3ebb588113749b4905385f1c40b8b383" name="a3ebb588113749b4905385f1c40b8b383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebb588113749b4905385f1c40b8b383">&#9670;&#160;</a></span>try_enter() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>lock_taken</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the lock. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be <code>false</code>. The output is <code>true</code> if the lock is acquired; otherwise, the output is <code>false</code>. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always <code>true</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if the current thread acquires the lock; otherwise, <code>false</code> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the milliseconds_timeout parameter equals Timeout::Infinite, this method is equivalent to xtd::threading::monotor::enter. If milliseconds_timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="afd6f9c0d2fb7cd11d4fad2c1750a1bb7" name="afd6f9c0d2fb7cd11d4fad2c1750a1bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6f9c0d2fb7cd11d4fad2c1750a1bb7">&#9670;&#160;</a></span>try_enter() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">int64</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if the current thread acquires the lock; otherwise, <code>false</code> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the milliseconds_timeout parameter equals Timeout::Infinite, this method is equivalent to xtd::threading::monotor::enter. If milliseconds_timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="a2bbf60d0c81756e2c34d1dc5336dc31c" name="a2bbf60d0c81756e2c34d1dc5336dc31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbf60d0c81756e2c34d1dc5336dc31c">&#9670;&#160;</a></span>try_enter() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">int64</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>lock_taken</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the lock. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be <code>false</code>. The output is <code>true</code> if the lock is acquired; otherwise, the output is <code>false</code>. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always <code>true</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if the current thread acquires the lock; otherwise, <code>false</code> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the milliseconds_timeout parameter equals Timeout::Infinite, this method is equivalent to xtd::threading::monotor::enter. If milliseconds_timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="a2f9c4422ca36bc1af1de59aa68c5e795" name="a2f9c4422ca36bc1af1de59aa68c5e795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9c4422ca36bc1af1de59aa68c5e795">&#9670;&#160;</a></span>try_enter() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="classxtd_1_1time__span.html" title="Represents a time interval.">time_span</a> representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if the current thread acquires the lock; otherwise, <code>false</code> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the value of the timeout parameter converted to milliseconds equals -1, this method is equivalent to xtd::threading::monotor::enter. If the value of timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="aa02a91612d5aff072456943c35716549" name="aa02a91612d5aff072456943c35716549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02a91612d5aff072456943c35716549">&#9670;&#160;</a></span>try_enter() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>lock_taken</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="classxtd_1_1time__span.html" title="Represents a time interval.">time_span</a> representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be <code>false</code>. The output is <code>true</code> if the lock is acquired; otherwise, the output is <code>false</code>. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always <code>true</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if the current thread acquires the lock; otherwise, <code>false</code> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the value of the timeout parameter converted to milliseconds equals -1, this method is equivalent to xtd::threading::monotor::enter. If the value of timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="acd63dcb3bbf83741c9bdfe9f6d074b8d" name="acd63dcb3bbf83741c9bdfe9f6d074b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd63dcb3bbf83741c9bdfe9f6d074b8d">&#9670;&#160;</a></span>wait() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::wait </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to wait. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait before the thread enters the ready queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock was reacquired before the specified time elapsed; <code>false</code> if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td><a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> is not invoked from within a synchronized block of code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method does not return until it reacquires an exclusive lock on the obj parameter. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations. </dd>
<dd>
The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method again. </dd>
<dd>
When a thread calls <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, or it is the next in the queue and a thread that holds the lock invokes <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. However, if milliseconds_timeout elapses before another thread invokes this object's <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method, the original thread is moved to the ready queue in order to regain the lock. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> is specified for the milliseconds_timeout parameter, this method blocks indefinitely unless the holder of the lock calls <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>. If milliseconds_timeout equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller executes <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> once, regardless of the number of times <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> on the object and invokes <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> as many times as necessary to restore the saved <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> count for the caller. Calling <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd></dl>

</div>
</div>
<a id="a3e7c9a4617cb310ee2027ffa125f3021" name="a3e7c9a4617cb310ee2027ffa125f3021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7c9a4617cb310ee2027ffa125f3021">&#9670;&#160;</a></span>wait() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::wait </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to wait. </td></tr>
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="classxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> representing the amount of time to wait before the thread enters the ready queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock was reacquired before the specified time elapsed; <code>false</code> if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td><a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> is not invoked from within a synchronized block of code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method does not return until it reacquires an exclusive lock on the obj parameter. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations. </dd>
<dd>
The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method again. </dd>
<dd>
When a thread calls <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, or it is the next in the queue and a thread that holds the lock invokes <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. However, if milliseconds_timeout elapses before another thread invokes this object's <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method, the original thread is moved to the ready queue in order to regain the lock. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> is specified for the milliseconds_timeout parameter, this method blocks indefinitely unless the holder of the lock calls <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>. If milliseconds_timeout equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller executes <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> once, regardless of the number of times <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> on the object and invokes <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> as many times as necessary to restore the saved <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> count for the caller. Calling <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd></dl>

</div>
</div>
<a id="a3e3a658dbdaf189b220095f17a1f3acd" name="a3e3a658dbdaf189b220095f17a1f3acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3a658dbdaf189b220095f17a1f3acd">&#9670;&#160;</a></span>wait() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::wait </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td><a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> is not invoked from within a synchronized block of code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method does not return until it reacquires an exclusive lock on the obj parameter. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations. </dd>
<dd>
The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method again. </dd>
<dd>
When a thread calls <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, or it is the next in the queue and a thread that holds the lock invokes <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. However, if milliseconds_timeout elapses before another thread invokes this object's <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method, the original thread is moved to the ready queue in order to regain the lock. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> is specified for the milliseconds_timeout parameter, this method blocks indefinitely unless the holder of the lock calls <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>. If milliseconds_timeout equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller executes <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> once, regardless of the number of times <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> on the object and invokes <a class="el" href="#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> as many times as necessary to restore the saved <a class="el" href="#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> count for the caller. Calling <a class="el" href="#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="monitor_8hpp_source.html">monitor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 2 2025 10:21:54 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
