<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::collections::generic::list&lt; type_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections.html">collections</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections_1_1generic.html">generic</a></li><li class="navelem"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1collections_1_1generic_1_1list-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::collections::generic::list&lt; type_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__collections.html">collections</a> &raquo; <a class="el" href="group__generic__collections.html">generic</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::collections::generic::list&lt; type_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1collections_1_1generic_1_1list.png" usemap="#xtd::collections::generic::list_3C_20type_5Ft_20_3E_map" alt=""/>
  <map id="xtd::collections::generic::list_3C_20type_5Ft_20_3E_map" name="xtd::collections::generic::list_3C_20type_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,222,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename type_t&gt;<br />
class xtd::collections::generic::list&lt; type_t &gt;</div><p>Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and manipulate lists. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_t&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a>, xtd::collections::generic::icollection&lt;type_t&gt;, xtd::collections::generic::ienumerable&lt;type_t&gt;, xtd::collections::generic::ilist&lt;type_t&gt;</div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1list_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a></div><div class="ttdoc">Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...</div><div class="ttdef"><b>Definition</b> list.h:33</div></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.h:40</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/list</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1collections_1_1generic.html" title="The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...">xtd::collections::generic</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> class instanciate as <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763" title="Represents the list base type.">xtd::collections::generic::list::base_type</a> a <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a> with <a class="el" href="group__helpers__generic__collections.html#gac7dc24539787a344466014161f2d39af" title="Represent an allocator alias.">xtd::collections::generic::helpers::allocator</a> instead <a href="https://en.cppreference.com/w/cpp/memory/allocator">std::allocator</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="action_8cpp-example.html#_a0">action.cpp</a>, <a class="el" href="animation_8cpp-example.html#_a3">animation.cpp</a>, <a class="el" href="array_list_8cpp-example.html#_a0">array_list.cpp</a>, <a class="el" href="array_list2_8cpp-example.html#_a0">array_list2.cpp</a>, <a class="el" href="assert_does_not_throw_8cpp-example.html#_a1">assert_does_not_throw.cpp</a>, <a class="el" href="assert_throws_8cpp-example.html#_a1">assert_throws.cpp</a>, <a class="el" href="assert_throws_any_8cpp-example.html#_a1">assert_throws_any.cpp</a>, <a class="el" href="assume_does_not_throw_8cpp-example.html#_a1">assume_does_not_throw.cpp</a>, <a class="el" href="assume_throws_8cpp-example.html#_a1">assume_throws.cpp</a>, <a class="el" href="assume_throws_any_8cpp-example.html#_a1">assume_throws_any.cpp</a>, <a class="el" href="auto_reset_event_8cpp-example.html#_a1">auto_reset_event.cpp</a>, <a class="el" href="border_style_8cpp-example.html#_a8">border_style.cpp</a>, <a class="el" href="boxing_8cpp-example.html#_a1">boxing.cpp</a>, <a class="el" href="calculator_8cpp-example.html#_a5">calculator.cpp</a>, <a class="el" href="collection_assert_8cpp-example.html#_a1">collection_assert.cpp</a>, <a class="el" href="collection_assert_all_items_are_instances_of_8cpp-example.html#_a1">collection_assert_all_items_are_instances_of.cpp</a>, <a class="el" href="collection_assert_all_items_are_not_null_8cpp-example.html#_a1">collection_assert_all_items_are_not_null.cpp</a>, <a class="el" href="collection_assert_all_items_are_unique_8cpp-example.html#_a1">collection_assert_all_items_are_unique.cpp</a>, <a class="el" href="collection_assert_are_equal_8cpp-example.html#_a1">collection_assert_are_equal.cpp</a>, <a class="el" href="collection_assert_are_equivalent_8cpp-example.html#_a1">collection_assert_are_equivalent.cpp</a>, <a class="el" href="collection_assert_are_not_equal_8cpp-example.html#_a1">collection_assert_are_not_equal.cpp</a>, <a class="el" href="collection_assert_are_not_equivalent_8cpp-example.html#_a1">collection_assert_are_not_equivalent.cpp</a>, <a class="el" href="collection_assert_contains_8cpp-example.html#_a1">collection_assert_contains.cpp</a>, <a class="el" href="collection_assert_does_not_contain_8cpp-example.html#_a1">collection_assert_does_not_contain.cpp</a>, <a class="el" href="collection_assert_is_empty_8cpp-example.html#_a1">collection_assert_is_empty.cpp</a>, <a class="el" href="collection_assert_is_not_empty_8cpp-example.html#_a1">collection_assert_is_not_empty.cpp</a>, <a class="el" href="collection_assert_is_ordered_8cpp-example.html#_a1">collection_assert_is_ordered.cpp</a>, <a class="el" href="collection_assume_8cpp-example.html#_a1">collection_assume.cpp</a>, <a class="el" href="collection_assume_all_items_are_instances_of_8cpp-example.html#_a1">collection_assume_all_items_are_instances_of.cpp</a>, <a class="el" href="collection_assume_all_items_are_not_null_8cpp-example.html#_a1">collection_assume_all_items_are_not_null.cpp</a>, <a class="el" href="collection_assume_all_items_are_unique_8cpp-example.html#_a1">collection_assume_all_items_are_unique.cpp</a>, <a class="el" href="collection_assume_are_equal_8cpp-example.html#_a1">collection_assume_are_equal.cpp</a>, <a class="el" href="collection_assume_are_equivalent_8cpp-example.html#_a1">collection_assume_are_equivalent.cpp</a>, <a class="el" href="collection_assume_are_not_equal_8cpp-example.html#_a1">collection_assume_are_not_equal.cpp</a>, <a class="el" href="collection_assume_are_not_equivalent_8cpp-example.html#_a1">collection_assume_are_not_equivalent.cpp</a>, <a class="el" href="collection_assume_contains_8cpp-example.html#_a1">collection_assume_contains.cpp</a>, <a class="el" href="collection_assume_does_not_contain_8cpp-example.html#_a1">collection_assume_does_not_contain.cpp</a>, <a class="el" href="collection_assume_is_empty_8cpp-example.html#_a1">collection_assume_is_empty.cpp</a>, <a class="el" href="collection_assume_is_not_empty_8cpp-example.html#_a1">collection_assume_is_not_empty.cpp</a>, <a class="el" href="collection_assume_is_ordered_8cpp-example.html#_a1">collection_assume_is_ordered.cpp</a>, <a class="el" href="collection_valid_8cpp-example.html#_a1">collection_valid.cpp</a>, <a class="el" href="collection_valid_all_items_are_instances_of_8cpp-example.html#_a1">collection_valid_all_items_are_instances_of.cpp</a>, <a class="el" href="collection_valid_all_items_are_not_null_8cpp-example.html#_a1">collection_valid_all_items_are_not_null.cpp</a>, <a class="el" href="collection_valid_all_items_are_unique_8cpp-example.html#_a1">collection_valid_all_items_are_unique.cpp</a>, <a class="el" href="collection_valid_are_equal_8cpp-example.html#_a1">collection_valid_are_equal.cpp</a>, <a class="el" href="collection_valid_are_equivalent_8cpp-example.html#_a1">collection_valid_are_equivalent.cpp</a>, <a class="el" href="collection_valid_are_not_equal_8cpp-example.html#_a1">collection_valid_are_not_equal.cpp</a>, <a class="el" href="collection_valid_are_not_equivalent_8cpp-example.html#_a1">collection_valid_are_not_equivalent.cpp</a>, <a class="el" href="collection_valid_contains_8cpp-example.html#_a1">collection_valid_contains.cpp</a>, <a class="el" href="collection_valid_does_not_contain_8cpp-example.html#_a1">collection_valid_does_not_contain.cpp</a>, <a class="el" href="collection_valid_is_empty_8cpp-example.html#_a1">collection_valid_is_empty.cpp</a>, <a class="el" href="collection_valid_is_not_empty_8cpp-example.html#_a1">collection_valid_is_not_empty.cpp</a>, <a class="el" href="collection_valid_is_ordered_8cpp-example.html#_a1">collection_valid_is_ordered.cpp</a>, <a class="el" href="colored_forms_8cpp-example.html#_a0">colored_forms.cpp</a>, <a class="el" href="colored_tab_pages_8cpp-example.html#_a8">colored_tab_pages.cpp</a>, <a class="el" href="console_clear_8cpp-example.html#_a0">console_clear.cpp</a>, <a class="el" href="console_color2_8cpp-example.html#_a0">console_color2.cpp</a>, <a class="el" href="console_color3_8cpp-example.html#_a0">console_color3.cpp</a>, <a class="el" href="console_color4_8cpp-example.html#_a0">console_color4.cpp</a>, <a class="el" href="console_firework_8cpp-example.html#_a4">console_firework.cpp</a>, <a class="el" href="console_song_8cpp-example.html#_a0">console_song.cpp</a>, <a class="el" href="console_song2_8cpp-example.html#_a0">console_song2.cpp</a>, <a class="el" href="console_song3_8cpp-example.html#_a0">console_song3.cpp</a>, <a class="el" href="console_unicode_8cpp-example.html#_a0">console_unicode.cpp</a>, <a class="el" href="date_time_add_hours_8cpp-example.html#_a0">date_time_add_hours.cpp</a>, <a class="el" href="date_time_add_minutes_8cpp-example.html#_a1">date_time_add_minutes.cpp</a>, <a class="el" href="date_time_now_8cpp-example.html#_a0">date_time_now.cpp</a>, <a class="el" href="date_time_now2_8cpp-example.html#_a0">date_time_now2.cpp</a>, <a class="el" href="date_time_today_8cpp-example.html#_a0">date_time_today.cpp</a>, <a class="el" href="default_trace_listener_8cpp-example.html#_a0">default_trace_listener.cpp</a>, <a class="el" href="dot_matrix_display_8cpp-example.html#_a2">dot_matrix_display.cpp</a>, <a class="el" href="draw_point_8cpp-example.html#_a8">draw_point.cpp</a>, <a class="el" href="environment_exit_8cpp-example.html#_a0">environment_exit.cpp</a>, <a class="el" href="environment_program_exit_8cpp-example.html#_a1">environment_program_exit.cpp</a>, <a class="el" href="fibonacci_series_8cpp-example.html#_a0">fibonacci_series.cpp</a>, <a class="el" href="file_info_move_to_8cpp-example.html#_a7">file_info_move_to.cpp</a>, <a class="el" href="font_families_8cpp-example.html#_a1">font_families.cpp</a>, <a class="el" href="form_paint_8cpp-example.html#_a8">form_paint.cpp</a>, <a class="el" href="form_show_8cpp-example.html#_a7">form_show.cpp</a>, <a class="el" href="format_class_8cpp-example.html#_a1">format_class.cpp</a>, <a class="el" href="format_class_object_8cpp-example.html#_a2">format_class_object.cpp</a>, <a class="el" href="format_sequence_containers_8cpp-example.html#_a0">format_sequence_containers.cpp</a>, <a class="el" href="fourteen_segment_display_8cpp-example.html#_a2">fourteen_segment_display.cpp</a>, <a class="el" href="graph_control_8cpp-example.html#_a6">graph_control.cpp</a>, <a class="el" href="graphics_8cpp-example.html#_a17">graphics.cpp</a>, <a class="el" href="iobservable_iobserver_8cpp-example.html#_a3">iobservable_iobserver.cpp</a>, <a class="el" href="ip_address_8cpp-example.html#_a0">ip_address.cpp</a>, <a class="el" href="labels_and_unicode_text_8cpp-example.html#_a2">labels_and_unicode_text.cpp</a>, <a class="el" href="lock_guard_8cpp-example.html#_a0">lock_guard.cpp</a>, <a class="el" href="main_8cpp-example.html#_a0">main.cpp</a>, <a class="el" href="main3_8cpp-example.html#_a0">main3.cpp</a>, <a class="el" href="main4_8cpp-example.html#_a0">main4.cpp</a>, <a class="el" href="manual_reset_event_8cpp-example.html#_a0">manual_reset_event.cpp</a>, <a class="el" href="monitor_8cpp-example.html#_a0">monitor.cpp</a>, <a class="el" href="mutex_8cpp-example.html#_a0">mutex.cpp</a>, <a class="el" href="nine_segment_display_8cpp-example.html#_a2">nine_segment_display.cpp</a>, <a class="el" href="open_file_box_8cpp-example.html#_a2">open_file_box.cpp</a>, <a class="el" href="painting_8cpp-example.html#_a17">painting.cpp</a>, <a class="el" href="random1_8cpp-example.html#_a0">random1.cpp</a>, <a class="el" href="random2_8cpp-example.html#_a1">random2.cpp</a>, <a class="el" href="random3_8cpp-example.html#_a1">random3.cpp</a>, <a class="el" href="semaphore_8cpp-example.html#_a1">semaphore.cpp</a>, <a class="el" href="seven_segment_display_8cpp-example.html#_a2">seven_segment_display.cpp</a>, <a class="el" href="sixteen_segment_display_8cpp-example.html#_a2">sixteen_segment_display.cpp</a>, <a class="el" href="socket_tcp_ip_v4_8cpp-example.html#_a4">socket_tcp_ip_v4.cpp</a>, <a class="el" href="socket_tcp_ip_v4_without_thread_8cpp-example.html#_a2">socket_tcp_ip_v4_without_thread.cpp</a>, <a class="el" href="socket_tcp_ip_v6_8cpp-example.html#_a4">socket_tcp_ip_v6.cpp</a>, <a class="el" href="socket_udp_ip_v4_8cpp-example.html#_a4">socket_udp_ip_v4.cpp</a>, <a class="el" href="socket_udp_ip_v6_8cpp-example.html#_a4">socket_udp_ip_v6.cpp</a>, <a class="el" href="sprintf_class_8cpp-example.html#_a1">sprintf_class.cpp</a>, <a class="el" href="sprintf_class_with_specified_formating_8cpp-example.html#_a4">sprintf_class_with_specified_formating.cpp</a>, <a class="el" href="sprintf_class_with_specified_formating_with_to_string_8cpp-example.html#_a4">sprintf_class_with_specified_formating_with_to_string.cpp</a>, <a class="el" href="startup3_8cpp-example.html#_a0">startup3.cpp</a>, <a class="el" href="startup4_8cpp-example.html#_a0">startup4.cpp</a>, <a class="el" href="stopwatch_8cpp-example.html#_a0">stopwatch.cpp</a>, <a class="el" href="test_forms_8cpp-example.html#_a34">test_forms.cpp</a>, <a class="el" href="udp_client_ip_v4_8cpp-example.html#_a4">udp_client_ip_v4.cpp</a>, <a class="el" href="udp_client_ip_v6_8cpp-example.html#_a4">udp_client_ip_v6.cpp</a>, <a class="el" href="user_control_8cpp-example.html#_a12">user_control.cpp</a>, <a class="el" href="valid_does_not_throw_8cpp-example.html#_a1">valid_does_not_throw.cpp</a>, <a class="el" href="valid_throws_8cpp-example.html#_a1">valid_throws.cpp</a>, <a class="el" href="valid_throws_any_8cpp-example.html#_a1">valid_throws_any.cpp</a>, and <a class="el" href="wiggly_8cpp-example.html#_a8">wiggly.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Alias</h2></td></tr>
<tr class="memitem:a19654ead074894e64f01f9cc0f3c382a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a19654ead074894e64f01f9cc0f3c382a">value_type</a> = type_t</td></tr>
<tr class="memdesc:a19654ead074894e64f01f9cc0f3c382a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a19654ead074894e64f01f9cc0f3c382a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eae17c8c5a4a35346476a34db53058"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> = <a class="el" href="group__helpers__generic__collections.html#gac7dc24539787a344466014161f2d39af">helpers::allocator</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a19654ead074894e64f01f9cc0f3c382a">value_type</a> &gt;</td></tr>
<tr class="memdesc:a88eae17c8c5a4a35346476a34db53058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list allocator type.  <br /></td></tr>
<tr class="separator:a88eae17c8c5a4a35346476a34db53058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ece889cd67b8cc0980dc198f7e17763"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> = std::vector&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a19654ead074894e64f01f9cc0f3c382a">value_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &gt;</td></tr>
<tr class="memdesc:a6ece889cd67b8cc0980dc198f7e17763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list base type.  <br /></td></tr>
<tr class="separator:a6ece889cd67b8cc0980dc198f7e17763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90417139ac25cf11819dddac5b1673fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> = base_type::size_type</td></tr>
<tr class="memdesc:a90417139ac25cf11819dddac5b1673fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list size type (usually <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>).  <br /></td></tr>
<tr class="separator:a90417139ac25cf11819dddac5b1673fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42840cc750c9b11dea43f4590bd48236"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a42840cc750c9b11dea43f4590bd48236">difference_type</a> = base_type::difference_type</td></tr>
<tr class="memdesc:a42840cc750c9b11dea43f4590bd48236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list difference type (usually <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca" title="Represent the signed integer type of the result of subtracting two pointers.">xtd::ptrdiff</a>).  <br /></td></tr>
<tr class="separator:a42840cc750c9b11dea43f4590bd48236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1351dfee4c745490cdf929d0cdcd3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a> = base_type::reference</td></tr>
<tr class="memdesc:a5de1351dfee4c745490cdf929d0cdcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reference of list value type.  <br /></td></tr>
<tr class="separator:a5de1351dfee4c745490cdf929d0cdcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb264f9f540a71533305b4a403be2c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5cb264f9f540a71533305b4a403be2c0">const_reference</a> = base_type::const_reference</td></tr>
<tr class="memdesc:a5cb264f9f540a71533305b4a403be2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reference of list value type.  <br /></td></tr>
<tr class="separator:a5cb264f9f540a71533305b4a403be2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecb8fa85ae77800ff69e9bbd0a78c94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#afecb8fa85ae77800ff69e9bbd0a78c94">pointer</a> = base_type::pointer</td></tr>
<tr class="memdesc:afecb8fa85ae77800ff69e9bbd0a78c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the pointer of list value type.  <br /></td></tr>
<tr class="separator:afecb8fa85ae77800ff69e9bbd0a78c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e6e2a937439350466c17ca4db29e6f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a66e6e2a937439350466c17ca4db29e6f">const_pointer</a> = base_type::const_pointer</td></tr>
<tr class="memdesc:a66e6e2a937439350466c17ca4db29e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const pointer of list value type.  <br /></td></tr>
<tr class="separator:a66e6e2a937439350466c17ca4db29e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39fd00c2f363da57190c4cd2d900b5e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> = base_type::iterator</td></tr>
<tr class="memdesc:ae39fd00c2f363da57190c4cd2d900b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of list value type.  <br /></td></tr>
<tr class="separator:ae39fd00c2f363da57190c4cd2d900b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80ac142ebe558540a122fcb1743534f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> = base_type::const_iterator</td></tr>
<tr class="memdesc:aa80ac142ebe558540a122fcb1743534f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of list value type.  <br /></td></tr>
<tr class="separator:aa80ac142ebe558540a122fcb1743534f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99b6f04636ae59a117180738a566f44"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa99b6f04636ae59a117180738a566f44">reverse_iterator</a> = base_type::reverse_iterator</td></tr>
<tr class="memdesc:aa99b6f04636ae59a117180738a566f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the reverse iterator of list value type.  <br /></td></tr>
<tr class="separator:aa99b6f04636ae59a117180738a566f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c42bd12dbb9c48dd4a4ee55fed2224"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04c42bd12dbb9c48dd4a4ee55fed2224">const_reverse_iterator</a> = base_type::const_reverse_iterator</td></tr>
<tr class="memdesc:a04c42bd12dbb9c48dd4a4ee55fed2224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const reverse iterator of list value type.  <br /></td></tr>
<tr class="separator:a04c42bd12dbb9c48dd4a4ee55fed2224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors</h2></td></tr>
<tr class="memitem:accf8a642ed6905d1d90091a14cb0b715"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#accf8a642ed6905d1d90091a14cb0b715">list</a> () noexcept=default</td></tr>
<tr class="memdesc:accf8a642ed6905d1d90091a14cb0b715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> class that is empty.  <br /></td></tr>
<tr class="separator:accf8a642ed6905d1d90091a14cb0b715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ae391bd2f3fd35ada3ce2fd367fa14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae0ae391bd2f3fd35ada3ce2fd367fa14">list</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:ae0ae391bd2f3fd35ada3ce2fd367fa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the List&lt;T&gt; class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.  <br /></td></tr>
<tr class="separator:ae0ae391bd2f3fd35ada3ce2fd367fa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bb61cfdfad9cd4341f1f0a3d33050c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a14bb61cfdfad9cd4341f1f0a3d33050c">list</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> count, const type_t &amp;value, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>())</td></tr>
<tr class="memdesc:a14bb61cfdfad9cd4341f1f0a3d33050c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with specified count copies of elements with specified value.  <br /></td></tr>
<tr class="separator:a14bb61cfdfad9cd4341f1f0a3d33050c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cc4bdf19efe722bb7bc0da3884c779"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#af2cc4bdf19efe722bb7bc0da3884c779">list</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> count, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>())</td></tr>
<tr class="memdesc:af2cc4bdf19efe722bb7bc0da3884c779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with specified count default-inserted instances of type_t. No copies are made.  <br /></td></tr>
<tr class="separator:af2cc4bdf19efe722bb7bc0da3884c779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc51a3e683e3bac9c842fdce084bde3"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a6dc51a3e683e3bac9c842fdce084bde3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6dc51a3e683e3bac9c842fdce084bde3">list</a> (input_iterator_t first, input_iterator_t last, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>())</td></tr>
<tr class="memdesc:a6dc51a3e683e3bac9c842fdce084bde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <br /></td></tr>
<tr class="separator:a6dc51a3e683e3bac9c842fdce084bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff2353f8653c3ce78c05d24e47c9d28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5ff2353f8653c3ce78c05d24e47c9d28">list</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>)=default</td></tr>
<tr class="memdesc:a5ff2353f8653c3ce78c05d24e47c9d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor with specified list.  <br /></td></tr>
<tr class="separator:a5ff2353f8653c3ce78c05d24e47c9d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54dd90ec02d5cc217accda235a2a74f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa54dd90ec02d5cc217accda235a2a74f">list</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>)</td></tr>
<tr class="memdesc:aa54dd90ec02d5cc217accda235a2a74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with specified base type list.  <br /></td></tr>
<tr class="separator:aa54dd90ec02d5cc217accda235a2a74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a2466eae6fedb211b816e8934c32aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ad9a2466eae6fedb211b816e8934c32aa">list</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:ad9a2466eae6fedb211b816e8934c32aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor with specified list, and allocator.  <br /></td></tr>
<tr class="separator:ad9a2466eae6fedb211b816e8934c32aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2adb2841645a57b6831a2dad0adabb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6e2adb2841645a57b6831a2dad0adabb">list</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a6e2adb2841645a57b6831a2dad0adabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor with specified base type list, and allocator.  <br /></td></tr>
<tr class="separator:a6e2adb2841645a57b6831a2dad0adabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69293cc12ef29f1daeb7b1e7a7077b55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a69293cc12ef29f1daeb7b1e7a7077b55">list</a> (std::initializer_list&lt; type_t &gt; items, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>())</td></tr>
<tr class="memdesc:a69293cc12ef29f1daeb7b1e7a7077b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the specified initializer list, and allocator.  <br /></td></tr>
<tr class="separator:a69293cc12ef29f1daeb7b1e7a7077b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e9da0820cef6abdc5b2cc5c9b01123"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a00e9da0820cef6abdc5b2cc5c9b01123">list</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)=default</td></tr>
<tr class="memdesc:a00e9da0820cef6abdc5b2cc5c9b01123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with specified list.  <br /></td></tr>
<tr class="separator:a00e9da0820cef6abdc5b2cc5c9b01123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a043acbdf64ac0164a3a87ce8e1d438"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5a043acbdf64ac0164a3a87ce8e1d438">list</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a5a043acbdf64ac0164a3a87ce8e1d438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with specified base type list.  <br /></td></tr>
<tr class="separator:a5a043acbdf64ac0164a3a87ce8e1d438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ed2884ed190f469f155ced6e2e6614"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ac9ed2884ed190f469f155ced6e2e6614">list</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:ac9ed2884ed190f469f155ced6e2e6614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with specified list, and allocator.  <br /></td></tr>
<tr class="separator:ac9ed2884ed190f469f155ced6e2e6614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04d6f1545b5e8038dd21bed83f6db93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ac04d6f1545b5e8038dd21bed83f6db93">list</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:ac04d6f1545b5e8038dd21bed83f6db93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with specified base tyoe list, and allocator.  <br /></td></tr>
<tr class="separator:ac04d6f1545b5e8038dd21bed83f6db93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:a3533b75538cf6c44108a4a8b0e929fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a3533b75538cf6c44108a4a8b0e929fff">back</a> ()</td></tr>
<tr class="memdesc:a3533b75538cf6c44108a4a8b0e929fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:a3533b75538cf6c44108a4a8b0e929fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d530e1134232db2bc60ef4a2a2428f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5cb264f9f540a71533305b4a403be2c0">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa5d530e1134232db2bc60ef4a2a2428f">back</a> () const</td></tr>
<tr class="memdesc:aa5d530e1134232db2bc60ef4a2a2428f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:aa5d530e1134232db2bc60ef4a2a2428f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b3ceaeef797791b084558ffa9c3301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa4b3ceaeef797791b084558ffa9c3301">begin</a> () noexcept</td></tr>
<tr class="memdesc:aa4b3ceaeef797791b084558ffa9c3301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the vector.  <br /></td></tr>
<tr class="separator:aa4b3ceaeef797791b084558ffa9c3301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801e5c44ca87ea5cb4bf314f5b9030dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a801e5c44ca87ea5cb4bf314f5b9030dc">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a801e5c44ca87ea5cb4bf314f5b9030dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the vector.  <br /></td></tr>
<tr class="separator:a801e5c44ca87ea5cb4bf314f5b9030dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b48e6b654bac6bbf9c142f9955abaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a19b48e6b654bac6bbf9c142f9955abaf">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a19b48e6b654bac6bbf9c142f9955abaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the vector.  <br /></td></tr>
<tr class="separator:a19b48e6b654bac6bbf9c142f9955abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd90dae167087e0bd1256a6c8efcfab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:abd90dae167087e0bd1256a6c8efcfab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container has currently allocated space for.  <br /></td></tr>
<tr class="separator:abd90dae167087e0bd1256a6c8efcfab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e4a06d9834e9ab59901dbdb88aa698"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a42e4a06d9834e9ab59901dbdb88aa698">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a42e4a06d9834e9ab59901dbdb88aa698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa4b3ceaeef797791b084558ffa9c3301" title="Returns an iterator to the first element of the vector.">xtd::collections::generic::list::begin()</a> == <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a>.  <br /></td></tr>
<tr class="separator:a42e4a06d9834e9ab59901dbdb88aa698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ee18bd2e89c978d30fe01129f66c0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f">end</a> () noexcept</td></tr>
<tr class="memdesc:a90ee18bd2e89c978d30fe01129f66c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the vector.  <br /></td></tr>
<tr class="separator:a90ee18bd2e89c978d30fe01129f66c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6652f95cd8005852cec61e8a0199a323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6652f95cd8005852cec61e8a0199a323">end</a> () const noexcept</td></tr>
<tr class="memdesc:a6652f95cd8005852cec61e8a0199a323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the vector.  <br /></td></tr>
<tr class="separator:a6652f95cd8005852cec61e8a0199a323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e97f6af2aa4b81cc69b4aeea31609a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a0e97f6af2aa4b81cc69b4aeea31609a9">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a0e97f6af2aa4b81cc69b4aeea31609a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the vector.  <br /></td></tr>
<tr class="separator:a0e97f6af2aa4b81cc69b4aeea31609a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26bc21b133fed029d1386a129177581"><td class="memItemLeft" align="right" valign="top">type_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ac26bc21b133fed029d1386a129177581">data</a> () noexcept</td></tr>
<tr class="memdesc:ac26bc21b133fed029d1386a129177581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <br /></td></tr>
<tr class="separator:ac26bc21b133fed029d1386a129177581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a01489ec5d120ccf0185ab8797cfb2"><td class="memItemLeft" align="right" valign="top">const type_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ad3a01489ec5d120ccf0185ab8797cfb2">data</a> () const noexcept</td></tr>
<tr class="memdesc:ad3a01489ec5d120ccf0185ab8797cfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <br /></td></tr>
<tr class="separator:ad3a01489ec5d120ccf0185ab8797cfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d6108ba8c402cb8016e664b5784e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#af6d6108ba8c402cb8016e664b5784e80">front</a> ()</td></tr>
<tr class="memdesc:af6d6108ba8c402cb8016e664b5784e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:af6d6108ba8c402cb8016e664b5784e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cca5231ff7537fe525294ce5422e90f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5cb264f9f540a71533305b4a403be2c0">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a8cca5231ff7537fe525294ce5422e90f">front</a> () const</td></tr>
<tr class="memdesc:a8cca5231ff7537fe525294ce5422e90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:a8cca5231ff7537fe525294ce5422e90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9860bdee2e4839e177a081597e92c1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#af9860bdee2e4839e177a081597e92c1f">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:af9860bdee2e4839e177a081597e92c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa4b3ceaeef797791b084558ffa9c3301" title="Returns an iterator to the first element of the vector.">xtd::collections::generic::list::begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a>) for the largest container.  <br /></td></tr>
<tr class="separator:af9860bdee2e4839e177a081597e92c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53711446f96fac038f5c5a1f162af06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa99b6f04636ae59a117180738a566f44">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ab53711446f96fac038f5c5a1f162af06">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:ab53711446f96fac038f5c5a1f162af06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255" title="Returns a reverse iterator to the element following the last element of the reversed vector....">xtd::collections::generic::list::rend()</a>.  <br /></td></tr>
<tr class="separator:ab53711446f96fac038f5c5a1f162af06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180ebc6d766b39f4d2d75673cb5d2d4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04c42bd12dbb9c48dd4a4ee55fed2224">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a180ebc6d766b39f4d2d75673cb5d2d4a">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a180ebc6d766b39f4d2d75673cb5d2d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255" title="Returns a reverse iterator to the element following the last element of the reversed vector....">xtd::collections::generic::list::rend()</a>.  <br /></td></tr>
<tr class="separator:a180ebc6d766b39f4d2d75673cb5d2d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da8d1f90937b99544b79ee0681286b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04c42bd12dbb9c48dd4a4ee55fed2224">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5da8d1f90937b99544b79ee0681286b5">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a5da8d1f90937b99544b79ee0681286b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255" title="Returns a reverse iterator to the element following the last element of the reversed vector....">xtd::collections::generic::list::rend()</a>.  <br /></td></tr>
<tr class="separator:a5da8d1f90937b99544b79ee0681286b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa786fa60f8ea7706cea5b9166ee07255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa99b6f04636ae59a117180738a566f44">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255">rend</a> () noexcept</td></tr>
<tr class="memdesc:aa786fa60f8ea7706cea5b9166ee07255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:aa786fa60f8ea7706cea5b9166ee07255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b8f1b28dc656c5eae143d02e842078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04c42bd12dbb9c48dd4a4ee55fed2224">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa7b8f1b28dc656c5eae143d02e842078">rend</a> () const noexcept</td></tr>
<tr class="memdesc:aa7b8f1b28dc656c5eae143d02e842078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:aa7b8f1b28dc656c5eae143d02e842078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a77df3e204d192f683c94747800feb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04c42bd12dbb9c48dd4a4ee55fed2224">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5a77df3e204d192f683c94747800feb2">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a5a77df3e204d192f683c94747800feb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a5a77df3e204d192f683c94747800feb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026e87f9ceab793d1046c84aab312132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132">size</a> () const noexcept</td></tr>
<tr class="memdesc:a026e87f9ceab793d1046c84aab312132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa4b3ceaeef797791b084558ffa9c3301" title="Returns an iterator to the first element of the vector.">xtd::collections::generic::list::begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a>).  <br /></td></tr>
<tr class="separator:a026e87f9ceab793d1046c84aab312132"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a99b7ff46291fd593e9e964becb72cd99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a99b7ff46291fd593e9e964becb72cd99">assign</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> count, const type_t &amp;value)</td></tr>
<tr class="memdesc:a99b7ff46291fd593e9e964becb72cd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with count copies of value value.  <br /></td></tr>
<tr class="separator:a99b7ff46291fd593e9e964becb72cd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a68e20f71ad11aa827a32584350ea09"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a3a68e20f71ad11aa827a32584350ea09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a3a68e20f71ad11aa827a32584350ea09">assign</a> (input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:a3a68e20f71ad11aa827a32584350ea09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with copies of those in the range [first, last).  <br /></td></tr>
<tr class="separator:a3a68e20f71ad11aa827a32584350ea09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263b2e8992e25f7dd8a9f5b172953dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a263b2e8992e25f7dd8a9f5b172953dfb">assign</a> (std::initializer_list&lt; type_t &gt; items)</td></tr>
<tr class="memdesc:a263b2e8992e25f7dd8a9f5b172953dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list items_.  <br /></td></tr>
<tr class="separator:a263b2e8992e25f7dd8a9f5b172953dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635bb913f6d867c1487b6dd7e1a1e7a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a635bb913f6d867c1487b6dd7e1a1e7a7">at</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> pos)</td></tr>
<tr class="memdesc:a635bb913f6d867c1487b6dd7e1a1e7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <br /></td></tr>
<tr class="separator:a635bb913f6d867c1487b6dd7e1a1e7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dbe399720e53b2eb47ad6e7e23bb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5cb264f9f540a71533305b4a403be2c0">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04dbe399720e53b2eb47ad6e7e23bb49">at</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> pos) const</td></tr>
<tr class="memdesc:a04dbe399720e53b2eb47ad6e7e23bb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking.  <br /></td></tr>
<tr class="separator:a04dbe399720e53b2eb47ad6e7e23bb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93c1437a2e6822818c5da110e0abfff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#af93c1437a2e6822818c5da110e0abfff">clear</a> ()</td></tr>
<tr class="memdesc:af93c1437a2e6822818c5da110e0abfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> returns zero.  <br /></td></tr>
<tr class="separator:af93c1437a2e6822818c5da110e0abfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3864b962f5b9794084a98ea32e92e367"><td class="memTemplParams" colspan="2">template&lt;typename... args_t&gt; </td></tr>
<tr class="memitem:a3864b962f5b9794084a98ea32e92e367"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a3864b962f5b9794084a98ea32e92e367">emplace</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> pos, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3864b962f5b9794084a98ea32e92e367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before <code>pos</code>.  <br /></td></tr>
<tr class="separator:a3864b962f5b9794084a98ea32e92e367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce67bd4908af30660def1d72b0f2de0"><td class="memTemplParams" colspan="2">template&lt;typename... args_t&gt; </td></tr>
<tr class="memitem:abce67bd4908af30660def1d72b0f2de0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abce67bd4908af30660def1d72b0f2de0">emplace_back</a> (args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:abce67bd4908af30660def1d72b0f2de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the end of the container. The element is constructed through <a href="https://en.cppreference.com/w/cpp/memory/allocator_traits/construct">std::allocator_traits::construct</a>, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments <code>args...</code> are forwarded to the constructor as <code>std::forward&lt;Args&gt;(args)...</code>.  <br /></td></tr>
<tr class="separator:abce67bd4908af30660def1d72b0f2de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedfe231d6da60a6ffb75299a02f1054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abedfe231d6da60a6ffb75299a02f1054">erase</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> pos)</td></tr>
<tr class="memdesc:abedfe231d6da60a6ffb75299a02f1054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the specified elements from the container.  <br /></td></tr>
<tr class="separator:abedfe231d6da60a6ffb75299a02f1054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7338de406e3e4d5db730ac9913a4ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ad7338de406e3e4d5db730ac9913a4ec2">erase</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> first, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> last)</td></tr>
<tr class="memdesc:ad7338de406e3e4d5db730ac9913a4ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the specified elements from the container.  <br /></td></tr>
<tr class="separator:ad7338de406e3e4d5db730ac9913a4ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c80a2e52bd99102b679fe1df0c752a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a2c80a2e52bd99102b679fe1df0c752a4">get_allocator</a> () const</td></tr>
<tr class="memdesc:a2c80a2e52bd99102b679fe1df0c752a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <br /></td></tr>
<tr class="separator:a2c80a2e52bd99102b679fe1df0c752a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51edb8469c934f7106889ea9deee83ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a51edb8469c934f7106889ea9deee83ff">get_base_type</a> () noexcept</td></tr>
<tr class="memdesc:a51edb8469c934f7106889ea9deee83ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type.  <br /></td></tr>
<tr class="separator:a51edb8469c934f7106889ea9deee83ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bc6b8e3564ea9800b39a224d55b5e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#af3bc6b8e3564ea9800b39a224d55b5e8">get_base_type</a> () const noexcept</td></tr>
<tr class="memdesc:af3bc6b8e3564ea9800b39a224d55b5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type.  <br /></td></tr>
<tr class="separator:af3bc6b8e3564ea9800b39a224d55b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead592fd9396cdf3e2badc93a04cfe11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aead592fd9396cdf3e2badc93a04cfe11">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> pos, const type_t &amp;value)</td></tr>
<tr class="memdesc:aead592fd9396cdf3e2badc93a04cfe11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements at the specified location in the container.  <br /></td></tr>
<tr class="separator:aead592fd9396cdf3e2badc93a04cfe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e14b9f52370ea4fa70453d86c84695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ab9e14b9f52370ea4fa70453d86c84695">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> pos, const type_t &amp;&amp;value)</td></tr>
<tr class="memdesc:ab9e14b9f52370ea4fa70453d86c84695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements at the specified location in the container.  <br /></td></tr>
<tr class="separator:ab9e14b9f52370ea4fa70453d86c84695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186991b32a89208f1605be429c2d421d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a186991b32a89208f1605be429c2d421d">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> pos, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> count, const type_t &amp;value)</td></tr>
<tr class="memdesc:a186991b32a89208f1605be429c2d421d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements at the specified location in the container.  <br /></td></tr>
<tr class="separator:a186991b32a89208f1605be429c2d421d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3293d1d86f22dbc07dcb2302f8b362f1"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a3293d1d86f22dbc07dcb2302f8b362f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a3293d1d86f22dbc07dcb2302f8b362f1">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> pos, input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:a3293d1d86f22dbc07dcb2302f8b362f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements at the specified location in the container.  <br /></td></tr>
<tr class="separator:a3293d1d86f22dbc07dcb2302f8b362f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2075fdcb75059f15477167b414413018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a2075fdcb75059f15477167b414413018">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> pos, const std::initializer_list&lt; type_t &gt; &amp;items)</td></tr>
<tr class="memdesc:a2075fdcb75059f15477167b414413018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements at the specified location in the container.  <br /></td></tr>
<tr class="separator:a2075fdcb75059f15477167b414413018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca27f004245b0f208dc16fc6a92669a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aca27f004245b0f208dc16fc6a92669a6">pop_back</a> ()</td></tr>
<tr class="memdesc:aca27f004245b0f208dc16fc6a92669a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container.  <br /></td></tr>
<tr class="separator:aca27f004245b0f208dc16fc6a92669a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc90be2133e3e24f145838dd97a09dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#acc90be2133e3e24f145838dd97a09dc6">push_back</a> (const type_t &amp;value)</td></tr>
<tr class="memdesc:acc90be2133e3e24f145838dd97a09dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <br /></td></tr>
<tr class="separator:acc90be2133e3e24f145838dd97a09dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab186b6bea9e2d2f68fa4b3297be4b601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ab186b6bea9e2d2f68fa4b3297be4b601">push_back</a> (type_t &amp;&amp;value)</td></tr>
<tr class="memdesc:ab186b6bea9e2d2f68fa4b3297be4b601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <br /></td></tr>
<tr class="separator:ab186b6bea9e2d2f68fa4b3297be4b601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e3e7a03550cba08f21ac3ad4baebff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a89e3e7a03550cba08f21ac3ad4baebff">resize</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> count)</td></tr>
<tr class="memdesc:a89e3e7a03550cba08f21ac3ad4baebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>. @param count The new size of the container. @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. @remarks If the current size is less than</code>count`, additional default-inserted elements are appended.  <br /></td></tr>
<tr class="separator:a89e3e7a03550cba08f21ac3ad4baebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74eff05fa1b43c834ea87353e77fb25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ad74eff05fa1b43c834ea87353e77fb25">resize</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> count, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a19654ead074894e64f01f9cc0f3c382a">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:ad74eff05fa1b43c834ea87353e77fb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>. @param count The new size of the container. @param value The value to initialize the new elements with. @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. @remarks If the current size is less than</code>count<code>, additional copies of</code>value` are appended.  <br /></td></tr>
<tr class="separator:ad74eff05fa1b43c834ea87353e77fb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693c87531b94daaa0f795f38be867de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a693c87531b94daaa0f795f38be867de2">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a693c87531b94daaa0f795f38be867de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <br /></td></tr>
<tr class="separator:a693c87531b94daaa0f795f38be867de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e20819dec1ddbd4fe1da58a125e80af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a8e20819dec1ddbd4fe1da58a125e80af">swap</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a8e20819dec1ddbd4fe1da58a125e80af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents and capacity of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.  <br /></td></tr>
<tr class="separator:a8e20819dec1ddbd4fe1da58a125e80af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd3bf5bec705bee0bf926a6be15220b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#adcd3bf5bec705bee0bf926a6be15220b">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:adcd3bf5bec705bee0bf926a6be15220b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that represents the current object.  <br /></td></tr>
<tr class="separator:adcd3bf5bec705bee0bf926a6be15220b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:a22d70762d7b206c20fbaa4472bcc1a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a22d70762d7b206c20fbaa4472bcc1a6a">operator=</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)=default</td></tr>
<tr class="memdesc:a22d70762d7b206c20fbaa4472bcc1a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of other.  <br /></td></tr>
<tr class="separator:a22d70762d7b206c20fbaa4472bcc1a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5ac93e35bacea9282c4397be0a2978"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a7b5ac93e35bacea9282c4397be0a2978">operator=</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a7b5ac93e35bacea9282c4397be0a2978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:a7b5ac93e35bacea9282c4397be0a2978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1ea1cdcbadfa958cc045b97284897c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a1d1ea1cdcbadfa958cc045b97284897c">operator=</a> (std::initializer_list&lt; type_t &gt; &amp;items)</td></tr>
<tr class="memdesc:a1d1ea1cdcbadfa958cc045b97284897c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist.  <br /></td></tr>
<tr class="separator:a1d1ea1cdcbadfa958cc045b97284897c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ff0a5da39a22f356f091a950c1c69b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a00ff0a5da39a22f356f091a950c1c69b">operator[]</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> pos)</td></tr>
<tr class="memdesc:a00ff0a5da39a22f356f091a950c1c69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos.  <br /></td></tr>
<tr class="separator:a00ff0a5da39a22f356f091a950c1c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855ae51cd2ee2fc5b8af9245d0398125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5cb264f9f540a71533305b4a403be2c0">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a855ae51cd2ee2fc5b8af9245d0398125">operator[]</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> pos) const</td></tr>
<tr class="memdesc:a855ae51cd2ee2fc5b8af9245d0398125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos.  <br /></td></tr>
<tr class="separator:a855ae51cd2ee2fc5b8af9245d0398125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13f930e7e7e230e900a945589d427b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a7b13f930e7e7e230e900a945589d427b">operator base_type &amp;</a> () noexcept</td></tr>
<tr class="memdesc:a7b13f930e7e7e230e900a945589d427b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a7b13f930e7e7e230e900a945589d427b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da38c0256afa5522c2736b05697f308"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a7da38c0256afa5522c2736b05697f308">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:a7da38c0256afa5522c2736b05697f308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a7da38c0256afa5522c2736b05697f308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga4ac188feb2d52b21e188417441519bb2">xtd::uptr</a>&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#abb9700deaba669584080178e391d97c4">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t &gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t &gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a88eae17c8c5a4a35346476a34db53058" name="a88eae17c8c5a4a35346476a34db53058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88eae17c8c5a4a35346476a34db53058">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::allocator_type =  <a class="el" href="group__helpers__generic__collections.html#gac7dc24539787a344466014161f2d39af">helpers::allocator</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a19654ead074894e64f01f9cc0f3c382a">value_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the list allocator type. </p>

</div>
</div>
<a id="a6ece889cd67b8cc0980dc198f7e17763" name="a6ece889cd67b8cc0980dc198f7e17763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ece889cd67b8cc0980dc198f7e17763">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::base_type =  std::vector&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a19654ead074894e64f01f9cc0f3c382a">value_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the list base type. </p>

</div>
</div>
<a id="aa80ac142ebe558540a122fcb1743534f" name="aa80ac142ebe558540a122fcb1743534f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80ac142ebe558540a122fcb1743534f">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::const_iterator =  base_type::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const iterator of list value type. </p>

</div>
</div>
<a id="a66e6e2a937439350466c17ca4db29e6f" name="a66e6e2a937439350466c17ca4db29e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e6e2a937439350466c17ca4db29e6f">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::const_pointer =  base_type::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const pointer of list value type. </p>

</div>
</div>
<a id="a5cb264f9f540a71533305b4a403be2c0" name="a5cb264f9f540a71533305b4a403be2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb264f9f540a71533305b4a403be2c0">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::const_reference =  base_type::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const reference of list value type. </p>

</div>
</div>
<a id="a04c42bd12dbb9c48dd4a4ee55fed2224" name="a04c42bd12dbb9c48dd4a4ee55fed2224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c42bd12dbb9c48dd4a4ee55fed2224">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::const_reverse_iterator =  base_type::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const reverse iterator of list value type. </p>

</div>
</div>
<a id="a42840cc750c9b11dea43f4590bd48236" name="a42840cc750c9b11dea43f4590bd48236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42840cc750c9b11dea43f4590bd48236">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::difference_type =  base_type::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the list difference type (usually <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca" title="Represent the signed integer type of the result of subtracting two pointers.">xtd::ptrdiff</a>). </p>

</div>
</div>
<a id="ae39fd00c2f363da57190c4cd2d900b5e" name="ae39fd00c2f363da57190c4cd2d900b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39fd00c2f363da57190c4cd2d900b5e">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::iterator =  base_type::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the iterator of list value type. </p>

</div>
</div>
<a id="afecb8fa85ae77800ff69e9bbd0a78c94" name="afecb8fa85ae77800ff69e9bbd0a78c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecb8fa85ae77800ff69e9bbd0a78c94">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::pointer =  base_type::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the pointer of list value type. </p>

</div>
</div>
<a id="a5de1351dfee4c745490cdf929d0cdcd3" name="a5de1351dfee4c745490cdf929d0cdcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de1351dfee4c745490cdf929d0cdcd3">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::reference =  base_type::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the reference of list value type. </p>

</div>
</div>
<a id="aa99b6f04636ae59a117180738a566f44" name="aa99b6f04636ae59a117180738a566f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99b6f04636ae59a117180738a566f44">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::reverse_iterator =  base_type::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the reverse iterator of list value type. </p>

</div>
</div>
<a id="a90417139ac25cf11819dddac5b1673fd" name="a90417139ac25cf11819dddac5b1673fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90417139ac25cf11819dddac5b1673fd">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::size_type =  base_type::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the list size type (usually <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>). </p>

</div>
</div>
<a id="a19654ead074894e64f01f9cc0f3c382a" name="a19654ead074894e64f01f9cc0f3c382a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19654ead074894e64f01f9cc0f3c382a">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::value_type =  type_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the list value type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="accf8a642ed6905d1d90091a14cb0b715" name="accf8a642ed6905d1d90091a14cb0b715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf8a642ed6905d1d90091a14cb0b715">&#9670;&#160;</a></span>list() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> class that is empty. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> is the number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> can hold. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a>, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
If the size of the collection can be estimated, using the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list(xtd::size)</a> constructor and specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a>. </dd>
<dd>
The capacity can be decreased by calling the xtd::collections::generic::list::trim_excess method or by setting the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity</a> property explicitly. Decreasing the capacity reallocates memory and copies all the elements in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a>. </dd>
<dd>
This constructor is an O(1) operation. </dd>
<dd>
The following code example demonstrates the default constructor of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> generic class. The default constructor creates a list with the default capacity, as demonstrated by displaying the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity</a> property. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The code example adds, inserts, and removes items, showing how the capacity changes as these methods are used. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae0ae391bd2f3fd35ada3ce2fd367fa14" name="ae0ae391bd2f3fd35ada3ce2fd367fa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ae391bd2f3fd35ada3ce2fd367fa14">&#9670;&#160;</a></span>list() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the List&lt;T&gt; class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection whose elements are copied to the new list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>The parameters collection is null or element reference null in collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The elements are copied onto the List&lt;T&gt; in the same order they are read by the enumerator of the collection. </dd>
<dd>
This constructor is an O(n) operation, where n is the number of elements in collection. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates the List&lt;T&gt; constructor and various methods of the List&lt;T&gt; class that act on ranges. An array of strings is created and passed to the constructor, populating the list with the elements of the array. The Capacity property is then displayed, to show that the initial capacity is exactly what is required to hold the input elements. <div class="fragment"></div><!-- fragment --></dd></dl>
<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> class that is empty and has the specified initial capacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The number of elements that the new list can initially store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> is the number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> can hold. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a>, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a>. </dd>
<dd>
The capacity can be decreased by calling the xtd::collections::generic::list::trim_excess method or by setting the xtd::collections::generic::list::cpacity property explicitly. Decreasing the capacity reallocates memory and copies all the elements in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a>. </dd>
<dd>
This constructor is an O(n) operation, where n is capacity. </dd>
<dd>
The following code example demonstrates the xtd::collections::generic::list::as_read_only method. A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> of strings with a capacity of 4 is created, because the ultimate size of the list is known to be exactly 4. The list is populated with four strings, and the AsReadOnly method is used to get a read-only xtd::collections::generic::ilist generic interface implementation that wraps the original list. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>An element of the original list is set to "Coelophysis" using the <code>item</code> property, and the contents of the read-only list are displayed again to demonstrate that it is just a wrapper for the original list. <div class="fragment"></div><!-- fragment --></dd></dl>
<p>Constructs an empty container with the given allocator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14bb61cfdfad9cd4341f1f0a3d33050c" name="a14bb61cfdfad9cd4341f1f0a3d33050c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bb61cfdfad9cd4341f1f0a3d33050c">&#9670;&#160;</a></span>list() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const type_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with specified count copies of elements with specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The size of the container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to initialize elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2cc4bdf19efe722bb7bc0da3884c779" name="af2cc4bdf19efe722bb7bc0da3884c779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cc4bdf19efe722bb7bc0da3884c779">&#9670;&#160;</a></span>list() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with specified count default-inserted instances of type_t. No copies are made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The size of the container. </td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dc51a3e683e3bac9c842fdce084bde3" name="a6dc51a3e683e3bac9c842fdce084bde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc51a3e683e3bac9c842fdce084bde3">&#9670;&#160;</a></span>list() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator the range to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator the range to copy the elements from. </td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff2353f8653c3ce78c05d24e47c9d28" name="a5ff2353f8653c3ce78c05d24e47c9d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff2353f8653c3ce78c05d24e47c9d28">&#9670;&#160;</a></span>list() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>&lt; type_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor with specified list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> which elements will be inserted from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa54dd90ec02d5cc217accda235a2a74f" name="aa54dd90ec02d5cc217accda235a2a74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54dd90ec02d5cc217accda235a2a74f">&#9670;&#160;</a></span>list() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with specified base type list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763" title="Represents the list base type.">xtd::collections::generic::list::base_type</a> which elements will be inserted from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9a2466eae6fedb211b816e8934c32aa" name="ad9a2466eae6fedb211b816e8934c32aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a2466eae6fedb211b816e8934c32aa">&#9670;&#160;</a></span>list() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>&lt; type_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor with specified list, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> which elements will be inserted from. </td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e2adb2841645a57b6831a2dad0adabb" name="a6e2adb2841645a57b6831a2dad0adabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2adb2841645a57b6831a2dad0adabb">&#9670;&#160;</a></span>list() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor with specified base type list, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> which elements will be inserted from. </td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69293cc12ef29f1daeb7b1e7a7077b55" name="a69293cc12ef29f1daeb7b1e7a7077b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69293cc12ef29f1daeb7b1e7a7077b55">&#9670;&#160;</a></span>list() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; type_t &gt;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the specified initializer list, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>The initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00e9da0820cef6abdc5b2cc5c9b01123" name="a00e9da0820cef6abdc5b2cc5c9b01123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e9da0820cef6abdc5b2cc5c9b01123">&#9670;&#160;</a></span>list() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>&lt; type_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with specified list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763" title="Represents the list base type.">xtd::collections::generic::list::base_type</a> which elements will be moved from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a043acbdf64ac0164a3a87ce8e1d438" name="a5a043acbdf64ac0164a3a87ce8e1d438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a043acbdf64ac0164a3a87ce8e1d438">&#9670;&#160;</a></span>list() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with specified base type list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763" title="Represents the list base type.">xtd::collections::generic::list::base_type</a> which elements will be moved from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9ed2884ed190f469f155ced6e2e6614" name="ac9ed2884ed190f469f155ced6e2e6614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ed2884ed190f469f155ced6e2e6614">&#9670;&#160;</a></span>list() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>&lt; type_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with specified list, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763" title="Represents the list base type.">xtd::collections::generic::list::base_type</a> which elements will be moved from. </td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac04d6f1545b5e8038dd21bed83f6db93" name="ac04d6f1545b5e8038dd21bed83f6db93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04d6f1545b5e8038dd21bed83f6db93">&#9670;&#160;</a></span>list() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with specified base tyoe list, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763" title="Represents the list base type.">xtd::collections::generic::list::base_type</a> which elements will be moved from. </td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a68e20f71ad11aa827a32584350ea09" name="a3a68e20f71ad11aa827a32584350ea09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a68e20f71ad11aa827a32584350ea09">&#9670;&#160;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with copies of those in the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator the range to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator the range to copy the elements from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if either argument is an iterator this current instance. </dd></dl>

</div>
</div>
<a id="a99b7ff46291fd593e9e964becb72cd99" name="a99b7ff46291fd593e9e964becb72cd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b7ff46291fd593e9e964becb72cd99">&#9670;&#160;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const type_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with count copies of value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to initialize elements of the container with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a263b2e8992e25f7dd8a9f5b172953dfb" name="a263b2e8992e25f7dd8a9f5b172953dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263b2e8992e25f7dd8a9f5b172953dfb">&#9670;&#160;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; type_t &gt;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with the elements from the initializer list items_. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>the initializer list to copy the values from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a635bb913f6d867c1487b6dd7e1a1e7a7" name="a635bb913f6d867c1487b6dd7e1a1e7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635bb913f6d867c1487b6dd7e1a1e7a7">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If pos is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04dbe399720e53b2eb47ad6e7e23bb49" name="a04dbe399720e53b2eb47ad6e7e23bb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dbe399720e53b2eb47ad6e7e23bb49">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5cb264f9f540a71533305b4a403be2c0">const_reference</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If pos is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3533b75538cf6c44108a4a8b0e929fff" name="a3533b75538cf6c44108a4a8b0e929fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3533b75538cf6c44108a4a8b0e929fff">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="aa5d530e1134232db2bc60ef4a2a2428f" name="aa5d530e1134232db2bc60ef4a2a2428f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d530e1134232db2bc60ef4a2a2428f">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5cb264f9f540a71533305b4a403be2c0">const_reference</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="a801e5c44ca87ea5cb4bf314f5b9030dc" name="a801e5c44ca87ea5cb4bf314f5b9030dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801e5c44ca87ea5cb4bf314f5b9030dc">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a>. </dd></dl>

</div>
</div>
<a id="aa4b3ceaeef797791b084558ffa9c3301" name="aa4b3ceaeef797791b084558ffa9c3301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b3ceaeef797791b084558ffa9c3301">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="console_clear_8cpp-example.html#a3">console_clear.cpp</a>, <a class="el" href="socket_tcp_ip_v4_8cpp-example.html#a7">socket_tcp_ip_v4.cpp</a>, <a class="el" href="socket_tcp_ip_v4_without_thread_8cpp-example.html#a8">socket_tcp_ip_v4_without_thread.cpp</a>, <a class="el" href="socket_tcp_ip_v6_8cpp-example.html#a7">socket_tcp_ip_v6.cpp</a>, and <a class="el" href="socket_udp_ip_v4_8cpp-example.html#a6">socket_udp_ip_v4.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abd90dae167087e0bd1256a6c8efcfab6" name="abd90dae167087e0bd1256a6c8efcfab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd90dae167087e0bd1256a6c8efcfab6">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that the container has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the currently allocated storage. </dd></dl>

</div>
</div>
<a id="a19b48e6b654bac6bbf9c142f9955abaf" name="a19b48e6b654bac6bbf9c142f9955abaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b48e6b654bac6bbf9c142f9955abaf">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a>. </dd></dl>

</div>
</div>
<a id="a0e97f6af2aa4b81cc69b4aeea31609a9" name="a0e97f6af2aa4b81cc69b4aeea31609a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e97f6af2aa4b81cc69b4aeea31609a9">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="af93c1437a2e6822818c5da110e0abfff" name="af93c1437a2e6822818c5da110e0abfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93c1437a2e6822818c5da110e0abfff">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container. After this call, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> returns zero. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Invalidates any references, pointers, and iterators referring to contained elements. Any past-the-end iterators are also invalidated. </dd>
<dd>
Leaves the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> of the vector unchanged (Note: the standard's restriction on the changes to capacity is in the specification of xtd::collections::generic::list::reserve(), see <a href="https://stackoverflow.com/a/18467916">SO</a>). </dd></dl>

</div>
</div>
<a id="a5da8d1f90937b99544b79ee0681286b5" name="a5da8d1f90937b99544b79ee0681286b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da8d1f90937b99544b79ee0681286b5">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04c42bd12dbb9c48dd4a4ee55fed2224">const_reverse_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255" title="Returns a reverse iterator to the element following the last element of the reversed vector....">xtd::collections::generic::list::rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255" title="Returns a reverse iterator to the element following the last element of the reversed vector....">xtd::collections::generic::list::rend()</a>. </dd></dl>

</div>
</div>
<a id="a5a77df3e204d192f683c94747800feb2" name="a5a77df3e204d192f683c94747800feb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a77df3e204d192f683c94747800feb2">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04c42bd12dbb9c48dd4a4ee55fed2224">const_reverse_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="ad3a01489ec5d120ccf0185ab8797cfb2" name="ad3a01489ec5d120ccf0185ab8797cfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a01489ec5d120ccf0185ab8797cfb2">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const type_t * <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, the returned pointer compares equal to the address of the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer is such that range [<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ac26bc21b133fed029d1386a129177581" title="Returns pointer to the underlying array serving as element storage.">xtd::collections::generic::list::data()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ac26bc21b133fed029d1386a129177581" title="Returns pointer to the underlying array serving as element storage.">xtd::collections::generic::list::data()</a> + <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ac26bc21b133fed029d1386a129177581" title="Returns pointer to the underlying array serving as element storage.">xtd::collections::generic::list::data()</a> is not dereferenceable in that case). </dd></dl>

</div>
</div>
<a id="ac26bc21b133fed029d1386a129177581" name="ac26bc21b133fed029d1386a129177581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26bc21b133fed029d1386a129177581">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type_t * <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, the returned pointer compares equal to the address of the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer is such that range [<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ac26bc21b133fed029d1386a129177581" title="Returns pointer to the underlying array serving as element storage.">xtd::collections::generic::list::data()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ac26bc21b133fed029d1386a129177581" title="Returns pointer to the underlying array serving as element storage.">xtd::collections::generic::list::data()</a> + <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ac26bc21b133fed029d1386a129177581" title="Returns pointer to the underlying array serving as element storage.">xtd::collections::generic::list::data()</a> is not dereferenceable in that case). </dd></dl>

</div>
</div>
<a id="a3864b962f5b9794084a98ea32e92e367" name="a3864b962f5b9794084a98ea32e92e367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3864b962f5b9794084a98ea32e92e367">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<div class="memtemplate">
template&lt;typename... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator before which the new element will be constructed. </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The element is constructed through <a href="https://en.cppreference.com/w/cpp/memory/allocator_traits/construct">std::allocator_traits::construct</a>, which typically uses placement-new to construct the element in-place at a location provided by the container. However, if the required location has been occupied by an existing element, the inserted element is constructed at another location at first, and then move assigned into the required location. </dd>
<dd>
The arguments <code>args...</code> are forwarded to the constructor as <code>std::forward&lt;args_t&gt;(args)....</code> <code>args...</code> may directly or indirectly refer to a value in the container. </dd>
<dd>
If after the operation the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and all references to the elements are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. </dd></dl>

</div>
</div>
<a id="abce67bd4908af30660def1d72b0f2de0" name="abce67bd4908af30660def1d72b0f2de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce67bd4908af30660def1d72b0f2de0">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<div class="memtemplate">
template&lt;typename... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the end of the container. The element is constructed through <a href="https://en.cppreference.com/w/cpp/memory/allocator_traits/construct">std::allocator_traits::construct</a>, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments <code>args...</code> are forwarded to the constructor as <code>std::forward&lt;Args&gt;(args)...</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the inserted element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If after the operation the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and all references to the elements are invalidated. Otherwise only the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator is invalidated. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="array_list_8cpp-example.html#a1">array_list.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a42e4a06d9834e9ab59901dbdb88aa698" name="a42e4a06d9834e9ab59901dbdb88aa698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e4a06d9834e9ab59901dbdb88aa698">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa4b3ceaeef797791b084558ffa9c3301" title="Returns an iterator to the first element of the vector.">xtd::collections::generic::list::begin()</a> == <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a6652f95cd8005852cec61e8a0199a323" name="a6652f95cd8005852cec61e8a0199a323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6652f95cd8005852cec61e8a0199a323">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a90ee18bd2e89c978d30fe01129f66c0f" name="a90ee18bd2e89c978d30fe01129f66c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ee18bd2e89c978d30fe01129f66c0f">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="console_clear_8cpp-example.html#a4">console_clear.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad7338de406e3e4d5db730ac9913a4ec2" name="ad7338de406e3e4d5db730ac9913a4ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7338de406e3e4d5db730ac9913a4ec2">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the specified elements from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator to the element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes the elements in the range [<code>first</code>, <code>last</code>). </dd>
<dd>
Iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and references to the elements at or after the point of the erase are invalidated. </dd>
<dd>
The iterator <code>first</code> does not need to be dereferenceable if <code>first == last</code>: erasing an empty range is a no-op. </dd>
<dd>
If <code>last == <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">end()</a></code> prior to removal, then the updated <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator is returned. </dd>
<dd>
If [<code>first</code>, <code>last</code>) is an empty range, then <code>last</code> is returned. </dd></dl>

</div>
</div>
<a id="abedfe231d6da60a6ffb75299a02f1054" name="abedfe231d6da60a6ffb75299a02f1054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedfe231d6da60a6ffb75299a02f1054">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the specified elements from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator to the element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes the element at <code>pos</code>. </dd>
<dd>
Iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and references to the elements at or after the point of the erase are invalidated. </dd>
<dd>
The iterator <code>pos</code> must be valid and dereferenceable. Thus the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for <code>pos. @remarks If</code>pos` refers to the last element, then thextd::collections::generic::list:: <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">end()</a> iterator is returned. </dd></dl>

</div>
</div>
<a id="af6d6108ba8c402cb8016e664b5784e80" name="af6d6108ba8c402cb8016e664b5784e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d6108ba8c402cb8016e664b5784e80">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="a8cca5231ff7537fe525294ce5422e90f" name="a8cca5231ff7537fe525294ce5422e90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cca5231ff7537fe525294ce5422e90f">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5cb264f9f540a71533305b4a403be2c0">const_reference</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling front on an empty container causes undefined behavior. </dd></dl>

</div>
</div>
<a id="a2c80a2e52bd99102b679fe1df0c752a4" name="a2c80a2e52bd99102b679fe1df0c752a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c80a2e52bd99102b679fe1df0c752a4">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a88eae17c8c5a4a35346476a34db53058">allocator_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="af3bc6b8e3564ea9800b39a224d55b5e8" name="af3bc6b8e3564ea9800b39a224d55b5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bc6b8e3564ea9800b39a224d55b5e8">&#9670;&#160;</a></span>get_base_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::get_base_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type. </dd></dl>

</div>
</div>
<a id="a51edb8469c934f7106889ea9deee83ff" name="a51edb8469c934f7106889ea9deee83ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51edb8469c934f7106889ea9deee83ff">&#9670;&#160;</a></span>get_base_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::get_base_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type. </dd></dl>

</div>
</div>
<a id="a2075fdcb75059f15477167b414413018" name="a2075fdcb75059f15477167b414413018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2075fdcb75059f15477167b414413018">&#9670;&#160;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; type_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements at the specified location in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the iterator before which the content will be inserted (pos may be the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">end()</a> iterator). </td></tr>
    <tr><td class="paramname">items</td><td>The initializer list to insert the values from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the first element inserted, or <code>pos</code> if <code>items</code> is empty. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code> before pos. </dd>
<dd>
Inserts elements from initializer list <code>items</code> before <code>pos</code>. </dd></dl>

</div>
</div>
<a id="ab9e14b9f52370ea4fa70453d86c84695" name="ab9e14b9f52370ea4fa70453d86c84695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e14b9f52370ea4fa70453d86c84695">&#9670;&#160;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements at the specified location in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the iterator before which the content will be inserted (pos may be the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">end()</a> iterator). </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the inserted <code>value</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code> before pos. </dd>
<dd>
If after the operation the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and all references to the elements are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. </dd></dl>

</div>
</div>
<a id="aead592fd9396cdf3e2badc93a04cfe11" name="aead592fd9396cdf3e2badc93a04cfe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead592fd9396cdf3e2badc93a04cfe11">&#9670;&#160;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const type_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements at the specified location in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the iterator before which the content will be inserted (pos may be the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">end()</a> iterator). </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the inserted <code>value</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code> before pos. </dd>
<dd>
If after the operation the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and all references to the elements are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. </dd></dl>

</div>
</div>
<a id="a3293d1d86f22dbc07dcb2302f8b362f1" name="a3293d1d86f22dbc07dcb2302f8b362f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3293d1d86f22dbc07dcb2302f8b362f1">&#9670;&#160;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements at the specified location in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first range of elements to insert, cannot be iterators into container for which insert is called </td></tr>
    <tr><td class="paramname">last</td><td>The last range of elements to insert, cannot be iterators into container for which insert is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the first element inserted, or <code>pos</code> if <code>first == last</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from range [<code>first</code>, <code>last</code>) before <code>pos</code>. </dd>
<dd>
If <code>first</code> and <code>last</code> are iterators into <code>*this</code>, the behavior is undefined. </dd>
<dd>
If after the operation the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and all references to the elements are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. </dd></dl>

</div>
</div>
<a id="a186991b32a89208f1605be429c2d421d" name="a186991b32a89208f1605be429c2d421d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186991b32a89208f1605be429c2d421d">&#9670;&#160;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#ae39fd00c2f363da57190c4cd2d900b5e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa80ac142ebe558540a122fcb1743534f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const type_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements at the specified location in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the iterator before which the content will be inserted (pos may be the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">end()</a> iterator). </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the first element inserted, or <code>pos</code> if <code>count == 0</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Iterator pointing to the first element inserted, or <code>pos</code> if <code>count == 0</code>. </dd>
<dd>
If after the operation the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and all references to the elements are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. </dd></dl>

</div>
</div>
<a id="af9860bdee2e4839e177a081597e92c1f" name="af9860bdee2e4839e177a081597e92c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9860bdee2e4839e177a081597e92c1f">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa4b3ceaeef797791b084558ffa9c3301" title="Returns an iterator to the first element of the vector.">xtd::collections::generic::list::begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a>) for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

</div>
</div>
<a id="a7b13f930e7e7e230e900a945589d427b" name="a7b13f930e7e7e230e900a945589d427b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b13f930e7e7e230e900a945589d427b">&#9670;&#160;</a></span>operator base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::operator <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlyong base type. </dd></dl>

</div>
</div>
<a id="a7da38c0256afa5522c2736b05697f308" name="a7da38c0256afa5522c2736b05697f308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da38c0256afa5522c2736b05697f308">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::operator const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a6ece889cd67b8cc0980dc198f7e17763">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlyong base type. </dd></dl>

</div>
</div>
<a id="a7b5ac93e35bacea9282c4397be0a2978" name="a7b5ac93e35bacea9282c4397be0a2978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5ac93e35bacea9282c4397be0a2978">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>&lt; type_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another base type container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a22d70762d7b206c20fbaa4472bcc1a6a" name="a22d70762d7b206c20fbaa4472bcc1a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d70762d7b206c20fbaa4472bcc1a6a">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>&lt; type_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a1d1ea1cdcbadfa958cc045b97284897c" name="a1d1ea1cdcbadfa958cc045b97284897c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1ea1cdcbadfa958cc045b97284897c">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; type_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list ilist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>Initializer list to use as data source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a00ff0a5da39a22f356f091a950c1c69b" name="a00ff0a5da39a22f356f091a950c1c69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ff0a5da39a22f356f091a950c1c69b">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5de1351dfee4c745490cdf929d0cdcd3">reference</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>No bounds checking is performed. </dd></dl>

</div>
</div>
<a id="a855ae51cd2ee2fc5b8af9245d0398125" name="a855ae51cd2ee2fc5b8af9245d0398125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855ae51cd2ee2fc5b8af9245d0398125">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a5cb264f9f540a71533305b4a403be2c0">const_reference</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>No bounds checking is performed. </dd></dl>

</div>
</div>
<a id="aca27f004245b0f208dc16fc6a92669a6" name="aca27f004245b0f208dc16fc6a92669a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca27f004245b0f208dc16fc6a92669a6">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Calling pop_back on an empty container results in undefined behavior. </dd>
<dd>
Iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and references to the last element are invalidated. </dd></dl>

</div>
</div>
<a id="acc90be2133e3e24f145838dd97a09dc6" name="acc90be2133e3e24f145838dd97a09dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc90be2133e3e24f145838dd97a09dc6">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const type_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value of the element to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If after the operation the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and all references to the elements are invalidated. Otherwise only the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator is invalidated. </dd>
<dd>
The new element is initialized as a copy of <code>value</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="boxing_8cpp-example.html#a3">boxing.cpp</a>, <a class="el" href="console_firework_8cpp-example.html#a5">console_firework.cpp</a>, and <a class="el" href="file_info_move_to_8cpp-example.html#a8">file_info_move_to.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab186b6bea9e2d2f68fa4b3297be4b601" name="ab186b6bea9e2d2f68fa4b3297be4b601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab186b6bea9e2d2f68fa4b3297be4b601">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value of the element to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If after the operation the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a> is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> a reallocation takes place, in which case all iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and all references to the elements are invalidated. Otherwise only the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator is invalidated. </dd>
<dd>
<code>value</code> is moved into the new element. </dd></dl>

</div>
</div>
<a id="a180ebc6d766b39f4d2d75673cb5d2d4a" name="a180ebc6d766b39f4d2d75673cb5d2d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180ebc6d766b39f4d2d75673cb5d2d4a">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04c42bd12dbb9c48dd4a4ee55fed2224">const_reverse_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255" title="Returns a reverse iterator to the element following the last element of the reversed vector....">xtd::collections::generic::list::rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255" title="Returns a reverse iterator to the element following the last element of the reversed vector....">xtd::collections::generic::list::rend()</a>. </dd></dl>

</div>
</div>
<a id="ab53711446f96fac038f5c5a1f162af06" name="ab53711446f96fac038f5c5a1f162af06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53711446f96fac038f5c5a1f162af06">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa99b6f04636ae59a117180738a566f44">reverse_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed vector. It corresponds to the last element of the non-reversed vector. If the vector is empty, the returned iterator is equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255" title="Returns a reverse iterator to the element following the last element of the reversed vector....">xtd::collections::generic::list::rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the vector is empty, the returned iterator will be equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa786fa60f8ea7706cea5b9166ee07255" title="Returns a reverse iterator to the element following the last element of the reversed vector....">xtd::collections::generic::list::rend()</a>. </dd></dl>

</div>
</div>
<a id="aa7b8f1b28dc656c5eae143d02e842078" name="aa7b8f1b28dc656c5eae143d02e842078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b8f1b28dc656c5eae143d02e842078">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a04c42bd12dbb9c48dd4a4ee55fed2224">const_reverse_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="aa786fa60f8ea7706cea5b9166ee07255" name="aa786fa60f8ea7706cea5b9166ee07255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa786fa60f8ea7706cea5b9166ee07255">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa99b6f04636ae59a117180738a566f44">reverse_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed vector. It corresponds to the element preceding the first element of the non-reversed vector. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This element acts as a placeholder; attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a89e3e7a03550cba08f21ac3ad4baebff" name="a89e3e7a03550cba08f21ac3ad4baebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e3e7a03550cba08f21ac3ad4baebff">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>. @param count The new size of the container. @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. @remarks If the current size is less than</code>count`, additional default-inserted elements are appended. </p>

</div>
</div>
<a id="ad74eff05fa1b43c834ea87353e77fb25" name="ad74eff05fa1b43c834ea87353e77fb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74eff05fa1b43c834ea87353e77fb25">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a19654ead074894e64f01f9cc0f3c382a">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain <code>count</code> elements, does nothing if <code>count == <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>. @param count The new size of the container. @param value The value to initialize the new elements with. @remarks If the current size is greater than</code>count<code>, the container is reduced to its first</code>count<code>elements. @remarks If the current size is less than</code>count<code>, additional copies of</code>value` are appended. </p>

</div>
</div>
<a id="a693c87531b94daaa0f795f38be867de2" name="a693c87531b94daaa0f795f38be867de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693c87531b94daaa0f795f38be867de2">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>
<dl class="section remark"><dt>Remarks</dt><dd>It is a non-binding request to reduce <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#abd90dae167087e0bd1256a6c8efcfab6" title="Returns the number of elements that the container has currently allocated space for.">xtd::collections::generic::list::capacity()</a> to <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a026e87f9ceab793d1046c84aab312132" title="Returns the number of elements in the container, i.e. std::distance(xtd::collections::generic::list::...">xtd::collections::generic::list::size()</a>. It depends on the implementation whether the request is fulfilled. </dd>
<dd>
If reallocation occurs, all iterators (including the <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator) and all references to the elements are invalidated. If no reallocation occurs, no iterators or references are invalidated. </dd></dl>

</div>
</div>
<a id="a026e87f9ceab793d1046c84aab312132" name="a026e87f9ceab793d1046c84aab312132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026e87f9ceab793d1046c84aab312132">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90417139ac25cf11819dddac5b1673fd">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#aa4b3ceaeef797791b084558ffa9c3301" title="Returns an iterator to the first element of the vector.">xtd::collections::generic::list::begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="border_style_8cpp-example.html#a10">border_style.cpp</a>, <a class="el" href="calculator_8cpp-example.html#a6">calculator.cpp</a>, <a class="el" href="default_trace_listener_8cpp-example.html#a1">default_trace_listener.cpp</a>, <a class="el" href="environment_exit_8cpp-example.html#a1">environment_exit.cpp</a>, <a class="el" href="environment_program_exit_8cpp-example.html#a3">environment_program_exit.cpp</a>, <a class="el" href="font_families_8cpp-example.html#a2">font_families.cpp</a>, <a class="el" href="ip_address_8cpp-example.html#a1">ip_address.cpp</a>, <a class="el" href="labels_and_unicode_text_8cpp-example.html#a3">labels_and_unicode_text.cpp</a>, <a class="el" href="main_8cpp-example.html#a1">main.cpp</a>, <a class="el" href="udp_client_ip_v4_8cpp-example.html#a5">udp_client_ip_v4.cpp</a>, and <a class="el" href="udp_client_ip_v6_8cpp-example.html#a5">udp_client_ip_v6.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8e20819dec1ddbd4fe1da58a125e80af" name="a8e20819dec1ddbd4fe1da58a125e80af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e20819dec1ddbd4fe1da58a125e80af">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a>&lt; type_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents and capacity of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </p>
<dl class="section remark"><dt>Remarks</dt><dd>All iterators and references remain valid. The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html#a90ee18bd2e89c978d30fe01129f66c0f" title="Returns an iterator to the element following the last element of the vector.">xtd::collections::generic::list::end()</a> iterator is invalidated. </dd></dl>

</div>
</div>
<a id="adcd3bf5bec705bee0bf926a6be15220b" name="adcd3bf5bec705bee0bf926a6be15220b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd3bf5bec705bee0bf926a6be15220b">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classxtd_1_1ustring.html" title="Represents text as a sequence of UTF-8 code units.">xtd::ustring</a> that represents the current object. </p>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the current object. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates what to_string returns. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>examples {</div>
<div class="line">  <span class="keyword">namespace </span>object_test {</div>
<div class="line">    <span class="keyword">class </span>object1 : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_typedef" href="group__types.html#ga14f390dd1d27bfab4cc2f26c1502c8ec">ptr&lt;object&gt;</a> obj1 = new_ptr&lt;examples::object_test::object1&gt;();</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(obj1-&gt;to_string());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="group__types.html#ga14f390dd1d27bfab4cc2f26c1502c8ec">ptr&lt;object&gt;</a> obj2 = new_ptr&lt;date_time&gt;(1971, 1, 5, 23, 5, 0);</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(obj2-&gt;to_string());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="group__types.html#ga14f390dd1d27bfab4cc2f26c1502c8ec">ptr&lt;object&gt;</a> obj3 = new_ptr&lt;boolean_object&gt;();</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(obj3-&gt;to_string());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// examples::object_test::object1</span></div>
<div class="line"><span class="comment">// Tue Jan  5 23:05:00 1971</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="agroup__types_html_ga14f390dd1d27bfab4cc2f26c1502c8ec"><div class="ttname"><a href="group__types.html#ga14f390dd1d27bfab4cc2f26c1502c8ec">xtd::ptr</a></div><div class="ttdeci">xtd::sptr&lt; type_t &gt; ptr</div><div class="ttdoc">The xtd::ptr object is a shared pointer.</div><div class="ttdef"><b>Definition</b> ptr.h:27</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.h:10</div></div>
</div><!-- fragment --> </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">xtd::object</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/collections/generic/<a class="el" href="list_8h_source.html">list.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 27 2024 23:41:59 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
