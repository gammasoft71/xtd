<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::thread_pool Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classxtd_1_1threading_1_1thread__pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classxtd_1_1threading_1_1thread__pool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::thread_pool Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">﹡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::thread_pool:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1thread__pool.png" usemap="#xtd::threading::thread_5Fpool_map" alt=""/>
  <map id="xtd::threading::thread_5Fpool_map" name="xtd::threading::thread_5Fpool_map">
<area href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted)." alt="xtd::static_object" shape="rect" coords="0,0,160,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords_gabc8f9c2aa36f6cee610a37f0e8227fd1.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_class" href="classxtd_1_1threading_1_1thread__pool.html">thread_pool</a> <a class="code hl_define" href="group__keywords_ga28796443ec37b938df7072c79595e3f6.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread__pool_html"><div class="ttname"><a href="classxtd_1_1threading_1_1thread__pool.html">xtd::threading::thread_pool</a></div><div class="ttdoc">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...</div><div class="ttdef"><b>Definition</b> thread_pool.h:52</div></div>
<div class="ttc" id="agroup__keywords_ga28796443ec37b938df7072c79595e3f6_html_ga28796443ec37b938df7072c79595e3f6"><div class="ttname"><a href="group__keywords_ga28796443ec37b938df7072c79595e3f6.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div><div class="ttdeci">#define static_</div><div class="ttdoc">This keyword is use to represent a static object. A static object can't be instantiated (constructors...</div><div class="ttdef"><b>Definition</b> static.h:37</div></div>
<div class="ttc" id="agroup__keywords_gabc8f9c2aa36f6cee610a37f0e8227fd1_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords_gabc8f9c2aa36f6cee610a37f0e8227fd1.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.h:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted).">xtd::static_object</a> → <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread_pool&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>In the following example, the main application thread queues a method named ThreadProc to execute on a thread pool thread, sleeps for one second, and then exits. The ThreadProc method simply displays a message. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/auto_reset_event&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread_pool&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/date_time&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/random&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/startup&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1threading.html">xtd::threading</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>wait_handle_example {</div>
<div class="line">  <span class="keyword">class </span>program {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">      <span class="comment">// Queue the task.</span></div>
<div class="line">      thread_pool::queue_user_work_item({thread_proc});</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;Main thread does some work, then sleeps.&quot;</span>);</div>
<div class="line">      thread::sleep(1000);</div>
<div class="line">      </div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;Main thread exits.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// This thread procedure performs the task.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc(std::any state_info) {</div>
<div class="line">      <span class="comment">// No state object was passed to queue_user_work_item, so state_info has no value.</span></div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;Hello from the thread pool.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords_ga44bd440a34d147923e428eacd1c8eedd.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(wait_handle_example::program::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example produces output similar to the following:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Main thread does some work, then sleeps.</span></div>
<div class="line"><span class="comment">// Hello from the thread pool.</span></div>
<div class="line"><span class="comment">// Main thread exits.</span></div>
<div class="ttc" id="agroup__keywords_ga44bd440a34d147923e428eacd1c8eedd_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords_ga44bd440a34d147923e428eacd1c8eedd.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.h:175</div></div>
<div class="ttc" id="anamespacextd_1_1threading_html"><div class="ttname"><a href="namespacextd_1_1threading.html">xtd::threading</a></div><div class="ttdoc">The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....</div><div class="ttdef"><b>Definition</b> abandoned_mutex_exception.h:10</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.h:10</div></div>
</div><!-- fragment --> If you comment out the call to the <a class="el" href="classxtd_1_1threading_1_1thread_a42bc6e2bb805f928e50ae73d243b95f2.html#a42bc6e2bb805f928e50ae73d243b95f2" title="Suspends the current thread for a specified time.">xtd::threading::thread::sleep</a> method, the main thread exits before method runs on the thread pool thread. The thread pool uses background threads, which do not keep the application running if all foreground threads have terminated. (This is a simple example of a race condition.) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur. Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information. The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system. Examples of operations that use thread pool threads include the following:<ul>
<li>When you create a xtd::threading::task::task or xtd::threading::task::task &lt; result_t &gt; object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</li>
<li>Asynchronous timers use the thread pool. Thread pool threads execute callbacks from the <a class="el" href="classxtd_1_1threading_1_1timer.html" title="Provides a mechanism for executing a method on a thread pool thread at specified intervals....">xtd::threading::timer</a> class and raise events from the <a class="el" href="classxtd_1_1timers_1_1timer.html" title="Generates an event after a set interval, with an option to generate recurring events.">xtd::timers::timer</a> class.</li>
<li>When you use registered wait handles, a system thread monitors the status of the wait handles. When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</li>
<li>When you call the <a class="el" href="classxtd_1_1threading_1_1thread__pool_a6e1d511cd1dbe0a07b98128042118f3c.html#a6e1d511cd1dbe0a07b98128042118f3c" title="Queues a method for execution. The method executes when a thread pool thread becomes available.">xtd::threading::thread_pool::queue_user_work_item</a> method to queue a method for execution on a thread pool thread. You do this by passing the method a <a class="el" href="group__xtd__core_ga8e591282c14ed5ae0c0038b503b1373d.html#ga8e591282c14ed5ae0c0038b503b1373d" title="Represents a callback method to be executed by a thread pool thread.">xtd::threading::wait_callback</a> delegate. The delegate has the signature @verbatom using wait_callback = <a class="el" href="group__xtd__core_ga53c721aac682a7ccf19ee17d92280e31.html#ga53c721aac682a7ccf19ee17d92280e31" title="Represents a xtd::delegate that has variable parameters and does not return a value.">action&lt;std::any&gt;</a>  where state is an object that contains data to be used by the delegate. The actual data can be passed to the delegate by calling the xtd::threading::thread_pool::queue_user_work_item(xtd::threading::wait_callback, std::any) method. </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The threads in the managed thread pool are background threads. That is, their <a class="el" href="classxtd_1_1threading_1_1thread_a11f3c0ca7be2108803058899a895193e.html#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> properties are true. This means that a <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> thread will not keep an application running after all foreground threads have exited. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>You can also queue work items that are not related to a wait operation to the thread pool. To request that a work item be handled by a thread in the thread pool, call the <a class="el" href="classxtd_1_1threading_1_1thread__pool_a6e1d511cd1dbe0a07b98128042118f3c.html#a6e1d511cd1dbe0a07b98128042118f3c" title="Queues a method for execution. The method executes when a thread pool thread becomes available.">xtd::threading::thread_pool::queue_user_work_item</a> method. This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool. There is no way to cancel a work item after it has been queued. </dd>
<dd>
Timer-queue timers and registered wait operations also use the thread pool. Their callback functions are queued to the thread pool. </dd>
<dd>
There is one thread pool per process.The default size of the thread pool for a process depends on several factors, such as the size of the virtual address space. A process can call the xtd::threading::thread_pool::gt_max_threads method to determine the number of threads. The number of threads in the thread pool can be changed by using the <a class="el" href="classxtd_1_1threading_1_1thread__pool_a35f26921fd206db30d10595147869ac5.html#a35f26921fd206db30d10595147869ac5" title="Sets the number of requests to the thread pool that can be active concurrently. All requests above th...">xtd::threading::thread_pool::set_max_threads</a> method. Each thread uses the default stack size and runs at the default priority. </dd>
<dd>
The thread pool provides new worker threads or I/O completion threads on demand until it reaches the maximum for each category. When a maximum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. The thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When demand is low, the actual number of thread pool threads can fall below the minimum values. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>You can use the <a class="el" href="classxtd_1_1threading_1_1thread__pool_a9d286fb4b631f16224678853d0f86669.html#a9d286fb4b631f16224678853d0f86669" title="Retrieves the number of idle threads the thread pool maintains in anticipation of new requests....">xtd::threading::thread_pool::get_min_threads</a> method to obtain these minimum values. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You can use the <a class="el" href="classxtd_1_1threading_1_1thread__pool_a5c3b43e653cf43209dcc846c4f2070f9.html#a5c3b43e653cf43209dcc846c4f2070f9" title="Sets the number of idle threads the thread pool maintains in anticipation of new requests.">xtd::threading::thread_pool::set_min_threads</a> method to increase the minimum number of threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:a67c0921c9e154215c14cf459b9d0f3ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a67c0921c9e154215c14cf459b9d0f3ed.html#a67c0921c9e154215c14cf459b9d0f3ed">close</a> ()</td></tr>
<tr class="memdesc:a67c0921c9e154215c14cf459b9d0f3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all resources and worker threads.  <br /></td></tr>
<tr class="separator:a67c0921c9e154215c14cf459b9d0f3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac881c038fd40c50b3e05f885dceb4a22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_ac881c038fd40c50b3e05f885dceb4a22.html#ac881c038fd40c50b3e05f885dceb4a22">get_available_threads</a> (size_t &amp;worker_threads, size_t &amp;completion_port_threads)</td></tr>
<tr class="memdesc:ac881c038fd40c50b3e05f885dceb4a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the difference between the maximum number of thread pool threads returned by the GetMaxThreads method, and the number currently active.  <br /></td></tr>
<tr class="separator:ac881c038fd40c50b3e05f885dceb4a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69068aac907ee0c13a7e4cd699c09c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_af69068aac907ee0c13a7e4cd699c09c7.html#af69068aac907ee0c13a7e4cd699c09c7">get_max_threads</a> (size_t &amp;worker_threads, size_t &amp;completion_port_threads)</td></tr>
<tr class="memdesc:af69068aac907ee0c13a7e4cd699c09c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.  <br /></td></tr>
<tr class="separator:af69068aac907ee0c13a7e4cd699c09c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d286fb4b631f16224678853d0f86669"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a9d286fb4b631f16224678853d0f86669.html#a9d286fb4b631f16224678853d0f86669">get_min_threads</a> (size_t &amp;worker_threads, size_t &amp;completion_port_threads)</td></tr>
<tr class="memdesc:a9d286fb4b631f16224678853d0f86669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of idle threads the thread pool maintains in anticipation of new requests. Always 0 for both.  <br /></td></tr>
<tr class="separator:a9d286fb4b631f16224678853d0f86669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448cec08735d8f22c79b2acb832130f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a448cec08735d8f22c79b2acb832130f9.html#a448cec08735d8f22c79b2acb832130f9">join_all</a> ()</td></tr>
<tr class="memdesc:a448cec08735d8f22c79b2acb832130f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join all resources and worker threads.  <br /></td></tr>
<tr class="separator:a448cec08735d8f22c79b2acb832130f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46511ae8bfea10f66ee96fb3b9cf3374"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a46511ae8bfea10f66ee96fb3b9cf3374.html#a46511ae8bfea10f66ee96fb3b9cf3374">join_all</a> (<a class="el" href="group__types_ga205462e259a4eca1545511085c2c350e.html#ga205462e259a4eca1545511085c2c350e">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a46511ae8bfea10f66ee96fb3b9cf3374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join all resources and worker threads.  <br /></td></tr>
<tr class="separator:a46511ae8bfea10f66ee96fb3b9cf3374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da6db77a7e9173bd1db7c1e8122c10d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a5da6db77a7e9173bd1db7c1e8122c10d.html#a5da6db77a7e9173bd1db7c1e8122c10d">join_all</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a5da6db77a7e9173bd1db7c1e8122c10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join all resources and worker threads.  <br /></td></tr>
<tr class="separator:a5da6db77a7e9173bd1db7c1e8122c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1d511cd1dbe0a07b98128042118f3c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a6e1d511cd1dbe0a07b98128042118f3c.html#a6e1d511cd1dbe0a07b98128042118f3c">queue_user_work_item</a> (const <a class="el" href="group__xtd__core_ga8e591282c14ed5ae0c0038b503b1373d.html#ga8e591282c14ed5ae0c0038b503b1373d">wait_callback</a> &amp;callback)</td></tr>
<tr class="memdesc:a6e1d511cd1dbe0a07b98128042118f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a method for execution. The method executes when a thread pool thread becomes available.  <br /></td></tr>
<tr class="separator:a6e1d511cd1dbe0a07b98128042118f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495589d2c33d3b82fa4e8478a2082088"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a495589d2c33d3b82fa4e8478a2082088.html#a495589d2c33d3b82fa4e8478a2082088">queue_user_work_item</a> (const <a class="el" href="group__xtd__core_ga8e591282c14ed5ae0c0038b503b1373d.html#ga8e591282c14ed5ae0c0038b503b1373d">wait_callback</a> &amp;callback, std::any state)</td></tr>
<tr class="memdesc:a495589d2c33d3b82fa4e8478a2082088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a method for execution. The method executes when a thread pool thread becomes available.  <br /></td></tr>
<tr class="separator:a495589d2c33d3b82fa4e8478a2082088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cce31828de40647b89320b2ace3a5e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a21cce31828de40647b89320b2ace3a5e.html#a21cce31828de40647b89320b2ace3a5e">register_wait_for_single_object</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;wait_object, const <a class="el" href="group__xtd__core_gae8743c04a110382ce68fbd35eef2f782.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;callback, std::any state, <a class="el" href="group__types_ga205462e259a4eca1545511085c2c350e.html#ga205462e259a4eca1545511085c2c350e">int32</a> milliseconds_timeout_interval, bool execute_only_once)</td></tr>
<tr class="memdesc:a21cce31828de40647b89320b2ace3a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.  <br /></td></tr>
<tr class="separator:a21cce31828de40647b89320b2ace3a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a112c7bc6718335fd075cccd2dd1af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_ac3a112c7bc6718335fd075cccd2dd1af.html#ac3a112c7bc6718335fd075cccd2dd1af">register_wait_for_single_object</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;wait_object, const <a class="el" href="group__xtd__core_gae8743c04a110382ce68fbd35eef2f782.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;callback, std::any state, <a class="el" href="group__types_ga2f2888f55e58cac4c07eb490db7868c4.html#ga2f2888f55e58cac4c07eb490db7868c4">int64</a> milliseconds_timeout_interval, bool execute_only_once)</td></tr>
<tr class="memdesc:ac3a112c7bc6718335fd075cccd2dd1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.  <br /></td></tr>
<tr class="separator:ac3a112c7bc6718335fd075cccd2dd1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923290b27e20898255ee9d38b4bfd2ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a923290b27e20898255ee9d38b4bfd2ed.html#a923290b27e20898255ee9d38b4bfd2ed">register_wait_for_single_object</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;wait_object, const <a class="el" href="group__xtd__core_gae8743c04a110382ce68fbd35eef2f782.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;callback, std::any state, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>, bool execute_only_once)</td></tr>
<tr class="memdesc:a923290b27e20898255ee9d38b4bfd2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.  <br /></td></tr>
<tr class="separator:a923290b27e20898255ee9d38b4bfd2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4005a0a841c8b79f8a687c881b9baaeb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a4005a0a841c8b79f8a687c881b9baaeb.html#a4005a0a841c8b79f8a687c881b9baaeb">register_wait_for_single_object</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;wait_object, const <a class="el" href="group__xtd__core_gae8743c04a110382ce68fbd35eef2f782.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;callback, std::any state, <a class="el" href="group__types_ga41c5d8b5d999ac5a2ff06fe57f38d5f5.html#ga41c5d8b5d999ac5a2ff06fe57f38d5f5">uint32</a> milliseconds_timeout_interval, bool execute_only_once)</td></tr>
<tr class="memdesc:a4005a0a841c8b79f8a687c881b9baaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.  <br /></td></tr>
<tr class="separator:a4005a0a841c8b79f8a687c881b9baaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f26921fd206db30d10595147869ac5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a35f26921fd206db30d10595147869ac5.html#a35f26921fd206db30d10595147869ac5">set_max_threads</a> (size_t worker_threads, size_t completion_port_threads)</td></tr>
<tr class="memdesc:a35f26921fd206db30d10595147869ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.  <br /></td></tr>
<tr class="separator:a35f26921fd206db30d10595147869ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3b43e653cf43209dcc846c4f2070f9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool_a5c3b43e653cf43209dcc846c4f2070f9.html#a5c3b43e653cf43209dcc846c4f2070f9">set_min_threads</a> (size_t worker_threads, size_t completion_port_threads)</td></tr>
<tr class="memdesc:a5c3b43e653cf43209dcc846c4f2070f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of idle threads the thread pool maintains in anticipation of new requests.  <br /></td></tr>
<tr class="separator:a5c3b43e653cf43209dcc846c4f2070f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="thread__pool_8h_source.html">thread_pool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html">thread_pool</a></li>
		<li class="footer">Generated on Sun Aug 4 2024 14:27:50 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
