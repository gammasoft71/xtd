<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::lock Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1lock.html">lock</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1threading_1_1lock-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::lock Class Reference<span class="mlabels"><span class="mlabel final">final</span></span><div class="ingroups"><a class="el" href="group__libraries.html">﹡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::lock:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1lock.png" usemap="#xtd::threading::lock_map" alt=""/>
  <map id="xtd::threading::lock_map" name="xtd::threading::lock_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,116,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a mechanism that synchronizes access to objects with <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a>. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_function" href="#aa08652a62b9d79bd961bcb9998ea4b8b">lock</a> final : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1lock_html_aa08652a62b9d79bd961bcb9998ea4b8b"><div class="ttname"><a href="#aa08652a62b9d79bd961bcb9998ea4b8b">xtd::threading::lock::lock</a></div><div class="ttdeci">lock(const object_t &amp;obj)</div><div class="ttdoc">Create a xtd::threading::lock object and acquires an exclusive lock on the specified obj.</div><div class="ttdef"><b>Definition</b> lock.hpp:41</div></div>
<div class="ttc" id="agroup__keywords_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.hpp:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> → xtd::lock </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/lock&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example uses the <a class="el" href="classxtd_1_1threading_1_1lock.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock</a> class to synchronize access to a single instance of a random number generator represented by the <a class="el" href="classxtd_1_1random.html" title="Represents a pseudo-random number generator, a device that produces a sequence of numbers that meet c...">xtd::random</a> class. The example creates ten threads, each of which executes asynchronously on a thread pool thread. Each thread generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum. After all threads have executed, these two values are then used to calculate the overall mean. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>examples {</div>
<div class="line">  <span class="keyword">class </span>account : <span class="keyword">public</span> <a class="code hl_function" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> account(<span class="keywordtype">int</span> initial) : balance(initial) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> do_transactions() {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> = 0; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> &lt; 100; ++<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>)</div>
<div class="line">        withdraw(<a class="code hl_class" href="classxtd_1_1random.html">random</a>.<a class="code hl_function" href="classxtd_1_1random.html#a629a30d5ddd8035f45afe7d982fda712">next</a>(1, 100));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">int</span> withdraw(<span class="keywordtype">int</span> amount) {</div>
<div class="line">      <span class="comment">// This condition never is true unless the lock statement is commented out.</span></div>
<div class="line">      <span class="keywordflow">if</span> (balance &lt; 0) <span class="keywordflow">throw</span> <a class="code hl_class" href="classxtd_1_1system__exception.html">system_exception</a> {<span class="stringliteral">&quot;Negative Balance&quot;</span>};</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Comment out the next line to see the effect of leaving out the lock keyword.</span></div>
<div class="line">      <a class="code hl_define" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a>(balance) {</div>
<div class="line">        <span class="keywordflow">if</span> (balance &lt; amount) <span class="keywordflow">return</span> 0;</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;Balance before Withdrawal :  {0}&quot;</span>, balance);</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;Amount to Withdraw        : -{0}&quot;</span>, amount);</div>
<div class="line">        balance = balance - amount;</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;Balance after Withdrawal  :  {0}&quot;</span>, balance);</div>
<div class="line">        <span class="keywordflow">return</span> amount;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> balance = 0;</div>
<div class="line">    xtd::random random;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">class </span>program {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">      <span class="keyword">auto</span> account = examples::account {1000};</div>
<div class="line">      </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> &lt; 10; ++<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>)</div>
<div class="line">        thread_pool::queue_user_work_item({account, &amp;account::do_transactions});</div>
<div class="line">      </div>
<div class="line">      thread_pool::close();</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(examples::program::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code can produce the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  1000</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -75</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  925</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  925</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -84</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  841</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  841</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -69</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  772</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  772</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -71</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  701</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  701</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -84</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  617</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  617</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -81</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  536</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  536</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -15</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  521</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  521</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -93</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  428</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  428</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -6</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  422</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  422</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -54</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  368</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  368</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -52</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  316</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  316</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -67</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  249</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  249</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -93</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  156</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  156</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -60</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  96</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  96</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -7</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  89</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  89</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -42</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  47</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  47</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -1</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  46</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  46</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -22</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  24</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  24</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -18</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  6</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  6</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -2</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  4</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  4</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -2</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  2</span></div>
<div class="line"><span class="comment">// Balance before Withdrawal :  2</span></div>
<div class="line"><span class="comment">// Amount to Withdraw        : -2</span></div>
<div class="line"><span class="comment">// Balance after Withdrawal  :  0</span></div>
<div class="ttc" id="aclassxtd_1_1object_html_ad2cab851376bb6ca085b567bf5da0f5f"><div class="ttname"><a href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">xtd::object::object</a></div><div class="ttdeci">object()=default</div><div class="ttdoc">Create a new instance of the ultimate base class object.</div></div>
<div class="ttc" id="aclassxtd_1_1random_html"><div class="ttname"><a href="classxtd_1_1random.html">xtd::random</a></div><div class="ttdoc">Represents a pseudo-random number generator, a device that produces a sequence of numbers that meet c...</div><div class="ttdef"><b>Definition</b> random.hpp:44</div></div>
<div class="ttc" id="aclassxtd_1_1random_html_a629a30d5ddd8035f45afe7d982fda712"><div class="ttname"><a href="classxtd_1_1random.html#a629a30d5ddd8035f45afe7d982fda712">xtd::random::next</a></div><div class="ttdeci">virtual int32 next() const</div><div class="ttdoc">Returns a nonnegative random number.</div></div>
<div class="ttc" id="aclassxtd_1_1system__exception_html"><div class="ttname"><a href="classxtd_1_1system__exception.html">xtd::system_exception</a></div><div class="ttdoc">The exception that is thrown when a method call is invalid for the object&#39;s current state.</div><div class="ttdef"><b>Definition</b> system_exception.hpp:18</div></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.hpp:168</div></div>
<div class="ttc" id="agroup__keywords_html_gacd9906b29d877eb1eb0a8c7bc4ab774a"><div class="ttname"><a href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a></div><div class="ttdeci">#define lock_(object)</div><div class="ttdoc">The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...</div><div class="ttdef"><b>Definition</b> lock.hpp:67</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">xtd::console_key::i</a></div><div class="ttdeci">@ i</div><div class="ttdoc">The I key.</div><div class="ttdef"><b>Definition</b> console_key.hpp:104</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>See <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> for more information. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:aa08652a62b9d79bd961bcb9998ea4b8b" id="r_aa08652a62b9d79bd961bcb9998ea4b8b"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:aa08652a62b9d79bd961bcb9998ea4b8b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa08652a62b9d79bd961bcb9998ea4b8b">lock</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:aa08652a62b9d79bd961bcb9998ea4b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classxtd_1_1threading_1_1lock.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock</a> object and acquires an exclusive lock on the specified obj.  <br /></td></tr>
<tr class="separator:aa08652a62b9d79bd961bcb9998ea4b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a830ce5455ae09643f3d85c7063bbd86d" id="r_a830ce5455ae09643f3d85c7063bbd86d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a830ce5455ae09643f3d85c7063bbd86d">pulse</a> ()</td></tr>
<tr class="memdesc:a830ce5455ae09643f3d85c7063bbd86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a thread in the waiting queue of a change in the locked object's state.  <br /></td></tr>
<tr class="separator:a830ce5455ae09643f3d85c7063bbd86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e0ca04c2aaba831b0dc99df23eaa57" id="r_aa2e0ca04c2aaba831b0dc99df23eaa57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2e0ca04c2aaba831b0dc99df23eaa57">pulse_all</a> ()</td></tr>
<tr class="memdesc:aa2e0ca04c2aaba831b0dc99df23eaa57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies all waiting threads of a change in the object's state.  <br /></td></tr>
<tr class="separator:aa2e0ca04c2aaba831b0dc99df23eaa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815dcc8e9b36f64c518f56170a6feb41" id="r_a815dcc8e9b36f64c518f56170a6feb41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a815dcc8e9b36f64c518f56170a6feb41">wait</a> (<a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a815dcc8e9b36f64c518f56170a6feb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.  <br /></td></tr>
<tr class="separator:a815dcc8e9b36f64c518f56170a6feb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947cbc0eae2c7b35938d342fd3915b6d" id="r_a947cbc0eae2c7b35938d342fd3915b6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a947cbc0eae2c7b35938d342fd3915b6d">wait</a> (const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a947cbc0eae2c7b35938d342fd3915b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.  <br /></td></tr>
<tr class="separator:a947cbc0eae2c7b35938d342fd3915b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab676bb9c5b09a88e772333ce4ca00afa" id="r_ab676bb9c5b09a88e772333ce4ca00afa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab676bb9c5b09a88e772333ce4ca00afa">wait</a> ()</td></tr>
<tr class="memdesc:ab676bb9c5b09a88e772333ce4ca00afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on an object and blocks the current thread until it reacquires the lock.  <br /></td></tr>
<tr class="separator:ab676bb9c5b09a88e772333ce4ca00afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b" id="r_a2743b6f75405882c28eebe2456f3837b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd11aa88ce86568b701b33fd1b3e508" id="r_a6bd11aa88ce86568b701b33fd1b3e508"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a6bd11aa88ce86568b701b33fd1b3e508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a6bd11aa88ce86568b701b33fd1b3e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d19ef177db62351b58a42f22138dbe" id="r_af2d19ef177db62351b58a42f22138dbe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:af2d19ef177db62351b58a42f22138dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:af2d19ef177db62351b58a42f22138dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa08652a62b9d79bd961bcb9998ea4b8b" name="aa08652a62b9d79bd961bcb9998ea4b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08652a62b9d79bd961bcb9998ea4b8b">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::lock::lock </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classxtd_1_1threading_1_1lock.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock</a> object and acquires an exclusive lock on the specified obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the monitor lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When the <a class="el" href="classxtd_1_1threading_1_1lock.html" title="Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.">xtd::threading::lock</a> destroyed it releases the exclusive lock specified in the constructor. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a830ce5455ae09643f3d85c7063bbd86d" name="a830ce5455ae09643f3d85c7063bbd86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830ce5455ae09643f3d85c7063bbd86d">&#9670;&#160;</a></span>pulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::lock::pulse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies a thread in the waiting queue of a change in the locked object's state. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only the current owner of the lock can signal a waiting object using <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock. Upon receiving the pulse, the waiting thread is moved to the ready queue. When the thread that invoked <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class does not maintain state indicating that the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method has been called. Thus, if you call <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> when no threads are waiting, the next thread that calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> blocks as if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> had never been called. If two threads are using <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> and <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> to interact, this could result in a deadlock. Contrast this with the behavior of the <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> class: If you signal an <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> by calling its <a class="el" href="classxtd_1_1threading_1_1event__wait__handle.html#a3254163aa012cb3dc8f99ff16c0c7d6c" title="Sets the state of the event to signaled, allowing one or more waiting threads to proceed.">xtd::threading::event_wait_handle::set</a> method, and there are no threads waiting, the <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> remains in a signaled state until a thread calls <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87" title="Blocks the current thread until the current xtd::threading::wait_handle receives a signal.">xtd::threading::wait_handle::wait_one</a>, <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a>, or <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a217129669f17b6f14201dccd0405450c" title="Waits for all the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_all</a>. The <a class="el" href="classxtd_1_1threading_1_1auto__reset__event.html" title="Represents a thread synchronization event that, when signaled, resets automatically after releasing a...">xtd::threading::auto_reset_event</a> releases that thread and returns to the unsignaled state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd>
<dd>
The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> methods must be invoked from within a synchronized block of code. </dd>
<dd>
To signal multiple threads, use the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. </dd></dl>

</div>
</div>
<a id="aa2e0ca04c2aaba831b0dc99df23eaa57" name="aa2e0ca04c2aaba831b0dc99df23eaa57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e0ca04c2aaba831b0dc99df23eaa57">&#9670;&#160;</a></span>pulse_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::lock::pulse_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies all waiting threads of a change in the object's state. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object. After the signal is sent, the waiting threads are moved to the ready queue. When the thread that invoked xtd::threading::monitor::xtd::threading::monitor::pulse_all releases the lock, the next thread in the ready queue acquires the lock. </dd>
<dd>
Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd>
<dd>
The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, xtd::threading::monitor::xtd::threading::monitor::pulse_all, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd>
<dd>
To signal a single thread, use the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method. </dd></dl>

</div>
</div>
<a id="a815dcc8e9b36f64c518f56170a6feb41" name="a815dcc8e9b36f64c518f56170a6feb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815dcc8e9b36f64c518f56170a6feb41">&#9670;&#160;</a></span>wait() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::lock::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to wait. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait before the thread enters the ready queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock was reacquired before the specified time elapsed; <code>false</code> if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td><a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> is not invoked from within a synchronized block of code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method does not return until it reacquires an exclusive lock on the obj parameter. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations. </dd>
<dd>
The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method again. </dd>
<dd>
When a thread calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, or it is the next in the queue and a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. However, if milliseconds_timeout elapses before another thread invokes this object's <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method, the original thread is moved to the ready queue in order to regain the lock. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> is specified for the milliseconds_timeout parameter, this method blocks indefinitely unless the holder of the lock calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>. If milliseconds_timeout equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller executes <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> once, regardless of the number of times <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> on the object and invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> as many times as necessary to restore the saved <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> count for the caller. Calling <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd></dl>

</div>
</div>
<a id="a947cbc0eae2c7b35938d342fd3915b6d" name="a947cbc0eae2c7b35938d342fd3915b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947cbc0eae2c7b35938d342fd3915b6d">&#9670;&#160;</a></span>wait() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::lock::wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="classxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> representing the amount of time to wait before the thread enters the ready queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock was reacquired before the specified time elapsed; <code>false</code> if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td><a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> is not invoked from within a synchronized block of code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method does not return until it reacquires an exclusive lock on the obj parameter. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations. </dd>
<dd>
The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method again. </dd>
<dd>
When a thread calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, or it is the next in the queue and a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. However, if milliseconds_timeout elapses before another thread invokes this object's <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method, the original thread is moved to the ready queue in order to regain the lock. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> is specified for the milliseconds_timeout parameter, this method blocks indefinitely unless the holder of the lock calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>. If milliseconds_timeout equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller executes <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> once, regardless of the number of times <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> on the object and invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> as many times as necessary to restore the saved <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> count for the caller. Calling <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd></dl>

</div>
</div>
<a id="ab676bb9c5b09a88e772333ce4ca00afa" name="ab676bb9c5b09a88e772333ce4ca00afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab676bb9c5b09a88e772333ce4ca00afa">&#9670;&#160;</a></span>wait() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::lock::wait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td><a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> is not invoked from within a synchronized block of code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method does not return until it reacquires an exclusive lock on the obj parameter. </dd>
<dd>
The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations. </dd>
<dd>
The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> method again. </dd>
<dd>
When a thread calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a>, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, or it is the next in the queue and a thread that holds the lock invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>. However, if milliseconds_timeout elapses before another thread invokes this object's <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a> method, the original thread is moved to the ready queue in order to regain the lock. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> is specified for the milliseconds_timeout parameter, this method blocks indefinitely unless the holder of the lock calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> or <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>. If milliseconds_timeout equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The caller executes <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> once, regardless of the number of times <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> on the object and invokes <a class="el" href="classxtd_1_1threading_1_1monitor.html#a511fd1ffb8c451222fe4071f7a19f243" title="Releases an exclusive lock on the specified obj.">xtd::threading::monitor::exit</a> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> as many times as necessary to restore the saved <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> count for the caller. Calling <a class="el" href="classxtd_1_1threading_1_1monitor.html#acd63dcb3bbf83741c9bdfe9f6d074b8d" title="Releases the lock on an object and blocks the current thread until it reacquires the lock....">xtd::threading::monitor::wait</a> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a>, <a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb" title="Notifies all waiting threads of a change in the object&#39;s state.">xtd::threading::monitor::pulse_all</a>, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> method explain what happens if <a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815" title="Notifies a thread in the waiting queue of a change in the locked object&#39;s state.">xtd::threading::monitor::pulse</a> is called when no threads are waiting. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="threading_2lock_8hpp_source.html">lock.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 4 2025 16:11:04 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
