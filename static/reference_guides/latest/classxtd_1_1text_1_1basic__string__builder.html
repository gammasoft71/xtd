<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::text::basic_string_builder&lt; char_t, traits_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1text.html">text</a></li><li class="navelem"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1text_1_1basic__string__builder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::text::basic_string_builder&lt; char_t, traits_t, allocator_t &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span><div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__text.html">text</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__strings.html">strings</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::text::basic_string_builder&lt; char_t, traits_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1text_1_1basic__string__builder.png" usemap="#xtd::text::basic_5Fstring_5Fbuilder_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::text::basic_5Fstring_5Fbuilder_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::text::basic_5Fstring_5Fbuilder_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,56,743,80"/>
<area href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f..." alt="xtd::iequatable&lt; type_t &gt;" shape="rect" coords="753,56,1496,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="376,0,1119,24"/>
<area href="classxtd_1_1extensions_1_1equality__operators.html" alt="xtd::extensions::equality_operators&lt; type_t, iequatable&lt; type_t &gt; &gt;" shape="rect" coords="1129,0,1872,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt;<br />
class xtd::text::basic_string_builder&lt; char_t, traits_t, allocator_t &gt;</div><p>Represents a mutable string of characters. This class cannot be inherited. </p>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1text.html" title="Contains classes that represent ASCII and Unicode character encodings; abstract base classes for conv...">xtd::text</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> class represents a string-like object whose value is a mutable sequence of characters. </dd>
<dd>
<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string_builder/basic_string_builder">std::basic_string&lt;char&gt;</a> and therefore offers the full API of std::basic_string. </dd>
<dd>
Several aliases for common character types are provided: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga2b0fa8983b51035b33f765fd06a5c9af" title="Represents text as a sequence of UTF-16 code units.">xtd::text::u16string_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;<a class="el" href="group__types.html#gaa8cad5eec279a2f84d8b8d2392b2201c" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga866d47762847e8a5f1de2e8589eda83d" title="Represents text as a sequence of UTF-32 code units.">xtd::text::u32string_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;<a class="el" href="group__types.html#gafab2aed44c397da401a7bc0b6ba53ca9" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga17bf6913bcf1464dac298cd30d0a2da0" title="Represents text as a sequence of UTF-8 code units.">xtd::text::u8string_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;<a class="el" href="group__types.html#ga222bc4d0543ff9a28877597b0bdc3b98" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga5619413acf6894bdc5403fd52b64a72e" title="Represents text as a sequence of UTF-16 code unit on Windows or UTF-32 code unit on non-Windows syste...">xtd::text::wstring_builder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;<a class="el" href="group__types.html#ga438e2b3e86176afb074a70ed50f6c302" title="Represents a wide character.">xtd::wchar</a>&gt;   </td></tr>
</table>
</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Appends a copy of the specified string to this instance. /</p>
<p>/</p>
<p>/ /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>&amp;) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto flag = false; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append("The value of the flag is ").append(flag).append("."); / <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>(sb.to_string()); / / // The example displays the following output: / // / // The value of the flag is `false`. /</code> / </dd>
<dd>
If <code>value</code> is <code>empty</code>, no changes are made. / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(const xtd::basic_string&lt;char_t&gt;&amp; value) {return append(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> {value});} / Appends a copy of a specified substring to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string that contains the substring to append. /</td></tr>
    <tr><td class="paramname">start_index</td><td>The starting position of the substring within <code>value</code>. /</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters in <code>value</code> to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity.<br  />
-or-<br  />
`start_index` + `count` is greater than the length of `value`. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method appends the specified range of characters in value to the current instance. If <code>value</code> is <code>empty</code> and <code>start_index</code> and <code>count</code> are both zero, no changes are made. / </dd>
<dd>
The xtd::text::basic_string_builder::append (const <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>&amp;, size_type, size_type) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto str = "First;George Washington;1789;1797"_s; / auto index = 0_z; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / auto length = str.index_of(';', index); / sb.append(str, index, length).append(" President of the United States: "); / index += length + 1; / length = str.index_of(';', index) - index; / sb.append(str, index, length).append(", from "); / index += length + 1; / length = str.index_of(';', index) - index; / sb.append(str, index, length).append(" to "); / index += length + 1; / sb.append(str, index, str.length() - index); / console::write_line(sb); / / // The example displays the following output: / // / // First President of the United States: George Washington, from 1789 to 1797 /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(const xtd::basic_string&lt;char_t&gt;&amp; value, size_type start_index, size_type count) {return append(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> {value, start_index, count});} / Appends the string representation of a specified boolean value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The boolean value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#ga6593319302fd0fc8ab795e52ec187729" title="Represents a boolean.">xtd::boolean</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto flag = false; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append("The value of the flag is ").append(flag).append("."); / <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>(sb.to_string()); / / // The example displays the following output: / // / // The value of the flag is `false`. /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::boolean value) {return append_format("{}", value);} / Appends the string representation of a specified 8-bit unsigned value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 8-bit unsigned value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#ga8eaeca343fe44fd32900e07de728ebd9" title="Represents a 8-bit unsigned integer.">xtd::byte</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto bytes = array&lt;byte&gt; {16, 132, 27, 253}; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / for (auto value : bytes) / sb.append(value).append(" "); / <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>("The byte array: {0}", sb.to_string()); / / // The example displays the following output: / // / // The byte array: 16 132 27 253 /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::byte value) {return append_format("{}", value);} / Appends the string representation of a specified decimal value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The decimal value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd" title="Represents a decimal-precision floating-point number.">xtd::decimal</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346.19l; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346.19***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::decimal value) {return append_format("{}", value);} / Appends the string representation of a specified double value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The double value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (double) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346.19; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346.19***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(double value) {return append_format("{}", value);} / Appends the string representation of a specified single value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The single value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#gaf9f0ae6db9fc51931d88c537c2bb7a4d" title="Represents a single-precision floating-point number.">xtd::single</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346.19f; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346.19***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::single value) {return append_format("{}", value);} / Appends the string representation of a specified 16-bit signed integer value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 16-bit signed value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#gaabbe5a5cfe907c1810dbbf3a4a23a241" title="Represents a 16-bit signed integer.">xtd::int16</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346_s16; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::int16 value) {return append_format("{}", value);} / Appends the string representation of a specified 32-bit signed integer value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 32-bit signed value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">xtd::int32</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::int32 value) {return append_format("{}", value);} / Appends the string representation of a specified 64-bit signed integer value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 64-bit signed value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f" title="Represents a 64-bit signed integer.">xtd::int64</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346_s64; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::int64 value) {return append_format("{}", value);} / Appends the string representation of a specified 8-bit signed integer value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 8-bit signed integer value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#ga41d04b2d8de5008019577dd15c518ddd" title="Represents a 8-bit signed integer.">xtd::sbyte</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto bytes = array&lt;sbyte&gt; {16, 132, 27, 253}; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / for (auto value : bytes) / sb.append(value).append(" "); / <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>("The byte array: {0}", sb.to_string()); / / // The example displays the following output: / // / // The byte array: 16 132 27 253 /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::sbyte value) {return append_format("{}", value);} / Appends the string representation of a specified 16-bit unsigned integer value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 16-bit unsigned value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#gaad002927004fb7689a9ca18ed578f7b7" title="Represents a 16-bit unsigned integer.">xtd::uint16</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346_u16; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::uint16 value) {return append_format("{}", value);} / Appends the string representation of a specified 32-bit unsigned integer value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 32-bit unsigned value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#gabcb8f2a01d025f4fd9ea205912f4735e" title="Represents a 32-bit unsigned integer.">xtd::uint32</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346_u32; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::uint32 value) {return append_format("{}", value);} / Appends the string representation of a specified 64-bit unsigned integer value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 64-bit unsigned value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (<a class="el" href="group__types.html#gac098a266f9daf0e7c5ced1dad47db325" title="Represents a 64-bit unsigned integer.">xtd::uint64</a>) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346_u64; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(xtd::uint64 value) {return append_format("{}", value);} / Appends the string representation of a specified xtd::text::basic_string_builder::value_type value to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The xtd::text::basic_string_builder::value_type value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (xtd::text::basic_string_builder::value_type) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto str = "Characters in a string."; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / for (auto ch : str) / sb.append(" '").append(ch).append("' "); / / <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>("Characters in the string:"); / <a class="el" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37" title="Writes the current line terminator to the standard output stream using the specified format informati...">console::write_line</a>("  {}", sb); / / // The example displays the following output: / // / // Characters in the string: / // 'C' 'h' 'a' 'r' 'a' 'c' 't' 'e' 'r' 's' ' ' 'i' 'n' ' ' 'a' ' ' 's' 't' 'r' 'i' 'n' 'g' '.' /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(value_type value) {return append(1_z, value);} / Appends a specified number of copies of the string representation of a Unicode character to this instance. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The character to append. /</td></tr>
    <tr><td class="paramname">repeat_count</td><td>The number of times to append <code>value</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (xtd::text::basic_string_builder::value_type, xtd::text::basic_string_builder::size_type) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. / <code> / auto value = 1346.19; / auto sb = <a class="el" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941" title="Represents text as a sequence of UTF-8 code units.">xtd::text::string_builder</a> {}; / sb.append('*', 5).append(value).append('*', 5); / console::write_line(sb); / / // The example displays the following output: / // / // *****1346.19***** /</code> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(value_type value, size_type repeat_count) {return append(repeat_count, value);}</dd></dl>
<p>/</p>
<p>/ Appends the string representation of a specified object to this instance. / </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">object_t</td><td>The type of object to append. /</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The xtd::text::basic_string_builder::append (object_t) method modifies the existing instance of this class; it does not return a new class instance. Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, as the following example illustrates. It defines a <code>dog</code> class, creates a <code>dog</code> object, and makes three calls to the xtd::text::basic_string_builder::append method to create a string that contains the dog's name and breed. / <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/text/string_builder&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/istringable&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>dog : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1istringable.html">istringable</a> {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">string</span> dog_breed;</div>
<div class="line">  <span class="keywordtype">string</span> dog_name;</div>
<div class="line">  </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  dog(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; breed) : dog_breed(breed), dog_name(name) {}</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; breed() const noexcept {<span class="keywordflow">return</span> dog_breed;}</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name() const noexcept {<span class="keywordflow">return</span> dog_name;}</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">string</span> <a class="code hl_function" href="classxtd_1_1istringable.html#a938940eaf830158edf5c54772df5e325">to_string</a>() const noexcept<span class="keyword"> override </span>{<span class="keywordflow">return</span> dog_name;}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> dog1 = dog {<span class="stringliteral">&quot;Mocka&quot;</span>, <span class="stringliteral">&quot;American Shepherd&quot;</span>};</div>
<div class="line">  <span class="keyword">auto</span> sb = <a class="code hl_typedef" href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941">xtd::text::string_builder</a> {};</div>
<div class="line">  sb.append(dog1).append(<span class="stringliteral">&quot;, breed: &quot;</span>).append(dog1.breed());</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(sb);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Mocka, breed: American Shepherd</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="aclassxtd_1_1istringable_html"><div class="ttname"><a href="classxtd_1_1istringable.html">xtd::istringable</a></div><div class="ttdoc">Provides a way to represent the current object as a string.</div><div class="ttdef"><b>Definition</b> istringable.hpp:22</div></div>
<div class="ttc" id="aclassxtd_1_1istringable_html_a938940eaf830158edf5c54772df5e325"><div class="ttname"><a href="classxtd_1_1istringable.html#a938940eaf830158edf5c54772df5e325">xtd::istringable::to_string</a></div><div class="ttdeci">virtual xtd::string to_string() const =0</div><div class="ttdoc">Gets a string that represents the current object.</div></div>
<div class="ttc" id="agroup__strings_html_ga80050d927e8b925c2668c1faebf0b941"><div class="ttname"><a href="group__strings.html#ga80050d927e8b925c2668c1faebf0b941">xtd::text::string_builder</a></div><div class="ttdeci">xtd::text::basic_string_builder&lt; char &gt; string_builder</div><div class="ttdoc">Represents text as a sequence of UTF-8 code units.</div><div class="ttdef"><b>Definition</b> string_builder.hpp:20</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> abstract_object.hpp:8</div></div>
</div><!-- fragment --> / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. template&lt;class object_t&gt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(object_t value) {return append_format("{}", value);} / Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of characters to append. /</td></tr>
    <tr><td class="paramname">ch</td><td>The character value to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends <code>count</code> copies of character <code>ch</code>. / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(size_type count, value_type ch) {return append(basic_string_builder(count, ch));} / Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends string <code>str</code>. / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(const basic_string_builder&amp; str) {return append(str, 0, str.length());} / Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to append. /</td></tr>
    <tr><td class="paramname">pos</td><td>The index of the first character to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends a substring [<code>pos</code>, <code>pos</code> + <code>count</code>) of <code>str</code>. / </dd>
<dd>
If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the appended substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / </dd>
<dd>
If <code>pos &gt; str.size()</code>, <code>std::out_of_range</code> is thrown. / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(const basic_string_builder&amp; str, size_type pos) {return append(str, pos, str.length() - pos);} / Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to append. /</td></tr>
    <tr><td class="paramname">pos</td><td>The index of the first character to append. /</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends a substring [<code>pos</code>, <code>pos</code> + <code>count</code>) of <code>str</code>. / </dd>
<dd>
If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the appended substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / </dd>
<dd>
If <code>pos &gt; str.size()</code>, <code>std::out_of_range</code> is thrown. / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(const basic_string_builder&amp; str, size_type pos, size_type count) { if (<a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> + count &gt; max_capacity()) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range); if (pos &gt; str.size() || pos + count &gt; str.length()) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range);; chars_.append(str.chars_, pos, count); return *this; } / Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to the character string to append. /</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends characters in the range [<code>s</code>, <code>s + count</code>). This range can contain null characters. / </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(const_pointer s, size_type count) {return append(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> {s, count});} / Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to the character string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends the null-terminated character string pointed to by <code>s</code>, as if by <code>append(s, traits_t::length(s))</code>. / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(const_pointer s) {return append(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> {s});} / Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of the range of characters to append. /</td></tr>
    <tr><td class="paramname">last</td><td>The last iterator of the range of characters to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends characters in the range [<code>first</code>, <code>last</code>). / </dd>
<dd>
This overload only participates in overload resolution if <code>input_iterator_t</code> qualifies as a <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">LegacyInputIterator</a>. / </dd>
<dd>
The capacity of this instance is adjusted as needed. template&lt;class input_iterator_t&gt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(input_iterator_t first, input_iterator_t last) { if (<a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> + std::distance(first, last) &gt; max_capacity()) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range); return append(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> {first, last}); } / Appends additional characters to the string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list with the characters to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Appends characters from the initializer list <code>ilist</code>. / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append(std::initializer_list&lt;value_type&gt; ilist) {return append(<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> {ilist});}</dd></dl>
<p>/ Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding argument in a parameters. / </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...args_t</td><td>Types of the values to format. /</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A composite format string. /</td></tr>
    <tr><td class="paramname">args</td><td>Arguments to format. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance with format appended. Each format item in format is replaced by the string representation of the corresponding object argument. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1format__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::format_exception</a></td><td>`format` is invalid. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method uses the composite formatting feature of the xtd framework to convert the value of an object to its text representation and embed that representation in the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. / </dd>
<dd>
The <code>format</code> parameter consists of optional zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to objects in the parameter list of this method. The formatting process replaces each format item with the string representation of the corresponding object. / </dd>
<dd>
The syntax of a format item is as follows: / <code>{[index][,length][:format_string]}</code> / </dd>
<dd>
Elements in square brackets are optional. The following table describes each element. / | Element | Description | / | -----------&mdash; | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------&mdash; | / | index | The optional zero-based position in the parameter list of the object to be formatted. If there is no parameter in the index position, a <a class="el" href="classxtd_1_1format__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::format_exception</a> is thrown. | / | length | The minimum number of characters in the string representation of the parameter. If positive, the parameter is right-aligned; if negative, it is left-aligned. | / | :format_string | A standard or custom format string that is supported by the parameter. | / </dd>
<dd>
The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. template&lt;class ...args_t&gt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append_format(const xtd::basic_string&lt;char_t&gt;&amp; format, args_t&amp;&amp; ... args) {return append(xtd::basic_string&lt;char_t&gt;::format(format, std::forward&lt;args_t&gt;(args)...));}</dd></dl>
<p>/ Concatenates and appends the members of a collection, using the specified separator between each member. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The string to use as a separator. <code>separator</code> is included in the concatenated and appended strings only if <code>values</code> has more than one element. /</td></tr>
    <tr><td class="paramname">values</td><td>A collection that contains the objects to concatenate and append to the current instance of the string builder. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. template&lt;class collection_t&gt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append_join(const xtd::basic_string&lt;char_t&gt;&amp; separator, const collection_t &amp;values) {return append(xtd::basic_string&lt;char_t&gt;::join(separator, values));} / Concatenates and appends the members of a collection, using the specified xtd::basic_string_builder::value_type separator between each member. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The xtd::basic_string_builder::value_type to use as a separator. <code>separator</code> is included in the concatenated and appended strings only if <code>values</code> has more than one element. /</td></tr>
    <tr><td class="paramname">values</td><td>A collection that contains the objects to concatenate and append to the current instance of the string builder. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. template&lt;class collection_t&gt; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append_join(value_type separator, const collection_t &amp;values) {return append(xtd::basic_string&lt;char_t&gt;::join(xtd::basic_string&lt;char_t&gt;(1, separator), values));}</dd></dl>
<p>/</p>
<p>/ Appends the default line terminator to the end of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. / </p><dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append_line() {return append(<a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string&lt;char_t&gt;</a> {<a class="el" href="classxtd_1_1environment.html#a19a9aa87ee20eb3789058621ed161c4e" title="Gets the newline string defined for this environment.">xtd::environment::new_line()</a>});} / Appends a copy of the specified string followed by the default line terminator to the end of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to append. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the append operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of this instance is adjusted as needed. / </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>/ When you instantiate the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object by calling the xtd::text::basic_string_builder::basic_string_builder(xtd::size, xtd::size) constructor, both the length and the capacity of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance can grow beyond the value of its xtd::text::basic_string_builder::max_capacity property. This can occur particularly when you call the xtd::text::basic_string_builder::append and xtd::text::basic_string_builder::append_format methods to append small strings. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; append_line(const xtd::basic_string&lt;char_t&gt;&amp; value) {return append(value).append_line();}</dd></dl>
<p>/ Returns a reference to the character at specified location <code>pos</code>. / </p><dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. const_reference <a class="el" href="namespacextd.html#a856ad36e5aacc976277ccc570b035695" title="Gets the specified element with bounds checking.">at(size_type pos) const </a>{return operator [](pos);} / Returns a reference to the character at specified location <code>pos</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. reference at(size_type pos) {return operator [](pos);}</td></tr>
  </table>
  </dd>
</dl>
<p>/ Removes all characters from the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance. / </p><dl class="section return"><dt>Returns</dt><dd>An object whose <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">xtd::text::basic_string_builder::length</a> is 0 (zero). / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a01bc6f8efa4202821e95f4fdf6298b30" title="The CLEAR key.">xtd::text::basic_string_builder::clear</a> is a convenience method that is equivalent to setting the <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">xtd::text::basic_string_builder::length</a> property of the current instance to 0 (zero). / </dd>
<dd>
All pointers, references, and iterators are invalidated. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a01bc6f8efa4202821e95f4fdf6298b30" title="The CLEAR key.">clear()</a> { chars_.clear(); return *this; }</dd></dl>
<p>/ Compares two character sequences. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The other string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to str. / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(const basic_string_builder&amp; str) const {return chars_.compare(str);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string_builder&amp; str) const {return chars_.compare(pos1, count1, str);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. /</td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / * If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string_builder&amp; str, size_type pos2) const {return chars_.compare(pos1, count1, str, pos2);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. /</td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. /</td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter: / * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). / * If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(size_type pos1, size_type count1, const basic_string_builder&amp; str, size_type pos2, size_type count2) const {return chars_.compare(pos1, count1, str, pos2, count2);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. / </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows: / * First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>. / * Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: / </dd>
<dd>
/ | Condition | Result | Return value | / | ----------------------------------------------------------&mdash; | ----------------------------&mdash; | ---------&mdash; | / | traits_t::compare(data1, data2, rlen) &lt; 0 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2 | data1 is <b>less than</b> data2 | &lt; 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 == size2 | data1 is <b>equal to</b> data2 | 0 | / | traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2 | data1 is <b>greater than</b> data2 | &gt; 0 | / | traits_t::compare(data1, data2, rlen) &gt; 0 | data1 is <b>greater than</b> data2 | &gt; 0 | <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260" title="Represents a 32-bit signed integer.">int32</a> compare(const_pointer s) const {return chars_.compare(s);} / Compares two character sequences. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. /</td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. /</td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>/ * Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order. / * Zero if both character sequences compare equivalent. / * Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. / * If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1$ , <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). @remarks A character sequence consisting of</code>count1<code>characters starting at</code>data1<code>is compared to a character sequence consisting of</code>count2<code>characters starting at</code>data2<code>as follows:<ul>
<li>First, calculate the number of characters to compare, as if by</li>
</ul>
</code>size_type rlen = std::min(count1, count2)<code>.<ul>
<li>Then compare the sequences by calling</li>
</ul>
</code>traits_t::compare(data1, data2, rlen)`. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>
</td></tr>
<tr class="memitem:a7e43fb14da06fe4c8abdfb096538347c" id="r_a7e43fb14da06fe4c8abdfb096538347c"><td class="memItemLeft" align="right" valign="top"><a id="a7e43fb14da06fe4c8abdfb096538347c" name="a7e43fb14da06fe4c8abdfb096538347c"></a>
<a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compare</b> (size_type pos1, size_type count1, const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="separator:a7e43fb14da06fe4c8abdfb096538347c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32da0105edfb4de7d7a4e03702bdd01" id="r_aa32da0105edfb4de7d7a4e03702bdd01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa32da0105edfb4de7d7a4e03702bdd01">compare</a> (size_type pos1, size_type count1, const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type count2) const</td></tr>
<tr class="memdesc:aa32da0105edfb4de7d7a4e03702bdd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:aa32da0105edfb4de7d7a4e03702bdd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0daf0e5823acccf7dc869e1e542d7e4" id="r_ae0daf0e5823acccf7dc869e1e542d7e4"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0daf0e5823acccf7dc869e1e542d7e4">copy</a> (pointer dest, size_type count) const</td></tr>
<tr class="memdesc:ae0daf0e5823acccf7dc869e1e542d7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a substring [<code>pos</code>, <code>pos + count</code>) to character string pointed to by <code>dest</code>. If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the copied substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:ae0daf0e5823acccf7dc869e1e542d7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eec80ec1a4223dc129301eb889e6a4" id="r_a68eec80ec1a4223dc129301eb889e6a4"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68eec80ec1a4223dc129301eb889e6a4">copy</a> (pointer dest, size_type count, size_type pos) const</td></tr>
<tr class="memdesc:a68eec80ec1a4223dc129301eb889e6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a substring [<code>pos</code>, <code>pos + count</code>) to character string pointed to by <code>dest</code>. If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the copied substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:a68eec80ec1a4223dc129301eb889e6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab371da2a717b123bae6b1d802ef8493c" id="r_ab371da2a717b123bae6b1d802ef8493c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab371da2a717b123bae6b1d802ef8493c">copy_to</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> source_index, <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; value_type &gt; &amp;destination, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> destination_index, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> destination_count) const</td></tr>
<tr class="memdesc:ab371da2a717b123bae6b1d802ef8493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters from a specified segment of this instance to a specified segment of a destination xtd::text::basic_string_builder::value_type array.  <br /></td></tr>
<tr class="separator:ab371da2a717b123bae6b1d802ef8493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96c2ac833670b1180ac068212ad9f4f" id="r_af96c2ac833670b1180ac068212ad9f4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af96c2ac833670b1180ac068212ad9f4f">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept override</td></tr>
<tr class="memdesc:af96c2ac833670b1180ac068212ad9f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, have the same value.  <br /></td></tr>
<tr class="separator:af96c2ac833670b1180ac068212ad9f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d34f9d4cd8a741fe9db2eee6c5aefd5" id="r_a0d34f9d4cd8a741fe9db2eee6c5aefd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d34f9d4cd8a741fe9db2eee6c5aefd5">equals</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a0d34f9d4cd8a741fe9db2eee6c5aefd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object have the same value.  <br /></td></tr>
<tr class="separator:a0d34f9d4cd8a741fe9db2eee6c5aefd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeb4cc1cfd200606618eb6739608942" id="r_abbeb4cc1cfd200606618eb6739608942"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbeb4cc1cfd200606618eb6739608942">ensure_capacity</a> (size_type capacity)</td></tr>
<tr class="memdesc:abbeb4cc1cfd200606618eb6739608942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the capacity of this instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is at least the specified value.  <br /></td></tr>
<tr class="separator:abbeb4cc1cfd200606618eb6739608942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5c9fcc11b456758adcff89a37db3d6" id="r_a5b5c9fcc11b456758adcff89a37db3d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b5c9fcc11b456758adcff89a37db3d6">erase</a> ()</td></tr>
<tr class="memdesc:a5b5c9fcc11b456758adcff89a37db3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:a5b5c9fcc11b456758adcff89a37db3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98036eb33b9f5efccea8f3ab0c4260d" id="r_aa98036eb33b9f5efccea8f3ab0c4260d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa98036eb33b9f5efccea8f3ab0c4260d">erase</a> (size_type index)</td></tr>
<tr class="memdesc:aa98036eb33b9f5efccea8f3ab0c4260d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:aa98036eb33b9f5efccea8f3ab0c4260d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba63b5048abc857d0ef9fec7202868e2" id="r_aba63b5048abc857d0ef9fec7202868e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba63b5048abc857d0ef9fec7202868e2">erase</a> (size_type index, size_type count)</td></tr>
<tr class="memdesc:aba63b5048abc857d0ef9fec7202868e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:aba63b5048abc857d0ef9fec7202868e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4a2cd3ac7315702ee353559ca0a826" id="r_a0b4a2cd3ac7315702ee353559ca0a826"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b4a2cd3ac7315702ee353559ca0a826">erase</a> (const_iterator position)</td></tr>
<tr class="memdesc:a0b4a2cd3ac7315702ee353559ca0a826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:a0b4a2cd3ac7315702ee353559ca0a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cc268cc3bbc170e27fb9890960ecfd" id="r_a43cc268cc3bbc170e27fb9890960ecfd"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43cc268cc3bbc170e27fb9890960ecfd">erase</a> (const_iterator <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, const_iterator <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>)</td></tr>
<tr class="memdesc:a43cc268cc3bbc170e27fb9890960ecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified characters from the string.  <br /></td></tr>
<tr class="separator:a43cc268cc3bbc170e27fb9890960ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd010f465e21bfe02a37a72327fcb8b" id="r_addd010f465e21bfe02a37a72327fcb8b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addd010f465e21bfe02a37a72327fcb8b">find</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:addd010f465e21bfe02a37a72327fcb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:addd010f465e21bfe02a37a72327fcb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4056d79afbf4cd7427b088ff37fd73" id="r_aca4056d79afbf4cd7427b088ff37fd73"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca4056d79afbf4cd7427b088ff37fd73">find</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:aca4056d79afbf4cd7427b088ff37fd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:aca4056d79afbf4cd7427b088ff37fd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871f4dcc9e986d3391773e94001d4424" id="r_a871f4dcc9e986d3391773e94001d4424"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a871f4dcc9e986d3391773e94001d4424">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:a871f4dcc9e986d3391773e94001d4424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:a871f4dcc9e986d3391773e94001d4424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa516a25b121ca140f4e32b25686ee448" id="r_aa516a25b121ca140f4e32b25686ee448"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa516a25b121ca140f4e32b25686ee448">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:aa516a25b121ca140f4e32b25686ee448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:aa516a25b121ca140f4e32b25686ee448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375a366e73b0bb4a472a54e55b7820b5" id="r_a375a366e73b0bb4a472a54e55b7820b5"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a375a366e73b0bb4a472a54e55b7820b5">find</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a375a366e73b0bb4a472a54e55b7820b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:a375a366e73b0bb4a472a54e55b7820b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dde10776af5e4236d17f723f5e16272" id="r_a1dde10776af5e4236d17f723f5e16272"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dde10776af5e4236d17f723f5e16272">find</a> (value_type ch) const</td></tr>
<tr class="memdesc:a1dde10776af5e4236d17f723f5e16272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a1dde10776af5e4236d17f723f5e16272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb87f140c3fb2c99c9213e41bdf6c7a" id="r_acdb87f140c3fb2c99c9213e41bdf6c7a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdb87f140c3fb2c99c9213e41bdf6c7a">find</a> (value_type ch, size_type pos) const</td></tr>
<tr class="memdesc:acdb87f140c3fb2c99c9213e41bdf6c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:acdb87f140c3fb2c99c9213e41bdf6c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1193f4f61458f636924c8c12e37c389e" id="r_a1193f4f61458f636924c8c12e37c389e"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1193f4f61458f636924c8c12e37c389e">find_first_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:a1193f4f61458f636924c8c12e37c389e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a1193f4f61458f636924c8c12e37c389e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01193dda07e43b164b2162867e8af66e" id="r_a01193dda07e43b164b2162867e8af66e"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01193dda07e43b164b2162867e8af66e">find_first_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a01193dda07e43b164b2162867e8af66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a01193dda07e43b164b2162867e8af66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4930ea45a844d0194dc6becc05f910" id="r_a5f4930ea45a844d0194dc6becc05f910"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f4930ea45a844d0194dc6becc05f910">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:a5f4930ea45a844d0194dc6becc05f910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a5f4930ea45a844d0194dc6becc05f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6486e9aa4f41fd50996a84103e643f" id="r_a0f6486e9aa4f41fd50996a84103e643f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f6486e9aa4f41fd50996a84103e643f">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a0f6486e9aa4f41fd50996a84103e643f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a0f6486e9aa4f41fd50996a84103e643f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5822b12952b2e94f633ed23864a033b1" id="r_a5822b12952b2e94f633ed23864a033b1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5822b12952b2e94f633ed23864a033b1">find_first_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a5822b12952b2e94f633ed23864a033b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a5822b12952b2e94f633ed23864a033b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173cc774d0d51ce3b178e057384bd785" id="r_a173cc774d0d51ce3b178e057384bd785"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a173cc774d0d51ce3b178e057384bd785">find_first_of</a> (value_type ch) const</td></tr>
<tr class="memdesc:a173cc774d0d51ce3b178e057384bd785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a173cc774d0d51ce3b178e057384bd785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021c75422a879b861ed2e6d70a87056d" id="r_a021c75422a879b861ed2e6d70a87056d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a021c75422a879b861ed2e6d70a87056d">find_first_of</a> (value_type ch, size_type pos) const</td></tr>
<tr class="memdesc:a021c75422a879b861ed2e6d70a87056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a021c75422a879b861ed2e6d70a87056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782483099e1899cde8dcdd99d33874a8" id="r_a782483099e1899cde8dcdd99d33874a8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a782483099e1899cde8dcdd99d33874a8">find_first_not_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:a782483099e1899cde8dcdd99d33874a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a782483099e1899cde8dcdd99d33874a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ea74d485358c59e05a8a4c166b9d57" id="r_a64ea74d485358c59e05a8a4c166b9d57"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ea74d485358c59e05a8a4c166b9d57">find_first_not_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a64ea74d485358c59e05a8a4c166b9d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a64ea74d485358c59e05a8a4c166b9d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3c984bc0ecb97d0b7b043aef7e342c" id="r_acd3c984bc0ecb97d0b7b043aef7e342c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd3c984bc0ecb97d0b7b043aef7e342c">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:acd3c984bc0ecb97d0b7b043aef7e342c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:acd3c984bc0ecb97d0b7b043aef7e342c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59823a9dd0e8f7198911cb405d1fd5d9" id="r_a59823a9dd0e8f7198911cb405d1fd5d9"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59823a9dd0e8f7198911cb405d1fd5d9">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a59823a9dd0e8f7198911cb405d1fd5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a59823a9dd0e8f7198911cb405d1fd5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b3ddb2b4b520bbb17977b9aa40abdd" id="r_a59b3ddb2b4b520bbb17977b9aa40abdd"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59b3ddb2b4b520bbb17977b9aa40abdd">find_first_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a59b3ddb2b4b520bbb17977b9aa40abdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a59b3ddb2b4b520bbb17977b9aa40abdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341d07800aea00111e68dc05f9e53b25" id="r_a341d07800aea00111e68dc05f9e53b25"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a341d07800aea00111e68dc05f9e53b25">find_first_not_of</a> (value_type ch) const</td></tr>
<tr class="memdesc:a341d07800aea00111e68dc05f9e53b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a341d07800aea00111e68dc05f9e53b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253195d4dd86e68c524904601b299455" id="r_a253195d4dd86e68c524904601b299455"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a253195d4dd86e68c524904601b299455">find_first_not_of</a> (value_type ch, size_type pos) const</td></tr>
<tr class="memdesc:a253195d4dd86e68c524904601b299455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a253195d4dd86e68c524904601b299455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14020567dcd6804b6cdcb44195921e08" id="r_a14020567dcd6804b6cdcb44195921e08"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14020567dcd6804b6cdcb44195921e08">find_last_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:a14020567dcd6804b6cdcb44195921e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a14020567dcd6804b6cdcb44195921e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695e88d8d0a58a53f73959164c6d6880" id="r_a695e88d8d0a58a53f73959164c6d6880"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a695e88d8d0a58a53f73959164c6d6880">find_last_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a695e88d8d0a58a53f73959164c6d6880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a695e88d8d0a58a53f73959164c6d6880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c85187149a417bd2f31d6a22acf2ce" id="r_af4c85187149a417bd2f31d6a22acf2ce"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c85187149a417bd2f31d6a22acf2ce">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:af4c85187149a417bd2f31d6a22acf2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:af4c85187149a417bd2f31d6a22acf2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448a629104e7ce594fd1a23aa00c6626" id="r_a448a629104e7ce594fd1a23aa00c6626"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448a629104e7ce594fd1a23aa00c6626">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a448a629104e7ce594fd1a23aa00c6626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a448a629104e7ce594fd1a23aa00c6626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f81f8edf0cf5a8ca3e544026074ef68" id="r_a5f81f8edf0cf5a8ca3e544026074ef68"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f81f8edf0cf5a8ca3e544026074ef68">find_last_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:a5f81f8edf0cf5a8ca3e544026074ef68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a5f81f8edf0cf5a8ca3e544026074ef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b96875455b6f3b0f2d1142ffbbacd25" id="r_a3b96875455b6f3b0f2d1142ffbbacd25"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b96875455b6f3b0f2d1142ffbbacd25">find_last_of</a> (value_type ch) const</td></tr>
<tr class="memdesc:a3b96875455b6f3b0f2d1142ffbbacd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a3b96875455b6f3b0f2d1142ffbbacd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81c01bf59e08e245516c40ebc2ee842" id="r_af81c01bf59e08e245516c40ebc2ee842"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af81c01bf59e08e245516c40ebc2ee842">find_last_of</a> (value_type ch, size_type pos) const</td></tr>
<tr class="memdesc:af81c01bf59e08e245516c40ebc2ee842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:af81c01bf59e08e245516c40ebc2ee842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b045db53e2ee1951e28b54df69a1cc9" id="r_a5b045db53e2ee1951e28b54df69a1cc9"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b045db53e2ee1951e28b54df69a1cc9">find_last_not_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:a5b045db53e2ee1951e28b54df69a1cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a5b045db53e2ee1951e28b54df69a1cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbef564df0bc8b53eb5af4c5d4d743f" id="r_a7dbef564df0bc8b53eb5af4c5d4d743f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dbef564df0bc8b53eb5af4c5d4d743f">find_last_not_of</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a7dbef564df0bc8b53eb5af4c5d4d743f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a7dbef564df0bc8b53eb5af4c5d4d743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce1bca49f91f2cbaf6cd55afb394a07" id="r_adce1bca49f91f2cbaf6cd55afb394a07"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adce1bca49f91f2cbaf6cd55afb394a07">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:adce1bca49f91f2cbaf6cd55afb394a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:adce1bca49f91f2cbaf6cd55afb394a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b25d4d6d8b1112152fed3d5a8675fb" id="r_a36b25d4d6d8b1112152fed3d5a8675fb"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36b25d4d6d8b1112152fed3d5a8675fb">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a36b25d4d6d8b1112152fed3d5a8675fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a36b25d4d6d8b1112152fed3d5a8675fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ada4c383c61f1705fed87a7a517f56" id="r_aa3ada4c383c61f1705fed87a7a517f56"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3ada4c383c61f1705fed87a7a517f56">find_last_not_of</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos) const</td></tr>
<tr class="memdesc:aa3ada4c383c61f1705fed87a7a517f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:aa3ada4c383c61f1705fed87a7a517f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09746cee91ee1b9de5560cc055a0ba67" id="r_a09746cee91ee1b9de5560cc055a0ba67"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09746cee91ee1b9de5560cc055a0ba67">find_last_not_of</a> (value_type ch) const</td></tr>
<tr class="memdesc:a09746cee91ee1b9de5560cc055a0ba67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a09746cee91ee1b9de5560cc055a0ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf963ad4b8dbdb486ce6d9861323568" id="r_a4cf963ad4b8dbdb486ce6d9861323568"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cf963ad4b8dbdb486ce6d9861323568">find_last_not_of</a> (value_type ch, size_type pos) const</td></tr>
<tr class="memdesc:a4cf963ad4b8dbdb486ce6d9861323568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned.  <br /></td></tr>
<tr class="separator:a4cf963ad4b8dbdb486ce6d9861323568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74555342c1e71644a8c85221c22a253" id="r_ab74555342c1e71644a8c85221c22a253"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab74555342c1e71644a8c85221c22a253">get_allocator</a> () const</td></tr>
<tr class="memdesc:ab74555342c1e71644a8c85221c22a253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the string.  <br /></td></tr>
<tr class="separator:ab74555342c1e71644a8c85221c22a253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255284f6f267ad0dec0b3ce000012406" id="r_a255284f6f267ad0dec0b3ce000012406"><td class="memItemLeft" align="right" valign="top">virtual const base_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a255284f6f267ad0dec0b3ce000012406">get_base_type</a> () const noexcept</td></tr>
<tr class="memdesc:a255284f6f267ad0dec0b3ce000012406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type.  <br /></td></tr>
<tr class="separator:a255284f6f267ad0dec0b3ce000012406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62861111a3dbc4a98fad55c9d550f1c0" id="r_a62861111a3dbc4a98fad55c9d550f1c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62861111a3dbc4a98fad55c9d550f1c0">get_hash_code</a> () const noexcept override</td></tr>
<tr class="memdesc:a62861111a3dbc4a98fad55c9d550f1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash code for this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>.  <br /></td></tr>
<tr class="separator:a62861111a3dbc4a98fad55c9d550f1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6adb1caf7d21ef5cf838abf7d1fe3a1" id="r_ad6adb1caf7d21ef5cf838abf7d1fe3a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6adb1caf7d21ef5cf838abf7d1fe3a1">insert</a> (size_type index, const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;value)</td></tr>
<tr class="memdesc:ad6adb1caf7d21ef5cf838abf7d1fe3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a string into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ad6adb1caf7d21ef5cf838abf7d1fe3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98ed3d1bcec424cc1ced4248256f1dc" id="r_ac98ed3d1bcec424cc1ced4248256f1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac98ed3d1bcec424cc1ced4248256f1dc">insert</a> (size_type index, const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;value, size_type count)</td></tr>
<tr class="memdesc:ac98ed3d1bcec424cc1ced4248256f1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts one or more copies of a specified string into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ac98ed3d1bcec424cc1ced4248256f1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71672fd9dc758a885e3ceffc79aa610e" id="r_a71672fd9dc758a885e3ceffc79aa610e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71672fd9dc758a885e3ceffc79aa610e">insert</a> (size_type index, <a class="el" href="group__types.html#ga6593319302fd0fc8ab795e52ec187729">xtd::boolean</a> value)</td></tr>
<tr class="memdesc:a71672fd9dc758a885e3ceffc79aa610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a boolean value into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a71672fd9dc758a885e3ceffc79aa610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81221aa31d3902af34338c7d5703087" id="r_ab81221aa31d3902af34338c7d5703087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81221aa31d3902af34338c7d5703087">insert</a> (size_type index, <a class="el" href="group__types.html#ga8eaeca343fe44fd32900e07de728ebd9">xtd::byte</a> value)</td></tr>
<tr class="memdesc:ab81221aa31d3902af34338c7d5703087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 8-bit unsigned integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ab81221aa31d3902af34338c7d5703087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b977f8e3d9556c431a732382a12077f" id="r_a3b977f8e3d9556c431a732382a12077f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b977f8e3d9556c431a732382a12077f">insert</a> (size_type index, <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a> value)</td></tr>
<tr class="memdesc:a3b977f8e3d9556c431a732382a12077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 8decimal into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a3b977f8e3d9556c431a732382a12077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1998f21c817095eae59166547f564e6a" id="r_a1998f21c817095eae59166547f564e6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1998f21c817095eae59166547f564e6a">insert</a> (size_type index, double value)</td></tr>
<tr class="memdesc:a1998f21c817095eae59166547f564e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified double into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a1998f21c817095eae59166547f564e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a136db945714bedcd09586014bc0a3" id="r_af4a136db945714bedcd09586014bc0a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4a136db945714bedcd09586014bc0a3">insert</a> (size_type index, <a class="el" href="group__types.html#gaf9f0ae6db9fc51931d88c537c2bb7a4d">xtd::single</a> value)</td></tr>
<tr class="memdesc:af4a136db945714bedcd09586014bc0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified single into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:af4a136db945714bedcd09586014bc0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebade1d7099ea019449faa5959c7c66e" id="r_aebade1d7099ea019449faa5959c7c66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebade1d7099ea019449faa5959c7c66e">insert</a> (size_type index, <a class="el" href="group__types.html#gaabbe5a5cfe907c1810dbbf3a4a23a241">xtd::int16</a> value)</td></tr>
<tr class="memdesc:aebade1d7099ea019449faa5959c7c66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 16-bit signed integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:aebade1d7099ea019449faa5959c7c66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3ab96abfdc0853a7239ace614ee4bc" id="r_a8e3ab96abfdc0853a7239ace614ee4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e3ab96abfdc0853a7239ace614ee4bc">insert</a> (size_type index, <a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">xtd::int32</a> value)</td></tr>
<tr class="memdesc:a8e3ab96abfdc0853a7239ace614ee4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 32-bit signed integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a8e3ab96abfdc0853a7239ace614ee4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935ba62175a9d015ff0cdb3bdde036f" id="r_ae935ba62175a9d015ff0cdb3bdde036f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae935ba62175a9d015ff0cdb3bdde036f">insert</a> (size_type index, <a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">xtd::int64</a> value)</td></tr>
<tr class="memdesc:ae935ba62175a9d015ff0cdb3bdde036f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 64-bit signed integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ae935ba62175a9d015ff0cdb3bdde036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe16b4a827b8c7451b6adeeb12c98822" id="r_abe16b4a827b8c7451b6adeeb12c98822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe16b4a827b8c7451b6adeeb12c98822">insert</a> (size_type index, <a class="el" href="group__types.html#ga41d04b2d8de5008019577dd15c518ddd">xtd::sbyte</a> value)</td></tr>
<tr class="memdesc:abe16b4a827b8c7451b6adeeb12c98822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 8-bit signed integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:abe16b4a827b8c7451b6adeeb12c98822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12493726c9d996c346d2015c8879b667" id="r_a12493726c9d996c346d2015c8879b667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12493726c9d996c346d2015c8879b667">insert</a> (size_type index, <a class="el" href="group__types.html#gaad002927004fb7689a9ca18ed578f7b7">xtd::uint16</a> value)</td></tr>
<tr class="memdesc:a12493726c9d996c346d2015c8879b667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 16-bit unsigned integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a12493726c9d996c346d2015c8879b667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ea5dab524bc80c779ae9f8e7e0418f" id="r_ae6ea5dab524bc80c779ae9f8e7e0418f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6ea5dab524bc80c779ae9f8e7e0418f">insert</a> (size_type index, <a class="el" href="group__types.html#gabcb8f2a01d025f4fd9ea205912f4735e">xtd::uint32</a> value)</td></tr>
<tr class="memdesc:ae6ea5dab524bc80c779ae9f8e7e0418f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 32-bit unsigned integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:ae6ea5dab524bc80c779ae9f8e7e0418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8182b9785bb3bcdb7b85bb816c1feacf" id="r_a8182b9785bb3bcdb7b85bb816c1feacf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8182b9785bb3bcdb7b85bb816c1feacf">insert</a> (size_type index, <a class="el" href="group__types.html#gac098a266f9daf0e7c5ced1dad47db325">xtd::uint64</a> value)</td></tr>
<tr class="memdesc:a8182b9785bb3bcdb7b85bb816c1feacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified 64-bit unsigned integer into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a8182b9785bb3bcdb7b85bb816c1feacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af88ec0b5a9a9507d434f01c88081ca" id="r_a7af88ec0b5a9a9507d434f01c88081ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7af88ec0b5a9a9507d434f01c88081ca">insert</a> (size_type index, value_type value)</td></tr>
<tr class="memdesc:a7af88ec0b5a9a9507d434f01c88081ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified Unicode character into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a7af88ec0b5a9a9507d434f01c88081ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a543f5eb24f0ce4efb0241346a6077b" id="r_a4a543f5eb24f0ce4efb0241346a6077b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a543f5eb24f0ce4efb0241346a6077b">insert</a> (size_type index, value_type value, size_type repeat_count)</td></tr>
<tr class="memdesc:a4a543f5eb24f0ce4efb0241346a6077b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a specified number of copies of the string representation of a Unicode character to this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a4a543f5eb24f0ce4efb0241346a6077b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e26ca656cb16b1a051d29bbc6c0b8cd" id="r_a8e26ca656cb16b1a051d29bbc6c0b8cd"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:a8e26ca656cb16b1a051d29bbc6c0b8cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e26ca656cb16b1a051d29bbc6c0b8cd">insert</a> (size_type index, object_t value)</td></tr>
<tr class="memdesc:a8e26ca656cb16b1a051d29bbc6c0b8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the string representation of a specified object into this instance at the specified character position.  <br /></td></tr>
<tr class="separator:a8e26ca656cb16b1a051d29bbc6c0b8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d09df18594f89f4ffc30414acdd611a" id="r_a4d09df18594f89f4ffc30414acdd611a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d09df18594f89f4ffc30414acdd611a">insert</a> (size_type index, size_type count, value_type ch)</td></tr>
<tr class="memdesc:a4d09df18594f89f4ffc30414acdd611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a4d09df18594f89f4ffc30414acdd611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b0e31251aca8ac7d1c995a4d310acf" id="r_a67b0e31251aca8ac7d1c995a4d310acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67b0e31251aca8ac7d1c995a4d310acf">insert</a> (size_type index, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, size_type s_index, size_type count)</td></tr>
<tr class="memdesc:a67b0e31251aca8ac7d1c995a4d310acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a67b0e31251aca8ac7d1c995a4d310acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cea578a9167bdb678a53d3caee7ae7" id="r_a88cea578a9167bdb678a53d3caee7ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88cea578a9167bdb678a53d3caee7ae7">replace</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;old_value, const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;new_value) noexcept</td></tr>
<tr class="memdesc:a88cea578a9167bdb678a53d3caee7ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts characters into the string.  <br /></td></tr>
<tr class="separator:a88cea578a9167bdb678a53d3caee7ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5d1e871c0993f1d447d2ee567e523d" id="r_a7b5d1e871c0993f1d447d2ee567e523d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b5d1e871c0993f1d447d2ee567e523d">replace</a> (const_iterator <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, const_iterator <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str)</td></tr>
<tr class="memdesc:a7b5d1e871c0993f1d447d2ee567e523d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces, within a substring of this instance, all occurrences of a specified string with another specified string.  <br /></td></tr>
<tr class="separator:a7b5d1e871c0993f1d447d2ee567e523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f15b2e74550cadf3a03adb10bbbbced" id="r_a0f15b2e74550cadf3a03adb10bbbbced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f15b2e74550cadf3a03adb10bbbbced">replace</a> (size_type pos, size_type count, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, size_type pos2)</td></tr>
<tr class="memdesc:a0f15b2e74550cadf3a03adb10bbbbced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a0f15b2e74550cadf3a03adb10bbbbced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3759d0dbdb288f6d9516aefe8878b525" id="r_a3759d0dbdb288f6d9516aefe8878b525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3759d0dbdb288f6d9516aefe8878b525">replace</a> (size_type pos, size_type count, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, size_type pos2, size_type count2)</td></tr>
<tr class="memdesc:a3759d0dbdb288f6d9516aefe8878b525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a3759d0dbdb288f6d9516aefe8878b525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee9f691c22dcd1658803d4496117255" id="r_a1ee9f691c22dcd1658803d4496117255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ee9f691c22dcd1658803d4496117255">replace</a> (size_type pos, size_type count, const_pointer cstr, size_type count2)</td></tr>
<tr class="memdesc:a1ee9f691c22dcd1658803d4496117255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a1ee9f691c22dcd1658803d4496117255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c7af9db7caa09b5f865b9d20e95c7c" id="r_a34c7af9db7caa09b5f865b9d20e95c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34c7af9db7caa09b5f865b9d20e95c7c">replace</a> (const_iterator <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, const_iterator <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>, const_pointer cstr)</td></tr>
<tr class="memdesc:a34c7af9db7caa09b5f865b9d20e95c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a34c7af9db7caa09b5f865b9d20e95c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e630d3858ea0aad67093fb1f51a3977" id="r_a9e630d3858ea0aad67093fb1f51a3977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e630d3858ea0aad67093fb1f51a3977">replace</a> (size_type pos, size_type count, size_type count2, value_type ch)</td></tr>
<tr class="memdesc:a9e630d3858ea0aad67093fb1f51a3977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a9e630d3858ea0aad67093fb1f51a3977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111f0dbc2b4811ecdd92f884e9cbc578" id="r_a111f0dbc2b4811ecdd92f884e9cbc578"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t&gt; </td></tr>
<tr class="memitem:a111f0dbc2b4811ecdd92f884e9cbc578"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a111f0dbc2b4811ecdd92f884e9cbc578">replace</a> (const_iterator <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, const_iterator <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>, input_iterator_t first2, input_iterator_t last2)</td></tr>
<tr class="memdesc:a111f0dbc2b4811ecdd92f884e9cbc578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:a111f0dbc2b4811ecdd92f884e9cbc578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2785748c9a606a2c0c724086b3b7a3" id="r_afd2785748c9a606a2c0c724086b3b7a3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd2785748c9a606a2c0c724086b3b7a3">rfind</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) const</td></tr>
<tr class="memdesc:afd2785748c9a606a2c0c724086b3b7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters.  <br /></td></tr>
<tr class="separator:afd2785748c9a606a2c0c724086b3b7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50146eee209c5eeef9ea1a6eaebb2459" id="r_a50146eee209c5eeef9ea1a6eaebb2459"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50146eee209c5eeef9ea1a6eaebb2459">rfind</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str, size_type pos) const</td></tr>
<tr class="memdesc:a50146eee209c5eeef9ea1a6eaebb2459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a50146eee209c5eeef9ea1a6eaebb2459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aad3615278f80f49b1a999a6317f13" id="r_aa0aad3615278f80f49b1a999a6317f13"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0aad3615278f80f49b1a999a6317f13">rfind</a> (const_pointer <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, size_type pos, size_type count) const</td></tr>
<tr class="memdesc:aa0aad3615278f80f49b1a999a6317f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:aa0aad3615278f80f49b1a999a6317f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee1570674497bc4871d7ad3b9b17ed7" id="r_a2ee1570674497bc4871d7ad3b9b17ed7"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ee1570674497bc4871d7ad3b9b17ed7">rfind</a> (value_type ch) const</td></tr>
<tr class="memdesc:a2ee1570674497bc4871d7ad3b9b17ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at xtd::text::basic_string_builder::npos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following xtd::text::basic_string_builder::npos). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as xtd::text::basic_string_builder::npos, the whole string will be searched. / @param s The pointer to a character string to search for. / @return Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. / @remarks Finds the first substring equal to the character string pointed to by</code>s<code>. The length of the string is determined by the first null character using</code>traits_t::length(s)<code>. / @remarks If [</code>s<code>,</code>s + traits_t::length(s)<code>) is not a valid range, the behavior is undefined. size_type rfind(const_pointer s) const {return chars_.rfind(s);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param s The pointer to a character string to search for. / @param pos The position at which to start the search / @return Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. / @remarks Finds the first substring equal to the character string pointed to by</code>s<code>. The length of the string is determined by the first null character using</code>traits_t::length(s)<code>. / @remarks If [</code>s<code>,</code>s + traits_t::length(s)<code>) is not a valid range, the behavior is undefined. size_type rfind(const_pointer s, size_type pos) const {return chars_.rfind(s, pos);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at xtd::text::basic_string_builder::npos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following xtd::text::basic_string_builder::npos). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as xtd::text::basic_string_builder::npos, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a2ee1570674497bc4871d7ad3b9b17ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd5950f09061481c41efd222922d8ce" id="r_adcd5950f09061481c41efd222922d8ce"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcd5950f09061481c41efd222922d8ce">rfind</a> (value_type ch, size_type pos) const</td></tr>
<tr class="memdesc:adcd5950f09061481c41efd222922d8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:adcd5950f09061481c41efd222922d8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa3478a9e5c14cf145652dae38ef19f" id="r_a3fa3478a9e5c14cf145652dae38ef19f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fa3478a9e5c14cf145652dae38ef19f">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a3fa3478a9e5c14cf145652dae38ef19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <br /></td></tr>
<tr class="separator:a3fa3478a9e5c14cf145652dae38ef19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168d97f3252db3d6706fa324190fbcd8" id="r_a168d97f3252db3d6706fa324190fbcd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a168d97f3252db3d6706fa324190fbcd8">substr</a> () const</td></tr>
<tr class="memdesc:a168d97f3252db3d6706fa324190fbcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == xtd::text::basic_string_builder::npos), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:a168d97f3252db3d6706fa324190fbcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b6033babf65f6afa93c1fa114fae88" id="r_aa6b6033babf65f6afa93c1fa114fae88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6b6033babf65f6afa93c1fa114fae88">substr</a> (size_type pos) const</td></tr>
<tr class="memdesc:aa6b6033babf65f6afa93c1fa114fae88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == xtd::text::basic_string_builder::npos), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:aa6b6033babf65f6afa93c1fa114fae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cd57b1e78f411c904144725389941a" id="r_a40cd57b1e78f411c904144725389941a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40cd57b1e78f411c904144725389941a">substr</a> (size_type pos, size_type count) const</td></tr>
<tr class="memdesc:a40cd57b1e78f411c904144725389941a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == xtd::text::basic_string_builder::npos), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:a40cd57b1e78f411c904144725389941a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4adcc8a4f6c42434091cc96fcc49061" id="r_aa4adcc8a4f6c42434091cc96fcc49061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4adcc8a4f6c42434091cc96fcc49061">swap</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aa4adcc8a4f6c42434091cc96fcc49061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the string with those of other. All iterators and references may be invalidated.  <br /></td></tr>
<tr class="separator:aa4adcc8a4f6c42434091cc96fcc49061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877feeab7ac0df07e40be12990dec52d" id="r_a877feeab7ac0df07e40be12990dec52d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__strings.html#ga2bd6ab53224f55d280a88872353123eb">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a877feeab7ac0df07e40be12990dec52d">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:a877feeab7ac0df07e40be12990dec52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char&gt;.  <br /></td></tr>
<tr class="separator:a877feeab7ac0df07e40be12990dec52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:a3d162b34eefce8985ad367f3ca78e4dc" id="r_a3d162b34eefce8985ad367f3ca78e4dc"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d162b34eefce8985ad367f3ca78e4dc">operator[]</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index) const</td></tr>
<tr class="memdesc:a3d162b34eefce8985ad367f3ca78e4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character at specified location index.  <br /></td></tr>
<tr class="separator:a3d162b34eefce8985ad367f3ca78e4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99facb90b642227990bd5b1f94bb1750" id="r_a99facb90b642227990bd5b1f94bb1750"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99facb90b642227990bd5b1f94bb1750">operator[]</a> (<a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> index)</td></tr>
<tr class="memdesc:a99facb90b642227990bd5b1f94bb1750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character at specified location index.  <br /></td></tr>
<tr class="separator:a99facb90b642227990bd5b1f94bb1750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f8e06524f9fa65f9c7017a9d9e4619" id="r_ab1f8e06524f9fa65f9c7017a9d9e4619"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1f8e06524f9fa65f9c7017a9d9e4619">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:ab1f8e06524f9fa65f9c7017a9d9e4619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:ab1f8e06524f9fa65f9c7017a9d9e4619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f826690bfb0d112064bfdd5cb0e0f88" id="r_a6f826690bfb0d112064bfdd5cb0e0f88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f826690bfb0d112064bfdd5cb0e0f88">operator base_type &amp;</a> () noexcept</td></tr>
<tr class="memdesc:a6f826690bfb0d112064bfdd5cb0e0f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a6f826690bfb0d112064bfdd5cb0e0f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecaa8470016180805e8aae60741be04" id="r_a1ecaa8470016180805e8aae60741be04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ecaa8470016180805e8aae60741be04">operator=</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str) noexcept</td></tr>
<tr class="memdesc:a1ecaa8470016180805e8aae60741be04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:a1ecaa8470016180805e8aae60741be04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8f1950013cfa7b62845ed804eadf2" id="r_afea8f1950013cfa7b62845ed804eadf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afea8f1950013cfa7b62845ed804eadf2">operator=</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:afea8f1950013cfa7b62845ed804eadf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:afea8f1950013cfa7b62845ed804eadf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb76aa90b3febf78d306d5eae58c0aaa" id="r_aeb76aa90b3febf78d306d5eae58c0aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb76aa90b3febf78d306d5eae58c0aaa">operator=</a> (const std::basic_string&lt; value_type &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:aeb76aa90b3febf78d306d5eae58c0aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:aeb76aa90b3febf78d306d5eae58c0aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cba958ff90c1eae4110b211598479ed" id="r_a8cba958ff90c1eae4110b211598479ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cba958ff90c1eae4110b211598479ed">operator=</a> (std::basic_string&lt; value_type &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a8cba958ff90c1eae4110b211598479ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a8cba958ff90c1eae4110b211598479ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361314e49ff5adb0ece44b9ebeaa068d" id="r_a361314e49ff5adb0ece44b9ebeaa068d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a361314e49ff5adb0ece44b9ebeaa068d">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; value_type &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a361314e49ff5adb0ece44b9ebeaa068d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a361314e49ff5adb0ece44b9ebeaa068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7b1d4ebec4fcf9da9d90ea3c3219cb" id="r_a7c7b1d4ebec4fcf9da9d90ea3c3219cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c7b1d4ebec4fcf9da9d90ea3c3219cb">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; value_type &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a7c7b1d4ebec4fcf9da9d90ea3c3219cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a7c7b1d4ebec4fcf9da9d90ea3c3219cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9440ad97280090e604efa6d926641189" id="r_a9440ad97280090e604efa6d926641189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9440ad97280090e604efa6d926641189">operator=</a> (const_pointer str)</td></tr>
<tr class="memdesc:a9440ad97280090e604efa6d926641189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a9440ad97280090e604efa6d926641189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8965763778b83efc5a9f7557806f2a1" id="r_ad8965763778b83efc5a9f7557806f2a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8965763778b83efc5a9f7557806f2a1">operator=</a> (value_type character)</td></tr>
<tr class="memdesc:ad8965763778b83efc5a9f7557806f2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:ad8965763778b83efc5a9f7557806f2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628c15f570caf7d2efa10554d1fde169" id="r_a628c15f570caf7d2efa10554d1fde169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a628c15f570caf7d2efa10554d1fde169">operator=</a> (const std::initializer_list&lt; value_type &gt; &amp;il)</td></tr>
<tr class="memdesc:a628c15f570caf7d2efa10554d1fde169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:a628c15f570caf7d2efa10554d1fde169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091ac07faa8b98417e11d70f4272d1c1" id="r_a091ac07faa8b98417e11d70f4272d1c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a091ac07faa8b98417e11d70f4272d1c1">operator+=</a> (const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;str)</td></tr>
<tr class="memdesc:a091ac07faa8b98417e11d70f4272d1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a091ac07faa8b98417e11d70f4272d1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b9d25941d4757dc74bb5b1a956d79f" id="r_af2b9d25941d4757dc74bb5b1a956d79f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2b9d25941d4757dc74bb5b1a956d79f">operator+=</a> (<a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&amp;str)</td></tr>
<tr class="memdesc:af2b9d25941d4757dc74bb5b1a956d79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:af2b9d25941d4757dc74bb5b1a956d79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446536be6df64bb7da260de2891a3993" id="r_a446536be6df64bb7da260de2891a3993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a446536be6df64bb7da260de2891a3993">operator+=</a> (const_pointer str)</td></tr>
<tr class="memdesc:a446536be6df64bb7da260de2891a3993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a446536be6df64bb7da260de2891a3993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad64103e7fd14893e78d8ccd8e71bb82" id="r_aad64103e7fd14893e78d8ccd8e71bb82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad64103e7fd14893e78d8ccd8e71bb82">operator+=</a> (value_type ch)</td></tr>
<tr class="memdesc:aad64103e7fd14893e78d8ccd8e71bb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:aad64103e7fd14893e78d8ccd8e71bb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8bbde943d2e5ecf565734c60e23903" id="r_a1f8bbde943d2e5ecf565734c60e23903"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a> (const type_t &amp;) const noexcept=0</td></tr>
<tr class="memdesc:a1f8bbde943d2e5ecf565734c60e23903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current object is equal to another object of the same type.  <br /></td></tr>
<tr class="separator:a1f8bbde943d2e5ecf565734c60e23903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa32da0105edfb4de7d7a4e03702bdd01" name="aa32da0105edfb4de7d7a4e03702bdd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32da0105edfb4de7d7a4e03702bdd01">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">int32</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the characters in the range [<code>s</code>, <code>s + count2</code>). The characters in [<code>s</code>, <code>s + count2</code>) may include null characters.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ae0daf0e5823acccf7dc869e1e542d7e4" name="ae0daf0e5823acccf7dc869e1e542d7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0daf0e5823acccf7dc869e1e542d7e4">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">pointer</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a substring [<code>pos</code>, <code>pos + count</code>) to character string pointed to by <code>dest</code>. If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the copied substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The pointer to the destination character string. </td></tr>
    <tr><td class="paramname">count</td><td>length of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters copied. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The resulting character string is not null-terminated. </dd></dl>

</div>
</div>
<a id="a68eec80ec1a4223dc129301eb889e6a4" name="a68eec80ec1a4223dc129301eb889e6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68eec80ec1a4223dc129301eb889e6a4">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">pointer</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a substring [<code>pos</code>, <code>pos + count</code>) to character string pointed to by <code>dest</code>. If the requested substring lasts past the end of the string, or if <code>count == npos</code>, the copied substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The pointer to the destination character string. </td></tr>
    <tr><td class="paramname">count</td><td>length of the substring. </td></tr>
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters copied. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The resulting character string is not null-terminated. </dd></dl>

</div>
</div>
<a id="ab371da2a717b123bae6b1d802ef8493c" name="ab371da2a717b123bae6b1d802ef8493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab371da2a717b123bae6b1d802ef8493c">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>source_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; value_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>destination_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>destination_count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters from a specified segment of this instance to a specified segment of a destination xtd::text::basic_string_builder::value_type array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_index</td><td>The starting position in this instance where characters will be copied from. The index is zero-based. </td></tr>
    <tr><td class="paramname">destination</td><td>The array where characters will be copied. </td></tr>
    <tr><td class="paramname">destination_index</td><td>The starting position in destination where characters will be copied. The index is zero-based. </td></tr>
    <tr><td class="paramname">destination_count</td><td>The number of characters to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`source_index` is greater than length <br  />
-or-<br  />
`destination_index` + 'destination_count' greater than destination size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="#ab371da2a717b123bae6b1d802ef8493c" title="Copies the characters from a specified segment of this instance to a specified segment of a destinati...">xtd::text::basic_string_builder::copy_to</a> method is intended to be used in the rare situation when you need to efficiently copy successive sections of a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object to an array. The array should be a fixed size, preallocated, reusable, and possibly globally accessible. </dd>
<dd>
For example, your code could populate a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object with a large number of characters then use the <a class="el" href="#ab371da2a717b123bae6b1d802ef8493c" title="Copies the characters from a specified segment of this instance to a specified segment of a destinati...">xtd::text::basic_string_builder::copy_to</a> method to copy small, successive pieces of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object to an array where the pieces are processed. When all the data in the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is processed, the size of the <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is set to zero and the cycle is repeated. </dd></dl>

</div>
</div>
<a id="af96c2ac833670b1180ac068212ad9f4f" name="af96c2ac833670b1180ac068212ad9f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96c2ac833670b1180ac068212ad9f4f">&#9670;&#160;</a></span>equals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object, have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>obj</code> is a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> and its value is the same as this instance; otherwise, <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">xtd::object</a>.</p>

</div>
</div>
<a id="a0d34f9d4cd8a741fe9db2eee6c5aefd5" name="a0d34f9d4cd8a741fe9db2eee6c5aefd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d34f9d4cd8a741fe9db2eee6c5aefd5">&#9670;&#160;</a></span>equals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

</div>
</div>
<a id="abbeb4cc1cfd200606618eb6739608942" name="abbeb4cc1cfd200606618eb6739608942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbeb4cc1cfd200606618eb6739608942">&#9670;&#160;</a></span>ensure_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::ensure_capacity </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the capacity of this instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is at least the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The minimum capacity to ensure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new capacity of this instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed Enlarging the value of this instance would exceed MaxCapacity.::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the current capacity is less than the <code>capacity</code> parameter, memory for this instance is reallocated to hold at least <code>capacity</code> number of characters; otherwise, no memory is changed. </dd></dl>

</div>
</div>
<a id="a5b5c9fcc11b456758adcff89a37db3d6" name="a5b5c9fcc11b456758adcff89a37db3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5c9fcc11b456758adcff89a37db3d6">&#9670;&#160;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes <code>std::min(count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - index)</code> characters starting at index. </dd></dl>

</div>
</div>
<a id="aa98036eb33b9f5efccea8f3ab0c4260d" name="aa98036eb33b9f5efccea8f3ab0c4260d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98036eb33b9f5efccea8f3ab0c4260d">&#9670;&#160;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The first character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes <code>std::min(count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - index)</code> characters starting at index. </dd></dl>

</div>
</div>
<a id="aba63b5048abc857d0ef9fec7202868e2" name="aba63b5048abc857d0ef9fec7202868e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba63b5048abc857d0ef9fec7202868e2">&#9670;&#160;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The first character to remove. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes <code>std::min(count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - index)</code> characters starting at index. </dd></dl>

</div>
</div>
<a id="a0b4a2cd3ac7315702ee353559ca0a826" name="a0b4a2cd3ac7315702ee353559ca0a826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4a2cd3ac7315702ee353559ca0a826">&#9670;&#160;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator</td>          <td class="paramname"><span class="paramname"><em>position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The iterator to the character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Iterator pointing to the character immediately following the character erased, or <a class="el" href="namespacextd.html#a3a39828bd6261156752c2d0eda4c625a" title="Returns an iterator to the end.">end()</a> if no such character exists. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes the character at <code>position</code>. </dd>
<dd>
If <code>position</code> is not a dereferenceable iterator on <code>*this</code>, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a43cc268cc3bbc170e27fb9890960ecfd" name="a43cc268cc3bbc170e27fb9890960ecfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cc268cc3bbc170e27fb9890960ecfd">&#9670;&#160;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified characters from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of the range of the characters to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator of the range of the characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the character last pointed to before the erase, or <a class="el" href="namespacextd.html#a3a39828bd6261156752c2d0eda4c625a" title="Returns an iterator to the end.">end()</a> if no such character exists. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes the characters in the range [<code>first</code>, <code>last</code>). </dd>
<dd>
If <code>first</code> or <code>last</code> is not a valid iterator on <code>*this</code>, or [<code>first</code>, <code>last</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="addd010f465e21bfe02a37a72327fcb8b" name="addd010f465e21bfe02a37a72327fcb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd010f465e21bfe02a37a72327fcb8b">&#9670;&#160;</a></span>find() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="aca4056d79afbf4cd7427b088ff37fd73" name="aca4056d79afbf4cd7427b088ff37fd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4056d79afbf4cd7427b088ff37fd73">&#9670;&#160;</a></span>find() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="a871f4dcc9e986d3391773e94001d4424" name="a871f4dcc9e986d3391773e94001d4424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871f4dcc9e986d3391773e94001d4424">&#9670;&#160;</a></span>find() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa516a25b121ca140f4e32b25686ee448" name="aa516a25b121ca140f4e32b25686ee448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa516a25b121ca140f4e32b25686ee448">&#9670;&#160;</a></span>find() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a375a366e73b0bb4a472a54e55b7820b5" name="a375a366e73b0bb4a472a54e55b7820b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375a366e73b0bb4a472a54e55b7820b5">&#9670;&#160;</a></span>find() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a1dde10776af5e4236d17f723f5e16272" name="a1dde10776af5e4236d17f723f5e16272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dde10776af5e4236d17f723f5e16272">&#9670;&#160;</a></span>find() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="acdb87f140c3fb2c99c9213e41bdf6c7a" name="acdb87f140c3fb2c99c9213e41bdf6c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb87f140c3fb2c99c9213e41bdf6c7a">&#9670;&#160;</a></span>find() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a1193f4f61458f636924c8c12e37c389e" name="a1193f4f61458f636924c8c12e37c389e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1193f4f61458f636924c8c12e37c389e">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a01193dda07e43b164b2162867e8af66e" name="a01193dda07e43b164b2162867e8af66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01193dda07e43b164b2162867e8af66e">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a5f4930ea45a844d0194dc6becc05f910" name="a5f4930ea45a844d0194dc6becc05f910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4930ea45a844d0194dc6becc05f910">&#9670;&#160;</a></span>find_first_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a0f6486e9aa4f41fd50996a84103e643f" name="a0f6486e9aa4f41fd50996a84103e643f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6486e9aa4f41fd50996a84103e643f">&#9670;&#160;</a></span>find_first_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a5822b12952b2e94f633ed23864a033b1" name="a5822b12952b2e94f633ed23864a033b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5822b12952b2e94f633ed23864a033b1">&#9670;&#160;</a></span>find_first_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a173cc774d0d51ce3b178e057384bd785" name="a173cc774d0d51ce3b178e057384bd785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173cc774d0d51ce3b178e057384bd785">&#9670;&#160;</a></span>find_first_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a021c75422a879b861ed2e6d70a87056d" name="a021c75422a879b861ed2e6d70a87056d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021c75422a879b861ed2e6d70a87056d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a782483099e1899cde8dcdd99d33874a8" name="a782483099e1899cde8dcdd99d33874a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782483099e1899cde8dcdd99d33874a8">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a64ea74d485358c59e05a8a4c166b9d57" name="a64ea74d485358c59e05a8a4c166b9d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ea74d485358c59e05a8a4c166b9d57">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="acd3c984bc0ecb97d0b7b043aef7e342c" name="acd3c984bc0ecb97d0b7b043aef7e342c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3c984bc0ecb97d0b7b043aef7e342c">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a59823a9dd0e8f7198911cb405d1fd5d9" name="a59823a9dd0e8f7198911cb405d1fd5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59823a9dd0e8f7198911cb405d1fd5d9">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a59b3ddb2b4b520bbb17977b9aa40abdd" name="a59b3ddb2b4b520bbb17977b9aa40abdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b3ddb2b4b520bbb17977b9aa40abdd">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a341d07800aea00111e68dc05f9e53b25" name="a341d07800aea00111e68dc05f9e53b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341d07800aea00111e68dc05f9e53b25">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a253195d4dd86e68c524904601b299455" name="a253195d4dd86e68c524904601b299455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253195d4dd86e68c524904601b299455">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a14020567dcd6804b6cdcb44195921e08" name="a14020567dcd6804b6cdcb44195921e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14020567dcd6804b6cdcb44195921e08">&#9670;&#160;</a></span>find_last_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a695e88d8d0a58a53f73959164c6d6880" name="a695e88d8d0a58a53f73959164c6d6880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695e88d8d0a58a53f73959164c6d6880">&#9670;&#160;</a></span>find_last_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="af4c85187149a417bd2f31d6a22acf2ce" name="af4c85187149a417bd2f31d6a22acf2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c85187149a417bd2f31d6a22acf2ce">&#9670;&#160;</a></span>find_last_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a448a629104e7ce594fd1a23aa00c6626" name="a448a629104e7ce594fd1a23aa00c6626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448a629104e7ce594fd1a23aa00c6626">&#9670;&#160;</a></span>find_last_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a5f81f8edf0cf5a8ca3e544026074ef68" name="a5f81f8edf0cf5a8ca3e544026074ef68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f81f8edf0cf5a8ca3e544026074ef68">&#9670;&#160;</a></span>find_last_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a3b96875455b6f3b0f2d1142ffbbacd25" name="a3b96875455b6f3b0f2d1142ffbbacd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b96875455b6f3b0f2d1142ffbbacd25">&#9670;&#160;</a></span>find_last_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="af81c01bf59e08e245516c40ebc2ee842" name="af81c01bf59e08e245516c40ebc2ee842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81c01bf59e08e245516c40ebc2ee842">&#9670;&#160;</a></span>find_last_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a5b045db53e2ee1951e28b54df69a1cc9" name="a5b045db53e2ee1951e28b54df69a1cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b045db53e2ee1951e28b54df69a1cc9">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a7dbef564df0bc8b53eb5af4c5d4d743f" name="a7dbef564df0bc8b53eb5af4c5d4d743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbef564df0bc8b53eb5af4c5d4d743f">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="adce1bca49f91f2cbaf6cd55afb394a07" name="adce1bca49f91f2cbaf6cd55afb394a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce1bca49f91f2cbaf6cd55afb394a07">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a36b25d4d6d8b1112152fed3d5a8675fb" name="a36b25d4d6d8b1112152fed3d5a8675fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b25d4d6d8b1112152fed3d5a8675fb">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa3ada4c383c61f1705fed87a7a517f56" name="aa3ada4c383c61f1705fed87a7a517f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ada4c383c61f1705fed87a7a517f56">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a09746cee91ee1b9de5560cc055a0ba67" name="a09746cee91ee1b9de5560cc055a0ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09746cee91ee1b9de5560cc055a0ba67">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a4cf963ad4b8dbdb486ce6d9861323568" name="a4cf963ad4b8dbdb486ce6d9861323568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf963ad4b8dbdb486ce6d9861323568">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,xtd::text::basic_string_builder::npos will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or xtd::text::basic_string_builder::npos if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="ab74555342c1e71644a8c85221c22a253" name="ab74555342c1e71644a8c85221c22a253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74555342c1e71644a8c85221c22a253">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="a255284f6f267ad0dec0b3ce000012406" name="a255284f6f267ad0dec0b3ce000012406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255284f6f267ad0dec0b3ce000012406">&#9670;&#160;</a></span>get_base_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const base_type &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::get_base_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type. </dd></dl>

</div>
</div>
<a id="a62861111a3dbc4a98fad55c9d550f1c0" name="a62861111a3dbc4a98fad55c9d550f1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62861111a3dbc4a98fad55c9d550f1c0">&#9670;&#160;</a></span>get_hash_code()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::get_hash_code </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash code for this <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">xtd::object</a>.</p>

</div>
</div>
<a id="ad6adb1caf7d21ef5cf838abf7d1fe3a1" name="ad6adb1caf7d21ef5cf838abf7d1fe3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6adb1caf7d21ef5cf838abf7d1fe3a1">&#9670;&#160;</a></span>insert() <span class="overload">[1/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a string into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The string to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="ac98ed3d1bcec424cc1ced4248256f1dc" name="ac98ed3d1bcec424cc1ced4248256f1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98ed3d1bcec424cc1ced4248256f1dc">&#9670;&#160;</a></span>insert() <span class="overload">[2/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts one or more copies of a specified string into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The string to insert. </td></tr>
    <tr><td class="paramname">count</td><td>The number of times to insert <code>value</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a71672fd9dc758a885e3ceffc79aa610e" name="a71672fd9dc758a885e3ceffc79aa610e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71672fd9dc758a885e3ceffc79aa610e">&#9670;&#160;</a></span>insert() <span class="overload">[3/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga6593319302fd0fc8ab795e52ec187729">xtd::boolean</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a boolean value into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="ab81221aa31d3902af34338c7d5703087" name="ab81221aa31d3902af34338c7d5703087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81221aa31d3902af34338c7d5703087">&#9670;&#160;</a></span>insert() <span class="overload">[4/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga8eaeca343fe44fd32900e07de728ebd9">xtd::byte</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 8-bit unsigned integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a3b977f8e3d9556c431a732382a12077f" name="a3b977f8e3d9556c431a732382a12077f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b977f8e3d9556c431a732382a12077f">&#9670;&#160;</a></span>insert() <span class="overload">[5/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 8decimal into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a1998f21c817095eae59166547f564e6a" name="a1998f21c817095eae59166547f564e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1998f21c817095eae59166547f564e6a">&#9670;&#160;</a></span>insert() <span class="overload">[6/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified double into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="af4a136db945714bedcd09586014bc0a3" name="af4a136db945714bedcd09586014bc0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a136db945714bedcd09586014bc0a3">&#9670;&#160;</a></span>insert() <span class="overload">[7/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaf9f0ae6db9fc51931d88c537c2bb7a4d">xtd::single</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified single into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="aebade1d7099ea019449faa5959c7c66e" name="aebade1d7099ea019449faa5959c7c66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebade1d7099ea019449faa5959c7c66e">&#9670;&#160;</a></span>insert() <span class="overload">[8/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaabbe5a5cfe907c1810dbbf3a4a23a241">xtd::int16</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 16-bit signed integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a8e3ab96abfdc0853a7239ace614ee4bc" name="a8e3ab96abfdc0853a7239ace614ee4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3ab96abfdc0853a7239ace614ee4bc">&#9670;&#160;</a></span>insert() <span class="overload">[9/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga60803bd100102370b937ec089f136260">xtd::int32</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 32-bit signed integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="ae935ba62175a9d015ff0cdb3bdde036f" name="ae935ba62175a9d015ff0cdb3bdde036f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935ba62175a9d015ff0cdb3bdde036f">&#9670;&#160;</a></span>insert() <span class="overload">[10/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9e309a49cfcc1ad3179d90fb5b2e60f">xtd::int64</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 64-bit signed integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="abe16b4a827b8c7451b6adeeb12c98822" name="abe16b4a827b8c7451b6adeeb12c98822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe16b4a827b8c7451b6adeeb12c98822">&#9670;&#160;</a></span>insert() <span class="overload">[11/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga41d04b2d8de5008019577dd15c518ddd">xtd::sbyte</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 8-bit signed integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a12493726c9d996c346d2015c8879b667" name="a12493726c9d996c346d2015c8879b667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12493726c9d996c346d2015c8879b667">&#9670;&#160;</a></span>insert() <span class="overload">[12/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaad002927004fb7689a9ca18ed578f7b7">xtd::uint16</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 16-bit unsigned integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="ae6ea5dab524bc80c779ae9f8e7e0418f" name="ae6ea5dab524bc80c779ae9f8e7e0418f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ea5dab524bc80c779ae9f8e7e0418f">&#9670;&#160;</a></span>insert() <span class="overload">[13/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gabcb8f2a01d025f4fd9ea205912f4735e">xtd::uint32</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 32-bit unsigned integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a8182b9785bb3bcdb7b85bb816c1feacf" name="a8182b9785bb3bcdb7b85bb816c1feacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8182b9785bb3bcdb7b85bb816c1feacf">&#9670;&#160;</a></span>insert() <span class="overload">[14/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gac098a266f9daf0e7c5ced1dad47db325">xtd::uint64</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified 64-bit unsigned integer into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a7af88ec0b5a9a9507d434f01c88081ca" name="a7af88ec0b5a9a9507d434f01c88081ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af88ec0b5a9a9507d434f01c88081ca">&#9670;&#160;</a></span>insert() <span class="overload">[15/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified Unicode character into this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a4a543f5eb24f0ce4efb0241346a6077b" name="a4a543f5eb24f0ce4efb0241346a6077b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a543f5eb24f0ce4efb0241346a6077b">&#9670;&#160;</a></span>insert() <span class="overload">[16/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>repeat_count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a specified number of copies of the string representation of a Unicode character to this instance at the specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The character to insert. </td></tr>
    <tr><td class="paramname">repeat_count</td><td>The number of times to append value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a8e26ca656cb16b1a051d29bbc6c0b8cd" name="a8e26ca656cb16b1a051d29bbc6c0b8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e26ca656cb16b1a051d29bbc6c0b8cd">&#9670;&#160;</a></span>insert() <span class="overload">[17/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class object_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the string representation of a specified object into this instance at the specified character position. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">object_t</td><td>The type of object to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in this instance where insertion begins. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Existing characters are shifted to make room for the new text. The capacity is adjusted as needed. </dd>
<dd>
This instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> is not changed if <code>value</code> is <code>empty</code> (its <code>length</code> is zero). </dd></dl>
<dl class="section user"><dt>Notes to Callers</dt><dd>Calls to this method threw an <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> if inserting value would cause the object's total length to exceed xtd::text::basic_string_builder::max_capacity. </dd></dl>

</div>
</div>
<a id="a4d09df18594f89f4ffc30414acdd611a" name="a4d09df18594f89f4ffc30414acdd611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d09df18594f89f4ffc30414acdd611a">&#9670;&#160;</a></span>insert() <span class="overload">[18/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position at which the content will be inserted. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to insert. </td></tr>
    <tr><td class="paramname">ch</td><td>The character to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>count</code> copies of character <code>ch</code> at the position <code>index</code>. </dd></dl>

</div>
</div>
<a id="a67b0e31251aca8ac7d1c995a4d310acf" name="a67b0e31251aca8ac7d1c995a4d310acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b0e31251aca8ac7d1c995a4d310acf">&#9670;&#160;</a></span>insert() <span class="overload">[19/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>s_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position at which the content will be inserted. </td></tr>
    <tr><td class="paramname">s</td><td>The pointer to the character string to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts null-terminated character string pointed to by <code>s</code> at the position <code>index</code>. The length of the string is determined by the first null character using <code>traits_t::length(s). <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert(size_type index, const_pointer s)</a> {return <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert(index, basic_string_builder(s))</a>;} / @brief Inserts characters into the string. / @param index The position at which the content will be inserted. / @param s The pointer to the character string to insert. / @param count The number of characters to insert. / @return A reference to this instance after the insert operation has completed. / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></code>index<code>is greater than the length of this instance.&lt;rr&gt;-or-&lt;br&gt;Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / @remarks Inserts the characters in the range [</code>s<code>,</code>s + count<code>) at the position</code>index<code>. The range can contain null characters. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert(size_type index, const_pointer s, size_type count)</a> {return <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert(index, basic_string_builder(s, count))</a>;} / @brief Inserts characters into the string. / @param index The position at which the content will be inserted. / @param str The string to insert. / @return A reference to this instance after the insert operation has completed. / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></code>index<code>is greater than the length of this instance.&lt;rr&gt;-or-&lt;br&gt;Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / @remarks Inserts string</code>str<code>at the position</code>index<code>. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; insert(size_type index, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; str) {return insert(index, str, 0, str.length());} / @brief Inserts characters into the string. / @param index The position at which the content will be inserted. / @param str The string to insert. / @param s_index The position of the first character in str to insert. / @param count The number of characters to insert. / @return A reference to this instance after the insert operation has completed. / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></code>index<code>is greater than the length of this instance.&lt;rr&gt;-or-&lt;br&gt;Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / @remarks Inserts a string, obtained by</code>str.substr(s_index, count)<code>at the position</code>index. </dd></dl>

</div>
</div>
<a id="a88cea578a9167bdb678a53d3caee7ae7" name="a88cea578a9167bdb678a53d3caee7ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cea578a9167bdb678a53d3caee7ae7">&#9670;&#160;</a></span>replace() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>old_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts characters into the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position at which the content will be inserted. </td></tr>
    <tr><td class="paramname">str</td><td>The string to insert. </td></tr>
    <tr><td class="paramname">s_index</td><td>The position of the first character in str to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the insert operation has completed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater than the length of this instance.&lt;rr&gt;-or-<br  />
Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts a string, obtained by <code>str.substr(s_index, str.length())</code> at the position <code>index. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; insert(size_type index, const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; str, size_type s_index) {return insert(index, str.chars_, s_index, str.length() - s_index);} / @brief Inserts characters into the string. / @param pos The iterator before which the characters will be inserted. / @param ch The character to insert. / @return An iterator which refers to the copy of the first inserted character or</code>pos<code>if no characters were inserted (</code>count == 0<code>or</code>first == last<code>or</code>ilist.size() == 0<code>) / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></code>pos<code>is greater than the length of this instance.&lt;rr&gt;-or-&lt;br&gt;Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / @remarks Inserts character</code>ch<code>before the character pointed by</code>pos<code>. iterator <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert(const_iterator pos, value_type ch)</a> {return <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert(pos, 1, ch)</a>;} / @brief Inserts characters into the string. / @param pos The iterator before which the characters will be inserted. / @param count The number of characters to insert. / @param ch The character to insert. / @return An iterator which refers to the copy of the first inserted character or</code>pos<code>if no characters were inserted (</code>count == 0<code>or</code>first == last<code>or</code>ilist.size() == 0<code>) / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></code>pos<code>is greater than the length of this instance.&lt;rr&gt;-or-&lt;br&gt;Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / @remarks Inserts</code>count<code>copies of character</code>ch<code>before the element (if any) pointed by</code>pos<code>. iterator <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert(const_iterator pos, size_type count, value_type ch )</a> { if (static_cast&lt;size_type&gt;(std::distance(cbegin(), pos)) &gt; <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a>) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range); if (<a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> + count &gt; max_capacity()) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range); return chars_.insert(pos, count, ch); } / @brief Inserts characters into the string. / @param pos The iterator before which the characters will be inserted. / @param first The firs position of range defining characters to insert. / @param last The last position of range defining characters to insert. / @return An iterator which refers to the copy of the first inserted character or</code>pos<code>if no characters were inserted (</code>count == 0<code>or</code>first == last<code>or</code>ilist.size() == 0<code>) / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></code>pos<code>is greater than the length of this instance.&lt;rr&gt;-or-&lt;br&gt;Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / @remarks Inserts characters from the range [</code>first<code>,</code>last<code>) before the element (if any) pointed by</code>pos<code>, as if by</code>insert(pos - <a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a>, basic_string(first, last, get_allocator()))<code>. / @remarks This overload does not participate in overload resolution if input_iterator_t does not satisfy [LegacyInputIterator](<a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">https://en.cppreference.com/w/cpp/named_req/InputIterator</a>). template&lt;class input_iterator_t&gt; iterator <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert( const_iterator pos, input_iterator_t first, input_iterator_t last)</a> { if (static_cast&lt;size_type&gt;(std::distance(cbegin(), pos)) &gt; <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a>) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range); if (<a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> + std::distance(first, last) &gt; max_capacity()) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range); return chars_.insert(pos, first, last); } / @brief Inserts characters into the string. / @param pos The iterator before which the characters will be inserted. / @param ilist The [std::initializer_list](<a href="https://en.cppreference.com/w/cpp/utility/initializer_list">https://en.cppreference.com/w/cpp/utility/initializer_list</a>) to insert the characters from / @return An iterator which refers to the copy of the first inserted character or</code>pos<code>if no characters were inserted (</code>count == 0<code>or</code>first == last<code>or</code>ilist.size() == 0<code>) / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></code>pos<code>is greater than the length of this instance.&lt;rr&gt;-or-&lt;br&gt;Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / @remarks Inserts elements from initializer list</code>ilist<code>before the element (if any) pointed by</code>pos`. iterator <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert(const_iterator pos, std::initializer_list&lt;value_type&gt; ilist)</a> { if (static_cast&lt;size_type&gt;(std::distance(cbegin(), pos)) &gt; <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a>) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range); return chars_.insert(pos, ilist); }</dd></dl>
<p>/ Removes the last character from the string. / </p><dl class="section remark"><dt>Remarks</dt><dd>Equivalent to <code>erase(<a class="el" href="namespacextd.html#a3a39828bd6261156752c2d0eda4c625a" title="Returns an iterator to the end.">end()</a> - 1)</code>. The behavior is undefined if the string is empty. void pop_back() {chars_.pop_back();}</dd></dl>
<p>/ Appends the given character ch to the end of the string. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to append. void push_back(value_type ch) {chars_.push_back(ch);}</td></tr>
  </table>
  </dd>
</dl>
<p>/ Removes the specified range of characters from this instance. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The zero-based position in this instance where removal begins. /</td></tr>
    <tr><td class="paramname">length</td><td>The number of characters to remove. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance after the excise operation has completed. / </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>If `start_index` + `length` is greater than the length of this instance. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The current method removes the specified range of characters from the current instance. The characters at (<code>start_index</code> + <code>length</code>) are moved to <code>start_index</code>, and the string value of the current instance is shortened by <code>length</code>. The capacity of the current instance is unaffected. / </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The xtd::text::basic_string_builder::remove method modifies the value of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance and returns that instance. It does not create and return a new <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; remove(size_type start_index, size_type length) {return erase(start_index, length);}</dd></dl>
<p>/ Replaces all occurrences of a specified character in this instance with another specified character. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>The character to replace. /</td></tr>
    <tr><td class="paramname">new_char</td><td>The character that replaces <code>old_char</code>. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance with <code>old_char</code> replaced by <code>new_char</code>. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal, case-sensitive comparison to identify occurrences of <code>old_char</code> in the current instance. The size of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> instance is unchanged after the replacement. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; replace(value_type old_char, value_type new_char) noexcept {return replace(old_char, new_char, 0, length());} / Replaces, within a substring of this instance, all occurrences of a specified character with another specified character. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>The character to replace. /</td></tr>
    <tr><td class="paramname">new_char</td><td>The character that replaces <code>old_char</code>. /</td></tr>
    <tr><td class="paramname">start_index</td><td>The position in this instance where the substring begins. /</td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this instance with <code>old_char</code> replaced by <code>new_char</code> in the range from <code>start_ index</code> to <code>start_index</code> + <code>count</code> - 1. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal, case-sensitive comparison to identify occurrences of <code>old_char</code> in the current instance. The size of the current <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object is unchanged after the replacement. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; replace(value_type old_char, value_type new_char, size_type start_index, size_type count) {return replace(xtd::basic_string&lt;char_t&gt;(1, old_char), xtd::basic_string&lt;char_t&gt;(1, new_char), start_index, count);} / Replaces all occurrences of a specified string in this instance with another specified string. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_value</td><td>The string to replace. /</td></tr>
    <tr><td class="paramname">new_value</td><td>The string that replaces 'old_value<code>. @return A reference to this instance with all instances of</code>old_value<code>replaced by</code>new_value<code>. @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. @remarks This method performs an ordinal, case-sensitive comparison to identify occurrences of</code>old_value<code>in the current instance. If</code>new_value<code>is xtd::basic_string::empty_string, all occurrences of</code>old_value` are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b5d1e871c0993f1d447d2ee567e523d" name="a7b5d1e871c0993f1d447d2ee567e523d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5d1e871c0993f1d447d2ee567e523d">&#9670;&#160;</a></span>replace() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const_iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces, within a substring of this instance, all occurrences of a specified string with another specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_value</td><td>The string to replace. </td></tr>
    <tr><td class="paramname">new_value</td><td>The string that replaces 'old_value<code>. / @param start_index The position in this instance where the substring begins. / @param count The length of the substring. / @return A reference to this instance with all instances of</code>old_value<code>replaced by</code>new_value<code>in the range from</code>start_index<code>to</code>start_index<code>+</code>count<code>- 1. / @exception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></code>start_index<code>plus</code>count<code>indicates a character position not within this instance.&lt;br&gt;-or-&lt;br&gt;Enlarging the value of this instance would exceed xtd::text::basic_string_builder::max_capacity. / @remarks This method performs an ordinal, case-sensitive comparison to identify occurrences of</code>old_value<code>in the substring of this current instance. If</code>new_value<code>is xtd::basic_string::empty_string, all occurrences of</code>old_value` are removed. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; replace(const xtd::basic_string&lt;char_t&gt;&amp; old_value, const xtd::basic_string&lt;char_t&gt;&amp; new_value, size_type start_index, size_type count) { if (start_index &gt; <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a> || start_index + count &gt; <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b" title="Returns the length of the current read_only_span.">length()</a>) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range); auto old_size = old_value.size(); auto new_size = new_value.size(); auto index = <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::size</a> {0}; while (true) { index = find(old_value, index); if (index == npos || index &gt;= start_index + count) break; if (index &gt;= start_index) { if (old_size == new_size) replace(index, old_size, new_value); else { erase(index, old_value.size()); <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0df5f3dfd2650ae5be9993434e2b2c0" title="The INS (INSERT) key.">insert(index, new_value)</a>; } } index += new_value.size(); } return *this; }</td></tr>
  </table>
  </dd>
</dl>
<p>/ Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. /</td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. /</td></tr>
    <tr><td class="paramname">str</td><td>The string to use for replacement. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with <code>str</code>. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; replace(size_type pos, size_type count, const basic_string_builder&amp; str) { if (pos &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> || pos + count &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range); chars_.replace(pos, count, str); return *this; } / Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. /</td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. /</td></tr>
    <tr><td class="paramname">str</td><td>The string to use for replacement. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. / </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with <code>str</code>. / </dd>
<dd>
If [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last`) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a0f15b2e74550cadf3a03adb10bbbbced" name="a0f15b2e74550cadf3a03adb10bbbbced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f15b2e74550cadf3a03adb10bbbbced">&#9670;&#160;</a></span>replace() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">str</td><td>The string to use for replacement. </td></tr>
    <tr><td class="paramname">pos2</td><td>The start of the substring to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with a substring [<code>pos2</code>, <code>std::min(pos2 + count2, str.size())</code>) of <code>str</code>. </dd></dl>

</div>
</div>
<a id="a3759d0dbdb288f6d9516aefe8878b525" name="a3759d0dbdb288f6d9516aefe8878b525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3759d0dbdb288f6d9516aefe8878b525">&#9670;&#160;</a></span>replace() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">str</td><td>The string to use for replacement. </td></tr>
    <tr><td class="paramname">pos2</td><td>The start of the substring to replace with. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with a substring [<code>pos2</code>, <code>std::min(pos2 + count2, str.size())</code>) of <code>str</code>. </dd></dl>

</div>
</div>
<a id="a1ee9f691c22dcd1658803d4496117255" name="a1ee9f691c22dcd1658803d4496117255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee9f691c22dcd1658803d4496117255">&#9670;&#160;</a></span>replace() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>cstr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">cstr</td><td>The pointer to the character string to use for replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with the characters in the range [<code>cstr</code>, <code>cstr + count2</code>). </dd>
<dd>
If [<code>cstr</code>, <code>cstr + count2</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a34c7af9db7caa09b5f865b9d20e95c7c" name="a34c7af9db7caa09b5f865b9d20e95c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c7af9db7caa09b5f865b9d20e95c7c">&#9670;&#160;</a></span>replace() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const_iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>cstr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">cstr</td><td>The pointer to the character string to use for replacement. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with the characters in the range [<code>cstr</code>, <code>cstr + count2</code>). </dd>
<dd>
If [<code>cstr</code>, <code>cstr + count2</code>) is not a valid range, the behavior is undefined. </dd>
<dd>
If [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last<code>) is not a valid range, the behavior is undefined. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; replace(const_iterator first, const_iterator last, const_pointer cstr, size_type count2) { chars_.replace(first, last, cstr, count2); return *this; } / @brief Replaces the characters in the range [</code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos<code>,</code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)<code>) or [</code>first<code>,</code>last<code>) with given characters. / @param pos The start of the substring that is going to be replaced. / @param count The length of the substring that is going to be replaced. / @param cstr The pointer to the character string to use for replacement. / @return This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. / @remarks Those characters are replaced with the characters in the range [</code>cstr<code>,</code>cstr + Traits::length(cstr)<code>). <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; replace(size_type pos, size_type count, const_pointer cstr) { chars_.replace(pos, count, cstr); return *this; } / @brief Replaces the characters in the range [</code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos<code>,</code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)<code>) or [</code>first<code>,</code>last<code>) with given characters. / @param first The first itrator of range of characters that is going to be replaced. / @param last The last itrator of range of characters that is going to be replaced. / @return This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. / @remarks Those characters are replaced with the characters in the range [</code>cstr<code>,</code>cstr + Traits::length(cstr)<code>). / @remarks If [</code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a><code>,</code>first<code>) or [</code>first<code>, last</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a9e630d3858ea0aad67093fb1f51a3977" name="a9e630d3858ea0aad67093fb1f51a3977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e630d3858ea0aad67093fb1f51a3977">&#9670;&#160;</a></span>replace() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The start of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring that is going to be replaced. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with <code>count2</code> copies of <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a111f0dbc2b4811ecdd92f884e9cbc578" name="a111f0dbc2b4811ecdd92f884e9cbc578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111f0dbc2b4811ecdd92f884e9cbc578">&#9670;&#160;</a></span>replace() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const_iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters to replace with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with <code>count2</code> copies of <code>ch</code>. </dd>
<dd>
If [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last<code>) is not a valid range, the behavior is undefined. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; replace(const_iterator first, const_iterator last, size_type count2, value_type ch) { chars_.replace(first, last, count2, ch); return *this; } / @brief Replaces the characters in the range [</code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos<code>,</code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)<code>) or [</code>first<code>,</code>last<code>) with given characters. / @param first The first itrator of range of characters that is going to be replaced. / @param last The last itrator of range of characters that is going to be replaced. / @param first2 The first itrator of range of characters to use for replacement. / @param last2 The last itrator of range of characters to use for replacement. / @return This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. / @remarks Those characters are replaced with the characters in the range [</code>first2<code>,</code>last2<code>) as if by</code>replace(first, last, basic_string(first2, last2, get_allocator()))<code>. / @remarks If [</code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a><code>,</code>first<code>) or [</code>first<code>, last</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="afd2785748c9a606a2c0c724086b3b7a3" name="afd2785748c9a606a2c0c724086b3b7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2785748c9a606a2c0c724086b3b7a3">&#9670;&#160;</a></span>rfind() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the characters in the range [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + pos</code>, <code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a> + std::min(pos + count, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>)</code>) or [<code>first</code>, <code>last</code>) with given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>The last itrator of range of characters that is going to be replaced. </td></tr>
    <tr><td class="paramname">ilist</td><td>The initializer list with the characters to use for replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance of <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those characters are replaced with the characters in <code>ilist</code>. </dd>
<dd>
If [<code><a class="el" href="namespacextd.html#a2b4bd6a98991447f6d1d2b4870a2f3b5" title="Returns an iterator to the beginning.">begin()</a></code>, <code>first</code>) or [<code>first</code>, last`) is not a valid range, the behavior is undefined. <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">basic_string_builder</a>&amp; replace(const_iterator first, const_iterator last, std::initializer_list&lt;value_type&gt; ilist) { chars_.replace(first, last, ilist); return *this; }</dd></dl>
<p>/ Informs a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> object of a planned change in size, so that it can manage the storage allocation appropriately /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>The new capacity of the string. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>new_cap</code> is greater than the current capacity(), new storage is allocated, and capacity() is made equal or greater than <code>new_cap</code>. / </dd>
<dd>
If <code>new_cap</code> is less than or equal to the current capacity(), there is no effect. / </dd>
<dd>
If a capacity change takes place, all iterators and references, including the past-the-end iterator, are invalidated. void reserve(size_type new_cap) { if (new_cap &gt; max_capacity_) xtd::helpers::throw_helper::throws(xtd::helpers::exception_case::argument_out_of_range);; if (new_cap &lt;= capacity()) return; chars_.reserve(new_cap); }</dd></dl>
<p>/ Resizes the string to contain count characters. /</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the string. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the current size is less than <code>count</code>, additional characters are appended: / </dd>
<dd>
Initializes appended characters to value_type() ('\0' if value_type is char). void resize(size_type count) {chars_.resize(count);} / Resizes the string to contain count characters. /</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the string. /</td></tr>
    <tr><td class="paramname">ch</td><td>The character to initialize the new characters with. / </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the current size is less than <code>count</code>, additional characters are appended: / </dd>
<dd>
Initializes appended characters to <code>ch</code>. void resize(size_type count, value_type ch) {chars_.resize(count, ch);}</dd></dl>
<p>/ Finds the last substring that is equal to the given character sequence. The search begins at xtd::text::basic_string_builder::npos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following xtd::text::basic_string_builder::npos). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as xtd::text::basic_string_builder::npos, the whole string will be searched. @return Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. @remarks Finds the first substring equal to</code>str`. </p>

</div>
</div>
<a id="a50146eee209c5eeef9ea1a6eaebb2459" name="a50146eee209c5eeef9ea1a6eaebb2459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50146eee209c5eeef9ea1a6eaebb2459">&#9670;&#160;</a></span>rfind() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="aa0aad3615278f80f49b1a999a6317f13" name="aa0aad3615278f80f49b1a999a6317f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aad3615278f80f49b1a999a6317f13">&#9670;&#160;</a></span>rfind() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a2ee1570674497bc4871d7ad3b9b17ed7" name="a2ee1570674497bc4871d7ad3b9b17ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee1570674497bc4871d7ad3b9b17ed7">&#9670;&#160;</a></span>rfind() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at xtd::text::basic_string_builder::npos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following xtd::text::basic_string_builder::npos). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as xtd::text::basic_string_builder::npos, the whole string will be searched. / @param s The pointer to a character string to search for. / @return Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. / @remarks Finds the first substring equal to the character string pointed to by</code>s<code>. The length of the string is determined by the first null character using</code>traits_t::length(s)<code>. / @remarks If [</code>s<code>,</code>s + traits_t::length(s)<code>) is not a valid range, the behavior is undefined. size_type rfind(const_pointer s) const {return chars_.rfind(s);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at</code>pos<code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following</code>pos<code>). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as</code>pos<code>, the whole string will be searched. / @param s The pointer to a character string to search for. / @param pos The position at which to start the search / @return Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. / @remarks Finds the first substring equal to the character string pointed to by</code>s<code>. The length of the string is determined by the first null character using</code>traits_t::length(s)<code>. / @remarks If [</code>s<code>,</code>s + traits_t::length(s)<code>) is not a valid range, the behavior is undefined. size_type rfind(const_pointer s, size_type pos) const {return chars_.rfind(s, pos);} / @brief Finds the last substring that is equal to the given character sequence. The search begins at xtd::text::basic_string_builder::npos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following xtd::text::basic_string_builder::npos). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as xtd::text::basic_string_builder::npos, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="adcd5950f09061481c41efd222922d8ce" name="adcd5950f09061481c41efd222922d8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd5950f09061481c41efd222922d8ce">&#9670;&#160;</a></span>rfind() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If xtd::text::basic_string_builder::npos or any value not smaller than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">xtd::text::basic_string_builder::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or xtd::text::basic_string_builder::npos if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a3fa3478a9e5c14cf145652dae38ef19f" name="a3fa3478a9e5c14cf145652dae38ef19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa3478a9e5c14cf145652dae38ef19f">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>
<dl class="section remark"><dt>Remarks</dt><dd>It is a non-binding request to reduce capacity() to <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>. It depends on the implementation if the request is fulfilled. </dd>
<dd>
If (and only if) reallocation takes place, all pointers, references, and iterators are invalidated. </dd></dl>

</div>
</div>
<a id="a168d97f3252db3d6706fa324190fbcd8" name="a168d97f3252db3d6706fa324190fbcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168d97f3252db3d6706fa324190fbcd8">&#9670;&#160;</a></span>substr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == xtd::text::basic_string_builder::npos), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string_builder(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="aa6b6033babf65f6afa93c1fa114fae88" name="aa6b6033babf65f6afa93c1fa114fae88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b6033babf65f6afa93c1fa114fae88">&#9670;&#160;</a></span>substr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == xtd::text::basic_string_builder::npos), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string_builder(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="a40cd57b1e78f411c904144725389941a" name="a40cd57b1e78f411c904144725389941a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cd57b1e78f411c904144725389941a">&#9670;&#160;</a></span>substr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == xtd::text::basic_string_builder::npos), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string_builder(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="aa4adcc8a4f6c42434091cc96fcc49061" name="aa4adcc8a4f6c42434091cc96fcc49061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4adcc8a4f6c42434091cc96fcc49061">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the string with those of other. All iterators and references may be invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to exchange the contents with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a877feeab7ac0df07e40be12990dec52d" name="a877feeab7ac0df07e40be12990dec52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877feeab7ac0df07e40be12990dec52d">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__strings.html#ga2bd6ab53224f55d280a88872353123eb">xtd::string</a> <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo</a></b></dt><dd>Uncomment the folllowing line and remove the next.. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">xtd::object</a>.</p>

</div>
</div>
<a id="a3d162b34eefce8985ad367f3ca78e4dc" name="a3d162b34eefce8985ad367f3ca78e4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d162b34eefce8985ad367f3ca78e4dc">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the character at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the character to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99facb90b642227990bd5b1f94bb1750" name="a99facb90b642227990bd5b1f94bb1750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99facb90b642227990bd5b1f94bb1750">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the character at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the character to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1f8e06524f9fa65f9c7017a9d9e4619" name="ab1f8e06524f9fa65f9c7017a9d9e4619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f8e06524f9fa65f9c7017a9d9e4619">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator const base_type &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a6f826690bfb0d112064bfdd5cb0e0f88" name="a6f826690bfb0d112064bfdd5cb0e0f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f826690bfb0d112064bfdd5cb0e0f88">&#9670;&#160;</a></span>operator base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator base_type &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a1ecaa8470016180805e8aae60741be04" name="a1ecaa8470016180805e8aae60741be04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecaa8470016180805e8aae60741be04">&#9670;&#160;</a></span>operator=() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="afea8f1950013cfa7b62845ed804eadf2" name="afea8f1950013cfa7b62845ed804eadf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea8f1950013cfa7b62845ed804eadf2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aeb76aa90b3febf78d306d5eae58c0aaa" name="aeb76aa90b3febf78d306d5eae58c0aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb76aa90b3febf78d306d5eae58c0aaa">&#9670;&#160;</a></span>operator=() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; value_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a8cba958ff90c1eae4110b211598479ed" name="a8cba958ff90c1eae4110b211598479ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cba958ff90c1eae4110b211598479ed">&#9670;&#160;</a></span>operator=() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; value_type &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a361314e49ff5adb0ece44b9ebeaa068d" name="a361314e49ff5adb0ece44b9ebeaa068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361314e49ff5adb0ece44b9ebeaa068d">&#9670;&#160;</a></span>operator=() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; value_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a7c7b1d4ebec4fcf9da9d90ea3c3219cb" name="a7c7b1d4ebec4fcf9da9d90ea3c3219cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7b1d4ebec4fcf9da9d90ea3c3219cb">&#9670;&#160;</a></span>operator=() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; value_type &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a9440ad97280090e604efa6d926641189" name="a9440ad97280090e604efa6d926641189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9440ad97280090e604efa6d926641189">&#9670;&#160;</a></span>operator=() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ad8965763778b83efc5a9f7557806f2a1" name="ad8965763778b83efc5a9f7557806f2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8965763778b83efc5a9f7557806f2a1">&#9670;&#160;</a></span>operator=() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>character</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a628c15f570caf7d2efa10554d1fde169" name="a628c15f570caf7d2efa10554d1fde169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628c15f570caf7d2efa10554d1fde169">&#9670;&#160;</a></span>operator=() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; value_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>il</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a091ac07faa8b98417e11d70f4272d1c1" name="a091ac07faa8b98417e11d70f4272d1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091ac07faa8b98417e11d70f4272d1c1">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="af2b9d25941d4757dc74bb5b1a956d79f" name="af2b9d25941d4757dc74bb5b1a956d79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b9d25941d4757dc74bb5b1a956d79f">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a446536be6df64bb7da260de2891a3993" name="a446536be6df64bb7da260de2891a3993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446536be6df64bb7da260de2891a3993">&#9670;&#160;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const_pointer</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="aad64103e7fd14893e78d8ccd8e71bb82" name="aad64103e7fd14893e78d8ccd8e71bb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad64103e7fd14893e78d8ccd8e71bb82">&#9670;&#160;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t, class traits_t = std::char_traits&lt;char_t&gt;, class allocator_t = xtd::collections::generic::helpers::allocator&lt;char_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">basic_string_builder</a> &amp; <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html">xtd::text::basic_string_builder</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">value_type</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/text/<a class="el" href="basic__string__builder_8hpp_source.html">basic_string_builder.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 23 2025 18:04:43 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
