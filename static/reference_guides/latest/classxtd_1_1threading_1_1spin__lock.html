<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::spin_lock Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html">spin_lock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1threading_1_1spin__lock-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::spin_lock Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::spin_lock:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1spin__lock.png" usemap="#xtd::threading::spin_5Flock_map" alt=""/>
  <map id="xtd::threading::spin_5Flock_map" name="xtd::threading::spin_5Flock_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,146,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1threading_1_1spin__lock.html">spin_lock</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.h:32</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1spin__lock_html"><div class="ttname"><a href="classxtd_1_1threading_1_1spin__lock.html">xtd::threading::spin_lock</a></div><div class="ttdoc">Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...</div><div class="ttdef"><b>Definition</b> spin_lock.h:34</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/spin_lock&gt;</span> </div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example shows how to use a <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a>: <div class="fragment"></div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Spin locks can be used for leaf-level locks where the object allocation implied by using a <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a>, in size, is overly expensive. A spin lock can be useful to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning. Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short. In general, while holding a spin lock, one should avoid any of these actions:<ul>
<li>blocking,</li>
<li>calling anything that itself may block,</li>
<li>holding more than one spin lock at once,</li>
<li>making dynamically dispatched calls (interface and virtuals),</li>
<li>making statically dispatched calls into any code one doesn't own, or</li>
<li>allocating memory. </li>
</ul>
</dd>
<dd>
<a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> should only be used after you have been determined that doing so will improve an application's performance. It is also important to note that <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> is a value type, for performance reasons. For this reason, you must be very careful not to accidentally copy a <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application. If a <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> instance must be passed around, it should be passed by reference rather than by value. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors</h2></td></tr>
<tr class="memitem:a58fa5007bcd2bf8644d8dc8ce9b30823"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a58fa5007bcd2bf8644d8dc8ce9b30823">spin_lock</a> ()</td></tr>
<tr class="memdesc:a58fa5007bcd2bf8644d8dc8ce9b30823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> structure.  <br /></td></tr>
<tr class="separator:a58fa5007bcd2bf8644d8dc8ce9b30823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1564fffb6c9f3ee5ea802e7c8a689323"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a1564fffb6c9f3ee5ea802e7c8a689323">spin_lock</a> (bool enable_thread_owner_tracking)</td></tr>
<tr class="memdesc:a1564fffb6c9f3ee5ea802e7c8a689323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> structure with the option to track thread IDs to improve debugging.  <br /></td></tr>
<tr class="separator:a1564fffb6c9f3ee5ea802e7c8a689323"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Properties</h2></td></tr>
<tr class="memitem:acdc54498e82b31d71af62424ffbc2cb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#acdc54498e82b31d71af62424ffbc2cb8">is_held</a> () const noexcept</td></tr>
<tr class="memdesc:acdc54498e82b31d71af62424ffbc2cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the lock is currently held by any thread.  <br /></td></tr>
<tr class="separator:acdc54498e82b31d71af62424ffbc2cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fa245a6e054558dd7d4272602c93d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a92fa245a6e054558dd7d4272602c93d0">is_held_by_current_thread</a> () const noexcept</td></tr>
<tr class="memdesc:a92fa245a6e054558dd7d4272602c93d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the lock is held by the current thread.  <br /></td></tr>
<tr class="separator:a92fa245a6e054558dd7d4272602c93d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531972816dbf8084244030140a9db621"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a531972816dbf8084244030140a9db621">is_thread_owner_tracking_enabled</a> () const noexcept</td></tr>
<tr class="memdesc:a531972816dbf8084244030140a9db621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether thread ownership tracking is enabled for this instance.  <br /></td></tr>
<tr class="separator:a531972816dbf8084244030140a9db621"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods</h2></td></tr>
<tr class="memitem:a24e13fcd4189869a3d23e187b42c792a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a">enter</a> (bool &amp;lock_taken)</td></tr>
<tr class="memdesc:a24e13fcd4189869a3d23e187b42c792a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired.  <br /></td></tr>
<tr class="separator:a24e13fcd4189869a3d23e187b42c792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ee56319b6e02c8c404321d04f6347e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a61ee56319b6e02c8c404321d04f6347e">exit</a> ()</td></tr>
<tr class="memdesc:a61ee56319b6e02c8c404321d04f6347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock.  <br /></td></tr>
<tr class="separator:a61ee56319b6e02c8c404321d04f6347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b66f6109eea3da0fe54e44886419782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a1b66f6109eea3da0fe54e44886419782">exit</a> (bool use_memory_barrier)</td></tr>
<tr class="memdesc:a1b66f6109eea3da0fe54e44886419782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock.  <br /></td></tr>
<tr class="separator:a1b66f6109eea3da0fe54e44886419782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e1ebdce78eacbba641ca8cb0d36ada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada">try_enter</a> (bool &amp;lock_taken)</td></tr>
<tr class="memdesc:a18e1ebdce78eacbba641ca8cb0d36ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired.  <br /></td></tr>
<tr class="separator:a18e1ebdce78eacbba641ca8cb0d36ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef47de7e0dec014b37778a0a6558433d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#aef47de7e0dec014b37778a0a6558433d">try_enter</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout, bool &amp;lock_taken)</td></tr>
<tr class="memdesc:aef47de7e0dec014b37778a0a6558433d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired.  <br /></td></tr>
<tr class="separator:aef47de7e0dec014b37778a0a6558433d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80299f8d1b5945954a087b17c3213e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#ac80299f8d1b5945954a087b17c3213e6">try_enter</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>, bool &amp;lock_taken)</td></tr>
<tr class="memdesc:ac80299f8d1b5945954a087b17c3213e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired.  <br /></td></tr>
<tr class="separator:ac80299f8d1b5945954a087b17c3213e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#aa8027c211754118c30ccf7e52557fd7a">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af734e36ea583a842339d7c4444fb6d86">memberwise_clone</a> () const noexcept</td></tr>
<tr class="memdesc:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sxd::ustring that represents the current object.  <br /></td></tr>
<tr class="separator:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a75cb9ed56172fb088ca6697d5d836b13">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1ee13700465eead7934f450749b952d7">reference_equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a58fa5007bcd2bf8644d8dc8ce9b30823" name="a58fa5007bcd2bf8644d8dc8ce9b30823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fa5007bcd2bf8644d8dc8ce9b30823">&#9670;&#160;</a></span>spin_lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::spin_lock::spin_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> structure. </p>

</div>
</div>
<a id="a1564fffb6c9f3ee5ea802e7c8a689323" name="a1564fffb6c9f3ee5ea802e7c8a689323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1564fffb6c9f3ee5ea802e7c8a689323">&#9670;&#160;</a></span>spin_lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::spin_lock::spin_lock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_thread_owner_tracking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> structure with the option to track thread IDs to improve debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_thread_owner_tracking</td><td>Whether to capture and use thread IDs for debugging purposes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The parameterless constructor for <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> tracks thread ownership. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a24e13fcd4189869a3d23e187b42c792a" name="a24e13fcd4189869a3d23e187b42c792a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e13fcd4189869a3d23e187b42c792a">&#9670;&#160;</a></span>enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::enter </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_taken</td><td>True if the lock is acquired; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1lock__recursion__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::lock_recursion_exception</a></td><td>Thread ownership tracking is enabled, and the current thread has already acquired this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's enabled is available through <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a531972816dbf8084244030140a9db621" title="Gets whether thread ownership tracking is enabled for this instance.">xtd::threading::spin_lock::is_thread_owner_tracking_enabled</a>), an exception will be thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock. </dd></dl>

</div>
</div>
<a id="a61ee56319b6e02c8c404321d04f6347e" name="a61ee56319b6e02c8c404321d04f6347e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ee56319b6e02c8c404321d04f6347e">&#9670;&#160;</a></span>exit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::synchronization_lock_exception</a></td><td>Thread ownership tracking is enabled, and the current thread is not the owner of this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The default overload of Exit provides the same behavior as if calling Exit using true as the argument. </dd>
<dd>
If you call <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a61ee56319b6e02c8c404321d04f6347e" title="Releases the lock.">xtd::threading::spin_lock::exit</a> without having first called <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a> the internal state of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> can become corrupted. </dd></dl>

</div>
</div>
<a id="a1b66f6109eea3da0fe54e44886419782" name="a1b66f6109eea3da0fe54e44886419782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b66f6109eea3da0fe54e44886419782">&#9670;&#160;</a></span>exit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::exit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_memory_barrier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_memory_barrier</td><td>A bool value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::synchronization_lock_exception</a></td><td>Thread ownership tracking is enabled, and the current thread is not the owner of this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling Exit with the use_memory_barrier argument set to true will improve the fairness of the lock at the expense of some performance. The default <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a61ee56319b6e02c8c404321d04f6347e" title="Releases the lock.">xtd::threading::spin_lock::exit</a> overload behaves as if specifying true for use_memory_barrier. </dd>
<dd>
If you call <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a61ee56319b6e02c8c404321d04f6347e" title="Releases the lock.">xtd::threading::spin_lock::exit</a> without having first called <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a> the internal state of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> can become corrupted. </dd></dl>

</div>
</div>
<a id="acdc54498e82b31d71af62424ffbc2cb8" name="acdc54498e82b31d71af62424ffbc2cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc54498e82b31d71af62424ffbc2cb8">&#9670;&#160;</a></span>is_held()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::spin_lock::is_held </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the lock is currently held by any thread. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the lock is currently held by any thread; otherwise false. </dd></dl>

</div>
</div>
<a id="a92fa245a6e054558dd7d4272602c93d0" name="a92fa245a6e054558dd7d4272602c93d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fa245a6e054558dd7d4272602c93d0">&#9670;&#160;</a></span>is_held_by_current_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::spin_lock::is_held_by_current_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the lock is held by the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the lock is held by the current thread; otherwise false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread. It is invalid to use this property when the lock was initialized to not track thread ownership. </dd></dl>

</div>
</div>
<a id="a531972816dbf8084244030140a9db621" name="a531972816dbf8084244030140a9db621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531972816dbf8084244030140a9db621">&#9670;&#160;</a></span>is_thread_owner_tracking_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::spin_lock::is_thread_owner_tracking_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether thread ownership tracking is enabled for this instance. </p>
<dl class="section return"><dt>Returns</dt><dd>true if thread ownership tracking is enabled for this instance; otherwise false. </dd></dl>

</div>
</div>
<a id="a18e1ebdce78eacbba641ca8cb0d36ada" name="a18e1ebdce78eacbba641ca8cb0d36ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e1ebdce78eacbba641ca8cb0d36ada">&#9670;&#160;</a></span>try_enter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::try_enter </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_taken</td><td>True if the lock is acquired; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1lock__recursion__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::lock_recursion_exception</a></td><td>Thread ownership tracking is enabled, and the current thread has already acquired this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a>, <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada" title="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the m...">xtd::threading::spin_lock::try_enter</a> will not block waiting for the lock to be available. If the lock is not available when <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada" title="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the m...">xtd::threading::spin_lock::try_enter</a> is called, it will return immediately without any further spinning. </dd></dl>

</div>
</div>
<a id="ac80299f8d1b5945954a087b17c3213e6" name="ac80299f8d1b5945954a087b17c3213e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80299f8d1b5945954a087b17c3213e6">&#9670;&#160;</a></span>try_enter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::try_enter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> that represents the number of milliseconds to wait, or a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> that represents -1 milliseconds to wait indefinitely. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>True if the lock is acquired; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1lock__recursion__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::lock_recursion_exception</a></td><td>Thread ownership tracking is enabled, and the current thread has already acquired this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a>, <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada" title="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the m...">xtd::threading::spin_lock::try_enter</a> will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the timeout has expired. </dd></dl>

</div>
</div>
<a id="aef47de7e0dec014b37778a0a6558433d" name="aef47de7e0dec014b37778a0a6558433d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef47de7e0dec014b37778a0a6558433d">&#9670;&#160;</a></span>try_enter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::try_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait, or <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> (-1) to wait indefinitely. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>True if the lock is acquired; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1lock__recursion__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::lock_recursion_exception</a></td><td>Thread ownership tracking is enabled, and the current thread has already acquired this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a>, <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada" title="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the m...">xtd::threading::spin_lock::try_enter</a> will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the milliseconds_timeout has expired. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="spin__lock_8h_source.html">spin_lock.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 22 2024 10:39:06 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
