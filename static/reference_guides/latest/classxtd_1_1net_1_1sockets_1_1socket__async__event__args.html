<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::net::sockets::socket_async_event_args Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1net.html">net</a></li><li class="navelem"><a class="el" href="namespacextd_1_1net_1_1sockets.html">sockets</a></li><li class="navelem"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::net::sockets::socket_async_event_args Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">﹡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::net::sockets::socket_async_event_args:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.png" usemap="#xtd::net::sockets::socket_5Fasync_5Fevent_5Fargs_map" alt=""/>
  <map id="xtd::net::sockets::socket_5Fasync_5Fevent_5Fargs_map" name="xtd::net::sockets::socket_5Fasync_5Fevent_5Fargs_map">
<area href="classxtd_1_1event__args.html" title="Represents the base class for classes that contain event data, and provides a value to use for events..." alt="xtd::event_args" shape="rect" coords="0,56,252,80"/>
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,252,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Represents an asynchronous socket operation. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_function" href="#afcf275879500d3f4f44e9acbbef5a4ad">socket_async_event_args</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1event__args.html">xtd::event_args</a></div>
<div class="ttc" id="aclassxtd_1_1event__args_html"><div class="ttname"><a href="classxtd_1_1event__args.html">xtd::event_args</a></div><div class="ttdoc">Represents the base class for classes that contain event data, and provides a value to use for events...</div><div class="ttdef"><b>Definition</b> event_args.hpp:18</div></div>
<div class="ttc" id="aclassxtd_1_1net_1_1sockets_1_1socket__async__event__args_html_afcf275879500d3f4f44e9acbbef5a4ad"><div class="ttname"><a href="#afcf275879500d3f4f44e9acbbef5a4ad">xtd::net::sockets::socket_async_event_args::socket_async_event_args</a></div><div class="ttdeci">socket_async_event_args()=default</div><div class="ttdoc">Creates an empty xtd::net::sockets::socket_async_event_args instance.</div></div>
<div class="ttc" id="agroup__keywords_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.hpp:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1event__args.html" title="Represents the base class for classes that contain event data, and provides a value to use for events...">xtd::event_args</a> → <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/net/sockets/socket_async_event_args&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1net_1_1sockets.html" title="The xtd::net::sockets namespace provides a managed implementation of the Berkeley Sockets interface f...">xtd::net::sockets</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> class is part of a set of enhancements to the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> class that provide an alternative asynchronous pattern that can be used by specialized high-performance socket applications. This class was specifically designed for network server applications that require high performance. An application can use the enhanced asynchronous pattern exclusively or only in targeted hot areas (for example, when receiving large amounts of data). </dd>
<dd>
The main feature of these enhancements is the avoidance of the repeated allocation and synchronization of objects during high-volume asynchronous socket I/O. The Begin/End design pattern currently implemented by the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> class requires a <a class="el" href="classxtd_1_1iasync__result.html" title="Represents the status of an asynchronous operation.">xtd::iasync_result</a> object be allocated for each asynchronous socket operation. </dd>
<dd>
In the new <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> class enhancements, asynchronous socket operations are described by reusable <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> objects allocated and maintained by the application. High-performance socket applications know best the amount of overlapped socket operations that must be sustained. The application can create as many of the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> objects that it needs. For example, if a server application needs to have 15 socket accept operations outstanding at all times to support incoming client connection rates, it can allocate 15 reusable <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> objects for that purpose. </dd>
<dd>
The pattern for performing an asynchronous socket operation with this class consists of the following steps:<ol type="1">
<li>Allocate a new <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> context object, or get a free one from an application pool.</li>
<li>Set properties on the context object to the operation about to be performed (the completion callback method, the data buffer, the offset into the buffer, and the maximum amount of data to transfer, for example).</li>
<li>Call the appropriate socket method (xxx_async) to initiate the asynchronous operation.</li>
<li>If the asynchronous socket method (xxx_async) returns <code>true</code>, in the callback, query the context properties for completion status.</li>
<li>If the asynchronous socket method (xxx_async) returns <code>false</code>, the operation completed synchronously. The context properties may be queried for the operation result.</li>
<li>Reuse the context for another operation, put it back in the pool, or discard it. </li>
</ol>
</dd>
<dd>
The lifetime of the new asynchronous socket operation context object is determined by references by the application code and asynchronous I/O references. It is not necessary for the application to retain a reference to an asynchronous socket operation context object after it is submitted as a parameter to one of the asynchronous socket operation methods. It will remain referenced until the completion callback returns. However it is advantageous for the application to retain the reference to the context so that it can be reused for a future asynchronous socket operation. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Events</h2></td></tr>
<tr class="memitem:a65c79e79a22401e10029936fee2c239d" id="r_a65c79e79a22401e10029936fee2c239d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1event.html">xtd::event</a>&lt; <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a>, xtd::delegate&lt; void(const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp;)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65c79e79a22401e10029936fee2c239d">completed</a></td></tr>
<tr class="memdesc:a65c79e79a22401e10029936fee2c239d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The event used to complete an asynchronous operation.  <br /></td></tr>
<tr class="separator:a65c79e79a22401e10029936fee2c239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:afcf275879500d3f4f44e9acbbef5a4ad" id="r_afcf275879500d3f4f44e9acbbef5a4ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcf275879500d3f4f44e9acbbef5a4ad">socket_async_event_args</a> ()=default</td></tr>
<tr class="memdesc:afcf275879500d3f4f44e9acbbef5a4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance.  <br /></td></tr>
<tr class="separator:afcf275879500d3f4f44e9acbbef5a4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc5080dc2c0825e3bb5d3b3d033fd7e" id="r_a1cc5080dc2c0825e3bb5d3b3d033fd7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cc5080dc2c0825e3bb5d3b3d033fd7e">socket_async_event_args</a> (bool suppress_execution_context_flow)</td></tr>
<tr class="memdesc:a1cc5080dc2c0825e3bb5d3b3d033fd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the SocketAsyncEventArgs.  <br /></td></tr>
<tr class="separator:a1cc5080dc2c0825e3bb5d3b3d033fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:a6e4a76dd4371da9f79a0527d2d654251" id="r_a6e4a76dd4371da9f79a0527d2d654251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html">xtd::net::sockets::socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e4a76dd4371da9f79a0527d2d654251">accept_socket</a> () const noexcept</td></tr>
<tr class="memdesc:a6e4a76dd4371da9f79a0527d2d654251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket to use or the socket created for accepting a connection with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:a6e4a76dd4371da9f79a0527d2d654251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087f0f8595a2005dfb80fe589c568b37" id="r_a087f0f8595a2005dfb80fe589c568b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a087f0f8595a2005dfb80fe589c568b37">accept_socket</a> (const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html">xtd::net::sockets::socket</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a087f0f8595a2005dfb80fe589c568b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the socket to use or the socket created for accepting a connection with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:a087f0f8595a2005dfb80fe589c568b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896899234c46784c7e9c12829e43f0d5" id="r_a896899234c46784c7e9c12829e43f0d5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#gaf2fe06df5401bdc7f8d62c5c55aa0ef4">xtd::byte</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a896899234c46784c7e9c12829e43f0d5">buffer</a> () const noexcept</td></tr>
<tr class="memdesc:a896899234c46784c7e9c12829e43f0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the data buffer to use with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:a896899234c46784c7e9c12829e43f0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c586d3eb24e987b80c366d5e6f0b62" id="r_a53c586d3eb24e987b80c366d5e6f0b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#gaf2fe06df5401bdc7f8d62c5c55aa0ef4">xtd::byte</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53c586d3eb24e987b80c366d5e6f0b62">buffer</a> () noexcept</td></tr>
<tr class="memdesc:a53c586d3eb24e987b80c366d5e6f0b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the data buffer to use with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:a53c586d3eb24e987b80c366d5e6f0b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:ae5a399f36ae7d7cfab3b1d711afd4016" id="r_ae5a399f36ae7d7cfab3b1d711afd4016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5a399f36ae7d7cfab3b1d711afd4016">set_buffer</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#gaf2fe06df5401bdc7f8d62c5c55aa0ef4">xtd::byte</a> &gt; &amp;memory_buffer)</td></tr>
<tr class="memdesc:ae5a399f36ae7d7cfab3b1d711afd4016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the region of memory to use as a buffer with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:ae5a399f36ae7d7cfab3b1d711afd4016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc17f9f31faa33850866560a068ee38" id="r_abdc17f9f31faa33850866560a068ee38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdc17f9f31faa33850866560a068ee38">set_buffer</a> (size_t offset, size_t count)</td></tr>
<tr class="memdesc:abdc17f9f31faa33850866560a068ee38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data buffer to use with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:abdc17f9f31faa33850866560a068ee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b9244656e0d6a370256310d58946b6" id="r_af0b9244656e0d6a370256310d58946b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0b9244656e0d6a370256310d58946b6">set_buffer</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#gaf2fe06df5401bdc7f8d62c5c55aa0ef4">xtd::byte</a> &gt; &amp;<a class="el" href="#a896899234c46784c7e9c12829e43f0d5">buffer</a>, size_t offset, size_t count)</td></tr>
<tr class="memdesc:af0b9244656e0d6a370256310d58946b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data buffer to use with an asynchronous socket method.  <br /></td></tr>
<tr class="separator:af0b9244656e0d6a370256310d58946b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Protected Methods</h2></td></tr>
<tr class="memitem:a0fa91c0d31760f45d51aa75df4172332" id="r_a0fa91c0d31760f45d51aa75df4172332"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fa91c0d31760f45d51aa75df4172332">on_complete</a> (const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>)</td></tr>
<tr class="memdesc:a0fa91c0d31760f45d51aa75df4172332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a method that is called when an asynchronous operation completes.  <br /></td></tr>
<tr class="separator:a0fa91c0d31760f45d51aa75df4172332"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:a57d59e60c60a648d26aa9e8cee2986ff" id="r_a57d59e60c60a648d26aa9e8cee2986ff"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1event__args.html">event_args</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1event__args.html#a57d59e60c60a648d26aa9e8cee2986ff">empty</a></td></tr>
<tr class="memdesc:a57d59e60c60a648d26aa9e8cee2986ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a value to use with events that do not have event data.  <br /></td></tr>
<tr class="separator:a57d59e60c60a648d26aa9e8cee2986ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853a24151468fffbafa1024a199a1091" id="r_a853a24151468fffbafa1024a199a1091"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1event__args.html#a853a24151468fffbafa1024a199a1091">event_args</a> ()=default</td></tr>
<tr class="memdesc:a853a24151468fffbafa1024a199a1091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1event__args.html" title="Represents the base class for classes that contain event data, and provides a value to use for events...">event_args</a> class.  <br /></td></tr>
<tr class="separator:a853a24151468fffbafa1024a199a1091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b" id="r_a2743b6f75405882c28eebe2456f3837b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd11aa88ce86568b701b33fd1b3e508" id="r_a6bd11aa88ce86568b701b33fd1b3e508"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a6bd11aa88ce86568b701b33fd1b3e508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a6bd11aa88ce86568b701b33fd1b3e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d19ef177db62351b58a42f22138dbe" id="r_af2d19ef177db62351b58a42f22138dbe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:af2d19ef177db62351b58a42f22138dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:af2d19ef177db62351b58a42f22138dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afcf275879500d3f4f44e9acbbef5a4ad" name="afcf275879500d3f4f44e9acbbef5a4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf275879500d3f4f44e9acbbef5a4ad">&#9670;&#160;</a></span>socket_async_event_args() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::net::sockets::socket_async_event_args::socket_async_event_args </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance. </p>
<dl class="section remark"><dt>Remarks</dt><dd>After calling this constructor all properties will have their default values:<ul>
<li>Object references will be null.</li>
<li>Properties that return an integer will return zero.</li>
<li>The xtd::net::sockets::socket_async_event_args::last_operation property will be equal to xtd::net::sockets::async_operation::none.</li>
<li>The xtd::net::sockets::socket_async_event_args::send_packets_flags property will be equal to <a class="el" href="group__xtd__core.html#gga926d52df9c101c748dd0e8b68dd91880a627224438c682e7853f4814e1ebafc49" title="Use the default thread to process long file transfer requests.">xtd::net::sockets::transmit_file_options::use_default_worker_thread</a>, which specifies no flags will be used.</li>
<li>The <a class="el" href="group__xtd__core.html#gacff43f3cb6c04f3be61be0a43cdbda16" title="Specifies socket send and receive behaviors. This enumeration has a flags attribute that allows a bit...">xtd::net::sockets::socket_async_event_args::socket_flags</a> property will be equal to xtd::net::sockets::async_operation::none. </li>
</ul>
</dd>
<dd>
The caller must set the appropriate properties prior to passing the object to the appropriate asynchronous socket (xxx_async) method. </dd></dl>

</div>
</div>
<a id="a1cc5080dc2c0825e3bb5d3b3d033fd7e" name="a1cc5080dc2c0825e3bb5d3b3d033fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc5080dc2c0825e3bb5d3b3d033fd7e">&#9670;&#160;</a></span>socket_async_event_args() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::net::sockets::socket_async_event_args::socket_async_event_args </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>suppress_execution_context_flow</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the SocketAsyncEventArgs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suppress_execution_context_flow</td><td>Whether to disable the capturing and flow of execution context. Execution context flow should only be disabled if it's handled by higher layers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e4a76dd4371da9f79a0527d2d654251" name="a6e4a76dd4371da9f79a0527d2d654251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4a76dd4371da9f79a0527d2d654251">&#9670;&#160;</a></span>accept_socket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html">xtd::net::sockets::socket</a> xtd::net::sockets::socket_async_event_args::accept_socket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the socket to use or the socket created for accepting a connection with an asynchronous socket method. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> to use or the socket created for accepting a connection with an asynchronous socket method. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property can be used to provide an already created Socket that will be used for an asynchronous socket accept operation. Upon completion of the accept operation, it is the socket representing the accepted connection. If not supplied (set to empty) before calling the xtd::net::sockets::socket::acceptA_async method, a new socket will be created automatically and be accessible in the completion callback with this property. </dd></dl>

</div>
</div>
<a id="a087f0f8595a2005dfb80fe589c568b37" name="a087f0f8595a2005dfb80fe589c568b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087f0f8595a2005dfb80fe589c568b37">&#9670;&#160;</a></span>accept_socket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp; xtd::net::sockets::socket_async_event_args::accept_socket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html">xtd::net::sockets::socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the socket to use or the socket created for accepting a connection with an asynchronous socket method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> to use or the socket created for accepting a connection with an asynchronous socket method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property can be used to provide an already created Socket that will be used for an asynchronous socket accept operation. Upon completion of the accept operation, it is the socket representing the accepted connection. If not supplied (set to empty) before calling the xtd::net::sockets::socket::acceptA_async method, a new socket will be created automatically and be accessible in the completion callback with this property. </dd></dl>

</div>
</div>
<a id="a896899234c46784c7e9c12829e43f0d5" name="a896899234c46784c7e9c12829e43f0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896899234c46784c7e9c12829e43f0d5">&#9670;&#160;</a></span>buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#gaf2fe06df5401bdc7f8d62c5c55aa0ef4">xtd::byte</a> &gt; &amp; xtd::net::sockets::socket_async_event_args::buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the data buffer to use with an asynchronous socket method. </p>
<dl class="section return"><dt>Returns</dt><dd>A Byte array that represents the data buffer to use with an asynchronous socket method. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property gets the data buffer currently associated with the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance. To set the buffer, the <a class="el" href="#ae5a399f36ae7d7cfab3b1d711afd4016" title="Sets the region of memory to use as a buffer with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::set_buffer</a> method must be used. </dd>
<dd>
This property is used with the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html#a23b63649d41275359b475ef60c279cf5" title="Begins an asynchronous operation to accept an incoming connection attempt.">xtd::net::sockets::socket::accept_async</a>, xtd::net::sockets::socket::connect_async, xtd::net::sockets::socket::receive_async, xtd::net::sockets::socket::receive_from_async, xtd::net::sockets::socket::receive_message_from_async, xtd::net::sockets::socket::send_async, and xtd::net::sockets::socket::send_to_async methods. </dd></dl>

</div>
</div>
<a id="a53c586d3eb24e987b80c366d5e6f0b62" name="a53c586d3eb24e987b80c366d5e6f0b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c586d3eb24e987b80c366d5e6f0b62">&#9670;&#160;</a></span>buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#gaf2fe06df5401bdc7f8d62c5c55aa0ef4">xtd::byte</a> &gt; &amp; xtd::net::sockets::socket_async_event_args::buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the data buffer to use with an asynchronous socket method. </p>
<dl class="section return"><dt>Returns</dt><dd>A Byte array that represents the data buffer to use with an asynchronous socket method. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property gets the data buffer currently associated with the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance. To set the buffer, the <a class="el" href="#ae5a399f36ae7d7cfab3b1d711afd4016" title="Sets the region of memory to use as a buffer with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::set_buffer</a> method must be used. </dd>
<dd>
This property is used with the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html#a23b63649d41275359b475ef60c279cf5" title="Begins an asynchronous operation to accept an incoming connection attempt.">xtd::net::sockets::socket::accept_async</a>, xtd::net::sockets::socket::connect_async, xtd::net::sockets::socket::receive_async, xtd::net::sockets::socket::receive_from_async, xtd::net::sockets::socket::receive_message_from_async, xtd::net::sockets::socket::send_async, and xtd::net::sockets::socket::send_to_async methods. </dd></dl>

</div>
</div>
<a id="ae5a399f36ae7d7cfab3b1d711afd4016" name="ae5a399f36ae7d7cfab3b1d711afd4016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a399f36ae7d7cfab3b1d711afd4016">&#9670;&#160;</a></span>set_buffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::net::sockets::socket_async_event_args::set_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#gaf2fe06df5401bdc7f8d62c5c55aa0ef4">xtd::byte</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>memory_buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the region of memory to use as a buffer with an asynchronous socket method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_buffer</td><td>The region of memory to use as a buffer with an asynchronous socket method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdc17f9f31faa33850866560a068ee38" name="abdc17f9f31faa33850866560a068ee38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc17f9f31faa33850866560a068ee38">&#9670;&#160;</a></span>set_buffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::net::sockets::socket_async_event_args::set_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the data buffer to use with an asynchronous socket method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset, in bytes, in the data buffer where the operation starts. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum amount of data, in bytes, to send or receive in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>An argument was out of range. This exception occurs if the offset parameter is greater than the length of the array in the <a class="el" href="#a896899234c46784c7e9c12829e43f0d5" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property. This exception also occurs if the count parameter is greater than the length of the array in the <a class="el" href="#a896899234c46784c7e9c12829e43f0d5" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property minus the offset parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The offset and count parameters can't be negative numbers. The combination of the offset and count parameters must be in bounds of the buffer array in the <a class="el" href="#a896899234c46784c7e9c12829e43f0d5" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property. </dd>
<dd>
This method sets the xtd::net::sockets::socket_async_event_args::count property to the count parameter and the xtd::net::sockets::socket_async_event_args::offset property to the offset parameter. If the <a class="el" href="#a896899234c46784c7e9c12829e43f0d5" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property is empty, this method ignores the offset and count parameters and sets the xtd::net::sockets::socket_async_event_args::offset and xtd::net::sockets::socket_async_event_args::count properties to 0. </dd>
<dd>
This method does not change the <a class="el" href="#a896899234c46784c7e9c12829e43f0d5" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property. </dd></dl>

</div>
</div>
<a id="af0b9244656e0d6a370256310d58946b6" name="af0b9244656e0d6a370256310d58946b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b9244656e0d6a370256310d58946b6">&#9670;&#160;</a></span>set_buffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::net::sockets::socket_async_event_args::set_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#gaf2fe06df5401bdc7f8d62c5c55aa0ef4">xtd::byte</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the data buffer to use with an asynchronous socket method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The data buffer to use with an asynchronous socket method. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, in the data buffer where the operation starts. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum amount of data, in bytes, to send or receive in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>An argument was out of range. This exception occurs if the offset parameter is greater than the length of the array in the <a class="el" href="#a896899234c46784c7e9c12829e43f0d5" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property. This exception also occurs if the count parameter is greater than the length of the array in the <a class="el" href="#a896899234c46784c7e9c12829e43f0d5" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property minus the offset parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The offset and count parameters can't be negative numbers. The combination of the offset and count parameters must be in bounds of the data array in the buffer parameter. </dd>
<dd>
This method sets the <a class="el" href="#a896899234c46784c7e9c12829e43f0d5" title="Gets the data buffer to use with an asynchronous socket method.">xtd::net::sockets::socket_async_event_args::buffer</a> property to the buffer parameter, the xtd::net::sockets::socket_async_event_args::count property to the count parameter, and the xtd::net::sockets::socket_async_event_args::offset property to the offset parameter. </dd></dl>

</div>
</div>
<a id="a0fa91c0d31760f45d51aa75df4172332" name="a0fa91c0d31760f45d51aa75df4172332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa91c0d31760f45d51aa75df4172332">&#9670;&#160;</a></span>on_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void xtd::net::sockets::socket_async_event_args::on_complete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents a method that is called when an asynchronous operation completes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The event that is signaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is not callable by user code. This method gets called by the internals of the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> object when the current operation is complete. This method is used with all asynchronous socket (xxx_async) methods. </dd>
<dd>
An application that creates a class inheriting from <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> can override this method to hook into this completion notification and clean up any resources that it allocated for the operation. The default implementation just raises the <a class="el" href="#a65c79e79a22401e10029936fee2c239d" title="The event used to complete an asynchronous operation.">xtd::net::sockets::socket_async_event_args::completed</a> event. </dd>
<dd>
This method is used to hook up an event handler to be used as the completion callback for a subsequent asynchronous socket operation. The caller must implement at least one callback delegate inherited from this method prior to starting an asynchronous socket operation using one of the asynchronous (xxx_async) methods on the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket.html" title="Implements the Berkeley sockets interface.">xtd::net::sockets::socket</a> class. </dd>
<dd>
The caller's xtd::net::sockets::socket_async_event_args::on_completed method provides a way for client applications to complete an asynchronous socket operation. A callback delegate must be implemented when an asynchronous socket operation is initiated. The completion callback delegate(s) inherited from the xtd::net::sockets::socket_async_event_args::on_completed method must contain program logic to finish processing the asynchronous socket operation for the client. </dd>
<dd>
When an asynchronous operation is signaled, the application uses the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> object parameter to obtain status of the completed asynchronous socket operation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a65c79e79a22401e10029936fee2c239d" name="a65c79e79a22401e10029936fee2c239d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c79e79a22401e10029936fee2c239d">&#9670;&#160;</a></span>completed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1event.html">xtd::event</a>&lt;<a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a>, xtd::delegate&lt;void(const <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html">socket_async_event_args</a>&amp;)&gt; &gt; xtd::net::sockets::socket_async_event_args::completed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The event used to complete an asynchronous operation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="#a65c79e79a22401e10029936fee2c239d" title="The event used to complete an asynchronous operation.">xtd::net::sockets::socket_async_event_args::completed</a> event provides a way for client applications to complete an asynchronous socket operation. An event handler should be attached to the event within a <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> instance when an asynchronous socket operation is initiated, otherwise the application will not be able to determine when the operation completes. </dd>
<dd>
The completion callback delegates referenced by the <a class="el" href="#a65c79e79a22401e10029936fee2c239d" title="The event used to complete an asynchronous operation.">xtd::net::sockets::socket_async_event_args::completed</a> event contains program logic to finish processing the asynchronous socket operation for the client. </dd>
<dd>
When the event is signaled, the application uses the <a class="el" href="classxtd_1_1net_1_1sockets_1_1socket__async__event__args.html" title="Represents an asynchronous socket operation.">xtd::net::sockets::socket_async_event_args</a> object parameter to obtain the status of the completed asynchronous socket operation. </dd>
<dd>
For more information about handling events, see <a href="https://gammasoft71.github.io/xtd/docs/documentation/guides/xtd.core/Events/overview">Handling and Raising Events</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/net/sockets/<a class="el" href="socket__async__event__args_8hpp_source.html">socket_async_event_args.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 14 2025 15:57:39 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
