<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::thread Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1threading_1_1thread-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::thread Class Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::thread:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1thread.png" usemap="#xtd::threading::thread_map" alt=""/>
  <map id="xtd::threading::thread_map" name="xtd::threading::thread_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,129,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Creates and controls a thread, sets its priority, and gets its status. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a> final : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.h:32</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html">xtd::threading::thread</a></div><div class="ttdoc">Creates and controls a thread, sets its priority, and gets its status.</div><div class="ttdef"><b>Definition</b> thread.h:41</div></div>
<div class="ttc" id="agroup__keywords_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.h:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> â†’ <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread&gt;</span> </div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates simple threading functionality. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/startup&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1threading.html">xtd::threading</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Simple threading scenario:  Start a static method running</span></div>
<div class="line"><span class="comment">// on a second thread.</span></div>
<div class="line"><span class="keyword">class </span>thread_example {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// The thread_proc method is called when the thread starts.</span></div>
<div class="line">  <span class="comment">// It loops ten times, writing to the console and yielding</span></div>
<div class="line">  <span class="comment">// the rest of its time slice each time, and then ends.</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc() {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> &lt; 10; ++<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;thread_proc: {0}&quot;</span>, i);</div>
<div class="line">      <span class="comment">// Yield the rest of the time slice.</span></div>
<div class="line">      thread::sleep(0);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Main thread: Start a second thread.&quot;</span>);</div>
<div class="line">    <span class="comment">// The constructor for the thread class requires a thread_start</span></div>
<div class="line">    <span class="comment">// delegate that represents the method to be executed on the</span></div>
<div class="line">    <span class="comment">// thread. xtd simplifies the creation of this delegate.</span></div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae358efa489f58062f10dd7316b65649e">t</a> = <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a> {thread_proc};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Start thread_proc. Note that on a uniprocessor, the new</span></div>
<div class="line">    <span class="comment">// thread does not get any processor time until the main thread</span></div>
<div class="line">    <span class="comment">// is preempted or yields. Uncomment the thread::sleep that</span></div>
<div class="line">    <span class="comment">// follows t.start() to see the difference.</span></div>
<div class="line">    t.start();</div>
<div class="line">    <span class="comment">//thread::sleep(0);</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;Main thread: Do some work.&quot;</span>);</div>
<div class="line">      thread::sleep(0);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Main thread: Call join(), to wait until thread_proc ends.&quot;</span>);</div>
<div class="line">    <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae358efa489f58062f10dd7316b65649e">t</a>.join();</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Main thread: thread_proc.join has returned.  Press Enter to end program.&quot;</span>);</div>
<div class="line">    console::read_line();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(thread_example::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code can produce the following output:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Main thread: Start a second thread.</span></div>
<div class="line"><span class="comment">// Main thread: Do some work.</span></div>
<div class="line"><span class="comment">// Main thread: Do some work.</span></div>
<div class="line"><span class="comment">// thread_proc: 0</span></div>
<div class="line"><span class="comment">// Main thread: Do some work.</span></div>
<div class="line"><span class="comment">// thread_proc: 1</span></div>
<div class="line"><span class="comment">// Main thread: Do some work.</span></div>
<div class="line"><span class="comment">// thread_proc: 2</span></div>
<div class="line"><span class="comment">// Main thread: Call join(), to wait until thread_proc ends.</span></div>
<div class="line"><span class="comment">// thread_proc: 3</span></div>
<div class="line"><span class="comment">// thread_proc: 4</span></div>
<div class="line"><span class="comment">// thread_proc: 5</span></div>
<div class="line"><span class="comment">// thread_proc: 6</span></div>
<div class="line"><span class="comment">// thread_proc: 7</span></div>
<div class="line"><span class="comment">// thread_proc: 8</span></div>
<div class="line"><span class="comment">// thread_proc: 9</span></div>
<div class="line"><span class="comment">// Main thread: thread_proc.join has returned.  Press Enter to end program.</span></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.h:162</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">xtd::console_key::i</a></div><div class="ttdeci">@ i</div><div class="ttdoc">The I key.</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2ae358efa489f58062f10dd7316b65649e"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae358efa489f58062f10dd7316b65649e">xtd::console_key::t</a></div><div class="ttdeci">@ t</div><div class="ttdoc">The T key.</div></div>
<div class="ttc" id="anamespacextd_1_1threading_html"><div class="ttname"><a href="namespacextd_1_1threading.html">xtd::threading</a></div><div class="ttdoc">The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....</div><div class="ttdef"><b>Definition</b> abandoned_mutex_exception.h:10</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> system_report.h:17</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>When a process starts, the system automatically creates a single foreground thread to execute application code. Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process. These threads can execute either in the foreground or in the background. In addition, you can use the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> class to execute code on worker threads that are managed by t frameworkhe xrd. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="environment_program_exit_8cpp-example.html#_a1">environment_program_exit.cpp</a>, <a class="el" href="event_wait_handle_8cpp-example.html#_a1">event_wait_handle.cpp</a>, <a class="el" href="exception_ptr_8cpp-example.html#_a0">exception_ptr.cpp</a>, <a class="el" href="interlocked_8cpp-example.html#_a0">interlocked.cpp</a>, <a class="el" href="interlocked_decrement_8cpp-example.html#_a0">interlocked_decrement.cpp</a>, <a class="el" href="lock_guard_8cpp-example.html#_a3">lock_guard.cpp</a>, <a class="el" href="mixing_std_and_xtd_threads_8cpp-example.html#_a1">mixing_std_and_xtd_threads.cpp</a>, <a class="el" href="monitor_8cpp-example.html#_a1">monitor.cpp</a>, <a class="el" href="network_stream_8cpp-example.html#_a0">network_stream.cpp</a>, <a class="el" href="socket_tcp_ip_v4_8cpp-example.html#_a0">socket_tcp_ip_v4.cpp</a>, <a class="el" href="socket_tcp_ip_v6_8cpp-example.html#_a0">socket_tcp_ip_v6.cpp</a>, <a class="el" href="socket_udp_ip_v4_8cpp-example.html#_a0">socket_udp_ip_v4.cpp</a>, <a class="el" href="socket_udp_ip_v6_8cpp-example.html#_a0">socket_udp_ip_v6.cpp</a>, <a class="el" href="tcp_client_ip_v4_8cpp-example.html#_a0">tcp_client_ip_v4.cpp</a>, <a class="el" href="tcp_client_ip_v6_8cpp-example.html#_a0">tcp_client_ip_v6.cpp</a>, <a class="el" href="thread_8cpp-example.html#_a0">thread.cpp</a>, <a class="el" href="timeout_8cpp-example.html#_a1">timeout.cpp</a>, <a class="el" href="udp_client_ip_v4_8cpp-example.html#_a0">udp_client_ip_v4.cpp</a>, and <a class="el" href="udp_client_ip_v6_8cpp-example.html#_a0">udp_client_ip_v6.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Fields</h2></td></tr>
<tr class="memitem:a5d3f07807d378451068228c15457a3a0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a5d3f07807d378451068228c15457a3a0">invalid_handle</a></td></tr>
<tr class="memdesc:a5d3f07807d378451068228c15457a3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an invalid native operating system handle. This field is read-only.  <br /></td></tr>
<tr class="separator:a5d3f07807d378451068228c15457a3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32ae3359fdaed5d27be7ecca2e1d96f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#aa32ae3359fdaed5d27be7ecca2e1d96f">invalid_thread_id</a></td></tr>
<tr class="memdesc:aa32ae3359fdaed5d27be7ecca2e1d96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an invalid native operating system thread id. This field is read-only.  <br /></td></tr>
<tr class="separator:aa32ae3359fdaed5d27be7ecca2e1d96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Cosntructors</h2></td></tr>
<tr class="memitem:a01ebb1fb46c9f74b982192f216f8951f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a01ebb1fb46c9f74b982192f216f8951f">thread</a> (const <a class="el" href="group__xtd__core.html#gab1ffc0e2d9a77d461783d8eef5aaa856">xtd::threading::parameterized_thread_start</a> &amp;<a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">start</a>)</td></tr>
<tr class="memdesc:a01ebb1fb46c9f74b982192f216f8951f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.  <br /></td></tr>
<tr class="separator:a01ebb1fb46c9f74b982192f216f8951f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeca95c7f2b871dc2a67e9afba1dec4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#adeca95c7f2b871dc2a67e9afba1dec4f">thread</a> (const <a class="el" href="group__xtd__core.html#gab1ffc0e2d9a77d461783d8eef5aaa856">xtd::threading::parameterized_thread_start</a> &amp;<a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">start</a>, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> max_stack_size)</td></tr>
<tr class="memdesc:adeca95c7f2b871dc2a67e9afba1dec4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.  <br /></td></tr>
<tr class="separator:adeca95c7f2b871dc2a67e9afba1dec4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0342b2526bddc655fa2bcffc67f849ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a0342b2526bddc655fa2bcffc67f849ab">thread</a> (const <a class="el" href="group__xtd__core.html#gaf06e74c3474ef92b55e4c26a5fdb1155">xtd::threading::thread_start</a> &amp;<a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">start</a>)</td></tr>
<tr class="memdesc:a0342b2526bddc655fa2bcffc67f849ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class.  <br /></td></tr>
<tr class="separator:a0342b2526bddc655fa2bcffc67f849ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc22c606eb31b612d4bc93c37f26a3d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#abc22c606eb31b612d4bc93c37f26a3d0">thread</a> (const <a class="el" href="group__xtd__core.html#gaf06e74c3474ef92b55e4c26a5fdb1155">xtd::threading::thread_start</a> &amp;<a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">start</a>, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> max_stack_size)</td></tr>
<tr class="memdesc:abc22c606eb31b612d4bc93c37f26a3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying the maximum stack size for the thread.  <br /></td></tr>
<tr class="separator:abc22c606eb31b612d4bc93c37f26a3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Properties</h2></td></tr>
<tr class="memitem:a29842cf40d3f56315dc81e4f6ebd1dbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a29842cf40d3f56315dc81e4f6ebd1dbb">handle</a> () const noexcept</td></tr>
<tr class="memdesc:a29842cf40d3f56315dc81e4f6ebd1dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the native operating system handle.  <br /></td></tr>
<tr class="separator:a29842cf40d3f56315dc81e4f6ebd1dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a5574f517670f6d31435c93584d933"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a85a5574f517670f6d31435c93584d933">is_alive</a> () const noexcept</td></tr>
<tr class="memdesc:a85a5574f517670f6d31435c93584d933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating the execution status of the current thread.  <br /></td></tr>
<tr class="separator:a85a5574f517670f6d31435c93584d933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f3c0ca7be2108803058899a895193e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a11f3c0ca7be2108803058899a895193e">is_background</a> () const noexcept</td></tr>
<tr class="memdesc:a11f3c0ca7be2108803058899a895193e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether or not a thread is a background thread.  <br /></td></tr>
<tr class="separator:a11f3c0ca7be2108803058899a895193e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279a9302f894d851e302670c9f4a515f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a279a9302f894d851e302670c9f4a515f">is_background</a> (bool value)</td></tr>
<tr class="memdesc:a279a9302f894d851e302670c9f4a515f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value indicating whether or not a thread is a background thread.  <br /></td></tr>
<tr class="separator:a279a9302f894d851e302670c9f4a515f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b508bda2790cd16858559f372f74ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a86b508bda2790cd16858559f372f74ae">is_main_thread</a> () const noexcept</td></tr>
<tr class="memdesc:a86b508bda2790cd16858559f372f74ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating the current thread is the main thread.  <br /></td></tr>
<tr class="separator:a86b508bda2790cd16858559f372f74ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2395ced1ac1ab57d0e7d53e7e8f3aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#ae2395ced1ac1ab57d0e7d53e7e8f3aec">is_thread_pool_thread</a> () const noexcept</td></tr>
<tr class="memdesc:ae2395ced1ac1ab57d0e7d53e7e8f3aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether or not a thread belongs to the managed thread pool.  <br /></td></tr>
<tr class="separator:ae2395ced1ac1ab57d0e7d53e7e8f3aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e8e55c7181e495e824ff4e0f74216f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#ac2e8e55c7181e495e824ff4e0f74216f">joinable</a> () const noexcept</td></tr>
<tr class="memdesc:ac2e8e55c7181e495e824ff4e0f74216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating the current thread is joinable.  <br /></td></tr>
<tr class="separator:ac2e8e55c7181e495e824ff4e0f74216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a65a2da3e743b8d710749633e10eacc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a5a65a2da3e743b8d710749633e10eacc">managed_thread_id</a> () const noexcept</td></tr>
<tr class="memdesc:a5a65a2da3e743b8d710749633e10eacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a unique identifier for the current managed thread.  <br /></td></tr>
<tr class="separator:a5a65a2da3e743b8d710749633e10eacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3052a857ff85892db9dd070d534cb087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1ustring.html">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a3052a857ff85892db9dd070d534cb087">name</a> () const noexcept</td></tr>
<tr class="memdesc:a3052a857ff85892db9dd070d534cb087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the thread.  <br /></td></tr>
<tr class="separator:a3052a857ff85892db9dd070d534cb087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2853e52b117e4a3fba311607f180e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a6b2853e52b117e4a3fba311607f180e4">name</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;value)</td></tr>
<tr class="memdesc:a6b2853e52b117e4a3fba311607f180e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the thread.  <br /></td></tr>
<tr class="separator:a6b2853e52b117e4a3fba311607f180e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afdfeb3abfb6ccc0f229bfb49c199f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d">xtd::threading::thread_priority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a0afdfeb3abfb6ccc0f229bfb49c199f9">priority</a> () const noexcept</td></tr>
<tr class="memdesc:a0afdfeb3abfb6ccc0f229bfb49c199f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating the scheduling priority of a thread.  <br /></td></tr>
<tr class="separator:a0afdfeb3abfb6ccc0f229bfb49c199f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f0434156fb0f1d24763a645b9af70c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a93f0434156fb0f1d24763a645b9af70c">priority</a> (<a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d">xtd::threading::thread_priority</a> value)</td></tr>
<tr class="memdesc:a93f0434156fb0f1d24763a645b9af70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value indicating the scheduling priority of a thread.  <br /></td></tr>
<tr class="separator:a93f0434156fb0f1d24763a645b9af70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7d950d7fb12c145e136c71e7b58609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a1b7d950d7fb12c145e136c71e7b58609">thread_id</a> () const noexcept</td></tr>
<tr class="memdesc:a1b7d950d7fb12c145e136c71e7b58609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the native operating system thread id.  <br /></td></tr>
<tr class="separator:a1b7d950d7fb12c145e136c71e7b58609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae289e05ff28dc8ac1d20cdba703381f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__threading.html#gad404f38f7d4e370680b792bc0f397d04">xtd::threading::thread_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#ae289e05ff28dc8ac1d20cdba703381f4">thread_state</a> () const noexcept</td></tr>
<tr class="memdesc:ae289e05ff28dc8ac1d20cdba703381f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value containing the states of the current thread.  <br /></td></tr>
<tr class="separator:ae289e05ff28dc8ac1d20cdba703381f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278b3fabeade100cbc012968115792fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a278b3fabeade100cbc012968115792fd">current_thread</a> () noexcept</td></tr>
<tr class="memdesc:a278b3fabeade100cbc012968115792fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently running thread.  <br /></td></tr>
<tr class="separator:a278b3fabeade100cbc012968115792fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1760f9c70f6d4c9aefbb9b8fc8eef1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a9f1760f9c70f6d4c9aefbb9b8fc8eef1">main_thread</a> ()</td></tr>
<tr class="memdesc:a9f1760f9c70f6d4c9aefbb9b8fc8eef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the main thread.  <br /></td></tr>
<tr class="separator:a9f1760f9c70f6d4c9aefbb9b8fc8eef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods</h2></td></tr>
<tr class="memitem:ae43084289f013543e52cd573eaffa55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#ae43084289f013543e52cd573eaffa55c">abort</a> ()</td></tr>
<tr class="memdesc:ae43084289f013543e52cd573eaffa55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises a xtd::threading::thread_aborted_exception in the thread on which it is invoked, to begin the process of terminating the thread. Calling this method usually terminates the thread.  <br /></td></tr>
<tr class="separator:ae43084289f013543e52cd573eaffa55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5251f21f947f99a446a8bf6fbdd4cf95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a5251f21f947f99a446a8bf6fbdd4cf95">detach</a> ()</td></tr>
<tr class="memdesc:a5251f21f947f99a446a8bf6fbdd4cf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread background.  <br /></td></tr>
<tr class="separator:a5251f21f947f99a446a8bf6fbdd4cf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a6354206f5d065d706198b3afac452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a23a6354206f5d065d706198b3afac452">interrupt</a> ()</td></tr>
<tr class="memdesc:a23a6354206f5d065d706198b3afac452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupts a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a39c85f6d7fe5d8369799963a01b17f3b" title="The thread_state is blocked. This could be the result of calling System::Threading::Thread....">xtd::threading::thread_state::wait_sleep_join</a> thread state.  <br /></td></tr>
<tr class="separator:a23a6354206f5d065d706198b3afac452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fc3f1079b67eb775925c7f1cb69a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a65fc3f1079b67eb775925c7f1cb69a56">join</a> ()</td></tr>
<tr class="memdesc:a65fc3f1079b67eb775925c7f1cb69a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until this thread object terminates, while continuing to perform standard COM and SendMessage pumping.  <br /></td></tr>
<tr class="separator:a65fc3f1079b67eb775925c7f1cb69a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa124f538ba5237af29df40faa2286b5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#aa124f538ba5237af29df40faa2286b5e">join</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:aa124f538ba5237af29df40faa2286b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until this thread object terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.  <br /></td></tr>
<tr class="separator:aa124f538ba5237af29df40faa2286b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa46ed49e7a0525099618680e1cd509"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a6fa46ed49e7a0525099618680e1cd509">join</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a6fa46ed49e7a0525099618680e1cd509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until this thread object terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.  <br /></td></tr>
<tr class="separator:a6fa46ed49e7a0525099618680e1cd509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e94d71691111ef5efb7d3c01086f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#aa0e94d71691111ef5efb7d3c01086f51">resume</a> ()</td></tr>
<tr class="memdesc:aa0e94d71691111ef5efb7d3c01086f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes a thread that has been suspended (Should not be used).  <br /></td></tr>
<tr class="separator:aa0e94d71691111ef5efb7d3c01086f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573cca51d21d56dcf79eaace281b74b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">start</a> ()</td></tr>
<tr class="memdesc:a573cca51d21d56dcf79eaace281b74b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the operating system to change the state of the current instance to <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a75101dcdfc88455bcafc9e53e0b06689" title="The thread_state has been started, it is not blocked, and there is no pending System::Threading::Thre...">xtd::threading::thread_state::running</a>.  <br /></td></tr>
<tr class="separator:a573cca51d21d56dcf79eaace281b74b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac732b49fad655a44394375b25878fda5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#ac732b49fad655a44394375b25878fda5">start</a> (std::any obj)</td></tr>
<tr class="memdesc:ac732b49fad655a44394375b25878fda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the operating system to change the state of the current instance to <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a75101dcdfc88455bcafc9e53e0b06689" title="The thread_state has been started, it is not blocked, and there is no pending System::Threading::Thre...">xtd::threading::thread_state::running</a>.  <br /></td></tr>
<tr class="separator:ac732b49fad655a44394375b25878fda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2416048e9a9f8adffc8cb8a969bb2760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a2416048e9a9f8adffc8cb8a969bb2760">suspend</a> ()</td></tr>
<tr class="memdesc:a2416048e9a9f8adffc8cb8a969bb2760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either suspends the thread, or if the thread is already suspended, has no effect (Should not be used).  <br /></td></tr>
<tr class="separator:a2416048e9a9f8adffc8cb8a969bb2760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6998fa3ca4218452ae93143d120174ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a6998fa3ca4218452ae93143d120174ba">join_all</a> ()</td></tr>
<tr class="memdesc:a6998fa3ca4218452ae93143d120174ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all joinable threads terminate.  <br /></td></tr>
<tr class="separator:a6998fa3ca4218452ae93143d120174ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af862f9b072e29e78324d76af04ed5ed1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#af862f9b072e29e78324d76af04ed5ed1">join_all</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:af862f9b072e29e78324d76af04ed5ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all joinable threads terminate or the specified time elapses, while continuing.  <br /></td></tr>
<tr class="separator:af862f9b072e29e78324d76af04ed5ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78f49e122e15aba2a9ca013e12e0bee"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#aa78f49e122e15aba2a9ca013e12e0bee">join_all</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:aa78f49e122e15aba2a9ca013e12e0bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all joinable threads terminate or the specified time elapses, while continuing.  <br /></td></tr>
<tr class="separator:aa78f49e122e15aba2a9ca013e12e0bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c59038a37bef5fe9a32936fd4ec997"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a21c59038a37bef5fe9a32936fd4ec997"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a21c59038a37bef5fe9a32936fd4ec997">join_all</a> (const collection_t &amp;threads)</td></tr>
<tr class="memdesc:a21c59038a37bef5fe9a32936fd4ec997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all specified joinable threads collection terminate.  <br /></td></tr>
<tr class="separator:a21c59038a37bef5fe9a32936fd4ec997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa075ec069e9a67da9aaadef6a80b7f95"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:aa075ec069e9a67da9aaadef6a80b7f95"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#aa075ec069e9a67da9aaadef6a80b7f95">join_all</a> (const collection_t &amp;threads, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:aa075ec069e9a67da9aaadef6a80b7f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all specified joinable threads collection terminate or the specified time elapses, while continuing.  <br /></td></tr>
<tr class="separator:aa075ec069e9a67da9aaadef6a80b7f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1fa6882ba1f0d0bdac7451c3e58cf9"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a6b1fa6882ba1f0d0bdac7451c3e58cf9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a6b1fa6882ba1f0d0bdac7451c3e58cf9">join_all</a> (const collection_t &amp;threads, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a6b1fa6882ba1f0d0bdac7451c3e58cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all specified joinable threads collection terminate or the specified time elapses, while continuing.  <br /></td></tr>
<tr class="separator:a6b1fa6882ba1f0d0bdac7451c3e58cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc6e2bb805f928e50ae73d243b95f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2">sleep</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a42bc6e2bb805f928e50ae73d243b95f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the current thread for a specified time.  <br /></td></tr>
<tr class="separator:a42bc6e2bb805f928e50ae73d243b95f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a26e99e726b6e86effa2339238b941"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#ab7a26e99e726b6e86effa2339238b941">sleep</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:ab7a26e99e726b6e86effa2339238b941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the current thread for a specified time.  <br /></td></tr>
<tr class="separator:ab7a26e99e726b6e86effa2339238b941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7861e3838380ffe3e0382ea52032d178"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a7861e3838380ffe3e0382ea52032d178">spin_wait</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> iterations)</td></tr>
<tr class="memdesc:a7861e3838380ffe3e0382ea52032d178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a thread to wait the number of times defined by the iterations parameter.  <br /></td></tr>
<tr class="separator:a7861e3838380ffe3e0382ea52032d178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a6bb9b87bc4bd70c1714a1933711b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a42a6bb9b87bc4bd70c1714a1933711b4">start_new</a> (const <a class="el" href="group__xtd__core.html#gaf06e74c3474ef92b55e4c26a5fdb1155">xtd::threading::thread_start</a> &amp;<a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">start</a>)</td></tr>
<tr class="memdesc:a42a6bb9b87bc4bd70c1714a1933711b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and immedialtely start a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> with specified method.  <br /></td></tr>
<tr class="separator:a42a6bb9b87bc4bd70c1714a1933711b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3038fd8df1b858aebfd6eb0889d855e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#ae3038fd8df1b858aebfd6eb0889d855e">start_new</a> (const <a class="el" href="group__xtd__core.html#gab1ffc0e2d9a77d461783d8eef5aaa856">xtd::threading::parameterized_thread_start</a> &amp;<a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0">start</a>, std::any obj)</td></tr>
<tr class="memdesc:ae3038fd8df1b858aebfd6eb0889d855e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and immedialtely start a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> with specified method.  <br /></td></tr>
<tr class="separator:ae3038fd8df1b858aebfd6eb0889d855e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a830b546f4aba0206b6fbd05a7176e5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread.html#a8a830b546f4aba0206b6fbd05a7176e5">yield</a> ()</td></tr>
<tr class="memdesc:a8a830b546f4aba0206b6fbd05a7176e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the thread to yield to.  <br /></td></tr>
<tr class="separator:a8a830b546f4aba0206b6fbd05a7176e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#aa8027c211754118c30ccf7e52557fd7a">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af734e36ea583a842339d7c4444fb6d86">memberwise_clone</a> () const noexcept</td></tr>
<tr class="memdesc:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sxd::ustring that represents the current object.  <br /></td></tr>
<tr class="separator:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a75cb9ed56172fb088ca6697d5d836b13">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1ee13700465eead7934f450749b952d7">reference_equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a01ebb1fb46c9f74b982192f216f8951f" name="a01ebb1fb46c9f74b982192f216f8951f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ebb1fb46c9f74b982192f216f8951f">&#9670;&#160;</a></span>thread() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::thread::thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gab1ffc0e2d9a77d461783d8eef5aaa856">xtd::threading::parameterized_thread_start</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying a delegate that allows an object to be passed to the thread when the thread is started. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread does not begin executing when it is created. To schedule the thread for execution, call the <a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start</a> method. To pass a data object to the thread, use the <a class="el" href="classxtd_1_1threading_1_1thread.html#ac732b49fad655a44394375b25878fda5" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start(std::any)</a> method overload. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="interlocked_8cpp-example.html#a3">interlocked.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adeca95c7f2b871dc2a67e9afba1dec4f" name="adeca95c7f2b871dc2a67e9afba1dec4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeca95c7f2b871dc2a67e9afba1dec4f">&#9670;&#160;</a></span>thread() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::thread::thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gab1ffc0e2d9a77d461783d8eef5aaa856">xtd::threading::parameterized_thread_start</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>max_stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
    <tr><td class="paramname">max_stack_size</td><td>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.<br  />
Important For partially trusted code, max_stack_size is ignored if it is greater than the default stack size. No exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread does not begin executing when it is created. To schedule the thread for execution, call the <a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start</a> method. To pass a data object to the thread, use the <a class="el" href="classxtd_1_1threading_1_1thread.html#ac732b49fad655a44394375b25878fda5" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start(std::any)</a> method overload. </dd></dl>

</div>
</div>
<a id="a0342b2526bddc655fa2bcffc67f849ab" name="a0342b2526bddc655fa2bcffc67f849ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0342b2526bddc655fa2bcffc67f849ab">&#9670;&#160;</a></span>thread() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::thread::thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gaf06e74c3474ef92b55e4c26a5fdb1155">xtd::threading::thread_start</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A <a class="el" href="group__xtd__core.html#gaf06e74c3474ef92b55e4c26a5fdb1155" title="Represents the method that executes on a xtd::threading::thread.">xtd::threading::thread_start</a> delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
    <tr><td class="paramname">max_stack_size</td><td>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.<br  />
Important For partially trusted code, max_stack_size is ignored if it is greater than the default stack size. No exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread does not begin executing when it is created. To schedule the thread for execution, call the <a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start</a> method. </dd></dl>

</div>
</div>
<a id="abc22c606eb31b612d4bc93c37f26a3d0" name="abc22c606eb31b612d4bc93c37f26a3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc22c606eb31b612d4bc93c37f26a3d0">&#9670;&#160;</a></span>thread() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::thread::thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gaf06e74c3474ef92b55e4c26a5fdb1155">xtd::threading::thread_start</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>max_stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying the maximum stack size for the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A <a class="el" href="group__xtd__core.html#gaf06e74c3474ef92b55e4c26a5fdb1155" title="Represents the method that executes on a xtd::threading::thread.">xtd::threading::thread_start</a> delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
    <tr><td class="paramname">max_stack_size</td><td>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.<br  />
Important For partially trusted code, max_stack_size is ignored if it is greater than the default stack size. No exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread does not begin executing when it is created. To schedule the thread for execution, call the <a class="el" href="classxtd_1_1threading_1_1thread.html#a573cca51d21d56dcf79eaace281b74b0" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start</a> method. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae43084289f013543e52cd573eaffa55c" name="ae43084289f013543e52cd573eaffa55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43084289f013543e52cd573eaffa55c">&#9670;&#160;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::abort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises a xtd::threading::thread_aborted_exception in the thread on which it is invoked, to begin the process of terminating the thread. Calling this method usually terminates the thread. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::threading::thread_aborted_exception</td><td>The thread that is being aborted is currently suspended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a278b3fabeade100cbc012968115792fd" name="a278b3fabeade100cbc012968115792fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278b3fabeade100cbc012968115792fd">&#9670;&#160;</a></span>current_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::current_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the currently running thread. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> that is the representation of the currently running thread. </dd></dl>

</div>
</div>
<a id="a5251f21f947f99a446a8bf6fbdd4cf95" name="a5251f21f947f99a446a8bf6fbdd4cf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5251f21f947f99a446a8bf6fbdd4cf95">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the thread background. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is identical to the call to xtd::threading::thread::is_background(true). </dd></dl>

</div>
</div>
<a id="a29842cf40d3f56315dc81e4f6ebd1dbb" name="a29842cf40d3f56315dc81e4f6ebd1dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29842cf40d3f56315dc81e4f6ebd1dbb">&#9670;&#160;</a></span>handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a> xtd::threading::thread::handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the native operating system handle. </p>
<dl class="section return"><dt>Returns</dt><dd>An intptr representing the native operating system handle. </dd></dl>

</div>
</div>
<a id="a23a6354206f5d065d706198b3afac452" name="a23a6354206f5d065d706198b3afac452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a6354206f5d065d706198b3afac452">&#9670;&#160;</a></span>interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::interrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupts a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a39c85f6d7fe5d8369799963a01b17f3b" title="The thread_state is blocked. This could be the result of calling System::Threading::Thread....">xtd::threading::thread_state::wait_sleep_join</a> thread state. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If this thread is not currently blocked in a thread_state::wait, thread_state::sleep, or thread_state::join state, it will be interrupted when it next begins to block. </dd>
<dd>
<a class="el" href="classxtd_1_1threading_1_1thread__interrupted__exception.html" title="The exception that is thrown when a Thread is interrupted while it is in a waiting state.">xtd::threading::thread_interrupted_exception</a> is thrown in the interrupted thread, but not until the thread blocks. If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted. </dd></dl>

</div>
</div>
<a id="a85a5574f517670f6d31435c93584d933" name="a85a5574f517670f6d31435c93584d933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a5574f517670f6d31435c93584d933">&#9670;&#160;</a></span>is_alive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::is_alive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating the execution status of the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this thread has been started and has not terminated normally or aborted; otherwise, false. </dd></dl>

</div>
</div>
<a id="a11f3c0ca7be2108803058899a895193e" name="a11f3c0ca7be2108803058899a895193e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f3c0ca7be2108803058899a895193e">&#9670;&#160;</a></span>is_background() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::is_background </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating whether or not a thread is a background thread. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this thread is or is to become a background thread; otherwise, false. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::threadng::thread_state_exception</td><td>The thread is dead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread is either a background thread or a foreground thread. Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating. Once all foreground threads belonging to a process have terminated, the system ends the process. Any remaining background threads are stopped and do not complete. </dd>
<dd>
By default, the following threads execute in the foreground (that is, their <a class="el" href="classxtd_1_1threading_1_1thread.html#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> property returns false):<ul>
<li>The primary thread (or main application thread).</li>
<li>All threads created by calling a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class constructor. </li>
</ul>
</dd>
<dd>
By default, the following threads execute in the background (that is, their <a class="el" href="classxtd_1_1threading_1_1thread.html#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> property returns true):<ul>
<li>Thread pool threads, which are a pool of worker threads maintained by the runtime. You can configure the thread pool and schedule work on thread pool threads by using the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> class.</li>
<li>All threads create without <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class (std::thread or threads create by oparating system API). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a279a9302f894d851e302670c9f4a515f" name="a279a9302f894d851e302670c9f4a515f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279a9302f894d851e302670c9f4a515f">&#9670;&#160;</a></span>is_background() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::is_background </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value indicating whether or not a thread is a background thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>true if this thread is or is to become a background thread; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::threadng::thread_state_exception</td><td>The thread is dead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread is either a background thread or a foreground thread. Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating. Once all foreground threads belonging to a process have terminated, the system ends the process. Any remaining background threads are stopped and do not complete. </dd>
<dd>
By default, the following threads execute in the foreground (that is, their <a class="el" href="classxtd_1_1threading_1_1thread.html#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> property returns false):<ul>
<li>The primary thread (or main application thread).</li>
<li>All threads created by calling a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class constructor. </li>
</ul>
</dd>
<dd>
By default, the following threads execute in the background (that is, their <a class="el" href="classxtd_1_1threading_1_1thread.html#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> property returns true):<ul>
<li>Thread pool threads, which are a pool of worker threads maintained by the runtime. You can configure the thread pool and schedule work on thread pool threads by using the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> class.</li>
<li>All threads create without <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class (std::thread or threads create by oparating system API). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a86b508bda2790cd16858559f372f74ae" name="a86b508bda2790cd16858559f372f74ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b508bda2790cd16858559f372f74ae">&#9670;&#160;</a></span>is_main_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::is_main_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating the current thread is the main thread. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this thread is the main thread; otherwise, false. </dd></dl>

</div>
</div>
<a id="ae2395ced1ac1ab57d0e7d53e7e8f3aec" name="ae2395ced1ac1ab57d0e7d53e7e8f3aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2395ced1ac1ab57d0e7d53e7e8f3aec">&#9670;&#160;</a></span>is_thread_pool_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::is_thread_pool_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating whether or not a thread belongs to the managed thread pool. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this thread belongs to the managed thread pool; otherwise, false. @rermarks For more information see <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a>. </dd></dl>

</div>
</div>
<a id="a65fc3f1079b67eb775925c7f1cb69a56" name="a65fc3f1079b67eb775925c7f1cb69a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fc3f1079b67eb775925c7f1cb69a56">&#9670;&#160;</a></span>join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the calling thread until this thread object terminates, while continuing to perform standard COM and SendMessage pumping. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="interlocked_8cpp-example.html#a4">interlocked.cpp</a>, <a class="el" href="lock_guard_8cpp-example.html#a4">lock_guard.cpp</a>, and <a class="el" href="monitor_8cpp-example.html#a2">monitor.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6fa46ed49e7a0525099618680e1cd509" name="a6fa46ed49e7a0525099618680e1cd509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa46ed49e7a0525099618680e1cd509">&#9670;&#160;</a></span>join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the calling thread until this thread object terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> set to the amount of time to wait for the thread to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread has terminated; false if the thread has not terminated after the amount of time specified by the xtd::milliseconds_timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>timeout is a negative number other than -1 milliseconds, which represents <br  />
-or-<br  />
 timeout is greater than <a class="el" href="classxtd_1_1box__integer.html#a21847edbb248c1b0d07a35e2a8c08232" title="Represents the largest possible value of type_t. This field is constant.">xtd::int32_object::max_value</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa124f538ba5237af29df40faa2286b5e" name="aa124f538ba5237af29df40faa2286b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa124f538ba5237af29df40faa2286b5e">&#9670;&#160;</a></span>join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the calling thread until this thread object terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the thread to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread has terminated; false if the thread has not terminated after the amount of time specified by the xtd::milliseconds_timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
    <tr><td class="paramname">xtd::argument_out_of_range_rxception</td><td>milliseconds_timeout is a negative number other than -1, which represents an infinite time-out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6998fa3ca4218452ae93143d120174ba" name="a6998fa3ca4218452ae93143d120174ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6998fa3ca4218452ae93143d120174ba">&#9670;&#160;</a></span>join_all() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all joinable threads terminate. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd>
<dd>
The xtd::startup::run method and <a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_</a> keyword call the <a class="el" href="classxtd_1_1threading_1_1thread.html#a6998fa3ca4218452ae93143d120174ba" title="Blocks the calling thread until all joinable threads terminate.">xtd::threading::thread::join_all</a> method. </dd>
<dd>
Call <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a67c0921c9e154215c14cf459b9d0f3ed" title="Close all resources and worker threads.">xtd::threading::thread_pool::close</a> method to join the end of running worker threads too. </dd></dl>

</div>
</div>
<a id="a21c59038a37bef5fe9a32936fd4ec997" name="a21c59038a37bef5fe9a32936fd4ec997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c59038a37bef5fe9a32936fd4ec997">&#9670;&#160;</a></span>join_all() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all specified joinable threads collection terminate. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd></dl>

</div>
</div>
<a id="a6b1fa6882ba1f0d0bdac7451c3e58cf9" name="a6b1fa6882ba1f0d0bdac7451c3e58cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1fa6882ba1f0d0bdac7451c3e58cf9">&#9670;&#160;</a></span>join_all() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all specified joinable threads collection terminate or the specified time elapses, while continuing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> set to the amount of time to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all threads have terminated; false if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd></dl>

</div>
</div>
<a id="aa075ec069e9a67da9aaadef6a80b7f95" name="aa075ec069e9a67da9aaadef6a80b7f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa075ec069e9a67da9aaadef6a80b7f95">&#9670;&#160;</a></span>join_all() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all specified joinable threads collection terminate or the specified time elapses, while continuing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all threads have terminated; false if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd></dl>

</div>
</div>
<a id="aa78f49e122e15aba2a9ca013e12e0bee" name="aa78f49e122e15aba2a9ca013e12e0bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78f49e122e15aba2a9ca013e12e0bee">&#9670;&#160;</a></span>join_all() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all joinable threads terminate or the specified time elapses, while continuing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> set to the amount of time to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all threads have terminated; false if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd>
<dd>
Call <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a67c0921c9e154215c14cf459b9d0f3ed" title="Close all resources and worker threads.">xtd::threading::thread_pool::close</a> method to join the end of running worker threads too. </dd></dl>

</div>
</div>
<a id="af862f9b072e29e78324d76af04ed5ed1" name="af862f9b072e29e78324d76af04ed5ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af862f9b072e29e78324d76af04ed5ed1">&#9670;&#160;</a></span>join_all() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all joinable threads terminate or the specified time elapses, while continuing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all threads have terminated; false if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd>
<dd>
Call <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a67c0921c9e154215c14cf459b9d0f3ed" title="Close all resources and worker threads.">xtd::threading::thread_pool::close</a> method to join the end of running worker threads too. </dd></dl>

</div>
</div>
<a id="ac2e8e55c7181e495e824ff4e0f74216f" name="ac2e8e55c7181e495e824ff4e0f74216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e8e55c7181e495e824ff4e0f74216f">&#9670;&#160;</a></span>joinable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::joinable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating the current thread is joinable. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this thread is joinable; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread is joinable if it started, not stopped and if is not a background thread. </dd>
<dd>
if the thread is joinable you can call the <a class="el" href="classxtd_1_1threading_1_1thread.html#a65fc3f1079b67eb775925c7f1cb69a56" title="Blocks the calling thread until this thread object terminates, while continuing to perform standard C...">xtd::threading::thread::join</a> method. </dd></dl>

</div>
</div>
<a id="a9f1760f9c70f6d4c9aefbb9b8fc8eef1" name="a9f1760f9c70f6d4c9aefbb9b8fc8eef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1760f9c70f6d4c9aefbb9b8fc8eef1">&#9670;&#160;</a></span>main_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::main_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the main thread. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> that is the representation of the main thread. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if the thread is not started this method return <a class="el" href="classxtd_1_1threading_1_1thread.html#a5d3f07807d378451068228c15457a3a0" title="Represents an invalid native operating system handle. This field is read-only.">xtd::threading::thread::invalid_handle</a>. </dd></dl>

</div>
</div>
<a id="a5a65a2da3e743b8d710749633e10eacc" name="a5a65a2da3e743b8d710749633e10eacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a65a2da3e743b8d710749633e10eacc">&#9670;&#160;</a></span>managed_thread_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> xtd::threading::thread::managed_thread_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a unique identifier for the current managed thread. </p>
<dl class="section return"><dt>Returns</dt><dd>An integer that represents a unique identifier for this managed thread. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread's <a class="el" href="classxtd_1_1threading_1_1thread.html#a5a65a2da3e743b8d710749633e10eacc" title="Gets a unique identifier for the current managed thread.">xtd::threading::thread::managed_thread_id</a> property value serves to uniquely identify that thread within its process. </dd>
<dd>
The value of the <a class="el" href="classxtd_1_1threading_1_1thread.html#a5a65a2da3e743b8d710749633e10eacc" title="Gets a unique identifier for the current managed thread.">xtd::threading::thread::managed_thread_id</a> property does not vary over time </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="mixing_std_and_xtd_threads_8cpp-example.html#a3">mixing_std_and_xtd_threads.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3052a857ff85892db9dd070d534cb087" name="a3052a857ff85892db9dd070d534cb087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3052a857ff85892db9dd070d534cb087">&#9670;&#160;</a></span>name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1ustring.html">ustring</a> xtd::threading::thread::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of the thread. </p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the name of the thread, or empty ("") if no name was set. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="mixing_std_and_xtd_threads_8cpp-example.html#a2">mixing_std_and_xtd_threads.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6b2853e52b117e4a3fba311607f180e4" name="a6b2853e52b117e4a3fba311607f180e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2853e52b117e4a3fba311607f180e4">&#9670;&#160;</a></span>name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the name of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A string containing the name of the thread, or empty ("") if no name was set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0afdfeb3abfb6ccc0f229bfb49c199f9" name="a0afdfeb3abfb6ccc0f229bfb49c199f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afdfeb3abfb6ccc0f229bfb49c199f9">&#9670;&#160;</a></span>priority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d">xtd::threading::thread_priority</a> xtd::threading::thread::priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating the scheduling priority of a thread. </p>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> values. The default value is <a class="el" href="group__threading.html#ggaeee08cba07c5c4d4d10ada96a70bf28dafea087517c26fadd409bd4b9dc642555" title="The system::threading::thread can be scheduled after threads with thread_priority::above_normal prior...">xtd::threading::thread_priority::normal</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has reached a final state, such as Aborted. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The value specified for a set operation is not a valid <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread can be assigned any one of the following priority <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> values:<ul>
<li>highest</li>
<li>above_normal</li>
<li>normal</li>
<li>below_normal</li>
<li>lowest </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="mixing_std_and_xtd_threads_8cpp-example.html#a4">mixing_std_and_xtd_threads.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a93f0434156fb0f1d24763a645b9af70c" name="a93f0434156fb0f1d24763a645b9af70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f0434156fb0f1d24763a645b9af70c">&#9670;&#160;</a></span>priority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d">xtd::threading::thread_priority</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value indicating the scheduling priority of a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>One of the <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> values. The default value is <a class="el" href="group__threading.html#ggaeee08cba07c5c4d4d10ada96a70bf28dafea087517c26fadd409bd4b9dc642555" title="The system::threading::thread can be scheduled after threads with thread_priority::above_normal prior...">xtd::threading::thread_priority::normal</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has reached a final state, such as Aborted. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The value specified for a set operation is not a valid <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread can be assigned any one of the following priority <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> values:<ul>
<li>highest</li>
<li>above_normal</li>
<li>normal</li>
<li>below_normal</li>
<li>lowest </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa0e94d71691111ef5efb7d3c01086f51" name="aa0e94d71691111ef5efb7d3c01086f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e94d71691111ef5efb7d3c01086f51">&#9670;&#160;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes a thread that has been suspended (Should not be used). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has not been started, is dead, or is not in the suspended state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Works only on Windows operating syetm. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not use the <a class="el" href="classxtd_1_1threading_1_1thread.html#a2416048e9a9f8adffc8cb8a969bb2760" title="Either suspends the thread, or if the thread is already suspended, has no effect (Should not be used)...">xtd::threading::thread::suspend</a> and <a class="el" href="classxtd_1_1threading_1_1thread.html#aa0e94d71691111ef5efb7d3c01086f51" title="Resumes a thread that has been suspended (Should not be used).">xtd::threading::thread::resume</a> methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the application might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the application that attempt to use that class are blocked. Deadlocks can occur very easily. </dd></dl>

</div>
</div>
<a id="ab7a26e99e726b6e86effa2339238b941" name="ab7a26e99e726b6e86effa2339238b941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a26e99e726b6e86effa2339238b941">&#9670;&#160;</a></span>sleep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::sleep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspends the current thread for a specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A std::chrono::duration set to the amount of time for which the thread is blocked. Specify zero to indicate that this thread should be suspended to allow other waiting threads to execute. Specify xtd::threading::Timeout.Infinite to block the thread indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The value of timeout is negative and is not equal to <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> in milliseconds, or is greater than xtd::Int32.MaxValue milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42bc6e2bb805f928e50ae73d243b95f2" name="a42bc6e2bb805f928e50ae73d243b95f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bc6e2bb805f928e50ae73d243b95f2">&#9670;&#160;</a></span>sleep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspends the current thread for a specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds for which the thread is blocked. Specify zero (0) to indicate that this thread should be suspended to allow other waiting threads to execute. Specify xtd::threading::Timeout.Infinite to block the thread indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>milliseconds_timeout is a negative number other than -1, which represents an infinite time-out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7861e3838380ffe3e0382ea52032d178" name="a7861e3838380ffe3e0382ea52032d178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7861e3838380ffe3e0382ea52032d178">&#9670;&#160;</a></span>spin_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::spin_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes a thread to wait the number of times defined by the iterations parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterations</td><td>A 32-bit signed integer that defines how long a thread is to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1thread.html#a7861e3838380ffe3e0382ea52032d178" title="Causes a thread to wait the number of times defined by the iterations parameter.">xtd::threading::thread::spin_wait</a> method is useful for implementing locks. Classes in the xtd, such as <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> and xtd::threading::reader_writer_lock, use this method internally. <a class="el" href="classxtd_1_1threading_1_1thread.html#a7861e3838380ffe3e0382ea52032d178" title="Causes a thread to wait the number of times defined by the iterations parameter.">xtd::threading::thread::spin_wait</a> essentially puts the processor into a very tight loop, with the loop count specified by the iterations parameter. The duration of the wait therefore depends on the speed of the processor. </dd>
<dd>
Contrast this with the <a class="el" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2" title="Suspends the current thread for a specified time.">xtd::threading::thread::sleep</a> method. A thread that calls <a class="el" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2" title="Suspends the current thread for a specified time.">xtd::threading::thread::sleep</a> yields the rest of its current slice of processor time, even if the specified interval is zero. Specifying a non-zero interval for <a class="el" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2" title="Suspends the current thread for a specified time.">xtd::threading::thread::sleep</a> removes the thread from consideration by the thread scheduler until the time interval has elapsed. </dd>
<dd>
<a class="el" href="classxtd_1_1threading_1_1thread.html#a7861e3838380ffe3e0382ea52032d178" title="Causes a thread to wait the number of times defined by the iterations parameter.">xtd::threading::thread::spin_wait</a> is not generally useful for ordinary applications. In most cases, you should use the synchronization classes provided by the xtd Framework; for example, call <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> or a statement that wraps xtd::threading::thread::monitor::enter </dd></dl>

</div>
</div>
<a id="a573cca51d21d56dcf79eaace281b74b0" name="a573cca51d21d56dcf79eaace281b74b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573cca51d21d56dcf79eaace281b74b0">&#9670;&#160;</a></span>start() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the operating system to change the state of the current instance to <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a75101dcdfc88455bcafc9e53e0b06689" title="The thread_state has been started, it is not blocked, and there is no pending System::Threading::Thre...">xtd::threading::thread_state::running</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has already been started. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="event_wait_handle_8cpp-example.html#a2">event_wait_handle.cpp</a>, <a class="el" href="interlocked_decrement_8cpp-example.html#a1">interlocked_decrement.cpp</a>, and <a class="el" href="timeout_8cpp-example.html#a2">timeout.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac732b49fad655a44394375b25878fda5" name="ac732b49fad655a44394375b25878fda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac732b49fad655a44394375b25878fda5">&#9670;&#160;</a></span>start() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::start </td>
          <td>(</td>
          <td class="paramtype">std::any&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the operating system to change the state of the current instance to <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a75101dcdfc88455bcafc9e53e0b06689" title="The thread_state has been started, it is not blocked, and there is no pending System::Threading::Thre...">xtd::threading::thread_state::running</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>An object that contains data to be used by the method the thread executes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has already been started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3038fd8df1b858aebfd6eb0889d855e" name="ae3038fd8df1b858aebfd6eb0889d855e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3038fd8df1b858aebfd6eb0889d855e">&#9670;&#160;</a></span>start_new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> xtd::threading::thread::start_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gab1ffc0e2d9a77d461783d8eef5aaa856">xtd::threading::parameterized_thread_start</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::any&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and immedialtely start a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> with specified method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
    <tr><td class="paramname">obj</td><td>An object that contains data to be used by the method the thread executes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42a6bb9b87bc4bd70c1714a1933711b4" name="a42a6bb9b87bc4bd70c1714a1933711b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a6bb9b87bc4bd70c1714a1933711b4">&#9670;&#160;</a></span>start_new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> xtd::threading::thread::start_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gaf06e74c3474ef92b55e4c26a5fdb1155">xtd::threading::thread_start</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and immedialtely start a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> with specified method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2416048e9a9f8adffc8cb8a969bb2760" name="a2416048e9a9f8adffc8cb8a969bb2760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2416048e9a9f8adffc8cb8a969bb2760">&#9670;&#160;</a></span>suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either suspends the thread, or if the thread is already suspended, has no effect (Should not be used). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has not been started or is dead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Works only on Windows operating syetm. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not use the <a class="el" href="classxtd_1_1threading_1_1thread.html#a2416048e9a9f8adffc8cb8a969bb2760" title="Either suspends the thread, or if the thread is already suspended, has no effect (Should not be used)...">xtd::threading::thread::suspend</a> and <a class="el" href="classxtd_1_1threading_1_1thread.html#aa0e94d71691111ef5efb7d3c01086f51" title="Resumes a thread that has been suspended (Should not be used).">xtd::threading::thread::resume</a> methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the application might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the application that attempt to use that class are blocked. Deadlocks can occur very easily. </dd></dl>

</div>
</div>
<a id="a1b7d950d7fb12c145e136c71e7b58609" name="a1b7d950d7fb12c145e136c71e7b58609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7d950d7fb12c145e136c71e7b58609">&#9670;&#160;</a></span>thread_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a> xtd::threading::thread::thread_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the native operating system thread id. </p>
<dl class="section return"><dt>Returns</dt><dd>An intptr representing the native operating thread id. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if the thread is not started this method return <a class="el" href="classxtd_1_1threading_1_1thread.html#aa32ae3359fdaed5d27be7ecca2e1d96f" title="Represents an invalid native operating system thread id. This field is read-only.">xtd::threading::thread::invalid_thread_id</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="mixing_std_and_xtd_threads_8cpp-example.html#a5">mixing_std_and_xtd_threads.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae289e05ff28dc8ac1d20cdba703381f4" name="ae289e05ff28dc8ac1d20cdba703381f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae289e05ff28dc8ac1d20cdba703381f4">&#9670;&#160;</a></span>thread_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__threading.html#gad404f38f7d4e370680b792bc0f397d04">xtd::threading::thread_state</a> xtd::threading::thread::thread_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value containing the states of the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__threading.html#gad404f38f7d4e370680b792bc0f397d04" title="Specifies the execution states of a System::Threading::Thread.">xtd::threading::thread_state</a> values indicating the state of the current thread. The initial value is <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1thread.html#ae289e05ff28dc8ac1d20cdba703381f4" title="Gets a value containing the states of the current thread.">xtd::threading::thread::thread_state</a> property provides more specific information than the <a class="el" href="classxtd_1_1threading_1_1thread.html#a85a5574f517670f6d31435c93584d933" title="Gets a value indicating the execution status of the current thread.">xtd::threading::thread::is_alive</a> property. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Thread state is only of interest in debugging scenarios. Your code should never use thread state to synchronize the activities of threads. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="mixing_std_and_xtd_threads_8cpp-example.html#a6">mixing_std_and_xtd_threads.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8a830b546f4aba0206b6fbd05a7176e5" name="a8a830b546f4aba0206b6fbd05a7176e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a830b546f4aba0206b6fbd05a7176e5">&#9670;&#160;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the thread to yield to. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the operating system switched execution to another thread; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If this method succeeds, the rest of the thread's current time slice is yielded. The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run. </dd>
<dd>
yielding is limited to the processor that is executing the calling thread. The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority. If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns false. </dd>
<dd>
This method is equivalent to using platform invoke to call the native Win32 switch_to_thread function. You should call the <a class="el" href="classxtd_1_1threading_1_1thread.html#a8a830b546f4aba0206b6fbd05a7176e5" title="Causes the calling thread to yield execution to another thread that is ready to run on the current pr...">xtd::threading::thread::yield</a> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5d3f07807d378451068228c15457a3a0" name="a5d3f07807d378451068228c15457a3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3f07807d378451068228c15457a3a0">&#9670;&#160;</a></span>invalid_handle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a> xtd::threading::thread::invalid_handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents an invalid native operating system handle. This field is read-only. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Used internally to initialize the xtd::thread::wait_handle::handle property. </dd></dl>

</div>
</div>
<a id="aa32ae3359fdaed5d27be7ecca2e1d96f" name="aa32ae3359fdaed5d27be7ecca2e1d96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32ae3359fdaed5d27be7ecca2e1d96f">&#9670;&#160;</a></span>invalid_thread_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a> xtd::threading::thread::invalid_thread_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents an invalid native operating system thread id. This field is read-only. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Used internally to initialize the <a class="el" href="classxtd_1_1threading_1_1thread.html#a1b7d950d7fb12c145e136c71e7b58609" title="Gets the native operating system thread id.">xtd::threading::thread::thread_id</a> property. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="thread_8h_source.html">thread.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 16 2023 22:50:04 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
