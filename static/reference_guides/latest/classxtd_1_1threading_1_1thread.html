<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::thread Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1threading_1_1thread-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::thread Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">﹡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::thread:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1thread.png" usemap="#xtd::threading::thread_map" alt=""/>
  <map id="xtd::threading::thread_map" name="xtd::threading::thread_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,132,24"/>
<area href="classxtd_1_1threading_1_1jthread.html" title="Creates and controls an automatically rejoins on destruction thread, sets its priority,..." alt="xtd::threading::jthread" shape="rect" coords="0,112,132,136"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Creates and controls a thread, sets its priority, and gets its status. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_function" href="#a01ebb1fb46c9f74b982192f216f8951f">thread</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html_a01ebb1fb46c9f74b982192f216f8951f"><div class="ttname"><a href="#a01ebb1fb46c9f74b982192f216f8951f">xtd::threading::thread::thread</a></div><div class="ttdeci">thread(const xtd::threading::parameterized_thread_start &amp;start)</div><div class="ttdoc">Initializes a new instance of the xtd::threading::thread class, specifying a delegate that allows an ...</div></div>
<div class="ttc" id="agroup__keywords_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.hpp:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> → <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example demonstrates simple threading functionality. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Simple threading scenario:  Start a static method running</span></div>
<div class="line"><span class="comment">// on a second thread.</span></div>
<div class="line"><span class="keyword">class </span>thread_example {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// The thread_proc method is called when the thread starts.</span></div>
<div class="line">  <span class="comment">// It loops ten times, writing to the console and yielding</span></div>
<div class="line">  <span class="comment">// the rest of its time slice each time, and then ends.</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc() {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> = 0; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> &lt; 10; ++<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>) {</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;thread_proc: {0}&quot;</span>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>);</div>
<div class="line">      <span class="comment">// Yield the rest of the time slice.</span></div>
<div class="line">      <a class="code hl_function" href="#a42bc6e2bb805f928e50ae73d243b95f2">thread::sleep</a>(0);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Main thread: Start a second thread.&quot;</span>);</div>
<div class="line">    <span class="comment">// The constructor for the thread class requires a thread_start</span></div>
<div class="line">    <span class="comment">// delegate that represents the method to be executed on the</span></div>
<div class="line">    <span class="comment">// thread. xtd simplifies the creation of this delegate.</span></div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae358efa489f58062f10dd7316b65649e">t</a> = thread {thread_proc};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Start thread_proc. Note that on a uniprocessor, the new</span></div>
<div class="line">    <span class="comment">// thread does not get any processor time until the main thread</span></div>
<div class="line">    <span class="comment">// is preempted or yields. Uncomment the thread::sleep that</span></div>
<div class="line">    <span class="comment">// follows t.start() to see the difference.</span></div>
<div class="line">    t.start();</div>
<div class="line">    <span class="comment">//thread::sleep(0);</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">      <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Main thread: Do some work.&quot;</span>);</div>
<div class="line">      thread::sleep(0);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Main thread: Call join(), to wait until thread_proc ends.&quot;</span>);</div>
<div class="line">    <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae358efa489f58062f10dd7316b65649e">t</a>.join();</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;Main thread: thread_proc.join has returned.  Press Enter to end program.&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#a01a96244846df28bb0178e3728434243">console::read_line</a>();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(thread_example::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code can produce the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Main thread: Start a second thread.</span></div>
<div class="line"><span class="comment">// Main thread: Do some work.</span></div>
<div class="line"><span class="comment">// Main thread: Do some work.</span></div>
<div class="line"><span class="comment">// thread_proc: 0</span></div>
<div class="line"><span class="comment">// Main thread: Do some work.</span></div>
<div class="line"><span class="comment">// thread_proc: 1</span></div>
<div class="line"><span class="comment">// Main thread: Do some work.</span></div>
<div class="line"><span class="comment">// thread_proc: 2</span></div>
<div class="line"><span class="comment">// Main thread: Call join(), to wait until thread_proc ends.</span></div>
<div class="line"><span class="comment">// thread_proc: 3</span></div>
<div class="line"><span class="comment">// thread_proc: 4</span></div>
<div class="line"><span class="comment">// thread_proc: 5</span></div>
<div class="line"><span class="comment">// thread_proc: 6</span></div>
<div class="line"><span class="comment">// thread_proc: 7</span></div>
<div class="line"><span class="comment">// thread_proc: 8</span></div>
<div class="line"><span class="comment">// thread_proc: 9</span></div>
<div class="line"><span class="comment">// Main thread: thread_proc.join has returned.  Press Enter to end program.</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_a01a96244846df28bb0178e3728434243"><div class="ttname"><a href="classxtd_1_1console.html#a01a96244846df28bb0178e3728434243">xtd::console::read_line</a></div><div class="ttdeci">static xtd::string read_line()</div><div class="ttdoc">Reads the next line of characters from the standard input stream.</div></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html_a42bc6e2bb805f928e50ae73d243b95f2"><div class="ttname"><a href="#a42bc6e2bb805f928e50ae73d243b95f2">xtd::threading::thread::sleep</a></div><div class="ttdeci">static void sleep(int32 milliseconds_timeout)</div><div class="ttdoc">Suspends the current thread for a specified time.</div></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.hpp:168</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">xtd::console_key::i</a></div><div class="ttdeci">@ i</div><div class="ttdoc">The I key.</div><div class="ttdef"><b>Definition</b> console_key.hpp:104</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2ae358efa489f58062f10dd7316b65649e"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae358efa489f58062f10dd7316b65649e">xtd::console_key::t</a></div><div class="ttdeci">@ t</div><div class="ttdoc">The T key.</div><div class="ttdef"><b>Definition</b> console_key.hpp:126</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>When a process starts, the system automatically creates a single foreground thread to execute application code. Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process. These threads can execute either in the foreground or in the background. In addition, you can use the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> class to execute code on worker threads that are managed by the framework xrd. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Fields</h2></td></tr>
<tr class="memitem:a5d3f07807d378451068228c15457a3a0" id="r_a5d3f07807d378451068228c15457a3a0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__types.html#ga6d54527a3ec7b15afb917a6ba73a4ece">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d3f07807d378451068228c15457a3a0">invalid_handle</a></td></tr>
<tr class="memdesc:a5d3f07807d378451068228c15457a3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an invalid native operating system handle. This field is read-only.  <br /></td></tr>
<tr class="separator:a5d3f07807d378451068228c15457a3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32ae3359fdaed5d27be7ecca2e1d96f" id="r_aa32ae3359fdaed5d27be7ecca2e1d96f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__types.html#ga6d54527a3ec7b15afb917a6ba73a4ece">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa32ae3359fdaed5d27be7ecca2e1d96f">invalid_thread_id</a></td></tr>
<tr class="memdesc:aa32ae3359fdaed5d27be7ecca2e1d96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an invalid native operating system thread id. This field is read-only.  <br /></td></tr>
<tr class="separator:aa32ae3359fdaed5d27be7ecca2e1d96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Cosntructors</h2></td></tr>
<tr class="memitem:a01ebb1fb46c9f74b982192f216f8951f" id="r_a01ebb1fb46c9f74b982192f216f8951f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01ebb1fb46c9f74b982192f216f8951f">thread</a> (const <a class="el" href="group__delegates.html#ga1961ded285db6ac6d364694eda5379a3">xtd::threading::parameterized_thread_start</a> &amp;<a class="el" href="#a573cca51d21d56dcf79eaace281b74b0">start</a>)</td></tr>
<tr class="memdesc:a01ebb1fb46c9f74b982192f216f8951f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.  <br /></td></tr>
<tr class="separator:a01ebb1fb46c9f74b982192f216f8951f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeca95c7f2b871dc2a67e9afba1dec4f" id="r_adeca95c7f2b871dc2a67e9afba1dec4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeca95c7f2b871dc2a67e9afba1dec4f">thread</a> (const <a class="el" href="group__delegates.html#ga1961ded285db6ac6d364694eda5379a3">xtd::threading::parameterized_thread_start</a> &amp;<a class="el" href="#a573cca51d21d56dcf79eaace281b74b0">start</a>, <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> max_stack_size)</td></tr>
<tr class="memdesc:adeca95c7f2b871dc2a67e9afba1dec4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.  <br /></td></tr>
<tr class="separator:adeca95c7f2b871dc2a67e9afba1dec4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0342b2526bddc655fa2bcffc67f849ab" id="r_a0342b2526bddc655fa2bcffc67f849ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0342b2526bddc655fa2bcffc67f849ab">thread</a> (const <a class="el" href="group__delegates.html#gacea3e237aac11920ba29f784740cba69">xtd::threading::thread_start</a> &amp;<a class="el" href="#a573cca51d21d56dcf79eaace281b74b0">start</a>)</td></tr>
<tr class="memdesc:a0342b2526bddc655fa2bcffc67f849ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class.  <br /></td></tr>
<tr class="separator:a0342b2526bddc655fa2bcffc67f849ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc22c606eb31b612d4bc93c37f26a3d0" id="r_abc22c606eb31b612d4bc93c37f26a3d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc22c606eb31b612d4bc93c37f26a3d0">thread</a> (const <a class="el" href="group__delegates.html#gacea3e237aac11920ba29f784740cba69">xtd::threading::thread_start</a> &amp;<a class="el" href="#a573cca51d21d56dcf79eaace281b74b0">start</a>, <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> max_stack_size)</td></tr>
<tr class="memdesc:abc22c606eb31b612d4bc93c37f26a3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying the maximum stack size for the thread.  <br /></td></tr>
<tr class="separator:abc22c606eb31b612d4bc93c37f26a3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:a51cda22580b84272a3c2a32a27206395" id="r_a51cda22580b84272a3c2a32a27206395"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51cda22580b84272a3c2a32a27206395">auto_join</a> () const noexcept</td></tr>
<tr class="memdesc:a51cda22580b84272a3c2a32a27206395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating the current thread wiil be joined when destroyed.  <br /></td></tr>
<tr class="separator:a51cda22580b84272a3c2a32a27206395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b38f90148168dcd5e3e7407a0c78e19" id="r_a8b38f90148168dcd5e3e7407a0c78e19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b38f90148168dcd5e3e7407a0c78e19">auto_join</a> (bool value)</td></tr>
<tr class="memdesc:a8b38f90148168dcd5e3e7407a0c78e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value indicating the current thread wiil be joined when destroyed.  <br /></td></tr>
<tr class="separator:a8b38f90148168dcd5e3e7407a0c78e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29842cf40d3f56315dc81e4f6ebd1dbb" id="r_a29842cf40d3f56315dc81e4f6ebd1dbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga6d54527a3ec7b15afb917a6ba73a4ece">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29842cf40d3f56315dc81e4f6ebd1dbb">handle</a> () const noexcept</td></tr>
<tr class="memdesc:a29842cf40d3f56315dc81e4f6ebd1dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the native operating system handle.  <br /></td></tr>
<tr class="separator:a29842cf40d3f56315dc81e4f6ebd1dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a5574f517670f6d31435c93584d933" id="r_a85a5574f517670f6d31435c93584d933"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a5574f517670f6d31435c93584d933">is_alive</a> () const noexcept</td></tr>
<tr class="memdesc:a85a5574f517670f6d31435c93584d933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating the execution status of the current thread.  <br /></td></tr>
<tr class="separator:a85a5574f517670f6d31435c93584d933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f3c0ca7be2108803058899a895193e" id="r_a11f3c0ca7be2108803058899a895193e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11f3c0ca7be2108803058899a895193e">is_background</a> () const noexcept</td></tr>
<tr class="memdesc:a11f3c0ca7be2108803058899a895193e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether or not a thread is a background thread.  <br /></td></tr>
<tr class="separator:a11f3c0ca7be2108803058899a895193e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279a9302f894d851e302670c9f4a515f" id="r_a279a9302f894d851e302670c9f4a515f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a279a9302f894d851e302670c9f4a515f">is_background</a> (bool value)</td></tr>
<tr class="memdesc:a279a9302f894d851e302670c9f4a515f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value indicating whether or not a thread is a background thread.  <br /></td></tr>
<tr class="separator:a279a9302f894d851e302670c9f4a515f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b508bda2790cd16858559f372f74ae" id="r_a86b508bda2790cd16858559f372f74ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86b508bda2790cd16858559f372f74ae">is_main_thread</a> () const noexcept</td></tr>
<tr class="memdesc:a86b508bda2790cd16858559f372f74ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating the current thread is the main thread.  <br /></td></tr>
<tr class="separator:a86b508bda2790cd16858559f372f74ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2395ced1ac1ab57d0e7d53e7e8f3aec" id="r_ae2395ced1ac1ab57d0e7d53e7e8f3aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2395ced1ac1ab57d0e7d53e7e8f3aec">is_thread_pool_thread</a> () const noexcept</td></tr>
<tr class="memdesc:ae2395ced1ac1ab57d0e7d53e7e8f3aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether or not a thread belongs to the managed thread pool.  <br /></td></tr>
<tr class="separator:ae2395ced1ac1ab57d0e7d53e7e8f3aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e8e55c7181e495e824ff4e0f74216f" id="r_ac2e8e55c7181e495e824ff4e0f74216f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2e8e55c7181e495e824ff4e0f74216f">joinable</a> () const noexcept</td></tr>
<tr class="memdesc:ac2e8e55c7181e495e824ff4e0f74216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating the current thread is joinable.  <br /></td></tr>
<tr class="separator:ac2e8e55c7181e495e824ff4e0f74216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a65a2da3e743b8d710749633e10eacc" id="r_a5a65a2da3e743b8d710749633e10eacc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a65a2da3e743b8d710749633e10eacc">managed_thread_id</a> () const noexcept</td></tr>
<tr class="memdesc:a5a65a2da3e743b8d710749633e10eacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a unique identifier for the current managed thread.  <br /></td></tr>
<tr class="separator:a5a65a2da3e743b8d710749633e10eacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49144c9d57db3cb0eb4dd76abd5d3bff" id="r_a49144c9d57db3cb0eb4dd76abd5d3bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49144c9d57db3cb0eb4dd76abd5d3bff">name</a> () const noexcept</td></tr>
<tr class="memdesc:a49144c9d57db3cb0eb4dd76abd5d3bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the thread.  <br /></td></tr>
<tr class="separator:a49144c9d57db3cb0eb4dd76abd5d3bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239fdba4dd9a69da1e9a05c907a9dc48" id="r_a239fdba4dd9a69da1e9a05c907a9dc48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a239fdba4dd9a69da1e9a05c907a9dc48">name</a> (const <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">string</a> &amp;value)</td></tr>
<tr class="memdesc:a239fdba4dd9a69da1e9a05c907a9dc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the thread.  <br /></td></tr>
<tr class="separator:a239fdba4dd9a69da1e9a05c907a9dc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afdfeb3abfb6ccc0f229bfb49c199f9" id="r_a0afdfeb3abfb6ccc0f229bfb49c199f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d">xtd::threading::thread_priority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0afdfeb3abfb6ccc0f229bfb49c199f9">priority</a> () const noexcept</td></tr>
<tr class="memdesc:a0afdfeb3abfb6ccc0f229bfb49c199f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating the scheduling priority of a thread.  <br /></td></tr>
<tr class="separator:a0afdfeb3abfb6ccc0f229bfb49c199f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f0434156fb0f1d24763a645b9af70c" id="r_a93f0434156fb0f1d24763a645b9af70c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93f0434156fb0f1d24763a645b9af70c">priority</a> (<a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d">xtd::threading::thread_priority</a> value)</td></tr>
<tr class="memdesc:a93f0434156fb0f1d24763a645b9af70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value indicating the scheduling priority of a thread.  <br /></td></tr>
<tr class="separator:a93f0434156fb0f1d24763a645b9af70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43262e94f7f115380c9546e253d29f2f" id="r_a43262e94f7f115380c9546e253d29f2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43262e94f7f115380c9546e253d29f2f">processor_affinity</a> () const noexcept</td></tr>
<tr class="memdesc:a43262e94f7f115380c9546e253d29f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the processors on which the associated thread can run.  <br /></td></tr>
<tr class="separator:a43262e94f7f115380c9546e253d29f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048f7ad1168e16001be404f16dbaf254" id="r_a048f7ad1168e16001be404f16dbaf254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a048f7ad1168e16001be404f16dbaf254">processor_affinity</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> &gt; &amp;value)</td></tr>
<tr class="memdesc:a048f7ad1168e16001be404f16dbaf254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the processors on which the associated thread can run.  <br /></td></tr>
<tr class="separator:a048f7ad1168e16001be404f16dbaf254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7d950d7fb12c145e136c71e7b58609" id="r_a1b7d950d7fb12c145e136c71e7b58609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga6d54527a3ec7b15afb917a6ba73a4ece">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b7d950d7fb12c145e136c71e7b58609">thread_id</a> () const noexcept</td></tr>
<tr class="memdesc:a1b7d950d7fb12c145e136c71e7b58609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the native operating system thread id.  <br /></td></tr>
<tr class="separator:a1b7d950d7fb12c145e136c71e7b58609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae289e05ff28dc8ac1d20cdba703381f4" id="r_ae289e05ff28dc8ac1d20cdba703381f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__threading.html#gad404f38f7d4e370680b792bc0f397d04">xtd::threading::thread_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae289e05ff28dc8ac1d20cdba703381f4">thread_state</a> () const noexcept</td></tr>
<tr class="memdesc:ae289e05ff28dc8ac1d20cdba703381f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value containing the states of the current thread.  <br /></td></tr>
<tr class="separator:ae289e05ff28dc8ac1d20cdba703381f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:ae43084289f013543e52cd573eaffa55c" id="r_ae43084289f013543e52cd573eaffa55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae43084289f013543e52cd573eaffa55c">abort</a> ()</td></tr>
<tr class="memdesc:ae43084289f013543e52cd573eaffa55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises a xtd::threading::thread_aborted_exception in the thread on which it is invoked, to begin the process of terminating the thread. Calling this method usually terminates the thread.  <br /></td></tr>
<tr class="separator:ae43084289f013543e52cd573eaffa55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5251f21f947f99a446a8bf6fbdd4cf95" id="r_a5251f21f947f99a446a8bf6fbdd4cf95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5251f21f947f99a446a8bf6fbdd4cf95">detach</a> ()</td></tr>
<tr class="memdesc:a5251f21f947f99a446a8bf6fbdd4cf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread background.  <br /></td></tr>
<tr class="separator:a5251f21f947f99a446a8bf6fbdd4cf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547137846df20cafba5cfb998b3f297c" id="r_a547137846df20cafba5cfb998b3f297c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a547137846df20cafba5cfb998b3f297c">get_hash_code</a> () const noexcept override</td></tr>
<tr class="memdesc:a547137846df20cafba5cfb998b3f297c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a547137846df20cafba5cfb998b3f297c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a6354206f5d065d706198b3afac452" id="r_a23a6354206f5d065d706198b3afac452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23a6354206f5d065d706198b3afac452">interrupt</a> ()</td></tr>
<tr class="memdesc:a23a6354206f5d065d706198b3afac452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupts a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a39c85f6d7fe5d8369799963a01b17f3b" title="The thread_state is blocked. This could be the result of calling System::Threading::Thread....">xtd::threading::thread_state::wait_sleep_join</a> thread state.  <br /></td></tr>
<tr class="separator:a23a6354206f5d065d706198b3afac452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fc3f1079b67eb775925c7f1cb69a56" id="r_a65fc3f1079b67eb775925c7f1cb69a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65fc3f1079b67eb775925c7f1cb69a56">join</a> ()</td></tr>
<tr class="memdesc:a65fc3f1079b67eb775925c7f1cb69a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until this thread object terminates, while continuing to perform standard COM and SendMessage pumping.  <br /></td></tr>
<tr class="separator:a65fc3f1079b67eb775925c7f1cb69a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa124f538ba5237af29df40faa2286b5e" id="r_aa124f538ba5237af29df40faa2286b5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa124f538ba5237af29df40faa2286b5e">join</a> (<a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:aa124f538ba5237af29df40faa2286b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until this thread object terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.  <br /></td></tr>
<tr class="separator:aa124f538ba5237af29df40faa2286b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa46ed49e7a0525099618680e1cd509" id="r_a6fa46ed49e7a0525099618680e1cd509"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa46ed49e7a0525099618680e1cd509">join</a> (const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a6fa46ed49e7a0525099618680e1cd509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until this thread object terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.  <br /></td></tr>
<tr class="separator:a6fa46ed49e7a0525099618680e1cd509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e94d71691111ef5efb7d3c01086f51" id="r_aa0e94d71691111ef5efb7d3c01086f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0e94d71691111ef5efb7d3c01086f51">resume</a> ()</td></tr>
<tr class="memdesc:aa0e94d71691111ef5efb7d3c01086f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes a thread that has been suspended (Should not be used).  <br /></td></tr>
<tr class="separator:aa0e94d71691111ef5efb7d3c01086f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573cca51d21d56dcf79eaace281b74b0" id="r_a573cca51d21d56dcf79eaace281b74b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a573cca51d21d56dcf79eaace281b74b0">start</a> ()</td></tr>
<tr class="memdesc:a573cca51d21d56dcf79eaace281b74b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the operating system to change the state of the current instance to <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a75101dcdfc88455bcafc9e53e0b06689" title="The thread_state has been started, it is not blocked, and there is no pending System::Threading::Thre...">xtd::threading::thread_state::running</a>.  <br /></td></tr>
<tr class="separator:a573cca51d21d56dcf79eaace281b74b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24caec3c59051d52cbb11d7a7359723d" id="r_a24caec3c59051d52cbb11d7a7359723d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24caec3c59051d52cbb11d7a7359723d">start</a> (const <a class="el" href="classxtd_1_1any__object.html">xtd::any_object</a> &amp;obj)</td></tr>
<tr class="memdesc:a24caec3c59051d52cbb11d7a7359723d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the operating system to change the state of the current instance to <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a75101dcdfc88455bcafc9e53e0b06689" title="The thread_state has been started, it is not blocked, and there is no pending System::Threading::Thre...">xtd::threading::thread_state::running</a>.  <br /></td></tr>
<tr class="separator:a24caec3c59051d52cbb11d7a7359723d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2416048e9a9f8adffc8cb8a969bb2760" id="r_a2416048e9a9f8adffc8cb8a969bb2760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2416048e9a9f8adffc8cb8a969bb2760">suspend</a> ()</td></tr>
<tr class="memdesc:a2416048e9a9f8adffc8cb8a969bb2760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either suspends the thread, or if the thread is already suspended, has no effect (Should not be used).  <br /></td></tr>
<tr class="separator:a2416048e9a9f8adffc8cb8a969bb2760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Properties</h2></td></tr>
<tr class="memitem:a278b3fabeade100cbc012968115792fd" id="r_a278b3fabeade100cbc012968115792fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a278b3fabeade100cbc012968115792fd">current_thread</a> () noexcept</td></tr>
<tr class="memdesc:a278b3fabeade100cbc012968115792fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently running thread.  <br /></td></tr>
<tr class="separator:a278b3fabeade100cbc012968115792fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1760f9c70f6d4c9aefbb9b8fc8eef1" id="r_a9f1760f9c70f6d4c9aefbb9b8fc8eef1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f1760f9c70f6d4c9aefbb9b8fc8eef1">main_thread</a> ()</td></tr>
<tr class="memdesc:a9f1760f9c70f6d4c9aefbb9b8fc8eef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the main thread.  <br /></td></tr>
<tr class="separator:a9f1760f9c70f6d4c9aefbb9b8fc8eef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:a42a6bb9b87bc4bd70c1714a1933711b4" id="r_a42a6bb9b87bc4bd70c1714a1933711b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42a6bb9b87bc4bd70c1714a1933711b4">start_new</a> (const <a class="el" href="group__delegates.html#gacea3e237aac11920ba29f784740cba69">xtd::threading::thread_start</a> &amp;<a class="el" href="#a573cca51d21d56dcf79eaace281b74b0">start</a>)</td></tr>
<tr class="memdesc:a42a6bb9b87bc4bd70c1714a1933711b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and immedialtely start a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> with specified method.  <br /></td></tr>
<tr class="separator:a42a6bb9b87bc4bd70c1714a1933711b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8260305986f58f91cab6f479827834" id="r_aca8260305986f58f91cab6f479827834"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca8260305986f58f91cab6f479827834">start_new</a> (const <a class="el" href="group__delegates.html#ga1961ded285db6ac6d364694eda5379a3">xtd::threading::parameterized_thread_start</a> &amp;<a class="el" href="#a573cca51d21d56dcf79eaace281b74b0">start</a>, const <a class="el" href="classxtd_1_1any__object.html">xtd::any_object</a> &amp;obj)</td></tr>
<tr class="memdesc:aca8260305986f58f91cab6f479827834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and immedialtely start a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> with specified method.  <br /></td></tr>
<tr class="separator:aca8260305986f58f91cab6f479827834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6998fa3ca4218452ae93143d120174ba" id="r_a6998fa3ca4218452ae93143d120174ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6998fa3ca4218452ae93143d120174ba">join_all</a> ()</td></tr>
<tr class="memdesc:a6998fa3ca4218452ae93143d120174ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all joinable threads terminate.  <br /></td></tr>
<tr class="separator:a6998fa3ca4218452ae93143d120174ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af862f9b072e29e78324d76af04ed5ed1" id="r_af862f9b072e29e78324d76af04ed5ed1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af862f9b072e29e78324d76af04ed5ed1">join_all</a> (<a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:af862f9b072e29e78324d76af04ed5ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all joinable threads terminate or the specified time elapses, while continuing.  <br /></td></tr>
<tr class="separator:af862f9b072e29e78324d76af04ed5ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78f49e122e15aba2a9ca013e12e0bee" id="r_aa78f49e122e15aba2a9ca013e12e0bee"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa78f49e122e15aba2a9ca013e12e0bee">join_all</a> (const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:aa78f49e122e15aba2a9ca013e12e0bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all joinable threads terminate or the specified time elapses, while continuing.  <br /></td></tr>
<tr class="separator:aa78f49e122e15aba2a9ca013e12e0bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c59038a37bef5fe9a32936fd4ec997" id="r_a21c59038a37bef5fe9a32936fd4ec997"><td class="memTemplParams" colspan="2">template&lt;class collection_t&gt; </td></tr>
<tr class="memitem:a21c59038a37bef5fe9a32936fd4ec997"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21c59038a37bef5fe9a32936fd4ec997">join_all</a> (const collection_t &amp;threads)</td></tr>
<tr class="memdesc:a21c59038a37bef5fe9a32936fd4ec997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all specified joinable threads collection terminate.  <br /></td></tr>
<tr class="separator:a21c59038a37bef5fe9a32936fd4ec997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa075ec069e9a67da9aaadef6a80b7f95" id="r_aa075ec069e9a67da9aaadef6a80b7f95"><td class="memTemplParams" colspan="2">template&lt;class collection_t&gt; </td></tr>
<tr class="memitem:aa075ec069e9a67da9aaadef6a80b7f95"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa075ec069e9a67da9aaadef6a80b7f95">join_all</a> (const collection_t &amp;threads, <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:aa075ec069e9a67da9aaadef6a80b7f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all specified joinable threads collection terminate or the specified time elapses, while continuing.  <br /></td></tr>
<tr class="separator:aa075ec069e9a67da9aaadef6a80b7f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1fa6882ba1f0d0bdac7451c3e58cf9" id="r_a6b1fa6882ba1f0d0bdac7451c3e58cf9"><td class="memTemplParams" colspan="2">template&lt;class collection_t&gt; </td></tr>
<tr class="memitem:a6b1fa6882ba1f0d0bdac7451c3e58cf9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b1fa6882ba1f0d0bdac7451c3e58cf9">join_all</a> (const collection_t &amp;threads, const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a6b1fa6882ba1f0d0bdac7451c3e58cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until all specified joinable threads collection terminate or the specified time elapses, while continuing.  <br /></td></tr>
<tr class="separator:a6b1fa6882ba1f0d0bdac7451c3e58cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc6e2bb805f928e50ae73d243b95f2" id="r_a42bc6e2bb805f928e50ae73d243b95f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42bc6e2bb805f928e50ae73d243b95f2">sleep</a> (<a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a42bc6e2bb805f928e50ae73d243b95f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the current thread for a specified time.  <br /></td></tr>
<tr class="separator:a42bc6e2bb805f928e50ae73d243b95f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a26e99e726b6e86effa2339238b941" id="r_ab7a26e99e726b6e86effa2339238b941"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7a26e99e726b6e86effa2339238b941">sleep</a> (const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:ab7a26e99e726b6e86effa2339238b941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the current thread for a specified time.  <br /></td></tr>
<tr class="separator:ab7a26e99e726b6e86effa2339238b941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7861e3838380ffe3e0382ea52032d178" id="r_a7861e3838380ffe3e0382ea52032d178"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7861e3838380ffe3e0382ea52032d178">spin_wait</a> (<a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> iterations)</td></tr>
<tr class="memdesc:a7861e3838380ffe3e0382ea52032d178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a thread to wait the number of times defined by the iterations parameter.  <br /></td></tr>
<tr class="separator:a7861e3838380ffe3e0382ea52032d178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce63292cb3e6dfbd89e34d0769d56cb" id="r_a7ce63292cb3e6dfbd89e34d0769d56cb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ce63292cb3e6dfbd89e34d0769d56cb">yield</a> () noexcept</td></tr>
<tr class="memdesc:a7ce63292cb3e6dfbd89e34d0769d56cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the thread to yield to.  <br /></td></tr>
<tr class="separator:a7ce63292cb3e6dfbd89e34d0769d56cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f" id="r_ad2cab851376bb6ca085b567bf5da0f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b" id="r_a2743b6f75405882c28eebe2456f3837b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40" id="r_a322144840e8ad539c039538997b0fe40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35" id="r_ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplParams" colspan="2">template&lt;class object_t&gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d19ef177db62351b58a42f22138dbe" id="r_af2d19ef177db62351b58a42f22138dbe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:af2d19ef177db62351b58a42f22138dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:af2d19ef177db62351b58a42f22138dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6" id="r_a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5" id="r_a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplParams" colspan="2">template&lt;class object_a_t, class object_b_t&gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a01ebb1fb46c9f74b982192f216f8951f" name="a01ebb1fb46c9f74b982192f216f8951f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ebb1fb46c9f74b982192f216f8951f">&#9670;&#160;</a></span>thread() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::thread::thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__delegates.html#ga1961ded285db6ac6d364694eda5379a3">xtd::threading::parameterized_thread_start</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying a delegate that allows an object to be passed to the thread when the thread is started. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread does not begin executing when it is created. To schedule the thread for execution, call the <a class="el" href="#a573cca51d21d56dcf79eaace281b74b0" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start</a> method. To pass a data object to the thread, use the <a class="el" href="#a24caec3c59051d52cbb11d7a7359723d" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start(const xtd::any_object&amp;)</a> method overload. </dd></dl>

</div>
</div>
<a id="adeca95c7f2b871dc2a67e9afba1dec4f" name="adeca95c7f2b871dc2a67e9afba1dec4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeca95c7f2b871dc2a67e9afba1dec4f">&#9670;&#160;</a></span>thread() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::thread::thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__delegates.html#ga1961ded285db6ac6d364694eda5379a3">xtd::threading::parameterized_thread_start</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a></td>          <td class="paramname"><span class="paramname"><em>max_stack_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
    <tr><td class="paramname">max_stack_size</td><td>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.<br  />
Important For partially trusted code, max_stack_size is ignored if it is greater than the default stack size. No exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread does not begin executing when it is created. To schedule the thread for execution, call the <a class="el" href="#a573cca51d21d56dcf79eaace281b74b0" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start</a> method. To pass a data object to the thread, use the <a class="el" href="#a24caec3c59051d52cbb11d7a7359723d" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start(const xtd::any_object&amp;)</a> method overload. </dd></dl>

</div>
</div>
<a id="a0342b2526bddc655fa2bcffc67f849ab" name="a0342b2526bddc655fa2bcffc67f849ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0342b2526bddc655fa2bcffc67f849ab">&#9670;&#160;</a></span>thread() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::thread::thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__delegates.html#gacea3e237aac11920ba29f784740cba69">xtd::threading::thread_start</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A <a class="el" href="group__delegates.html#gacea3e237aac11920ba29f784740cba69" title="Represents the method that executes on a xtd::threading::thread.">xtd::threading::thread_start</a> delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
    <tr><td class="paramname">max_stack_size</td><td>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.<br  />
Important For partially trusted code, max_stack_size is ignored if it is greater than the default stack size. No exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread does not begin executing when it is created. To schedule the thread for execution, call the <a class="el" href="#a573cca51d21d56dcf79eaace281b74b0" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start</a> method. </dd></dl>

</div>
</div>
<a id="abc22c606eb31b612d4bc93c37f26a3d0" name="abc22c606eb31b612d4bc93c37f26a3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc22c606eb31b612d4bc93c37f26a3d0">&#9670;&#160;</a></span>thread() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::thread::thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__delegates.html#gacea3e237aac11920ba29f784740cba69">xtd::threading::thread_start</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a></td>          <td class="paramname"><span class="paramname"><em>max_stack_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class, specifying the maximum stack size for the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A <a class="el" href="group__delegates.html#gacea3e237aac11920ba29f784740cba69" title="Represents the method that executes on a xtd::threading::thread.">xtd::threading::thread_start</a> delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
    <tr><td class="paramname">max_stack_size</td><td>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.<br  />
Important For partially trusted code, max_stack_size is ignored if it is greater than the default stack size. No exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread does not begin executing when it is created. To schedule the thread for execution, call the <a class="el" href="#a573cca51d21d56dcf79eaace281b74b0" title="Causes the operating system to change the state of the current instance to xtd::threading::thread_sta...">xtd::threading::thread::start</a> method. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a51cda22580b84272a3c2a32a27206395" name="a51cda22580b84272a3c2a32a27206395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cda22580b84272a3c2a32a27206395">&#9670;&#160;</a></span>auto_join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::auto_join </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating the current thread wiil be joined when destroyed. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this thread will be joined when destroyed; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a8b38f90148168dcd5e3e7407a0c78e19" name="a8b38f90148168dcd5e3e7407a0c78e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b38f90148168dcd5e3e7407a0c78e19">&#9670;&#160;</a></span>auto_join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::auto_join </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value indicating the current thread wiil be joined when destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><code>true</code> if this thread will be joined when destroyed; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> current instance. </dd></dl>

</div>
</div>
<a id="a29842cf40d3f56315dc81e4f6ebd1dbb" name="a29842cf40d3f56315dc81e4f6ebd1dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29842cf40d3f56315dc81e4f6ebd1dbb">&#9670;&#160;</a></span>handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga6d54527a3ec7b15afb917a6ba73a4ece">intptr</a> xtd::threading::thread::handle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the native operating system handle. </p>
<dl class="section return"><dt>Returns</dt><dd>An intptr representing the native operating system handle. </dd></dl>

</div>
</div>
<a id="a85a5574f517670f6d31435c93584d933" name="a85a5574f517670f6d31435c93584d933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a5574f517670f6d31435c93584d933">&#9670;&#160;</a></span>is_alive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::is_alive </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating the execution status of the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this thread has been started and has not terminated normally or aborted; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a11f3c0ca7be2108803058899a895193e" name="a11f3c0ca7be2108803058899a895193e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f3c0ca7be2108803058899a895193e">&#9670;&#160;</a></span>is_background() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::is_background </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating whether or not a thread is a background thread. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this thread is or is to become a background thread; otherwise, <code>false</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::threadng::thread_state_exception</td><td>The thread is dead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread is either a background thread or a foreground thread. Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating. Once all foreground threads belonging to a process have terminated, the system ends the process. Any remaining background threads are stopped and do not complete. </dd>
<dd>
By default, the following threads execute in the foreground (that is, their <a class="el" href="#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> property returns false):<ul>
<li>The primary thread (or main application thread).</li>
<li>All threads created by calling a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class constructor. </li>
</ul>
</dd>
<dd>
By default, the following threads execute in the background (that is, their <a class="el" href="#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> property returns <code>true</code>):<ul>
<li>Thread pool threads, which are a pool of worker threads maintained by the runtime. You can configure the thread pool and schedule work on thread pool threads by using the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> class.</li>
<li>All threads create without <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class (std::thread or threads create by oparating system API). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a279a9302f894d851e302670c9f4a515f" name="a279a9302f894d851e302670c9f4a515f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279a9302f894d851e302670c9f4a515f">&#9670;&#160;</a></span>is_background() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::is_background </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value indicating whether or not a thread is a background thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><code>true</code> if this thread is or is to become a background thread; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> current instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::threadng::thread_state_exception</td><td>The thread is dead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread is either a background thread or a foreground thread. Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating. Once all foreground threads belonging to a process have terminated, the system ends the process. Any remaining background threads are stopped and do not complete. </dd>
<dd>
By default, the following threads execute in the foreground (that is, their <a class="el" href="#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> property returns <code>false</code>):<ul>
<li>The primary thread (or main application thread).</li>
<li>All threads created by calling a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class constructor. </li>
</ul>
</dd>
<dd>
By default, the following threads execute in the background (that is, their <a class="el" href="#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> property returns <code>true</code>):<ul>
<li>Thread pool threads, which are a pool of worker threads maintained by the runtime. You can configure the thread pool and schedule work on thread pool threads by using the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> class.</li>
<li>All threads create without <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> class (std::thread or threads create by oparating system API). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a86b508bda2790cd16858559f372f74ae" name="a86b508bda2790cd16858559f372f74ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b508bda2790cd16858559f372f74ae">&#9670;&#160;</a></span>is_main_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::is_main_thread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating the current thread is the main thread. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this thread is the main thread; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae2395ced1ac1ab57d0e7d53e7e8f3aec" name="ae2395ced1ac1ab57d0e7d53e7e8f3aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2395ced1ac1ab57d0e7d53e7e8f3aec">&#9670;&#160;</a></span>is_thread_pool_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::is_thread_pool_thread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating whether or not a thread belongs to the managed thread pool. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this thread belongs to the managed thread pool; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For more information see <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a>. </dd></dl>

</div>
</div>
<a id="ac2e8e55c7181e495e824ff4e0f74216f" name="ac2e8e55c7181e495e824ff4e0f74216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e8e55c7181e495e824ff4e0f74216f">&#9670;&#160;</a></span>joinable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::joinable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating the current thread is joinable. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this thread is joinable; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread is joinable if it started, not stopped and if is not a background thread. </dd>
<dd>
if the thread is joinable you can call the <a class="el" href="#a65fc3f1079b67eb775925c7f1cb69a56" title="Blocks the calling thread until this thread object terminates, while continuing to perform standard C...">xtd::threading::thread::join</a> method. </dd></dl>

</div>
</div>
<a id="a5a65a2da3e743b8d710749633e10eacc" name="a5a65a2da3e743b8d710749633e10eacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a65a2da3e743b8d710749633e10eacc">&#9670;&#160;</a></span>managed_thread_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a> xtd::threading::thread::managed_thread_id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a unique identifier for the current managed thread. </p>
<dl class="section return"><dt>Returns</dt><dd>An integer that represents a unique identifier for this managed thread. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread's <a class="el" href="#a5a65a2da3e743b8d710749633e10eacc" title="Gets a unique identifier for the current managed thread.">xtd::threading::thread::managed_thread_id</a> property value serves to uniquely identify that thread within its process. </dd>
<dd>
The value of the <a class="el" href="#a5a65a2da3e743b8d710749633e10eacc" title="Gets a unique identifier for the current managed thread.">xtd::threading::thread::managed_thread_id</a> property does not vary over time </dd></dl>

</div>
</div>
<a id="a49144c9d57db3cb0eb4dd76abd5d3bff" name="a49144c9d57db3cb0eb4dd76abd5d3bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49144c9d57db3cb0eb4dd76abd5d3bff">&#9670;&#160;</a></span>name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">string</a> xtd::threading::thread::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of the thread. </p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the name of the thread, or empty ("") if no name was set. </dd></dl>

</div>
</div>
<a id="a239fdba4dd9a69da1e9a05c907a9dc48" name="a239fdba4dd9a69da1e9a05c907a9dc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239fdba4dd9a69da1e9a05c907a9dc48">&#9670;&#160;</a></span>name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__strings.html#ga60154d7201cef3f8d0d5e241ef54b25e">string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the name of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A string containing the name of the thread, or empty ("") if no name was set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> current instance. </dd></dl>

</div>
</div>
<a id="a0afdfeb3abfb6ccc0f229bfb49c199f9" name="a0afdfeb3abfb6ccc0f229bfb49c199f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afdfeb3abfb6ccc0f229bfb49c199f9">&#9670;&#160;</a></span>priority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d">xtd::threading::thread_priority</a> xtd::threading::thread::priority </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating the scheduling priority of a thread. </p>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> values. The default value is <a class="el" href="group__threading.html#ggaeee08cba07c5c4d4d10ada96a70bf28dafea087517c26fadd409bd4b9dc642555" title="The system::threading::thread can be scheduled after threads with thread_priority::above_normal prior...">xtd::threading::thread_priority::normal</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has reached a final state, such as Aborted. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The value specified for a set operation is not a valid <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread can be assigned any one of the following priority <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> values:<ul>
<li>highest</li>
<li>above_normal</li>
<li>normal</li>
<li>below_normal</li>
<li>lowest </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a93f0434156fb0f1d24763a645b9af70c" name="a93f0434156fb0f1d24763a645b9af70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f0434156fb0f1d24763a645b9af70c">&#9670;&#160;</a></span>priority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d">xtd::threading::thread_priority</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value indicating the scheduling priority of a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>One of the <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> values. The default value is <a class="el" href="group__threading.html#ggaeee08cba07c5c4d4d10ada96a70bf28dafea087517c26fadd409bd4b9dc642555" title="The system::threading::thread can be scheduled after threads with thread_priority::above_normal prior...">xtd::threading::thread_priority::normal</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has reached a final state, such as Aborted. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The value specified for a set operation is not a valid <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A thread can be assigned any one of the following priority <a class="el" href="group__threading.html#gaeee08cba07c5c4d4d10ada96a70bf28d" title="Specifies the scheduling priority of a system::threading::thread.">xtd::threading::thread_priority</a> values:<ul>
<li>highest</li>
<li>above_normal</li>
<li>normal</li>
<li>below_normal</li>
<li>lowest </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a43262e94f7f115380c9546e253d29f2f" name="a43262e94f7f115380c9546e253d29f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43262e94f7f115380c9546e253d29f2f">&#9670;&#160;</a></span>processor_affinity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> &gt; &amp; xtd::threading::thread::processor_affinity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the processors on which the associated thread can run. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1array.html">xtd::array&lt;xtd::size&gt;</a> that represents an array of processor numbers on which the thread can run. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has reached a final state, such as Aborted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the array is empty, no affinity is defined. </dd>
<dd>
Works only on Windows and Linux operating syetms, no effect on others. </dd></dl>

</div>
</div>
<a id="a048f7ad1168e16001be404f16dbaf254" name="a048f7ad1168e16001be404f16dbaf254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048f7ad1168e16001be404f16dbaf254">&#9670;&#160;</a></span>processor_affinity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::processor_affinity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the processors on which the associated thread can run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An <a class="el" href="classxtd_1_1array.html">xtd::array&lt;xtd::size&gt;</a> that represents an array of processor numbers on which the thread can run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has reached a final state, such as Aborted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the array is empty, no affinity is defined. </dd>
<dd>
Works only on Windows and Linux operating syetms, no effect on others. </dd></dl>

</div>
</div>
<a id="a1b7d950d7fb12c145e136c71e7b58609" name="a1b7d950d7fb12c145e136c71e7b58609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7d950d7fb12c145e136c71e7b58609">&#9670;&#160;</a></span>thread_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga6d54527a3ec7b15afb917a6ba73a4ece">intptr</a> xtd::threading::thread::thread_id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the native operating system thread id. </p>
<dl class="section return"><dt>Returns</dt><dd>An intptr representing the native operating thread id. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if the thread is not started this method return <a class="el" href="#aa32ae3359fdaed5d27be7ecca2e1d96f" title="Represents an invalid native operating system thread id. This field is read-only.">xtd::threading::thread::invalid_thread_id</a>. </dd></dl>

</div>
</div>
<a id="ae289e05ff28dc8ac1d20cdba703381f4" name="ae289e05ff28dc8ac1d20cdba703381f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae289e05ff28dc8ac1d20cdba703381f4">&#9670;&#160;</a></span>thread_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__threading.html#gad404f38f7d4e370680b792bc0f397d04">xtd::threading::thread_state</a> xtd::threading::thread::thread_state </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value containing the states of the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__threading.html#gad404f38f7d4e370680b792bc0f397d04" title="Specifies the execution states of a System::Threading::Thread.">xtd::threading::thread_state</a> values indicating the state of the current thread. The initial value is <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="#ae289e05ff28dc8ac1d20cdba703381f4" title="Gets a value containing the states of the current thread.">xtd::threading::thread::thread_state</a> property provides more specific information than the <a class="el" href="#a85a5574f517670f6d31435c93584d933" title="Gets a value indicating the execution status of the current thread.">xtd::threading::thread::is_alive</a> property. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Thread state is only of interest in debugging scenarios. Your code should never use thread state to synchronize the activities of threads. </dd></dl>

</div>
</div>
<a id="a278b3fabeade100cbc012968115792fd" name="a278b3fabeade100cbc012968115792fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278b3fabeade100cbc012968115792fd">&#9670;&#160;</a></span>current_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::current_thread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the currently running thread. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> that is the representation of the currently running thread. </dd></dl>

</div>
</div>
<a id="a9f1760f9c70f6d4c9aefbb9b8fc8eef1" name="a9f1760f9c70f6d4c9aefbb9b8fc8eef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1760f9c70f6d4c9aefbb9b8fc8eef1">&#9670;&#160;</a></span>main_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> &amp; xtd::threading::thread::main_thread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the main thread. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> that is the representation of the main thread. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if the thread is not started this method return <a class="el" href="#a5d3f07807d378451068228c15457a3a0" title="Represents an invalid native operating system handle. This field is read-only.">xtd::threading::thread::invalid_handle</a>. </dd></dl>

</div>
</div>
<a id="ae43084289f013543e52cd573eaffa55c" name="ae43084289f013543e52cd573eaffa55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43084289f013543e52cd573eaffa55c">&#9670;&#160;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::abort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises a xtd::threading::thread_aborted_exception in the thread on which it is invoked, to begin the process of terminating the thread. Calling this method usually terminates the thread. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::threading::thread_aborted_exception</td><td>The thread that is being aborted is currently suspended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5251f21f947f99a446a8bf6fbdd4cf95" name="a5251f21f947f99a446a8bf6fbdd4cf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5251f21f947f99a446a8bf6fbdd4cf95">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::detach </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the thread background. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is identical to the call to xtd::threading::thread::is_background(true). </dd></dl>

</div>
</div>
<a id="a547137846df20cafba5cfb998b3f297c" name="a547137846df20cafba5cfb998b3f297c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547137846df20cafba5cfb998b3f297c">&#9670;&#160;</a></span>get_hash_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> xtd::threading::thread::get_hash_code </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serves as a hash function for a particular type. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code for the current object. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">xtd::object</a>.</p>

</div>
</div>
<a id="a23a6354206f5d065d706198b3afac452" name="a23a6354206f5d065d706198b3afac452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a6354206f5d065d706198b3afac452">&#9670;&#160;</a></span>interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::interrupt </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupts a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a39c85f6d7fe5d8369799963a01b17f3b" title="The thread_state is blocked. This could be the result of calling System::Threading::Thread....">xtd::threading::thread_state::wait_sleep_join</a> thread state. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If this thread is not currently blocked in a thread_state::wait, thread_state::sleep, or thread_state::join state, it will be interrupted when it next begins to block. </dd>
<dd>
<a class="el" href="classxtd_1_1threading_1_1thread__interrupted__exception.html" title="The exception that is thrown when a Thread is interrupted while it is in a waiting state.">xtd::threading::thread_interrupted_exception</a> is thrown in the interrupted thread, but not until the thread blocks. If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted. </dd></dl>

</div>
</div>
<a id="a65fc3f1079b67eb775925c7f1cb69a56" name="a65fc3f1079b67eb775925c7f1cb69a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fc3f1079b67eb775925c7f1cb69a56">&#9670;&#160;</a></span>join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::join </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the calling thread until this thread object terminates, while continuing to perform standard COM and SendMessage pumping. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa124f538ba5237af29df40faa2286b5e" name="aa124f538ba5237af29df40faa2286b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa124f538ba5237af29df40faa2286b5e">&#9670;&#160;</a></span>join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the calling thread until this thread object terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the thread to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the thread has terminated; <code>false</code> if the thread has not terminated after the amount of time specified by the xtd::milliseconds_timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
    <tr><td class="paramname">xtd::argument_out_of_range_rxception</td><td>milliseconds_timeout is a negative number other than -1, which represents an infinite time-out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fa46ed49e7a0525099618680e1cd509" name="a6fa46ed49e7a0525099618680e1cd509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa46ed49e7a0525099618680e1cd509">&#9670;&#160;</a></span>join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::thread::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the calling thread until this thread object terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="classxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> set to the amount of time to wait for the thread to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the thread has terminated; <code>false</code> if the thread has not terminated after the amount of time specified by the xtd::milliseconds_timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>timeout is a negative number other than -1 milliseconds, which represents <br  />
-or-<br  />
 timeout is greater than <a class="el" href="classxtd_1_1box__integer.html#a21847edbb248c1b0d07a35e2a8c08232">xtd::int32_object::max_value</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0e94d71691111ef5efb7d3c01086f51" name="aa0e94d71691111ef5efb7d3c01086f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e94d71691111ef5efb7d3c01086f51">&#9670;&#160;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::resume </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes a thread that has been suspended (Should not be used). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has not been started, is dead, or is not in the suspended state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Works only on Windows operating syetm. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not use the <a class="el" href="#a2416048e9a9f8adffc8cb8a969bb2760" title="Either suspends the thread, or if the thread is already suspended, has no effect (Should not be used)...">xtd::threading::thread::suspend</a> and <a class="el" href="#aa0e94d71691111ef5efb7d3c01086f51" title="Resumes a thread that has been suspended (Should not be used).">xtd::threading::thread::resume</a> methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the application might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the application that attempt to use that class are blocked. Deadlocks can occur very easily. </dd></dl>

</div>
</div>
<a id="a573cca51d21d56dcf79eaace281b74b0" name="a573cca51d21d56dcf79eaace281b74b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573cca51d21d56dcf79eaace281b74b0">&#9670;&#160;</a></span>start() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::start </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the operating system to change the state of the current instance to <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a75101dcdfc88455bcafc9e53e0b06689" title="The thread_state has been started, it is not blocked, and there is no pending System::Threading::Thre...">xtd::threading::thread_state::running</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has already been started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24caec3c59051d52cbb11d7a7359723d" name="a24caec3c59051d52cbb11d7a7359723d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24caec3c59051d52cbb11d7a7359723d">&#9670;&#160;</a></span>start() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1any__object.html">xtd::any_object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the operating system to change the state of the current instance to <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a75101dcdfc88455bcafc9e53e0b06689" title="The thread_state has been started, it is not blocked, and there is no pending System::Threading::Thre...">xtd::threading::thread_state::running</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>An object that contains data to be used by the method the thread executes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has already been started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2416048e9a9f8adffc8cb8a969bb2760" name="a2416048e9a9f8adffc8cb8a969bb2760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2416048e9a9f8adffc8cb8a969bb2760">&#9670;&#160;</a></span>suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::thread::suspend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either suspends the thread, or if the thread is already suspended, has no effect (Should not be used). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The thread has not been started or is dead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Works only on Windows operating syetm, no effect on others. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not use the <a class="el" href="#a2416048e9a9f8adffc8cb8a969bb2760" title="Either suspends the thread, or if the thread is already suspended, has no effect (Should not be used)...">xtd::threading::thread::suspend</a> and <a class="el" href="#aa0e94d71691111ef5efb7d3c01086f51" title="Resumes a thread that has been suspended (Should not be used).">xtd::threading::thread::resume</a> methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the application might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the application that attempt to use that class are blocked. Deadlocks can occur very easily. </dd></dl>

</div>
</div>
<a id="a42a6bb9b87bc4bd70c1714a1933711b4" name="a42a6bb9b87bc4bd70c1714a1933711b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a6bb9b87bc4bd70c1714a1933711b4">&#9670;&#160;</a></span>start_new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> xtd::threading::thread::start_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__delegates.html#gacea3e237aac11920ba29f784740cba69">xtd::threading::thread_start</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and immedialtely start a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> with specified method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca8260305986f58f91cab6f479827834" name="aca8260305986f58f91cab6f479827834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8260305986f58f91cab6f479827834">&#9670;&#160;</a></span>start_new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1thread.html">thread</a> xtd::threading::thread::start_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__delegates.html#ga1961ded285db6ac6d364694eda5379a3">xtd::threading::parameterized_thread_start</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1any__object.html">xtd::any_object</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and immedialtely start a <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> with specified method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A delegate that represents the methods to be invoked when this thread begins executing. </td></tr>
    <tr><td class="paramname">obj</td><td>An object that contains data to be used by the method the thread executes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The start parameter is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6998fa3ca4218452ae93143d120174ba" name="a6998fa3ca4218452ae93143d120174ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6998fa3ca4218452ae93143d120174ba">&#9670;&#160;</a></span>join_all() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all joinable threads terminate. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd>
<dd>
The xtd::startup::run method and <a class="el" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd" title="Defines the entry point to be called when the application loads. Generally this is set either to the ...">startup_</a> keyword call the <a class="el" href="#a6998fa3ca4218452ae93143d120174ba" title="Blocks the calling thread until all joinable threads terminate.">xtd::threading::thread::join_all</a> method. </dd>
<dd>
Call <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a67c0921c9e154215c14cf459b9d0f3ed" title="Close all resources and worker threads.">xtd::threading::thread_pool::close</a> method to join the end of running worker threads too. </dd></dl>

</div>
</div>
<a id="af862f9b072e29e78324d76af04ed5ed1" name="af862f9b072e29e78324d76af04ed5ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af862f9b072e29e78324d76af04ed5ed1">&#9670;&#160;</a></span>join_all() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all joinable threads terminate or the specified time elapses, while continuing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all threads have terminated; <code>false</code> if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd>
<dd>
Call <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a67c0921c9e154215c14cf459b9d0f3ed" title="Close all resources and worker threads.">xtd::threading::thread_pool::close</a> method to join the end of running worker threads too. </dd></dl>

</div>
</div>
<a id="aa78f49e122e15aba2a9ca013e12e0bee" name="aa78f49e122e15aba2a9ca013e12e0bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78f49e122e15aba2a9ca013e12e0bee">&#9670;&#160;</a></span>join_all() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all joinable threads terminate or the specified time elapses, while continuing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="classxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> set to the amount of time to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all threads have terminated; <code>false</code> if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd>
<dd>
Call <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a67c0921c9e154215c14cf459b9d0f3ed" title="Close all resources and worker threads.">xtd::threading::thread_pool::close</a> method to join the end of running worker threads too. </dd></dl>

</div>
</div>
<a id="a21c59038a37bef5fe9a32936fd4ec997" name="a21c59038a37bef5fe9a32936fd4ec997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c59038a37bef5fe9a32936fd4ec997">&#9670;&#160;</a></span>join_all() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class collection_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;</td>          <td class="paramname"><span class="paramname"><em>threads</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all specified joinable threads collection terminate. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd></dl>

</div>
</div>
<a id="aa075ec069e9a67da9aaadef6a80b7f95" name="aa075ec069e9a67da9aaadef6a80b7f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa075ec069e9a67da9aaadef6a80b7f95">&#9670;&#160;</a></span>join_all() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class collection_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;</td>          <td class="paramname"><span class="paramname"><em>threads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all specified joinable threads collection terminate or the specified time elapses, while continuing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all threads have terminated; <code>false</code> if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd></dl>

</div>
</div>
<a id="a6b1fa6882ba1f0d0bdac7451c3e58cf9" name="a6b1fa6882ba1f0d0bdac7451c3e58cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1fa6882ba1f0d0bdac7451c3e58cf9">&#9670;&#160;</a></span>join_all() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class collection_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::join_all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;</td>          <td class="paramname"><span class="paramname"><em>threads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until all specified joinable threads collection terminate or the specified time elapses, while continuing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="classxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> set to the amount of time to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all threads have terminated; <code>false</code> if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1thread__state__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::thread_state_exception</a></td><td>The caller attempted to join a thread that is in the <a class="el" href="group__threading.html#ggad404f38f7d4e370680b792bc0f397d04a28ee56ece67abbd7bfc38eb955412865" title="The System::Threading::Thread.Start() method has not been invoked on the thread_state.">xtd::threading::thread_state::unstarted</a> state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd></dl>

</div>
</div>
<a id="a42bc6e2bb805f928e50ae73d243b95f2" name="a42bc6e2bb805f928e50ae73d243b95f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bc6e2bb805f928e50ae73d243b95f2">&#9670;&#160;</a></span>sleep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a></td>          <td class="paramname"><span class="paramname"><em>milliseconds_timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspends the current thread for a specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds for which the thread is blocked. Specify zero (0) to indicate that this thread should be suspended to allow other waiting threads to execute. Specify xtd::threading::Timeout.Infinite to block the thread indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>milliseconds_timeout is a negative number other than -1, which represents an infinite time-out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7a26e99e726b6e86effa2339238b941" name="ab7a26e99e726b6e86effa2339238b941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a26e99e726b6e86effa2339238b941">&#9670;&#160;</a></span>sleep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::sleep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspends the current thread for a specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A std::chrono::duration set to the amount of time for which the thread is blocked. Specify zero to indicate that this thread should be suspended to allow other waiting threads to execute. Specify xtd::threading::Timeout.Infinite to block the thread indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The value of timeout is negative and is not equal to <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> in milliseconds, or is greater than xtd::Int32.MaxValue milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7861e3838380ffe3e0382ea52032d178" name="a7861e3838380ffe3e0382ea52032d178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7861e3838380ffe3e0382ea52032d178">&#9670;&#160;</a></span>spin_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread::spin_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">int32</a></td>          <td class="paramname"><span class="paramname"><em>iterations</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes a thread to wait the number of times defined by the iterations parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterations</td><td>A 32-bit signed integer that defines how long a thread is to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="#a7861e3838380ffe3e0382ea52032d178" title="Causes a thread to wait the number of times defined by the iterations parameter.">xtd::threading::thread::spin_wait</a> method is useful for implementing locks. Classes in the xtd, such as <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> and xtd::threading::reader_writer_lock, use this method internally. <a class="el" href="#a7861e3838380ffe3e0382ea52032d178" title="Causes a thread to wait the number of times defined by the iterations parameter.">xtd::threading::thread::spin_wait</a> essentially puts the processor into a very tight loop, with the loop count specified by the iterations parameter. The duration of the wait therefore depends on the speed of the processor. </dd>
<dd>
Contrast this with the <a class="el" href="#a42bc6e2bb805f928e50ae73d243b95f2" title="Suspends the current thread for a specified time.">xtd::threading::thread::sleep</a> method. A thread that calls <a class="el" href="#a42bc6e2bb805f928e50ae73d243b95f2" title="Suspends the current thread for a specified time.">xtd::threading::thread::sleep</a> yields the rest of its current slice of processor time, even if the specified interval is zero. Specifying a non-zero interval for <a class="el" href="#a42bc6e2bb805f928e50ae73d243b95f2" title="Suspends the current thread for a specified time.">xtd::threading::thread::sleep</a> removes the thread from consideration by the thread scheduler until the time interval has elapsed. </dd>
<dd>
<a class="el" href="#a7861e3838380ffe3e0382ea52032d178" title="Causes a thread to wait the number of times defined by the iterations parameter.">xtd::threading::thread::spin_wait</a> is not generally useful for ordinary applications. In most cases, you should use the synchronization classes provided by the xtd Framework; for example, call <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::monitor::enter</a> or a statement that wraps <a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9" title="Acquires an exclusive lock on the specified obj.">xtd::threading::thread::monitor::enter</a> </dd></dl>

</div>
</div>
<a id="a7ce63292cb3e6dfbd89e34d0769d56cb" name="a7ce63292cb3e6dfbd89e34d0769d56cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce63292cb3e6dfbd89e34d0769d56cb">&#9670;&#160;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread::yield </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the thread to yield to. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operating system switched execution to another thread; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If this method succeeds, the rest of the thread's current time slice is yielded. The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run. </dd>
<dd>
yielding is limited to the processor that is executing the calling thread. The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority. If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <code>false</code>. </dd>
<dd>
This method is equivalent to using platform invoke to call the native Win32 switch_to_thread function. You should call the <a class="el" href="#a7ce63292cb3e6dfbd89e34d0769d56cb" title="Causes the calling thread to yield execution to another thread that is ready to run on the current pr...">xtd::threading::thread::yield</a> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5d3f07807d378451068228c15457a3a0" name="a5d3f07807d378451068228c15457a3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3f07807d378451068228c15457a3a0">&#9670;&#160;</a></span>invalid_handle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__types.html#ga6d54527a3ec7b15afb917a6ba73a4ece">intptr</a> xtd::threading::thread::invalid_handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents an invalid native operating system handle. This field is read-only. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Used internally to initialize the xtd::thread::wait_handle::handle property. </dd></dl>

</div>
</div>
<a id="aa32ae3359fdaed5d27be7ecca2e1d96f" name="aa32ae3359fdaed5d27be7ecca2e1d96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32ae3359fdaed5d27be7ecca2e1d96f">&#9670;&#160;</a></span>invalid_thread_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__types.html#ga6d54527a3ec7b15afb917a6ba73a4ece">intptr</a> xtd::threading::thread::invalid_thread_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents an invalid native operating system thread id. This field is read-only. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Used internally to initialize the <a class="el" href="#a1b7d950d7fb12c145e136c71e7b58609" title="Gets the native operating system thread id.">xtd::threading::thread::thread_id</a> property. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="thread_8hpp_source.html">thread.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 5 2025 21:58:57 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
