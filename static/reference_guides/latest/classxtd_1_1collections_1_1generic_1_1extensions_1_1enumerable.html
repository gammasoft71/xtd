<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections.html">collections</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections_1_1generic.html">generic</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections_1_1generic_1_1extensions.html">extensions</a></li><li class="navelem"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">enumerable</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__collections.html">collections</a> &raquo; <a class="el" href="group__generic__collections.html">generic</a> &raquo; <a class="el" href="group__extensions__generic__collections.html">extensions</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.png" usemap="#xtd::collections::generic::extensions::enumerable_3C_20enumerable_5Ft_2C_20source_5Ft_20_3E_map" alt=""/>
  <map id="xtd::collections::generic::extensions::enumerable_3C_20enumerable_5Ft_2C_20source_5Ft_20_3E_map" name="xtd::collections::generic::extensions::enumerable_3C_20enumerable_5Ft_2C_20source_5Ft_20_3E_map">
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" alt="xtd::collections::generic::ienumerable&lt; xtd::any_object &gt;" shape="rect" coords="0,56,438,80"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class enumerable_t, class source_t&gt;<br />
class xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt;</div><p>Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> type_t&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">enumerable</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1static__object.html">xtd::static_object</a>;</div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a></div><div class="ttdoc">Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:32</div></div>
<div class="ttc" id="aclassxtd_1_1static__object_html"><div class="ttname"><a href="classxtd_1_1static__object.html">xtd::static_object</a></div><div class="ttdoc">Represent a static object. A static class can&#39;t be instantiated (constructors are deleted).</div><div class="ttdef"><b>Definition</b> static.hpp:20</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/generic/extensions/enumerable&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1linq.html" title="Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).">xtd::linq</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:afa0428a5d439bb7fd6a75f0ca54751c5" id="r_afa0428a5d439bb7fd6a75f0ca54751c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa0428a5d439bb7fd6a75f0ca54751c5">enumerable_type</a></td></tr>
<tr class="memdesc:afa0428a5d439bb7fd6a75f0ca54751c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable enumerable type.  <br /></td></tr>
<tr class="separator:afa0428a5d439bb7fd6a75f0ca54751c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723aac49b8d3459b2caaff26c2ab90e0" id="r_a723aac49b8d3459b2caaff26c2ab90e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a723aac49b8d3459b2caaff26c2ab90e0">source_type</a></td></tr>
<tr class="memdesc:a723aac49b8d3459b2caaff26c2ab90e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable source type.  <br /></td></tr>
<tr class="separator:a723aac49b8d3459b2caaff26c2ab90e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f" id="r_aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a></td></tr>
<tr class="memdesc:aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:aec4cd2ae6b5b4fde97fef8e2f160336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2" id="r_a417e4adb1792949e9a54516bee2ca3d2"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a417e4adb1792949e9a54516bee2ca3d2">list</a></td></tr>
<tr class="memdesc:a417e4adb1792949e9a54516bee2ca3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a417e4adb1792949e9a54516bee2ca3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:a22f3540f62b3b6140ecf188faf509842" id="r_a22f3540f62b3b6140ecf188faf509842"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22f3540f62b3b6140ecf188faf509842">aggregate</a> (const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const</td></tr>
<tr class="memdesc:a22f3540f62b3b6140ecf188faf509842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a22f3540f62b3b6140ecf188faf509842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bbfa7cff2e26dcf33e973a97d42316" id="r_af8bbfa7cff2e26dcf33e973a97d42316"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bbfa7cff2e26dcf33e973a97d42316">aggregate</a> (const source_t &amp;seed, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const</td></tr>
<tr class="memdesc:af8bbfa7cff2e26dcf33e973a97d42316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:af8bbfa7cff2e26dcf33e973a97d42316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359f0f326affdbf94b54eb5933bf747e" id="r_a359f0f326affdbf94b54eb5933bf747e"><td class="memTemplParams" colspan="2">template&lt;class accumulate_t&gt; </td></tr>
<tr class="memitem:a359f0f326affdbf94b54eb5933bf747e"><td class="memTemplItemLeft" align="right" valign="top">accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a359f0f326affdbf94b54eb5933bf747e">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const accumulate_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>) const</td></tr>
<tr class="memdesc:a359f0f326affdbf94b54eb5933bf747e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a359f0f326affdbf94b54eb5933bf747e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487db86dcfc03a261804db9288b917df" id="r_a487db86dcfc03a261804db9288b917df"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a487db86dcfc03a261804db9288b917df">aggregate</a> (const source_t &amp;seed, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a487db86dcfc03a261804db9288b917df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a487db86dcfc03a261804db9288b917df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a25236539c411682f728129aaeba9a2" id="r_a7a25236539c411682f728129aaeba9a2"><td class="memTemplParams" colspan="2">template&lt;class result_t, class accumulate_t&gt; </td></tr>
<tr class="memitem:a7a25236539c411682f728129aaeba9a2"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a25236539c411682f728129aaeba9a2">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const accumulate_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a7a25236539c411682f728129aaeba9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a7a25236539c411682f728129aaeba9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c344a4319826da54bae2611d78f7e41" id="r_a8c344a4319826da54bae2611d78f7e41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c344a4319826da54bae2611d78f7e41">all</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a8c344a4319826da54bae2611d78f7e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a8c344a4319826da54bae2611d78f7e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e647f592add925edc5682334fa2b29" id="r_a25e647f592add925edc5682334fa2b29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25e647f592add925edc5682334fa2b29">any</a> () const noexcept</td></tr>
<tr class="memdesc:a25e647f592add925edc5682334fa2b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a25e647f592add925edc5682334fa2b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddaea79f05f3a1d7c83bdc64883ec44" id="r_a7ddaea79f05f3a1d7c83bdc64883ec44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ddaea79f05f3a1d7c83bdc64883ec44">any</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a7ddaea79f05f3a1d7c83bdc64883ec44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a7ddaea79f05f3a1d7c83bdc64883ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34c33a40d0180b2be5a5bfae2bda31e" id="r_ae34c33a40d0180b2be5a5bfae2bda31e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae34c33a40d0180b2be5a5bfae2bda31e">append</a> (const source_t &amp;element) const noexcept</td></tr>
<tr class="memdesc:ae34c33a40d0180b2be5a5bfae2bda31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:ae34c33a40d0180b2be5a5bfae2bda31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d20a7b596a0b4f468a80faaa8d0c93" id="r_ae9d20a7b596a0b4f468a80faaa8d0c93"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9d20a7b596a0b4f468a80faaa8d0c93">as_enumerable</a> () const noexcept</td></tr>
<tr class="memdesc:ae9d20a7b596a0b4f468a80faaa8d0c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ae9d20a7b596a0b4f468a80faaa8d0c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5669f1a9bf9da6303aa9ff29197b4799" id="r_a5669f1a9bf9da6303aa9ff29197b4799"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5669f1a9bf9da6303aa9ff29197b4799">average</a> () const noexcept</td></tr>
<tr class="memdesc:a5669f1a9bf9da6303aa9ff29197b4799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of source_t values.  <br /></td></tr>
<tr class="separator:a5669f1a9bf9da6303aa9ff29197b4799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994683d04e77ec8464431ec8ac429a7c" id="r_a994683d04e77ec8464431ec8ac429a7c"><td class="memTemplParams" colspan="2">template&lt;class result_t&gt; </td></tr>
<tr class="memitem:a994683d04e77ec8464431ec8ac429a7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a994683d04e77ec8464431ec8ac429a7c">cast</a> () const noexcept</td></tr>
<tr class="memdesc:a994683d04e77ec8464431ec8ac429a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> to the specified type.  <br /></td></tr>
<tr class="separator:a994683d04e77ec8464431ec8ac429a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992667d25a4fc7fd3383d9eafd716eca" id="r_a992667d25a4fc7fd3383d9eafd716eca"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a992667d25a4fc7fd3383d9eafd716eca">chunk</a> (size_t <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">size</a>) const</td></tr>
<tr class="memdesc:a992667d25a4fc7fd3383d9eafd716eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the elements of a sequence into chunks of size at most size.  <br /></td></tr>
<tr class="separator:a992667d25a4fc7fd3383d9eafd716eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc904cd780ff73da92d5d8f4e6c81468" id="r_afc904cd780ff73da92d5d8f4e6c81468"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc904cd780ff73da92d5d8f4e6c81468">concat</a> (const <a class="el" href="#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;second) const noexcept</td></tr>
<tr class="memdesc:afc904cd780ff73da92d5d8f4e6c81468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two sequences.  <br /></td></tr>
<tr class="separator:afc904cd780ff73da92d5d8f4e6c81468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e29837254bb373971404eb103ba26" id="r_ad77e29837254bb373971404eb103ba26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad77e29837254bb373971404eb103ba26">contains</a> (const source_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:ad77e29837254bb373971404eb103ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using the default equality comparer.  <br /></td></tr>
<tr class="separator:ad77e29837254bb373971404eb103ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4be2e1cde9d4316519230b03e0496" id="r_a87d4be2e1cde9d4316519230b03e0496"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87d4be2e1cde9d4316519230b03e0496">contains</a> (const source_t &amp;value, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept</td></tr>
<tr class="memdesc:a87d4be2e1cde9d4316519230b03e0496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using a specified equality comparer.  <br /></td></tr>
<tr class="separator:a87d4be2e1cde9d4316519230b03e0496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0560a5c54fcf0e9786018f00e136c7fb" id="r_a0560a5c54fcf0e9786018f00e136c7fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0560a5c54fcf0e9786018f00e136c7fb">count</a> () const noexcept</td></tr>
<tr class="memdesc:a0560a5c54fcf0e9786018f00e136c7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in current sequence.  <br /></td></tr>
<tr class="separator:a0560a5c54fcf0e9786018f00e136c7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef0abd344f629aef3c96e49d272b50c" id="r_aeef0abd344f629aef3c96e49d272b50c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeef0abd344f629aef3c96e49d272b50c">count</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:aeef0abd344f629aef3c96e49d272b50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number that represents how many elements in the specified sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aeef0abd344f629aef3c96e49d272b50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b65916d2ccf5f2e4d1eb3f4ef4850d" id="r_a45b65916d2ccf5f2e4d1eb3f4ef4850d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45b65916d2ccf5f2e4d1eb3f4ef4850d">count</a> (const source_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:a45b65916d2ccf5f2e4d1eb3f4ef4850d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with the specified value.  <br /></td></tr>
<tr class="separator:a45b65916d2ccf5f2e4d1eb3f4ef4850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4457cca131d9c0a6ffe086e8eb0f94" id="r_a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="memTemplParams" colspan="2">template&lt;class key_t&gt; </td></tr>
<tr class="memitem:a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e4457cca131d9c0a6ffe086e8eb0f94">count_by</a> (const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector) const noexcept</td></tr>
<tr class="memdesc:a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:a4e4457cca131d9c0a6ffe086e8eb0f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc573c1483ac2d7952eb75e8b114e49" id="r_acfc573c1483ac2d7952eb75e8b114e49"><td class="memTemplParams" colspan="2">template&lt;class key_t&gt; </td></tr>
<tr class="memitem:acfc573c1483ac2d7952eb75e8b114e49"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfc573c1483ac2d7952eb75e8b114e49">count_by</a> (const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;key_comparer) const noexcept</td></tr>
<tr class="memdesc:acfc573c1483ac2d7952eb75e8b114e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:acfc573c1483ac2d7952eb75e8b114e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b55e90e328b05491b96d053b5d5fc0f" id="r_a6b55e90e328b05491b96d053b5d5fc0f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b55e90e328b05491b96d053b5d5fc0f">default_if_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a6b55e90e328b05491b96d053b5d5fc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a6b55e90e328b05491b96d053b5d5fc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adcbae38abdfd1ce51e6bb29ed2c3e3" id="r_a5adcbae38abdfd1ce51e6bb29ed2c3e3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5adcbae38abdfd1ce51e6bb29ed2c3e3">default_if_empty</a> (const source_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:a5adcbae38abdfd1ce51e6bb29ed2c3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the specified value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a5adcbae38abdfd1ce51e6bb29ed2c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed33cd2bdca30be4a7746d569a8367a7" id="r_aed33cd2bdca30be4a7746d569a8367a7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed33cd2bdca30be4a7746d569a8367a7">distinct</a> () const noexcept</td></tr>
<tr class="memdesc:aed33cd2bdca30be4a7746d569a8367a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distinct elements from a sequence by using the default equality comparer to compare values.  <br /></td></tr>
<tr class="separator:aed33cd2bdca30be4a7746d569a8367a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4e42accb00e5e59a3262c6624dfc7c" id="r_abb4e42accb00e5e59a3262c6624dfc7c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb4e42accb00e5e59a3262c6624dfc7c">distinct</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept</td></tr>
<tr class="memdesc:abb4e42accb00e5e59a3262c6624dfc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distinct elements from a sequence by using a specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; to compare values.  <br /></td></tr>
<tr class="separator:abb4e42accb00e5e59a3262c6624dfc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcddc251cf8f945686a5f77807e62dcd" id="r_afcddc251cf8f945686a5f77807e62dcd"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcddc251cf8f945686a5f77807e62dcd">first_or_default</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>, const source_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:afcddc251cf8f945686a5f77807e62dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:afcddc251cf8f945686a5f77807e62dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52658d4876a5f7642288ef7cfd0be8" id="r_a2e52658d4876a5f7642288ef7cfd0be8"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e52658d4876a5f7642288ef7cfd0be8">first_or_default</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:a2e52658d4876a5f7642288ef7cfd0be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2e52658d4876a5f7642288ef7cfd0be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0a757b76c036ef644cec12662f887" id="r_a2ba0a757b76c036ef644cec12662f887"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ba0a757b76c036ef644cec12662f887">first_or_default</a> (const source_t default_value) const noexcept</td></tr>
<tr class="memdesc:a2ba0a757b76c036ef644cec12662f887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2ba0a757b76c036ef644cec12662f887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964948d137047014d18a7cc5db15f46f" id="r_a964948d137047014d18a7cc5db15f46f"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a964948d137047014d18a7cc5db15f46f">first_or_default</a> () const noexcept</td></tr>
<tr class="memdesc:a964948d137047014d18a7cc5db15f46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a964948d137047014d18a7cc5db15f46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9472d2fb32abc451658a9a49b1850a" id="r_abd9472d2fb32abc451658a9a49b1850a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd9472d2fb32abc451658a9a49b1850a">order_by</a> (const std::function&lt; source_t(const source_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:abd9472d2fb32abc451658a9a49b1850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order according to a key.  <br /></td></tr>
<tr class="separator:abd9472d2fb32abc451658a9a49b1850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf1d21996e82ad730383c1c83f9d4f5" id="r_a5cf1d21996e82ad730383c1c83f9d4f5"><td class="memTemplParams" colspan="2">template&lt;class key_t&gt; </td></tr>
<tr class="memitem:a5cf1d21996e82ad730383c1c83f9d4f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5cf1d21996e82ad730383c1c83f9d4f5">order_by_descending</a> (const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:a5cf1d21996e82ad730383c1c83f9d4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in descending order according to a key.  <br /></td></tr>
<tr class="separator:a5cf1d21996e82ad730383c1c83f9d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab380ad6e3fcd5d1cad403eae4e5d9d56" id="r_ab380ad6e3fcd5d1cad403eae4e5d9d56"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab380ad6e3fcd5d1cad403eae4e5d9d56">order_by_descending</a> (const std::function&lt; source_t(const source_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:ab380ad6e3fcd5d1cad403eae4e5d9d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in descending order according to a key.  <br /></td></tr>
<tr class="separator:ab380ad6e3fcd5d1cad403eae4e5d9d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dd17c4172c503636ef8c0b1954415f" id="r_a22dd17c4172c503636ef8c0b1954415f"><td class="memTemplParams" colspan="2">template&lt;class key_t&gt; </td></tr>
<tr class="memitem:a22dd17c4172c503636ef8c0b1954415f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22dd17c4172c503636ef8c0b1954415f">order_by</a> (const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector) const</td></tr>
<tr class="memdesc:a22dd17c4172c503636ef8c0b1954415f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order according to a key.  <br /></td></tr>
<tr class="separator:a22dd17c4172c503636ef8c0b1954415f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf27a2adb67c1144bc20c98151c45639" id="r_adf27a2adb67c1144bc20c98151c45639"><td class="memTemplParams" colspan="2">template&lt;class result_t&gt; </td></tr>
<tr class="memitem:adf27a2adb67c1144bc20c98151c45639"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf27a2adb67c1144bc20c98151c45639">select</a> (const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:adf27a2adb67c1144bc20c98151c45639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:adf27a2adb67c1144bc20c98151c45639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2388e79e9cf3b548edcbfd01c7fb606" id="r_ac2388e79e9cf3b548edcbfd01c7fb606"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2388e79e9cf3b548edcbfd01c7fb606">select</a> (const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:ac2388e79e9cf3b548edcbfd01c7fb606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:ac2388e79e9cf3b548edcbfd01c7fb606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72b6ac4c22f5ed599d5bcad4bcb8f51" id="r_ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="memTemplParams" colspan="2">template&lt;class result_t&gt; </td></tr>
<tr class="memitem:ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae72b6ac4c22f5ed599d5bcad4bcb8f51">select</a> (const std::function&lt; result_t(const source_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:ae72b6ac4c22f5ed599d5bcad4bcb8f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057c689f8c51e80cbf49b14e8cad1b00" id="r_a057c689f8c51e80cbf49b14e8cad1b00"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a057c689f8c51e80cbf49b14e8cad1b00">select</a> (const std::function&lt; source_t(const source_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a057c689f8c51e80cbf49b14e8cad1b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a057c689f8c51e80cbf49b14e8cad1b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9186b87e4e781e16cfeca4d3e83ca6ba" id="r_a9186b87e4e781e16cfeca4d3e83ca6ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a417e4adb1792949e9a54516bee2ca3d2">list</a>&lt; source_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9186b87e4e781e16cfeca4d3e83ca6ba">to_list</a> () const noexcept</td></tr>
<tr class="memdesc:a9186b87e4e781e16cfeca4d3e83ca6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a9186b87e4e781e16cfeca4d3e83ca6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb58e81e7cbc4401a227fa23918fd3c" id="r_accb58e81e7cbc4401a227fa23918fd3c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accb58e81e7cbc4401a227fa23918fd3c">where</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:accb58e81e7cbc4401a227fa23918fd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:accb58e81e7cbc4401a227fa23918fd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cebfce505a8ba369e428df6c5935491" id="r_a2cebfce505a8ba369e428df6c5935491"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cebfce505a8ba369e428df6c5935491">where</a> (const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) const</td></tr>
<tr class="memdesc:a2cebfce505a8ba369e428df6c5935491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a2cebfce505a8ba369e428df6c5935491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afa0428a5d439bb7fd6a75f0ca54751c5" name="afa0428a5d439bb7fd6a75f0ca54751c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0428a5d439bb7fd6a75f0ca54751c5">&#9670;&#160;</a></span>enumerable_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::enumerable_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the ienumerable enumerable type. </p>

</div>
</div>
<a id="a723aac49b8d3459b2caaff26c2ab90e0" name="a723aac49b8d3459b2caaff26c2ab90e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723aac49b8d3459b2caaff26c2ab90e0">&#9670;&#160;</a></span>source_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::source_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the ienumerable source type. </p>

</div>
</div>
<a id="aec4cd2ae6b5b4fde97fef8e2f160336f" name="aec4cd2ae6b5b4fde97fef8e2f160336f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4cd2ae6b5b4fde97fef8e2f160336f">&#9670;&#160;</a></span>ienumerable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class type_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::ienumerable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the ienumerable value type. </p>

</div>
</div>
<a id="a417e4adb1792949e9a54516bee2ca3d2" name="a417e4adb1792949e9a54516bee2ca3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417e4adb1792949e9a54516bee2ca3d2">&#9670;&#160;</a></span>list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class type_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the list value type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a22f3540f62b3b6140ecf188faf509842" name="a22f3540f62b3b6140ecf188faf509842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f3540f62b3b6140ecf188faf509842">&#9670;&#160;</a></span>aggregate() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">source_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="#a22f3540f62b3b6140ecf188faf509842" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af8bbfa7cff2e26dcf33e973a97d42316" name="af8bbfa7cff2e26dcf33e973a97d42316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bbfa7cff2e26dcf33e973a97d42316">&#9670;&#160;</a></span>aggregate() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">source_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::aggregate </td>
          <td>(</td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.aggregate(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
<div class="ttc" id="aclassxtd_1_1array_html"><div class="ttname"><a href="classxtd_1_1array.html">xtd::array</a></div><div class="ttdoc">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...</div><div class="ttdef"><b>Definition</b> array.hpp:63</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a359f0f326affdbf94b54eb5933bf747e" name="a359f0f326affdbf94b54eb5933bf747e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359f0f326affdbf94b54eb5933bf747e">&#9670;&#160;</a></span>aggregate() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class accumulate_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accumulate_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::aggregate </td>
          <td>(</td>
          <td class="paramtype">const accumulate_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const accumulate_t &amp;, const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.aggregate(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a487db86dcfc03a261804db9288b917df" name="a487db86dcfc03a261804db9288b917df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487db86dcfc03a261804db9288b917df">&#9670;&#160;</a></span>aggregate() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">source_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::aggregate </td>
          <td>(</td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result_selector</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name = fruits.aggregate(<span class="stringliteral">&quot;bananas&quot;</span>,</div>
<div class="line">     [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">     <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">     [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.to_upper();});</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7a25236539c411682f728129aaeba9a2" name="a7a25236539c411682f728129aaeba9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a25236539c411682f728129aaeba9a2">&#9670;&#160;</a></span>aggregate() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class result_t, class accumulate_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::aggregate </td>
          <td>(</td>
          <td class="paramtype">const accumulate_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const accumulate_t &amp;, const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result_selector</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name = fruits.aggregate(<span class="stringliteral">&quot;bananas&quot;</span>,</div>
<div class="line">     [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">     <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">     [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.to_upper();});</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8c344a4319826da54bae2611d78f7e41" name="a8c344a4319826da54bae2611d78f7e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c344a4319826da54bae2611d78f7e41">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::all </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, <code>false</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is <code>true</code> if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.all([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  console::write_line(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a25e647f592add925edc5682334fa2b29" name="a25e647f592add925edc5682334fa2b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e647f592add925edc5682334fa2b29">&#9670;&#160;</a></span>any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::any </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the source sequence contains any elements; otherwise, <code>false</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="#a417e4adb1792949e9a54516bee2ca3d2">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.any();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a417e4adb1792949e9a54516bee2ca3d2"><div class="ttname"><a href="#a417e4adb1792949e9a54516bee2ca3d2">xtd::collections::generic::extensions::enumerable::list</a></div><div class="ttdeci">typename xtd::linq::enumerable::list&lt; type_t &gt; list</div><div class="ttdoc">Represents the list value type.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:47</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7ddaea79f05f3a1d7c83bdc64883ec44" name="a7ddaea79f05f3a1d7c83bdc64883ec44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddaea79f05f3a1d7c83bdc64883ec44">&#9670;&#160;</a></span>any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::any </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, <code>false</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is <code>true</code> if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="#a417e4adb1792949e9a54516bee2ca3d2">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.any();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae34c33a40d0180b2be5a5bfae2bda31e" name="ae34c33a40d0180b2be5a5bfae2bda31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34c33a40d0180b2be5a5bfae2bda31e">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>element</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="#a417e4adb1792949e9a54516bee2ca3d2">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.append(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(string::join(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(string::join(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(string::join(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae9d20a7b596a0b4f468a80faaa8d0c93" name="ae9d20a7b596a0b4f468a80faaa8d0c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d20a7b596a0b4f468a80faaa8d0c93">&#9670;&#160;</a></span>as_enumerable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::as_enumerable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5669f1a9bf9da6303aa9ff29197b4799" name="a5669f1a9bf9da6303aa9ff29197b4799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5669f1a9bf9da6303aa9ff29197b4799">&#9670;&#160;</a></span>average()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::average </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of source_t values. </p>
<dl class="section return"><dt>Returns</dt><dd>The average of this sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>this sequence contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a994683d04e77ec8464431ec8ac429a7c" name="a994683d04e77ec8464431ec8ac429a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994683d04e77ec8464431ec8ac429a7c">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class result_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::cast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the elements of an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> to the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains each element of the source sequence cast to the specified type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__cast__exception.html" title="The exception that is thrown for invalid casting or explicit conversion.">xtd::invalid_cast_exception</a></td><td>An element in the sequence cannot be cast to type `result_t`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a992667d25a4fc7fd3383d9eafd716eca" name="a992667d25a4fc7fd3383d9eafd716eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992667d25a4fc7fd3383d9eafd716eca">&#9670;&#160;</a></span>chunk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::chunk </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the elements of a sequence into chunks of size at most size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to chunk. </td></tr>
    <tr><td class="paramname">size</td><td>The maximum size of each chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence of chunks of size at most size. </dd></dl>

</div>
</div>
<a id="afc904cd780ff73da92d5d8f4e6c81468" name="afc904cd780ff73da92d5d8f4e6c81468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc904cd780ff73da92d5d8f4e6c81468">&#9670;&#160;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">second</td><td>The sequence to concatenate to the current sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the concatenated elements of the two input sequences. </dd></dl>

</div>
</div>
<a id="ad77e29837254bb373971404eb103ba26" name="ad77e29837254bb373971404eb103ba26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77e29837254bb373971404eb103ba26">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains a specified element by using the default equality comparer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to locate in the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the source sequence contains an element that has the specified value; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a87d4be2e1cde9d4316519230b03e0496" name="a87d4be2e1cde9d4316519230b03e0496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d4be2e1cde9d4316519230b03e0496">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains a specified element by using a specified equality comparer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to locate in the sequence. </td></tr>
    <tr><td class="paramname">comparer</td><td>An equality comparer to compare values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the source sequence contains an element that has the specified value; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a0560a5c54fcf0e9786018f00e136c7fb" name="a0560a5c54fcf0e9786018f00e136c7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0560a5c54fcf0e9786018f00e136c7fb">&#9670;&#160;</a></span>count() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in current sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the input sequence. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae8deab4a1605619cb40cd56504a5b54c" title="Returns the number of elements in a sequence.">xtd::linq::enumerable::count</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;) to count the elements in a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> number_of_fruits = fruits.enumerable::count();</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;There are {0} fruits in the collection.&quot;</span>, number_of_fruits);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// There are 6 fruits in the collection.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aeef0abd344f629aef3c96e49d272b50c" name="aeef0abd344f629aef3c96e49d272b50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef0abd344f629aef3c96e49d272b50c">&#9670;&#160;</a></span>count() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a number that represents how many elements in the specified sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A number that represents how many elements in the sequence satisfy the condition in the predicate function. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae8deab4a1605619cb40cd56504a5b54c" title="Returns the number of elements in a sequence.">xtd::linq::enumerable::count</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;bool(const source_t&amp;)&gt;&amp;) to count the elements in a sequence that satisfy a condition. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>pet {</div>
<div class="line">  <span class="keywordtype">string</span> name;</div>
<div class="line">  <span class="keywordtype">bool</span> vaccinated = <span class="keyword">false</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> pet&amp; lhs, <span class="keyword">const</span> pet&amp; rhs) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">return</span> lhs.name == rhs.name &amp;&amp; lhs.vaccinated == rhs.vaccinated;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {.name = <span class="stringliteral">&quot;Barley&quot;</span>, .vaccinated = <span class="keyword">true</span>},</div>
<div class="line">    pet {.name = <span class="stringliteral">&quot;Boots&quot;</span>, .vaccinated = <span class="keyword">false</span>},</div>
<div class="line">    pet {.name = <span class="stringliteral">&quot;Whiskers&quot;</span>, .vaccinated = <span class="keyword">false</span>}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> number_unvaccinated = pets.<a class="code hl_function" href="classxtd_1_1basic__array.html#a2e50b538f5aa4913d3180fcee49499c2">count</a>([](<span class="keyword">const</span> pet&amp; pet) {<span class="keywordflow">return</span> !pet.vaccinated;});</div>
<div class="line">  console::write_line(<span class="stringliteral">&quot;There are {} unvaccinated animals.&quot;</span>, number_unvaccinated);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// There are 2 unvaccinated animals.</span></div>
<div class="ttc" id="aclassxtd_1_1basic__array_html_a2e50b538f5aa4913d3180fcee49499c2"><div class="ttname"><a href="classxtd_1_1basic__array.html#a2e50b538f5aa4913d3180fcee49499c2">xtd::basic_array::count</a></div><div class="ttdeci">size_type count() const noexcept override</div><div class="ttdoc">Gets the number of elements contained in the xtd::array &lt;type_t&gt;.</div><div class="ttdef"><b>Definition</b> basic_array.hpp:129</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a45b65916d2ccf5f2e4d1eb3f4ef4850d" name="a45b65916d2ccf5f2e4d1eb3f4ef4850d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b65916d2ccf5f2e4d1eb3f4ef4850d">&#9670;&#160;</a></span>count() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A number representing the number of elements in the sequence that are equal to the <code>value</code>. </dd></dl>

</div>
</div>
<a id="a4e4457cca131d9c0a6ffe086e8eb0f94" name="a4e4457cca131d9c0a6ffe086e8eb0f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4457cca131d9c0a6ffe086e8eb0f94">&#9670;&#160;</a></span>count_by() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class key_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::count_by </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; key_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the count of elements in the current sequence grouped by key. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key_t</td><td>The type of the key returned by <code>key_selector</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_selector</td><td>A function to extract the key for each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enumerable containing the frequencies of each key occurrence in current sequence. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ac4fcd2e099e280f4c2c6cdfa9ce2423b" title="Returns the count of elements in the source sequence grouped by key.">xtd::linq::enumerable::count_by</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;key_t(const source_t&amp;)&gt;&amp;) to count the number of elements in a sequence grouped by key. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>student : <a class="code hl_class" href="classxtd_1_1iequatable.html">iequatable</a>&lt;student&gt; {</div>
<div class="line">  student() = <span class="keywordflow">default</span>;</div>
<div class="line">  student(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; score) : name {name}, score {score} {}</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">string</span> name;</div>
<div class="line">  <span class="keywordtype">string</span> score;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a>(<span class="keyword">const</span> student&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> {</div>
<div class="line">    <span class="keywordflow">return</span> name == <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.name &amp;&amp; score == <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.score;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> students = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;student&gt;</a> {</div>
<div class="line">    {<span class="stringliteral">&quot;Alice&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Bob&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Charlie&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;David&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Eve&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = students.count_by&lt;<span class="keywordtype">string</span>&gt;([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; student) {<span class="keywordflow">return</span> student.score;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [score, count] : query)</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Students with a {}-score: {}&quot;</span>, score, count);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Students with a A-score: 2</span></div>
<div class="line"><span class="comment">// Students with a B-score: 2</span></div>
<div class="line"><span class="comment">// Students with a C-score: 1</span></div>
<div class="ttc" id="aclassxtd_1_1iequatable_html"><div class="ttname"><a href="classxtd_1_1iequatable.html">xtd::iequatable</a></div><div class="ttdoc">Defines a generalized method that a value type or class implements to create a type-specific method f...</div><div class="ttdef"><b>Definition</b> iequatable.hpp:22</div></div>
<div class="ttc" id="aclassxtd_1_1iequatable_html_a1f8bbde943d2e5ecf565734c60e23903"><div class="ttname"><a href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">xtd::iequatable::equals</a></div><div class="ttdeci">virtual bool equals(const type_t &amp;) const noexcept=0</div><div class="ttdoc">Indicates whether the current object is equal to another object of the same type.</div></div>
<div class="ttc" id="agroup__xtd__core_html_gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb"><div class="ttname"><a href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">xtd::uri_components::query</a></div><div class="ttdeci">@ query</div><div class="ttdoc">The xtd::uri::query data.</div><div class="ttdef"><b>Definition</b> uri_components.hpp:29</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf"><div class="ttname"><a href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">xtd::platform_id::other</a></div><div class="ttdeci">@ other</div><div class="ttdoc">The operating system is other.</div><div class="ttdef"><b>Definition</b> platform_id.hpp:60</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acfc573c1483ac2d7952eb75e8b114e49" name="acfc573c1483ac2d7952eb75e8b114e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc573c1483ac2d7952eb75e8b114e49">&#9670;&#160;</a></span>count_by() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class key_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::count_by </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; key_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_comparer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the count of elements in the current sequence grouped by key. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key_t</td><td>The type of the key returned by <code>key_selector</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_selector</td><td>A function to extract the key for each element. </td></tr>
    <tr><td class="paramname">key_comparer</td><td>An equality comparer to compare keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enumerable containing the frequencies of each key occurrence in current sequence. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ac4fcd2e099e280f4c2c6cdfa9ce2423b" title="Returns the count of elements in the source sequence grouped by key.">xtd::linq::enumerable::count_by</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;key_t(const source_t&amp;)&gt;&amp;) to count the number of elements in a sequence grouped by key. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>student : <a class="code hl_class" href="classxtd_1_1iequatable.html">iequatable</a>&lt;student&gt; {</div>
<div class="line">  student() = <span class="keywordflow">default</span>;</div>
<div class="line">  student(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; score) : name {name}, score {score} {}</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">string</span> name;</div>
<div class="line">  <span class="keywordtype">string</span> score;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a>(<span class="keyword">const</span> student&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> {</div>
<div class="line">    <span class="keywordflow">return</span> name == <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.name &amp;&amp; score == <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.score;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> students = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;student&gt;</a> {</div>
<div class="line">    {<span class="stringliteral">&quot;Alice&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Bob&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Charlie&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;David&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Eve&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = students.count_by&lt;<span class="keywordtype">string</span>&gt;([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; student) {<span class="keywordflow">return</span> student.score;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [score, count] : query)</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Students with a {}-score: {}&quot;</span>, score, count);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Students with a A-score: 2</span></div>
<div class="line"><span class="comment">// Students with a B-score: 2</span></div>
<div class="line"><span class="comment">// Students with a C-score: 1</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6b55e90e328b05491b96d053b5d5fc0f" name="a6b55e90e328b05491b96d053b5d5fc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b55e90e328b05491b96d053b5d5fc0f">&#9670;&#160;</a></span>default_if_empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::default_if_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the current sequence is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains default_value if source is empty; otherwise, source. </dd></dl>

</div>
</div>
<a id="a5adcbae38abdfd1ce51e6bb29ed2c3e3" name="a5adcbae38abdfd1ce51e6bb29ed2c3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adcbae38abdfd1ce51e6bb29ed2c3e3">&#9670;&#160;</a></span>default_if_empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::default_if_empty </td>
          <td>(</td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elements of the specified sequence or the specified value in a singleton collection if the current sequence is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_value</td><td>The value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains default_value if source is empty; otherwise, source. </dd></dl>

</div>
</div>
<a id="aed33cd2bdca30be4a7746d569a8367a7" name="aed33cd2bdca30be4a7746d569a8367a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed33cd2bdca30be4a7746d569a8367a7">&#9670;&#160;</a></span>distinct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::distinct </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns distinct elements from a sequence by using the default equality comparer to compare values. </p>
<dl class="section return"><dt>Returns</dt><dd>An enumerable distinct elements from the source sequence. </dd></dl>

</div>
</div>
<a id="abb4e42accb00e5e59a3262c6624dfc7c" name="abb4e42accb00e5e59a3262c6624dfc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4e42accb00e5e59a3262c6624dfc7c">&#9670;&#160;</a></span>distinct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::distinct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns distinct elements from a sequence by using a specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; to compare values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The sequence to remove duplicate elements from. </td></tr>
    <tr><td class="paramname">comparer</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; to compare values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enumerable distinct elements from the source sequence. </dd></dl>

</div>
</div>
<a id="afcddc251cf8f945686a5f77807e62dcd" name="afcddc251cf8f945686a5f77807e62dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcddc251cf8f945686a5f77807e62dcd">&#9670;&#160;</a></span>first_or_default() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">source_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a2e52658d4876a5f7642288ef7cfd0be8" name="a2e52658d4876a5f7642288ef7cfd0be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e52658d4876a5f7642288ef7cfd0be8">&#9670;&#160;</a></span>first_or_default() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">source_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a2ba0a757b76c036ef644cec12662f887" name="a2ba0a757b76c036ef644cec12662f887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba0a757b76c036ef644cec12662f887">&#9670;&#160;</a></span>first_or_default() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">source_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const source_t</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a964948d137047014d18a7cc5db15f46f" name="a964948d137047014d18a7cc5db15f46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964948d137047014d18a7cc5db15f46f">&#9670;&#160;</a></span>first_or_default() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">source_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::first_or_default </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="abd9472d2fb32abc451658a9a49b1850a" name="abd9472d2fb32abc451658a9a49b1850a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9472d2fb32abc451658a9a49b1850a">&#9670;&#160;</a></span>order_by() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::order_by </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a sequence in ascending order according to a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_selector</td><td>A function to extract a key from an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use order_by&lt;key_t,âsource_t&gt;(ienumerable &lt;source_t&gt;,âstd::function&lt;key_t(const source_t&amp;)&gt;) to sort the elements of a sequence. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5cf1d21996e82ad730383c1c83f9d4f5" name="a5cf1d21996e82ad730383c1c83f9d4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf1d21996e82ad730383c1c83f9d4f5">&#9670;&#160;</a></span>order_by_descending() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class key_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::order_by_descending </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; key_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a sequence in descending order according to a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_selector</td><td>A function to extract a key from an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use order_by&lt;key_t,âsource_t&gt;(ienumerable &lt;source_t&gt;,âstd::function&lt;key_t(const source_t&amp;)&gt;) to sort the elements of a sequence. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab380ad6e3fcd5d1cad403eae4e5d9d56" name="ab380ad6e3fcd5d1cad403eae4e5d9d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab380ad6e3fcd5d1cad403eae4e5d9d56">&#9670;&#160;</a></span>order_by_descending() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::order_by_descending </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a sequence in descending order according to a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_selector</td><td>A function to extract a key from an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use order_by&lt;key_t,âsource_t&gt;(ienumerable &lt;source_t&gt;,âstd::function&lt;key_t(const source_t&amp;)&gt;) to sort the elements of a sequence. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a22dd17c4172c503636ef8c0b1954415f" name="a22dd17c4172c503636ef8c0b1954415f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dd17c4172c503636ef8c0b1954415f">&#9670;&#160;</a></span>order_by() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class key_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::order_by </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; key_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a sequence in ascending order according to a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_selector</td><td>A function to extract a key from an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use order_by&lt;key_t,âsource_t&gt;(ienumerable &lt;source_t&gt;,âstd::function&lt;key_t(const source_t&amp;)&gt;) to sort the elements of a sequence. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adf27a2adb67c1144bc20c98151c45639" name="adf27a2adb67c1144bc20c98151c45639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf27a2adb67c1144bc20c98151c45639">&#9670;&#160;</a></span>select() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class result_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0d5849798f7b5ae566dd5e7c175dfe3d" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac2388e79e9cf3b548edcbfd01c7fb606" name="ac2388e79e9cf3b548edcbfd01c7fb606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2388e79e9cf3b548edcbfd01c7fb606">&#9670;&#160;</a></span>select() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0d5849798f7b5ae566dd5e7c175dfe3d" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae72b6ac4c22f5ed599d5bcad4bcb8f51" name="ae72b6ac4c22f5ed599d5bcad4bcb8f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72b6ac4c22f5ed599d5bcad4bcb8f51">&#9670;&#160;</a></span>select() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<div class="memtemplate">
template&lt;class result_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, size_t index)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0d5849798f7b5ae566dd5e7c175dfe3d" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a057c689f8c51e80cbf49b14e8cad1b00" name="a057c689f8c51e80cbf49b14e8cad1b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057c689f8c51e80cbf49b14e8cad1b00">&#9670;&#160;</a></span>select() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, size_t index)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0d5849798f7b5ae566dd5e7c175dfe3d" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9186b87e4e781e16cfeca4d3e83ca6ba" name="a9186b87e4e781e16cfeca4d3e83ca6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9186b87e4e781e16cfeca4d3e83ca6ba">&#9670;&#160;</a></span>to_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a417e4adb1792949e9a54516bee2ca3d2">list</a>&lt; source_t &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::to_list </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a452f69ae6e7daea4c93977fc2ba8b044" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;size_t&gt;</a> lengths = fruits.select&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_function" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a> : lengths)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1list_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a></div><div class="ttdoc">Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...</div><div class="ttdef"><b>Definition</b> list.hpp:79</div></div>
<div class="ttc" id="anamespacextd_html_aa9cc6219bcf151f5a94b26a70ba8654b"><div class="ttname"><a href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">xtd::length</a></div><div class="ttdeci">constexpr size_type length() const noexcept</div><div class="ttdoc">Returns the length of the current read_only_span.</div><div class="ttdef"><b>Definition</b> read_only_span.hpp:229</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="accb58e81e7cbc4401a227fa23918fd3c" name="accb58e81e7cbc4401a227fa23918fd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb58e81e7cbc4401a227fa23918fd3c">&#9670;&#160;</a></span>where() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::where </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ac03a53b77498111f8869505458df9915" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.where([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2cebfce505a8ba369e428df6c5935491" name="a2cebfce505a8ba369e428df6c5935491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cebfce505a8ba369e428df6c5935491">&#9670;&#160;</a></span>where() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class enumerable_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable</a>&lt; enumerable_t, source_t &gt;::where </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ac03a53b77498111f8869505458df9915" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, size_t)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.where([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <a class="code hl_typedef" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">size</a> index) {</div>
<div class="line">    <span class="keywordflow">return</span> number &lt;= as&lt;int&gt;(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
<div class="ttc" id="agroup__types_html_ga221e5b824352c9046d353e4659af5b87"><div class="ttname"><a href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">Represents a size of any object in bytes.</div><div class="ttdef"><b>Definition</b> size.hpp:23</div></div>
<div class="ttc" id="agroup__xtd__core_html_gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df"><div class="ttname"><a href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">xtd::number_styles::number</a></div><div class="ttdeci">@ number</div><div class="ttdoc">Indicates that the allow_leading_white, allow_trailing_white, allow_leading_sign, allow_trailing_sign...</div><div class="ttdef"><b>Definition</b> number_styles.hpp:46</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/collections/generic/extensions/<a class="el" href="collections_2generic_2extensions_2enumerable_8hpp_source.html">enumerable.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 9 2025 21:04:26 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
