<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::mutex Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1mutex.html">mutex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1threading_1_1mutex-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::mutex Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::mutex:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1mutex.png" usemap="#xtd::threading::mutex_map" alt=""/>
  <map id="xtd::threading::mutex_map" name="xtd::threading::mutex_map">
<area href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources." alt="xtd::threading::wait_handle" shape="rect" coords="0,112,160,136"/>
<area href="classxtd_1_1icomparable.html" alt="xtd::icomparable&lt; mutex &gt;" shape="rect" coords="170,112,330,136"/>
<area href="classxtd_1_1iequatable.html" alt="xtd::iequatable&lt; mutex &gt;" shape="rect" coords="340,112,500,136"/>
<area href="classxtd_1_1abstract__object.html" title="Represent an abstract class." alt="xtd::abstract_object" shape="rect" coords="0,56,160,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="170,56,330,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="340,56,500,80"/>
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,160,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>A synchronization primitive that can also be used for interprocess synchronization. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1threading_1_1mutex.html">mutex</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a>, <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1icomparable.html">icomparable</a>&lt;mutex&gt;, <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1iequatable.html">xtd::iequatable</a>&lt;mutex&gt;</div>
<div class="ttc" id="aclassxtd_1_1icomparable_html"><div class="ttname"><a href="classxtd_1_1icomparable.html">xtd::icomparable</a></div><div class="ttdoc">Defines a generalized comparison method that a value type or class implements to create a type-specif...</div><div class="ttdef"><b>Definition</b> icomparable.h:17</div></div>
<div class="ttc" id="aclassxtd_1_1iequatable_html"><div class="ttname"><a href="classxtd_1_1iequatable.html">xtd::iequatable</a></div><div class="ttdoc">Defines a generalized method that a value type or class implements to create a type-specific method f...</div><div class="ttdef"><b>Definition</b> iequatable.h:18</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1mutex_html"><div class="ttname"><a href="classxtd_1_1threading_1_1mutex.html">xtd::threading::mutex</a></div><div class="ttdoc">A synchronization primitive that can also be used for interprocess synchronization.</div><div class="ttdef"><b>Definition</b> mutex.h:48</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1wait__handle_html"><div class="ttname"><a href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></div><div class="ttdoc">Encapsulates operating system specific objects that wait for exclusive access to shared resources.</div><div class="ttdef"><b>Definition</b> wait_handle.h:48</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/mutex&gt;</span> </div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource. <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> is a synchronization primitive that grants exclusive access to the shared resource to only one thread. If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex. </dd>
<dd>
You can use the <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87" title="Blocks the current thread until the current xtd::threading::wait_handle receives a signal.">xtd::threading::wait_handle::wait_one</a> method to request ownership of a mutex. The calling thread blocks until one of the following occurs:<ul>
<li>The mutex is signaled to indicate that it is not owned. When this happens, the <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87" title="Blocks the current thread until the current xtd::threading::wait_handle receives a signal.">xtd::threading::wait_handle::wait_one</a> method returns true, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex. When it has finished accessing the resource, the thread must call the <a class="el" href="classxtd_1_1threading_1_1mutex.html#a02f2e273ef08cdf7008087b9966de53d" title="Releases the Mutex once.">xtd::threading::mutex::release_mutex</a> method to release ownership of the mutex. The first example in the Examples section illustrates this pattern.</li>
<li>The time-out interval specified in the call to a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87" title="Blocks the current thread until the current xtd::threading::wait_handle receives a signal.">xtd::threading::wait_handle::wait_one</a> method that has a <pre class="fragment">milliseconds_timeout </pre> or timeout parameter has elapsed. When this happens, the <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87" title="Blocks the current thread until the current xtd::threading::wait_handle receives a signal.">xtd::threading::wait_handle::wait_one</a> method returns false, and the calling thread makes no further attempt to acquire ownership of the mutex. In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread. Because the thread never acquired ownership of the mutex, it must not call the <a class="el" href="classxtd_1_1threading_1_1mutex.html#a02f2e273ef08cdf7008087b9966de53d" title="Releases the Mutex once.">xtd::threading::mutex::release_mutex</a> method. The second example in the Examples section illustrates this pattern. </li>
</ul>
</dd>
<dd>
The <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class enforces thread identity, so a mutex can be released only by the thread that acquired it. By contrast, the <a class="el" href="classxtd_1_1threading_1_1semaphore.html" title="Limits the number of threads that can access a resource or pool of resources concurrently.">xtd::threading::semaphore</a> class does not enforce thread identity. A mutex can also be passed across application domain boundaries. </dd>
<dd>
The thread that owns a mutex can request the same mutex in repeated calls to <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87" title="Blocks the current thread until the current xtd::threading::wait_handle receives a signal.">xtd::threading::wait_handle::wait_one</a> without blocking its execution. However, the thread must call the <a class="el" href="classxtd_1_1threading_1_1mutex.html#a02f2e273ef08cdf7008087b9966de53d" title="Releases the Mutex once.">xtd::threading::mutex::release_mutex</a> method the same number of times to release ownership of the mutex. </dd>
<dd>
Because the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class inherits from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, you can also call the static <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a217129669f17b6f14201dccd0405450c" title="Waits for all the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_all</a> and <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a> methods to synchronize access to a protected resource. </dd>
<dd>
If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled, and the next waiting thread gets ownership. An <a class="el" href="classxtd_1_1threading_1_1abandoned__mutex__exception.html" title="The exception that is thrown when a Thread is in an invalid ThreadState for the method call.">xtd::threading::abandoned_mutex_exception</a> is thrown in the next thread that acquires the abandoned mutex. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). </dd>
<dd>
Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes. A local mutex exists only within your process. It can be used by any thread in your process that has a reference to the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> object that represents the mutex. Each unnamed <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> object represents a separate local mutex. </dd>
<dd>
Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create a <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> object that represents a named system mutex by using a constructor that accepts a name. The operating-system object can be created at the same time, or it can exist before the creation of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> object. You can create multiple <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> objects that represent the same named system mutex, and you can use the <a class="el" href="classxtd_1_1threading_1_1mutex.html#a7aac64a1e68fe54acedadb5c48061887" title="Opens an existing named mutex.">xtd::threading::mutex::open_existing</a> method to open an existing named system mutex. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The backslash () and slash(/) are a reserved character in a mutex name. Don't use a backslash () and slash (/) in a mutex name except as specified in the note on using mutexes in terminal server sessions. Otherwise, a <a class="el" href="classxtd_1_1io_1_1directory__not__found__exception.html" title="The exception that is thrown when part of a file or directory cannot be found.">xtd::io::directory_not_found_exception</a> may be thrown, even though the name of the mutex represents an existing file. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The unnamed mutex is a <a href="https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex">std::recursive_timed_mutex</a> of C++17. You can therefore use <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> or <a href="https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex">std::recursive_timed_mutex</a> indifferently in your projects. </dd>
<dd>
If you use other synchronization objects for your threads and you use <a class="el" href="classxtd_1_1threading_1_1thread.html" title="Creates and controls a thread, sets its priority, and gets its status.">xtd::threading::thread</a> you are interested in using <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a>. You will also benefit from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a217129669f17b6f14201dccd0405450c" title="Waits for all the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_all</a> and <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a> among others to synchronize all your objects. </dd>
<dd>
On the other hand, if you only use mutexes and you use <a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a> then you are interested in using <a href="https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex">std::recursive_timed_mutex</a>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>This example shows how a local <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> object is used to synchronize access to a protected resource. Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <a class="el" href="classxtd_1_1threading_1_1mutex.html#a02f2e273ef08cdf7008087b9966de53d" title="Releases the Mutex once.">xtd::threading::mutex::release_mutex</a> method to release ownership of the mutex. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/mutex&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/startup&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1threading.html">xtd::threading</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>mutex_example {</div>
<div class="line">  <span class="keyword">class </span>program {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">      <span class="comment">// Create the threads that will use the protected resource.</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> &lt; num_threads; ++<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>) {</div>
<div class="line">        threads.emplace_back(thread_proc);</div>
<div class="line">        threads.back().name(ustring::format(<span class="stringliteral">&quot;thread_{0}&quot;</span>, i + 1));</div>
<div class="line">        threads.back().start();</div>
<div class="line">      }</div>
<div class="line">      </div>
<div class="line">      thread::join_all(threads);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc() {</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keyword">auto</span> i = 0; <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a> &lt; num_iterations; ++<a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">i</a>)</div>
<div class="line">        Use_resource();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// This method represents a resource that must be synchronized</span></div>
<div class="line">    <span class="comment">// so that only one thread at a time can enter.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> Use_resource() {</div>
<div class="line">      <span class="comment">// Wait until it is safe to enter.</span></div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;{0} is requesting the mutex&quot;</span>,</div>
<div class="line">                        thread::current_thread().name());</div>
<div class="line">      mut.wait_one();</div>
<div class="line">      </div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;{0} has entered the protected area&quot;</span>,</div>
<div class="line">                          thread::current_thread().name());</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Place code to access non-reentrant resources here.</span></div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Simulate some work.</span></div>
<div class="line">      thread::sleep(500);</div>
<div class="line">      </div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;{0} is leaving the protected area&quot;</span>,</div>
<div class="line">                          thread::current_thread().name());</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Release the mutex.</span></div>
<div class="line">      mut.release_mutex();</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;{0} has released the mutex&quot;</span>,</div>
<div class="line">                          thread::current_thread().name());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> std::vector&lt;thread&gt; threads;</div>
<div class="line">    <span class="comment">// Create a new mutex. The creating thread does not own the mutex.</span></div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code hl_class" href="classxtd_1_1threading_1_1mutex.html">mutex</a> mut;</div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">int</span> num_iterations = 1;</div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">int</span> num_threads = 3;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(mutex_example::program::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example produces output similar to the following:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// thread_1 is requesting the mutex</span></div>
<div class="line"><span class="comment">// thread_1 has entered the protected area</span></div>
<div class="line"><span class="comment">// thread_2 is requesting the mutex</span></div>
<div class="line"><span class="comment">// thread_3 is requesting the mutex</span></div>
<div class="line"><span class="comment">// thread_1 is leaving the protected area</span></div>
<div class="line"><span class="comment">// thread_1 has released the mutex</span></div>
<div class="line"><span class="comment">// thread_2 has entered the protected area</span></div>
<div class="line"><span class="comment">// thread_2 is leaving the protected area</span></div>
<div class="line"><span class="comment">// thread_2 has released the mutex</span></div>
<div class="line"><span class="comment">// thread_3 has entered the protected area</span></div>
<div class="line"><span class="comment">// thread_3 is leaving the protected area</span></div>
<div class="line"><span class="comment">// thread_3 has released the mutex</span></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.h:162</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a865c0c0b4ab0e063e5caa3387c1a8741">xtd::console_key::i</a></div><div class="ttdeci">@ i</div><div class="ttdoc">The I key.</div></div>
<div class="ttc" id="anamespacextd_1_1threading_html"><div class="ttname"><a href="namespacextd_1_1threading.html">xtd::threading</a></div><div class="ttdoc">The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....</div><div class="ttdef"><b>Definition</b> abandoned_mutex_exception.h:10</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> system_report.h:17</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="mutex_8cpp-example.html#_a0">mutex.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Alias</h2></td></tr>
<tr class="memitem:a76d46795a5139906244351664dce7cc6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a76d46795a5139906244351664dce7cc6">native_handle_type</a> = <a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a></td></tr>
<tr class="memdesc:a76d46795a5139906244351664dce7cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rpresents the native handle type.  <br /></td></tr>
<tr class="separator:a76d46795a5139906244351664dce7cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors</h2></td></tr>
<tr class="memitem:aa7652ef5f76f63d3c267fd07210bbbfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#aa7652ef5f76f63d3c267fd07210bbbfd">mutex</a> ()</td></tr>
<tr class="memdesc:aa7652ef5f76f63d3c267fd07210bbbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with default properties.  <br /></td></tr>
<tr class="separator:aa7652ef5f76f63d3c267fd07210bbbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba0e062174dbacc0abf69a2b9c6c00a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a7ba0e062174dbacc0abf69a2b9c6c00a">mutex</a> (bool initially_owned)</td></tr>
<tr class="memdesc:a7ba0e062174dbacc0abf69a2b9c6c00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> with a bool value that indicates whether the calling thread should have initial ownership of the mutex.  <br /></td></tr>
<tr class="separator:a7ba0e062174dbacc0abf69a2b9c6c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf4bdf5b10f6793ec5e40d35d2b58aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#acdf4bdf5b10f6793ec5e40d35d2b58aa">mutex</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name)</td></tr>
<tr class="memdesc:acdf4bdf5b10f6793ec5e40d35d2b58aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with a string that is the name of the mutex.  <br /></td></tr>
<tr class="separator:acdf4bdf5b10f6793ec5e40d35d2b58aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5404ce2f3eeceeed8bae6290b81090a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a5404ce2f3eeceeed8bae6290b81090a5">mutex</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name, bool &amp;created_new)</td></tr>
<tr class="memdesc:a5404ce2f3eeceeed8bae6290b81090a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with a string that is the name of the mutex, and a bool value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.  <br /></td></tr>
<tr class="separator:a5404ce2f3eeceeed8bae6290b81090a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab772c061d636f24fa6b46f13255b5af5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#ab772c061d636f24fa6b46f13255b5af5">mutex</a> (bool initially_owned, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name)</td></tr>
<tr class="memdesc:ab772c061d636f24fa6b46f13255b5af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with a bool value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.  <br /></td></tr>
<tr class="separator:ab772c061d636f24fa6b46f13255b5af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c5b4625562ec463ff6b143a1c9bc0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a35c5b4625562ec463ff6b143a1c9bc0c">mutex</a> (bool initially_owned, const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name, bool &amp;created_new)</td></tr>
<tr class="memdesc:a35c5b4625562ec463ff6b143a1c9bc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with a bool value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a bool value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.  <br /></td></tr>
<tr class="separator:a35c5b4625562ec463ff6b143a1c9bc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Properties</h2></td></tr>
<tr class="memitem:aa4b414b099d21ce89c3dd9c6d9dd9793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#aa4b414b099d21ce89c3dd9c6d9dd9793">handle</a> () const noexcept override</td></tr>
<tr class="memdesc:aa4b414b099d21ce89c3dd9c6d9dd9793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the native operating system handle.  <br /></td></tr>
<tr class="separator:aa4b414b099d21ce89c3dd9c6d9dd9793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edfd2414178ff3f1e79ce4d29c8e972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a0edfd2414178ff3f1e79ce4d29c8e972">handle</a> (<a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a> value) override</td></tr>
<tr class="memdesc:a0edfd2414178ff3f1e79ce4d29c8e972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the native operating system handle.  <br /></td></tr>
<tr class="separator:a0edfd2414178ff3f1e79ce4d29c8e972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bd35dea959247ffd3f359c41b2d45b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a76d46795a5139906244351664dce7cc6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#ae9bd35dea959247ffd3f359c41b2d45b">native_handle</a> () const noexcept</td></tr>
<tr class="memdesc:ae9bd35dea959247ffd3f359c41b2d45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying implementation-defined native handle object.  <br /></td></tr>
<tr class="separator:ae9bd35dea959247ffd3f359c41b2d45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods</h2></td></tr>
<tr class="memitem:aad7c66ee04153877e8933cdcfa375043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#aad7c66ee04153877e8933cdcfa375043">close</a> () override</td></tr>
<tr class="memdesc:aad7c66ee04153877e8933cdcfa375043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all resources held by the current <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>.  <br /></td></tr>
<tr class="separator:aad7c66ee04153877e8933cdcfa375043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7bf412a6af20f33768a77951ad602b"><td class="memItemLeft" align="right" valign="top"><a id="a7a7bf412a6af20f33768a77951ad602b" name="a7a7bf412a6af20f33768a77951ad602b"></a>
<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compare_to</b> (const <a class="el" href="classxtd_1_1threading_1_1mutex.html">mutex</a> &amp;value) const noexcept override</td></tr>
<tr class="separator:a7a7bf412a6af20f33768a77951ad602b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e4bd839ebc7afe43be0c00fa47a438"><td class="memItemLeft" align="right" valign="top"><a id="af1e4bd839ebc7afe43be0c00fa47a438" name="af1e4bd839ebc7afe43be0c00fa47a438"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classxtd_1_1threading_1_1mutex.html">mutex</a> &amp;value) const noexcept override</td></tr>
<tr class="separator:af1e4bd839ebc7afe43be0c00fa47a438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddc38175a9924e96308d50a3b876f07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a6ddc38175a9924e96308d50a3b876f07">lock</a> ()</td></tr>
<tr class="memdesc:a6ddc38175a9924e96308d50a3b876f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution until the lock is acquired.  <br /></td></tr>
<tr class="separator:a6ddc38175a9924e96308d50a3b876f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f2e273ef08cdf7008087b9966de53d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a02f2e273ef08cdf7008087b9966de53d">release_mutex</a> ()</td></tr>
<tr class="memdesc:a02f2e273ef08cdf7008087b9966de53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the Mutex once.  <br /></td></tr>
<tr class="separator:a02f2e273ef08cdf7008087b9966de53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f2b2901ae223419bef4baed022caee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#af6f2b2901ae223419bef4baed022caee">try_lock</a> () noexcept</td></tr>
<tr class="memdesc:af6f2b2901ae223419bef4baed022caee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true, otherwise returns false.  <br /></td></tr>
<tr class="separator:af6f2b2901ae223419bef4baed022caee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91f77df7a9ecbdf7d7ff45874d76399"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#af91f77df7a9ecbdf7d7ff45874d76399">try_lock_for</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>) noexcept</td></tr>
<tr class="memdesc:af91f77df7a9ecbdf7d7ff45874d76399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to lock the mutex. Blocks until specified timeout_duration has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.  <br /></td></tr>
<tr class="separator:af91f77df7a9ecbdf7d7ff45874d76399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2486cf6791c2f805dab4682645ed64d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a2486cf6791c2f805dab4682645ed64d0">try_lock_until</a> (const <a class="el" href="classxtd_1_1date__time.html">date_time</a> &amp;timeout_time) noexcept</td></tr>
<tr class="memdesc:a2486cf6791c2f805dab4682645ed64d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to lock the mutex. Blocks until specified timeout_time has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.  <br /></td></tr>
<tr class="separator:a2486cf6791c2f805dab4682645ed64d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9adcf7d62eddfb67d3d6e079603c54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#acc9adcf7d62eddfb67d3d6e079603c54">unlock</a> ()</td></tr>
<tr class="memdesc:acc9adcf7d62eddfb67d3d6e079603c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the mutex.  <br /></td></tr>
<tr class="separator:acc9adcf7d62eddfb67d3d6e079603c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aac64a1e68fe54acedadb5c48061887"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1mutex.html">mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a7aac64a1e68fe54acedadb5c48061887">open_existing</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name)</td></tr>
<tr class="memdesc:a7aac64a1e68fe54acedadb5c48061887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing named mutex.  <br /></td></tr>
<tr class="separator:a7aac64a1e68fe54acedadb5c48061887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2e4f0cb974ca885b367bf2453be4f1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a1b2e4f0cb974ca885b367bf2453be4f1">try_open_existing</a> (const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;name, <a class="el" href="classxtd_1_1threading_1_1mutex.html">mutex</a> &amp;result) noexcept</td></tr>
<tr class="memdesc:a1b2e4f0cb974ca885b367bf2453be4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.  <br /></td></tr>
<tr class="separator:a1b2e4f0cb974ca885b367bf2453be4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Protected methods</h2></td></tr>
<tr class="memitem:a9fdaa8f872d88a427616d3a309b8bdb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a9fdaa8f872d88a427616d3a309b8bdb9">signal</a> () override</td></tr>
<tr class="memdesc:a9fdaa8f872d88a427616d3a309b8bdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases ownership of the specified <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">wait_handle</a> object.  <br /></td></tr>
<tr class="separator:a9fdaa8f872d88a427616d3a309b8bdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bb2824e6fda49dc1a7d843b269fcd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1mutex.html#ae9bb2824e6fda49dc1a7d843b269fcd4">wait</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout) override</td></tr>
<tr class="memdesc:ae9bb2824e6fda49dc1a7d843b269fcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait ownership of the specified mutex object.  <br /></td></tr>
<tr class="separator:ae9bb2824e6fda49dc1a7d843b269fcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classxtd_1_1threading_1_1wait__handle')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></td></tr>
<tr class="memitem:a1c98f88990d103ede2f1f9dcbed8956b inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a1c98f88990d103ede2f1f9dcbed8956b">invalid_handle</a></td></tr>
<tr class="memdesc:a1c98f88990d103ede2f1f9dcbed8956b inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an invalid native operating system handle. This field is read-only.  <br /></td></tr>
<tr class="separator:a1c98f88990d103ede2f1f9dcbed8956b inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cd044ea1e43ec86d62960d667ec67d inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a88cd044ea1e43ec86d62960d667ec67d">wait_timeout</a></td></tr>
<tr class="memdesc:a88cd044ea1e43ec86d62960d667ec67d inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a> operation timed out before any of the wait handles were signaled. This field is constant. @remrarks This field is one of the possible return values of <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35" title="Waits for any of the elements in the specified collection to receive a signal.">xtd::threading::wait_handle::wait_any</a>.  <br /></td></tr>
<tr class="separator:a88cd044ea1e43ec86d62960d667ec67d inherit pub_static_attribs_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1threading_1_1wait__handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1threading_1_1wait__handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></td></tr>
<tr class="memitem:a73af88726a64d8720c4075f540ff14da inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a73af88726a64d8720c4075f540ff14da">wait_handle</a> ()=default</td></tr>
<tr class="memdesc:a73af88726a64d8720c4075f540ff14da inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> class.  <br /></td></tr>
<tr class="separator:a73af88726a64d8720c4075f540ff14da inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53dcefc6844ecf0d6d9967ac489ac87 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ab53dcefc6844ecf0d6d9967ac489ac87">wait_one</a> ()</td></tr>
<tr class="memdesc:ab53dcefc6844ecf0d6d9967ac489ac87 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until the current <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> receives a signal.  <br /></td></tr>
<tr class="separator:ab53dcefc6844ecf0d6d9967ac489ac87 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65749b3c963772bef5440b1c8faca6ea inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a65749b3c963772bef5440b1c8faca6ea">wait_one</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a65749b3c963772bef5440b1c8faca6ea inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until the current <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> receives a signal, using 32-bit signed integer to measure the time interval.  <br /></td></tr>
<tr class="separator:a65749b3c963772bef5440b1c8faca6ea inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffdfd0f2f35f6768cb78bded574aa01 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a6ffdfd0f2f35f6768cb78bded574aa01">wait_one</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a6ffdfd0f2f35f6768cb78bded574aa01 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until the current instance receives a signal, using a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> to measure the time interval.  <br /></td></tr>
<tr class="separator:a6ffdfd0f2f35f6768cb78bded574aa01 inherit pub_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#aa8027c211754118c30ccf7e52557fd7a">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:aa8027c211754118c30ccf7e52557fd7a inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af734e36ea583a842339d7c4444fb6d86">memberwise_clone</a> () const noexcept</td></tr>
<tr class="memdesc:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:af734e36ea583a842339d7c4444fb6d86 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1ustring.html">xtd::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a5682215ee76ab97c48580ab162c49507">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sxd::ustring that represents the current object.  <br /></td></tr>
<tr class="separator:a5682215ee76ab97c48580ab162c49507 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1icomparable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1icomparable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1icomparable.html">xtd::icomparable&lt; mutex &gt;</a></td></tr>
<tr class="memitem:a8e5ad6ed9d798584e8b9be5749d6faa5 inherit pub_methods_classxtd_1_1icomparable"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1icomparable.html#a8e5ad6ed9d798584e8b9be5749d6faa5">compare_to</a> (const mutex &amp;obj) const noexcept=0</td></tr>
<tr class="memdesc:a8e5ad6ed9d798584e8b9be5749d6faa5 inherit pub_methods_classxtd_1_1icomparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current instance with another object of the same type.  <br /></td></tr>
<tr class="separator:a8e5ad6ed9d798584e8b9be5749d6faa5 inherit pub_methods_classxtd_1_1icomparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1iequatable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1iequatable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1iequatable.html">xtd::iequatable&lt; mutex &gt;</a></td></tr>
<tr class="memitem:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a> (const mutex &amp;) const noexcept=0</td></tr>
<tr class="memdesc:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current object is equal to another object of the same type.  <br /></td></tr>
<tr class="separator:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1threading_1_1wait__handle')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></td></tr>
<tr class="memitem:a01c82b06ca8a5d14aba5f1fb396c16f7 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a01c82b06ca8a5d14aba5f1fb396c16f7">signal_and_wait</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_signal, <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_wait)</td></tr>
<tr class="memdesc:a01c82b06ca8a5d14aba5f1fb396c16f7 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals one <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> and waits on another.  <br /></td></tr>
<tr class="separator:a01c82b06ca8a5d14aba5f1fb396c16f7 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aebea15b640d53b04a97306515768d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a83aebea15b640d53b04a97306515768d">signal_and_wait</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_signal, <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_wait, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a83aebea15b640d53b04a97306515768d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals one <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> and waits on another, specifying a time-out interval as a 32-bit signed integer.  <br /></td></tr>
<tr class="separator:a83aebea15b640d53b04a97306515768d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2056ee81b21f23f6b0a7bd7f3bc232e8 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a2056ee81b21f23f6b0a7bd7f3bc232e8">signal_and_wait</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_signal, <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;to_wait, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a2056ee81b21f23f6b0a7bd7f3bc232e8 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals one <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> and waits on another, specifying a time-out interval as a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">time_span</a>.  <br /></td></tr>
<tr class="separator:a2056ee81b21f23f6b0a7bd7f3bc232e8 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217129669f17b6f14201dccd0405450c inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a217129669f17b6f14201dccd0405450c inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a217129669f17b6f14201dccd0405450c">wait_all</a> (const collection_t &amp;wait_handles)</td></tr>
<tr class="memdesc:a217129669f17b6f14201dccd0405450c inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the elements in the specified collection to receive a signal.  <br /></td></tr>
<tr class="separator:a217129669f17b6f14201dccd0405450c inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa977d4e62fe9fd5cc7c57cd4eb58f2 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a8aa977d4e62fe9fd5cc7c57cd4eb58f2 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a8aa977d4e62fe9fd5cc7c57cd4eb58f2">wait_all</a> (const collection_t &amp;wait_handles, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a8aa977d4e62fe9fd5cc7c57cd4eb58f2 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the elements in the specified collection to receive a signal, using an int32 value to measure the time interval.  <br /></td></tr>
<tr class="separator:a8aa977d4e62fe9fd5cc7c57cd4eb58f2 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda61f20a00dfc9a8b0f125edc9e8aa6 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:aeda61f20a00dfc9a8b0f125edc9e8aa6 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aeda61f20a00dfc9a8b0f125edc9e8aa6">wait_all</a> (const collection_t &amp;wait_handles, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:aeda61f20a00dfc9a8b0f125edc9e8aa6 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the elements in the specified collection to receive a signal, using a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> value to measure the time interval.  <br /></td></tr>
<tr class="separator:aeda61f20a00dfc9a8b0f125edc9e8aa6 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2a73d9052723690ff0e15a338cce35 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:aee2a73d9052723690ff0e15a338cce35 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#aee2a73d9052723690ff0e15a338cce35">wait_any</a> (const collection_t &amp;wait_handles)</td></tr>
<tr class="memdesc:aee2a73d9052723690ff0e15a338cce35 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for any of the elements in the specified collection to receive a signal.  <br /></td></tr>
<tr class="separator:aee2a73d9052723690ff0e15a338cce35 inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1275f297e0dbddbf302edf0cd2a37d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a5b1275f297e0dbddbf302edf0cd2a37d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a5b1275f297e0dbddbf302edf0cd2a37d">wait_any</a> (const collection_t &amp;wait_handles, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a5b1275f297e0dbddbf302edf0cd2a37d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for any of the elements in the specified collection to receive a signal, using a 32-bit signed integer to measure the time interval.  <br /></td></tr>
<tr class="separator:a5b1275f297e0dbddbf302edf0cd2a37d inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa704be64592eed6531ec3953bb9897e inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:afa704be64592eed6531ec3953bb9897e inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html#afa704be64592eed6531ec3953bb9897e">wait_any</a> (const collection_t &amp;wait_handles, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:afa704be64592eed6531ec3953bb9897e inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for any of the elements in the specified collection to receive a signal, using a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> to measure the time interval.  <br /></td></tr>
<tr class="separator:afa704be64592eed6531ec3953bb9897e inherit pub_static_methods_classxtd_1_1threading_1_1wait__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a75cb9ed56172fb088ca6697d5d836b13">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a75cb9ed56172fb088ca6697d5d836b13 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1ee13700465eead7934f450749b952d7">reference_equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_a, const <a class="el" href="classxtd_1_1object.html">object</a> &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a1ee13700465eead7934f450749b952d7 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classxtd_1_1threading_1_1wait__handle"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classxtd_1_1threading_1_1wait__handle')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html">xtd::threading::wait_handle</a></td></tr>
<tr class="inherit_header pro_methods_classxtd_1_1abstract__object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classxtd_1_1abstract__object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classxtd_1_1abstract__object.html">xtd::abstract_object</a></td></tr>
<tr class="memitem:ad7a701628e47b725c0bc15400085d714 inherit pro_methods_classxtd_1_1abstract__object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1abstract__object.html#ad7a701628e47b725c0bc15400085d714">abstract_object</a> ()=default</td></tr>
<tr class="memdesc:ad7a701628e47b725c0bc15400085d714 inherit pro_methods_classxtd_1_1abstract__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1abstract__object.html" title="Represent an abstract class.">xtd::abstract_object</a> class.  <br /></td></tr>
<tr class="separator:ad7a701628e47b725c0bc15400085d714 inherit pro_methods_classxtd_1_1abstract__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a76d46795a5139906244351664dce7cc6" name="a76d46795a5139906244351664dce7cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d46795a5139906244351664dce7cc6">&#9670;&#160;</a></span>native_handle_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1threading_1_1mutex.html#a76d46795a5139906244351664dce7cc6">xtd::threading::mutex::native_handle_type</a> =  <a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rpresents the native handle type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa7652ef5f76f63d3c267fd07210bbbfd" name="aa7652ef5f76f63d3c267fd07210bbbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7652ef5f76f63d3c267fd07210bbbfd">&#9670;&#160;</a></span>mutex() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::mutex::mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with default properties. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Calling this constructor overload is the same as calling the <a class="el" href="classxtd_1_1threading_1_1mutex.html#a7ba0e062174dbacc0abf69a2b9c6c00a" title="Initializes a new instance of the xtd::threading::mutex with a bool value that indicates whether the ...">xtd::threading::mutex::mutex(bool)</a> constructor overload and specifying false for initial ownership of the mutex. That is, the calling thread does not own the mutex. </dd></dl>

</div>
</div>
<a id="a7ba0e062174dbacc0abf69a2b9c6c00a" name="a7ba0e062174dbacc0abf69a2b9c6c00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba0e062174dbacc0abf69a2b9c6c00a">&#9670;&#160;</a></span>mutex() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::mutex::mutex </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initially_owned</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> with a bool value that indicates whether the calling thread should have initial ownership of the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initially_owned</td><td>true to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdf4bdf5b10f6793ec5e40d35d2b58aa" name="acdf4bdf5b10f6793ec5e40d35d2b58aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf4bdf5b10f6793ec5e40d35d2b58aa">&#9670;&#160;</a></span>mutex() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::mutex::mutex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with a string that is the name of the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, an empty string. The name is case-sensitive. The backslash character () and slsh (/) are reserved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::io::io_xception</td><td>name is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes "Global\" and "Local" are case-sensitive.<br  />
-or-<br  />
There was some other error. The HResult property may provide more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The initially owned is set to flase. </dd></dl>

</div>
</div>
<a id="a5404ce2f3eeceeed8bae6290b81090a5" name="a5404ce2f3eeceeed8bae6290b81090a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5404ce2f3eeceeed8bae6290b81090a5">&#9670;&#160;</a></span>mutex() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::mutex::mutex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>created_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with a string that is the name of the mutex, and a bool value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, an empty string. The name is case-sensitive. The backslash character () and slsh (/) are reserved. </td></tr>
    <tr><td class="paramname">created_new</td><td>When this method returns, contains a bool that is true if a local mutex was created (that is, if name is empty string) or if the specified named system mutex was created; false if the specified named system mutex already existed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::io::io_xception</td><td>name is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes "Global\" and "Local" are case-sensitive.<br  />
-or-<br  />
There was some other error. The HResult property may provide more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The initially owned is set to flase. </dd></dl>

</div>
</div>
<a id="ab772c061d636f24fa6b46f13255b5af5" name="ab772c061d636f24fa6b46f13255b5af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab772c061d636f24fa6b46f13255b5af5">&#9670;&#160;</a></span>mutex() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::mutex::mutex </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initially_owned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with a bool value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initially_owned</td><td>true to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, false. </td></tr>
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, an empty string. The name is case-sensitive. The backslash character () and slsh (/) are reserved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::io::io_xception</td><td>name is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes "Global\" and "Local" are case-sensitive.<br  />
-or-<br  />
There was some other error. The HResult property may provide more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35c5b4625562ec463ff6b143a1c9bc0c" name="a35c5b4625562ec463ff6b143a1c9bc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c5b4625562ec463ff6b143a1c9bc0c">&#9670;&#160;</a></span>mutex() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::mutex::mutex </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initially_owned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>created_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> class with a bool value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a bool value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initially_owned</td><td>true to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, false. </td></tr>
    <tr><td class="paramname">name</td><td>The name, if the synchronization object is to be shared with other processes; otherwise, an empty string. The name is case-sensitive. The backslash character () and slsh (/) are reserved. </td></tr>
    <tr><td class="paramname">created_new</td><td>When this method returns, contains a bool that is true if a local mutex was created (that is, if name is empty string) or if the specified named system mutex was created; false if the specified named system mutex already existed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::io::io_xception</td><td>name is invalid. This can be for various reasons, including some restrictions that may be placed by the operating system, such as an unknown prefix or invalid characters. Note that the name and common prefixes "Global\" and "Local" are case-sensitive.<br  />
-or-<br  />
There was some other error. The HResult property may provide more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aad7c66ee04153877e8933cdcfa375043" name="aad7c66ee04153877e8933cdcfa375043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7c66ee04153877e8933cdcfa375043">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::mutex::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases all resources held by the current <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You to call this method in the destructor of the inherited class. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a177d4ddb89f80c3932de535af29e7c76">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<a id="aa4b414b099d21ce89c3dd9c6d9dd9793" name="aa4b414b099d21ce89c3dd9c6d9dd9793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b414b099d21ce89c3dd9c6d9dd9793">&#9670;&#160;</a></span>handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a> xtd::threading::mutex::handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the native operating system handle. </p>
<dl class="section return"><dt>Returns</dt><dd>An intptr representing the native operating system handle. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ac6ea513628eed434543d706fb69c144c">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<a id="a0edfd2414178ff3f1e79ce4d29c8e972" name="a0edfd2414178ff3f1e79ce4d29c8e972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edfd2414178ff3f1e79ce4d29c8e972">&#9670;&#160;</a></span>handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::mutex::handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gaa7283e1dd31c385d954467f7ea324451">intptr</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the native operating system handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An intptr representing the native operating system handle. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a1ae25cca055cc110953d333475ef5c3f">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<a id="a6ddc38175a9924e96308d50a3b876f07" name="a6ddc38175a9924e96308d50a3b876f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddc38175a9924e96308d50a3b876f07">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::mutex::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution until the lock is acquired. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If lock is called by a thread that already owns the mutex, the behavior is undefined: for example, the program may deadlock. An implementation that can detect the invalid usage is encouraged to throw a std::system_error with error condition resource_deadlock_would_occur instead of deadlocking. </dd>
<dd>
Prior <a class="el" href="classxtd_1_1threading_1_1mutex.html#acc9adcf7d62eddfb67d3d6e079603c54" title="Unlocks the mutex.">unlock()</a> operations on the same mutex synchronize-with (as defined in std::memory_order) this operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classxtd_1_1threading_1_1mutex.html#a6ddc38175a9924e96308d50a3b876f07" title="Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution ...">xtd::threading::mutex::lock()</a> is usually not called directly: std::unique_lock, std::scoped_lock, and std::lock_guard are used to manage exclusive locking. </dd></dl>

</div>
</div>
<a id="ae9bd35dea959247ffd3f359c41b2d45b" name="ae9bd35dea959247ffd3f359c41b2d45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bd35dea959247ffd3f359c41b2d45b">&#9670;&#160;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1threading_1_1mutex.html#a76d46795a5139906244351664dce7cc6">native_handle_type</a> xtd::threading::mutex::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying implementation-defined native handle object. </p>
<dl class="section return"><dt>Returns</dt><dd>Implementation-defined native handle object. </dd></dl>

</div>
</div>
<a id="a7aac64a1e68fe54acedadb5c48061887" name="a7aac64a1e68fe54acedadb5c48061887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aac64a1e68fe54acedadb5c48061887">&#9670;&#160;</a></span>open_existing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1mutex.html">mutex</a> xtd::threading::mutex::open_existing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing named mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of a system-wide named mutex object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> object that represents a named system mutex. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>is a zero-length string <br  />
-or-<br  />
 name is longer than 128 characters </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1io_1_1io__exception.html" title="The exception that is thrown when an I/O error occurs.">xtd::io::io_exception</a></td><td>An Io error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02f2e273ef08cdf7008087b9966de53d" name="a02f2e273ef08cdf7008087b9966de53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f2e273ef08cdf7008087b9966de53d">&#9670;&#160;</a></span>release_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::mutex::release_mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the Mutex once. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1object__closed__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::object_closed_exception</a></td><td>the handle is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fdaa8f872d88a427616d3a309b8bdb9" name="a9fdaa8f872d88a427616d3a309b8bdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdaa8f872d88a427616d3a309b8bdb9">&#9670;&#160;</a></span>signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::mutex::signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases ownership of the specified <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">wait_handle</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>true If the function succeeds, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Override this function for all derived object </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#ae3323e1eb8bc5686e88c8eb54d93e2c8">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<a id="af6f2b2901ae223419bef4baed022caee" name="af6f2b2901ae223419bef4baed022caee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f2b2901ae223419bef4baed022caee">&#9670;&#160;</a></span>try_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::mutex::try_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true, otherwise returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>timeout A <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> that represents the number of milliseconds to wait, or a <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> that represents -1 milliseconds to wait indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lock was acquired successfully, otherwise false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is allowed to fail spuriously and return false even if the mutex is not currently locked by any other thread. </dd>
<dd>
If try_lock is called by a thread that already owns the mutex, the behavior is undefined. </dd>
<dd>
Prior <a class="el" href="classxtd_1_1threading_1_1mutex.html#acc9adcf7d62eddfb67d3d6e079603c54" title="Unlocks the mutex.">unlock()</a> operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true. Note that prior <a class="el" href="classxtd_1_1threading_1_1mutex.html#a6ddc38175a9924e96308d50a3b876f07" title="Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution ...">lock()</a> does not synchronize with this operation if it returns false. </dd></dl>

</div>
</div>
<a id="af91f77df7a9ecbdf7d7ff45874d76399" name="af91f77df7a9ecbdf7d7ff45874d76399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91f77df7a9ecbdf7d7ff45874d76399">&#9670;&#160;</a></span>try_lock_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::mutex::try_lock_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to lock the mutex. Blocks until specified timeout_duration has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>minimum duration to block for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lock was acquired successfully, otherwise false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If timeout_duration is less or equal timeout_duration.zero(), the function behaves like <a class="el" href="classxtd_1_1threading_1_1mutex.html#af6f2b2901ae223419bef4baed022caee" title="Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true,...">try_lock()</a>. </dd>
<dd>
This function may block for longer than timeout_duration due to scheduling or resource contention delays. </dd>
<dd>
The standard recommends that a steady_clock is used to measure the duration. If an implementation uses a system_clock instead, the wait time may also be sensitive to clock adjustments. </dd>
<dd>
As with <a class="el" href="classxtd_1_1threading_1_1mutex.html#af6f2b2901ae223419bef4baed022caee" title="Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true,...">try_lock()</a>, this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point during timeout_duration. </dd>
<dd>
Prior <a class="el" href="classxtd_1_1threading_1_1mutex.html#acc9adcf7d62eddfb67d3d6e079603c54" title="Unlocks the mutex.">unlock()</a> operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true. </dd>
<dd>
If try_lock_for is called by a thread that already owns the mutex, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a2486cf6791c2f805dab4682645ed64d0" name="a2486cf6791c2f805dab4682645ed64d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2486cf6791c2f805dab4682645ed64d0">&#9670;&#160;</a></span>try_lock_until()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::mutex::try_lock_until </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1date__time.html">date_time</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to lock the mutex. Blocks until specified timeout_time has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>maximum time point to block until </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lock was acquired successfully, otherwise false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If timeout_time has already passed, this function behaves like <a class="el" href="classxtd_1_1threading_1_1mutex.html#af6f2b2901ae223419bef4baed022caee" title="Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true,...">try_lock()</a>. </dd>
<dd>
Clock must meet the Clock requirements. The program is ill-formed if std::chrono::is_clock_v&lt;Clock&gt; is false (since C++20). </dd>
<dd>
The standard recommends that the clock tied to timeout_time be used, in which case adjustments of the clock may be taken into account. Thus, the duration of the block might be more or less than timeout_time - Clock::now() at the time of the call, depending on the direction of the adjustment and whether it is honored by the implementation. The function also may block until after timeout_time has been reached due to process scheduling or resource contention delays. </dd>
<dd>
As with <a class="el" href="classxtd_1_1threading_1_1mutex.html#af6f2b2901ae223419bef4baed022caee" title="Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true,...">try_lock()</a>, this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point before timeout_time. </dd>
<dd>
Prior <a class="el" href="classxtd_1_1threading_1_1mutex.html#acc9adcf7d62eddfb67d3d6e079603c54" title="Unlocks the mutex.">unlock()</a> operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true. </dd>
<dd>
If try_lock_until is called by a thread that already owns the mutex, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a1b2e4f0cb974ca885b367bf2453be4f1" name="a1b2e4f0cb974ca885b367bf2453be4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2e4f0cb974ca885b367bf2453be4f1">&#9670;&#160;</a></span>try_open_existing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::mutex::try_open_existing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1ustring.html">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1threading_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the synchronization object to be shared with other processes. The name is case-sensitive. The backslash character () and (/) are reserved. </td></tr>
    <tr><td class="paramname">result</td><td>When this method returns, contains a <a class="el" href="classxtd_1_1threading_1_1mutex.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::mutex</a> object that represents the named mutex if the call succeeded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the named mutex was opened successfully; otherwise, false. In some cases, false may be returned for invalid names. </dd></dl>

</div>
</div>
<a id="acc9adcf7d62eddfb67d3d6e079603c54" name="acc9adcf7d62eddfb67d3d6e079603c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9adcf7d62eddfb67d3d6e079603c54">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::mutex::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks the mutex. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined. </dd>
<dd>
This operation synchronizes-with (as defined in std::memory_order) any subsequent lock operation that obtains ownership of the same mutex. </dd>
<dd>
<a class="el" href="classxtd_1_1threading_1_1mutex.html#acc9adcf7d62eddfb67d3d6e079603c54" title="Unlocks the mutex.">xtd::threading::mutex::unlock()</a> is usually not called directly: std::unique_lock and std::lock_guard are used to manage exclusive locking. </dd></dl>

</div>
</div>
<a id="ae9bb2824e6fda49dc1a7d843b269fcd4" name="ae9bb2824e6fda49dc1a7d843b269fcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bb2824e6fda49dc1a7d843b269fcd4">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::mutex::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wait ownership of the specified mutex object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A valid handle to an open object. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait, or -1 to wait indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the current instance receives a signal; otherwise, false. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If milliseconds_timeout is zero, the method does not block. It tests the state of the wait handle and returns immediately. </dd>
<dd>
Override this function for all derived object </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1threading_1_1wait__handle.html#a9bb413f1c6bf14c9a514896f972dd35b">xtd::threading::wait_handle</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="mutex_8h_source.html">mutex.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 8 2024 21:22:01 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
