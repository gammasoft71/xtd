<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::linq::enumerable Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1linq.html">linq</a></li><li class="navelem"><a class="el" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1linq_1_1enumerable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::linq::enumerable Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__linq.html">linq</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::linq::enumerable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1linq_1_1enumerable.png" usemap="#xtd::linq::enumerable_map" alt=""/>
  <map id="xtd::linq::enumerable_map" name="xtd::linq::enumerable_map">
<area href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted)." alt="xtd::static_object" shape="rect" coords="0,0,125,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_t&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1static__object.html">xtd::static_object</a>;</div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html">xtd::linq::enumerable</a></div><div class="ttdoc">Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:48</div></div>
<div class="ttc" id="aclassxtd_1_1static__object_html"><div class="ttname"><a href="classxtd_1_1static__object.html">xtd::static_object</a></div><div class="ttdoc">Represent a static object. A static class can't be instantiated (constructors are deleted).</div><div class="ttdef"><b>Definition</b> static.hpp:20</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1linq.html" title="Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).">xtd::linq</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:a9b93549961bf64c99497c5f00f2d0850"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a9b93549961bf64c99497c5f00f2d0850"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a9b93549961bf64c99497c5f00f2d0850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a9b93549961bf64c99497c5f00f2d0850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe98058d15812a559f8be3da5df32f3b"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:abe98058d15812a559f8be3da5df32f3b"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#abe98058d15812a559f8be3da5df32f3b">aggregate</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:abe98058d15812a559f8be3da5df32f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:abe98058d15812a559f8be3da5df32f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154f1aff8fafef647831bc9554c9b48d"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a154f1aff8fafef647831bc9554c9b48d"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a154f1aff8fafef647831bc9554c9b48d">aggregate</a> (const collection_t &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a154f1aff8fafef647831bc9554c9b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a154f1aff8fafef647831bc9554c9b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5e27b4f583424d1e482fff52e132f0"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5e5e27b4f583424d1e482fff52e132f0"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5e5e27b4f583424d1e482fff52e132f0">aggregate</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a5e5e27b4f583424d1e482fff52e132f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a5e5e27b4f583424d1e482fff52e132f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30589beb45024a839978c362e81da5a9"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename func_t &gt; </td></tr>
<tr class="memitem:a30589beb45024a839978c362e81da5a9"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a30589beb45024a839978c362e81da5a9">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a30589beb45024a839978c362e81da5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a30589beb45024a839978c362e81da5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a099b2454f8e21f24dbbaabe02920"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename func_t &gt; </td></tr>
<tr class="memitem:a486a099b2454f8e21f24dbbaabe02920"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a486a099b2454f8e21f24dbbaabe02920">aggregate</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a486a099b2454f8e21f24dbbaabe02920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a486a099b2454f8e21f24dbbaabe02920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename func_t &gt; </td></tr>
<tr class="memitem:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab6acc19f96c13e626d8fc69d7bfc14c5">aggregate</a> (const collection_t &amp;source, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda77ef769372aed4db74698b6173d74"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename func_t &gt; </td></tr>
<tr class="memitem:adda77ef769372aed4db74698b6173d74"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#adda77ef769372aed4db74698b6173d74">aggregate</a> (input_iterator_t first, input_iterator_t last, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:adda77ef769372aed4db74698b6173d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:adda77ef769372aed4db74698b6173d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3340ab0fa239b6fdb872931d7515b457"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t &gt; </td></tr>
<tr class="memitem:a3340ab0fa239b6fdb872931d7515b457"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3340ab0fa239b6fdb872931d7515b457">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a3340ab0fa239b6fdb872931d7515b457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a3340ab0fa239b6fdb872931d7515b457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf60bcfdb39219adf2dc7a06e11ed02b"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t &gt; </td></tr>
<tr class="memitem:aaf60bcfdb39219adf2dc7a06e11ed02b"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aaf60bcfdb39219adf2dc7a06e11ed02b">aggregate</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:aaf60bcfdb39219adf2dc7a06e11ed02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:aaf60bcfdb39219adf2dc7a06e11ed02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename collection_t &gt; </td></tr>
<tr class="memitem:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab1bdd7a08b78efc2a7debbb7f69a7e02">aggregate</a> (const collection_t &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46b4f242688699339f4b391055a6e72"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ab46b4f242688699339f4b391055a6e72"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab46b4f242688699339f4b391055a6e72">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab46b4f242688699339f4b391055a6e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ab46b4f242688699339f4b391055a6e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a2e351b94c0f26c7ee776cf501e3c5"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename func_t &gt; </td></tr>
<tr class="memitem:a19a2e351b94c0f26c7ee776cf501e3c5"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a19a2e351b94c0f26c7ee776cf501e3c5">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a19a2e351b94c0f26c7ee776cf501e3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a19a2e351b94c0f26c7ee776cf501e3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0d88bae5dea4ff57a629a874aaf9c9"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename func_t &gt; </td></tr>
<tr class="memitem:a3f0d88bae5dea4ff57a629a874aaf9c9"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3f0d88bae5dea4ff57a629a874aaf9c9">aggregate</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a3f0d88bae5dea4ff57a629a874aaf9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a3f0d88bae5dea4ff57a629a874aaf9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f264b52a622ec32100c5a9ade3500c"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename collection_t , typename func_t &gt; </td></tr>
<tr class="memitem:a50f264b52a622ec32100c5a9ade3500c"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a50f264b52a622ec32100c5a9ade3500c">aggregate</a> (const collection_t &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a50f264b52a622ec32100c5a9ade3500c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a50f264b52a622ec32100c5a9ade3500c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7e4b4e77fe80020fafce9b60441061"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename input_iterator_t , typename func_t &gt; </td></tr>
<tr class="memitem:a3b7e4b4e77fe80020fafce9b60441061"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3b7e4b4e77fe80020fafce9b60441061">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a3b7e4b4e77fe80020fafce9b60441061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a3b7e4b4e77fe80020fafce9b60441061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bfe5c433036b8a3435984e84a879d0"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t &gt; </td></tr>
<tr class="memitem:aa3bfe5c433036b8a3435984e84a879d0"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa3bfe5c433036b8a3435984e84a879d0">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:aa3bfe5c433036b8a3435984e84a879d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:aa3bfe5c433036b8a3435984e84a879d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5fac97ce4ed32fae2389ca8bd6f039"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t &gt; </td></tr>
<tr class="memitem:acb5fac97ce4ed32fae2389ca8bd6f039"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#acb5fac97ce4ed32fae2389ca8bd6f039">aggregate</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:acb5fac97ce4ed32fae2389ca8bd6f039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:acb5fac97ce4ed32fae2389ca8bd6f039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc1c09dd640d49cf46e47315353ed18"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t , typename collection_t &gt; </td></tr>
<tr class="memitem:aadc1c09dd640d49cf46e47315353ed18"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aadc1c09dd640d49cf46e47315353ed18">aggregate</a> (const collection_t &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:aadc1c09dd640d49cf46e47315353ed18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:aadc1c09dd640d49cf46e47315353ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86311e56c9cda909d08cdabdcf472b5"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ab86311e56c9cda909d08cdabdcf472b5"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab86311e56c9cda909d08cdabdcf472b5">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:ab86311e56c9cda909d08cdabdcf472b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:ab86311e56c9cda909d08cdabdcf472b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8165ca22a410944137c96611dd9372c9"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a8165ca22a410944137c96611dd9372c9"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8165ca22a410944137c96611dd9372c9">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a8165ca22a410944137c96611dd9372c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a8165ca22a410944137c96611dd9372c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669f7014e913a93da252d43ef79c8c5d"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a669f7014e913a93da252d43ef79c8c5d"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a669f7014e913a93da252d43ef79c8c5d">aggregate</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a669f7014e913a93da252d43ef79c8c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a669f7014e913a93da252d43ef79c8c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6e9be709bf0d6bfb742135409e193c"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename result_t , typename collection_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a1b6e9be709bf0d6bfb742135409e193c"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a1b6e9be709bf0d6bfb742135409e193c">aggregate</a> (const collection_t &amp;collection, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a1b6e9be709bf0d6bfb742135409e193c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a1b6e9be709bf0d6bfb742135409e193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1fb529106403a96744a6f0e409179c"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename result_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a2f1fb529106403a96744a6f0e409179c"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2f1fb529106403a96744a6f0e409179c">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a2f1fb529106403a96744a6f0e409179c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a2f1fb529106403a96744a6f0e409179c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a119ff990e2b66cf2f6e9767a5d2828"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a8a119ff990e2b66cf2f6e9767a5d2828"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8a119ff990e2b66cf2f6e9767a5d2828">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a8a119ff990e2b66cf2f6e9767a5d2828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a8a119ff990e2b66cf2f6e9767a5d2828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdb88934befdaed37829882eaadd797"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:aefdb88934befdaed37829882eaadd797"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aefdb88934befdaed37829882eaadd797">aggregate</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:aefdb88934befdaed37829882eaadd797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:aefdb88934befdaed37829882eaadd797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3218c9c234c742982c4d85953286b9"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename collection_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a0d3218c9c234c742982c4d85953286b9"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0d3218c9c234c742982c4d85953286b9">aggregate</a> (const collection_t &amp;collection, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a0d3218c9c234c742982c4d85953286b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a0d3218c9c234c742982c4d85953286b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2f7ca162d5d735492ed63bc2d1f076fd">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400685e150fbc23f95103aec6038e0da"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a400685e150fbc23f95103aec6038e0da"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da">all</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a400685e150fbc23f95103aec6038e0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a400685e150fbc23f95103aec6038e0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea91e6e4f3bed614d28d5b30457714c"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a9ea91e6e4f3bed614d28d5b30457714c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9ea91e6e4f3bed614d28d5b30457714c">all</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a9ea91e6e4f3bed614d28d5b30457714c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a9ea91e6e4f3bed614d28d5b30457714c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d2b50122ac7429831299a556be7efa"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:af5d2b50122ac7429831299a556be7efa"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af5d2b50122ac7429831299a556be7efa">all</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:af5d2b50122ac7429831299a556be7efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:af5d2b50122ac7429831299a556be7efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8fd7b35aaebdbea8331a5aaeea8cad9c">all</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefce790cf7adf0d0c20ca7a74049c569"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:aefce790cf7adf0d0c20ca7a74049c569"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aefce790cf7adf0d0c20ca7a74049c569">all</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:aefce790cf7adf0d0c20ca7a74049c569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aefce790cf7adf0d0c20ca7a74049c569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10d530295951578e15a956cb1ad0d13"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:aa10d530295951578e15a956cb1ad0d13"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa10d530295951578e15a956cb1ad0d13">all</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:aa10d530295951578e15a956cb1ad0d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aa10d530295951578e15a956cb1ad0d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ec7f29327dfa3a235e192a697f88b7"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:ab5ec7f29327dfa3a235e192a697f88b7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab5ec7f29327dfa3a235e192a697f88b7">all</a> (const collection_t &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ab5ec7f29327dfa3a235e192a697f88b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:ab5ec7f29327dfa3a235e192a697f88b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3bca3810844c7f42e4bb3f09c1b3820b">all</a> (input_iterator_t first, input_iterator_t last, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c3f84b83d0dad286c73c7b045a40c"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:aca7c3f84b83d0dad286c73c7b045a40c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aca7c3f84b83d0dad286c73c7b045a40c">any</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:aca7c3f84b83d0dad286c73c7b045a40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:aca7c3f84b83d0dad286c73c7b045a40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d821ea84a7020c6dfe783a6974655c5"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a7d821ea84a7020c6dfe783a6974655c5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a7d821ea84a7020c6dfe783a6974655c5">any</a> (const std::initializer_list&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a7d821ea84a7020c6dfe783a6974655c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a7d821ea84a7020c6dfe783a6974655c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa5fca6b9d7bc049f1eef56457c17a2bf">any</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5200b0bf55e0d4ca3bd76e300b34a3ca">any</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa60ed473f8fad23f5890e348879599"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a2fa60ed473f8fad23f5890e348879599"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2fa60ed473f8fad23f5890e348879599">any</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a2fa60ed473f8fad23f5890e348879599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a2fa60ed473f8fad23f5890e348879599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b6725cee172b85da265823ff80d09e"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ae3b6725cee172b85da265823ff80d09e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae3b6725cee172b85da265823ff80d09e">any</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ae3b6725cee172b85da265823ff80d09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:ae3b6725cee172b85da265823ff80d09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2270a08fffe2f4cce7944d2a77e21202"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a2270a08fffe2f4cce7944d2a77e21202"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2270a08fffe2f4cce7944d2a77e21202">any</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a2270a08fffe2f4cce7944d2a77e21202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a2270a08fffe2f4cce7944d2a77e21202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5f332f87f28c6c9ea9e7df729ed3d3b7">any</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d4d24a49cba2174fea98b2e45f15d1"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:aa5d4d24a49cba2174fea98b2e45f15d1"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa5d4d24a49cba2174fea98b2e45f15d1">any</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:aa5d4d24a49cba2174fea98b2e45f15d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aa5d4d24a49cba2174fea98b2e45f15d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf6ff6617b38dc9496ecac90282768d"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a5cf6ff6617b38dc9496ecac90282768d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5cf6ff6617b38dc9496ecac90282768d">any</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a5cf6ff6617b38dc9496ecac90282768d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a5cf6ff6617b38dc9496ecac90282768d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782315b34c17c5bebb5e00277a8fe0c3"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a782315b34c17c5bebb5e00277a8fe0c3"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a782315b34c17c5bebb5e00277a8fe0c3">any</a> (const collection_t &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a782315b34c17c5bebb5e00277a8fe0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a782315b34c17c5bebb5e00277a8fe0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b3479936dce019d229f63ae01b51c5"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:ad4b3479936dce019d229f63ae01b51c5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ad4b3479936dce019d229f63ae01b51c5">any</a> (input_iterator_t first, input_iterator_t last, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ad4b3479936dce019d229f63ae01b51c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:ad4b3479936dce019d229f63ae01b51c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf22bf866179b4de2e4272eabff559a0"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:adf22bf866179b4de2e4272eabff559a0"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">append</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:adf22bf866179b4de2e4272eabff559a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:adf22bf866179b4de2e4272eabff559a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecb4005cf51493e0b9ae25e7b24c19c"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a4ecb4005cf51493e0b9ae25e7b24c19c"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ecb4005cf51493e0b9ae25e7b24c19c">append</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:a4ecb4005cf51493e0b9ae25e7b24c19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a4ecb4005cf51493e0b9ae25e7b24c19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8263fc7e8283eef962407c4313cc4a7"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:ac8263fc7e8283eef962407c4313cc4a7"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ac8263fc7e8283eef962407c4313cc4a7">append</a> (const collection_t &amp;source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:ac8263fc7e8283eef962407c4313cc4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:ac8263fc7e8283eef962407c4313cc4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be188acb4bb748b0112589c342e8423"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a0be188acb4bb748b0112589c342e8423"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0be188acb4bb748b0112589c342e8423">append</a> (input_iterator_t first, input_iterator_t last, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:a0be188acb4bb748b0112589c342e8423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a0be188acb4bb748b0112589c342e8423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d172ff89909b3d3e27cf4c91116177"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a25d172ff89909b3d3e27cf4c91116177"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a25d172ff89909b3d3e27cf4c91116177">as_enumerable</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a25d172ff89909b3d3e27cf4c91116177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a25d172ff89909b3d3e27cf4c91116177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb53ce6fab643cbe01dcb3925c698af"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a5bb53ce6fab643cbe01dcb3925c698af"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5bb53ce6fab643cbe01dcb3925c698af">as_enumerable</a> (const std::initializer_list&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a5bb53ce6fab643cbe01dcb3925c698af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a5bb53ce6fab643cbe01dcb3925c698af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90ec21b4abacec8eb0e29071f8efc97"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:af90ec21b4abacec8eb0e29071f8efc97"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af90ec21b4abacec8eb0e29071f8efc97">as_enumerable</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:af90ec21b4abacec8eb0e29071f8efc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:af90ec21b4abacec8eb0e29071f8efc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9518817b1581ae817e402b740bbb1f"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a0a9518817b1581ae817e402b740bbb1f"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0a9518817b1581ae817e402b740bbb1f">as_enumerable</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a0a9518817b1581ae817e402b740bbb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a0a9518817b1581ae817e402b740bbb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637ef7b9fc2bb6c501901d6d2eea0349"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a637ef7b9fc2bb6c501901d6d2eea0349">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a637ef7b9fc2bb6c501901d6d2eea0349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values.  <br /></td></tr>
<tr class="separator:a637ef7b9fc2bb6c501901d6d2eea0349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1981940673117d7d1a07bfadc4cd807e"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a1981940673117d7d1a07bfadc4cd807e">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; double &gt; &amp;source)</td></tr>
<tr class="memdesc:a1981940673117d7d1a07bfadc4cd807e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of double values.  <br /></td></tr>
<tr class="separator:a1981940673117d7d1a07bfadc4cd807e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d48767f0f4a494a6a2796ab1e5c00"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a7b7d48767f0f4a494a6a2796ab1e5c00">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; float &gt; &amp;source)</td></tr>
<tr class="memdesc:a7b7d48767f0f4a494a6a2796ab1e5c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of float values.  <br /></td></tr>
<tr class="separator:a7b7d48767f0f4a494a6a2796ab1e5c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dc3877d6633a433380dbc69feaae25"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a64dc3877d6633a433380dbc69feaae25">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a64dc3877d6633a433380dbc69feaae25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values.  <br /></td></tr>
<tr class="separator:a64dc3877d6633a433380dbc69feaae25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180145af875f8afdd754a57912662d7b"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a180145af875f8afdd754a57912662d7b">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a180145af875f8afdd754a57912662d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values.  <br /></td></tr>
<tr class="separator:a180145af875f8afdd754a57912662d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e5bd4af93fd8b03d1ff9fb30b9da39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a48e5bd4af93fd8b03d1ff9fb30b9da39">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a48e5bd4af93fd8b03d1ff9fb30b9da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values.  <br /></td></tr>
<tr class="separator:a48e5bd4af93fd8b03d1ff9fb30b9da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fcb0557ee8c42fbf6906e481478b73"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a43fcb0557ee8c42fbf6906e481478b73">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a43fcb0557ee8c42fbf6906e481478b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional double values.  <br /></td></tr>
<tr class="separator:a43fcb0557ee8c42fbf6906e481478b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813a36db751d09ea896190063c987b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ad813a36db751d09ea896190063c987b9">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ad813a36db751d09ea896190063c987b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional float values.  <br /></td></tr>
<tr class="separator:ad813a36db751d09ea896190063c987b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11950bd1bc11a3e69ca92dd960ccaa83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a11950bd1bc11a3e69ca92dd960ccaa83">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a11950bd1bc11a3e69ca92dd960ccaa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values.  <br /></td></tr>
<tr class="separator:a11950bd1bc11a3e69ca92dd960ccaa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df923caaf850458512e70dd985df80d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9df923caaf850458512e70dd985df80d">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a9df923caaf850458512e70dd985df80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values.  <br /></td></tr>
<tr class="separator:a9df923caaf850458512e70dd985df80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77239b8123b06e5f2d088fb74500995"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ab77239b8123b06e5f2d088fb74500995"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab77239b8123b06e5f2d088fb74500995">first_or_default</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:ab77239b8123b06e5f2d088fb74500995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ab77239b8123b06e5f2d088fb74500995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e0e9badb3b2fb329a9504b838c7be"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a1b5e0e9badb3b2fb329a9504b838c7be"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a1b5e0e9badb3b2fb329a9504b838c7be">first_or_default</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:a1b5e0e9badb3b2fb329a9504b838c7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a1b5e0e9badb3b2fb329a9504b838c7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ebabc65a26f263c61c446dbef009b3"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:ae6ebabc65a26f263c61c446dbef009b3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae6ebabc65a26f263c61c446dbef009b3">first_or_default</a> (const collection_t &amp;source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:ae6ebabc65a26f263c61c446dbef009b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ae6ebabc65a26f263c61c446dbef009b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71c11e30879c9af8531c855b5eb8088"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ae71c11e30879c9af8531c855b5eb8088"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae71c11e30879c9af8531c855b5eb8088">first_or_default</a> (input_iterator_t first, input_iterator_t last, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:ae71c11e30879c9af8531c855b5eb8088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ae71c11e30879c9af8531c855b5eb8088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15732619b209ff177c90ad91b1a4bd3"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ab15732619b209ff177c90ad91b1a4bd3"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab15732619b209ff177c90ad91b1a4bd3">first_or_default</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ab15732619b209ff177c90ad91b1a4bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ab15732619b209ff177c90ad91b1a4bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1847ab0e3c969d868e81e84809beedec"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a1847ab0e3c969d868e81e84809beedec"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a1847ab0e3c969d868e81e84809beedec">first_or_default</a> (const std::initializer_list&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a1847ab0e3c969d868e81e84809beedec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a1847ab0e3c969d868e81e84809beedec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0922997a0fda313f2c308ece6841ac"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a0e0922997a0fda313f2c308ece6841ac"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0e0922997a0fda313f2c308ece6841ac">first_or_default</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:a0e0922997a0fda313f2c308ece6841ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a0e0922997a0fda313f2c308ece6841ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8ef9173ba49b6d1ce79a2aa72d5d781a">first_or_default</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad0f9812852378c4ed08a50f39396cd"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2ad0f9812852378c4ed08a50f39396cd">range</a> (<a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> start, <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> count)</td></tr>
<tr class="memdesc:a2ad0f9812852378c4ed08a50f39396cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of integral numbers within a specified range.  <br /></td></tr>
<tr class="separator:a2ad0f9812852378c4ed08a50f39396cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2df9541f109773859bcaaf42015b8cd"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t &gt; </td></tr>
<tr class="memitem:ae2df9541f109773859bcaaf42015b8cd"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd">select</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:ae2df9541f109773859bcaaf42015b8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:ae2df9541f109773859bcaaf42015b8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ed748289d607a75c7cadd7d44438e7"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t &gt; </td></tr>
<tr class="memitem:a83ed748289d607a75c7cadd7d44438e7"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a83ed748289d607a75c7cadd7d44438e7">select</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a83ed748289d607a75c7cadd7d44438e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a83ed748289d607a75c7cadd7d44438e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cff7768a676655cf4e501cf207ba994"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a8cff7768a676655cf4e501cf207ba994"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8cff7768a676655cf4e501cf207ba994">select</a> (const collection_t &amp;source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a8cff7768a676655cf4e501cf207ba994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a8cff7768a676655cf4e501cf207ba994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3159d59161a1a74114d24e228f4bf5"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a2d3159d59161a1a74114d24e228f4bf5"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2d3159d59161a1a74114d24e228f4bf5">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a2d3159d59161a1a74114d24e228f4bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a2d3159d59161a1a74114d24e228f4bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c7e6501518fc4f9fffdfc3f9938569"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t , typename selector_t &gt; </td></tr>
<tr class="memitem:a85c7e6501518fc4f9fffdfc3f9938569"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a85c7e6501518fc4f9fffdfc3f9938569">select</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const selector_t &amp;selector)</td></tr>
<tr class="memdesc:a85c7e6501518fc4f9fffdfc3f9938569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a85c7e6501518fc4f9fffdfc3f9938569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4f8fbb6607356fb5e477dac9c649ef"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t , typename selector_t &gt; </td></tr>
<tr class="memitem:ade4f8fbb6607356fb5e477dac9c649ef"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade4f8fbb6607356fb5e477dac9c649ef">select</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const selector_t &amp;selector)</td></tr>
<tr class="memdesc:ade4f8fbb6607356fb5e477dac9c649ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:ade4f8fbb6607356fb5e477dac9c649ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99da5af6cddca634225d163aa10c62d"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename collection_t , typename selector_t &gt; </td></tr>
<tr class="memitem:ab99da5af6cddca634225d163aa10c62d"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab99da5af6cddca634225d163aa10c62d">select</a> (const collection_t &amp;source, const selector_t &amp;selector)</td></tr>
<tr class="memdesc:ab99da5af6cddca634225d163aa10c62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:ab99da5af6cddca634225d163aa10c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addae5520d1a61675e56e3884c930f0df"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename input_iterator_t , typename selector_t &gt; </td></tr>
<tr class="memitem:addae5520d1a61675e56e3884c930f0df"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#addae5520d1a61675e56e3884c930f0df">select</a> (input_iterator_t first, input_iterator_t last, const selector_t &amp;selector)</td></tr>
<tr class="memdesc:addae5520d1a61675e56e3884c930f0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:addae5520d1a61675e56e3884c930f0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f003a07c40e6e294a3f0a7112b928a"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a18f003a07c40e6e294a3f0a7112b928a"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a18f003a07c40e6e294a3f0a7112b928a">select</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a18f003a07c40e6e294a3f0a7112b928a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a18f003a07c40e6e294a3f0a7112b928a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcb14aeb0d0b46693e2ae6f0da5822e"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a7dcb14aeb0d0b46693e2ae6f0da5822e"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a7dcb14aeb0d0b46693e2ae6f0da5822e">select</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a7dcb14aeb0d0b46693e2ae6f0da5822e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a7dcb14aeb0d0b46693e2ae6f0da5822e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e0db840e15ea8213f3f3bdf8e4f037"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a87e0db840e15ea8213f3f3bdf8e4f037"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a87e0db840e15ea8213f3f3bdf8e4f037">select</a> (const collection_t &amp;source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a87e0db840e15ea8213f3f3bdf8e4f037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a87e0db840e15ea8213f3f3bdf8e4f037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67de3d7bedf4a2b37263f3f8c80dd23b"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a67de3d7bedf4a2b37263f3f8c80dd23b"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a67de3d7bedf4a2b37263f3f8c80dd23b">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a67de3d7bedf4a2b37263f3f8c80dd23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a67de3d7bedf4a2b37263f3f8c80dd23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3c2720e70eef7092b4bce8b8369dc7"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename selector_t &gt; </td></tr>
<tr class="memitem:a3a3c2720e70eef7092b4bce8b8369dc7"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3a3c2720e70eef7092b4bce8b8369dc7">select</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const selector_t &amp;selector)</td></tr>
<tr class="memdesc:a3a3c2720e70eef7092b4bce8b8369dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a3a3c2720e70eef7092b4bce8b8369dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9e68ed442244553973d42ab8dbf244"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename selector_t &gt; </td></tr>
<tr class="memitem:aaf9e68ed442244553973d42ab8dbf244"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aaf9e68ed442244553973d42ab8dbf244">select</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const selector_t &amp;selector)</td></tr>
<tr class="memdesc:aaf9e68ed442244553973d42ab8dbf244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:aaf9e68ed442244553973d42ab8dbf244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7725606d2b6f446b3dc3fba8ebfc4bc9"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename selector_t &gt; </td></tr>
<tr class="memitem:a7725606d2b6f446b3dc3fba8ebfc4bc9"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a7725606d2b6f446b3dc3fba8ebfc4bc9">select</a> (const collection_t &amp;source, const selector_t &amp;selector)</td></tr>
<tr class="memdesc:a7725606d2b6f446b3dc3fba8ebfc4bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a7725606d2b6f446b3dc3fba8ebfc4bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87785914520f41f313f3359e4a1cdf11"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename selector_t &gt; </td></tr>
<tr class="memitem:a87785914520f41f313f3359e4a1cdf11"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a87785914520f41f313f3359e4a1cdf11">select</a> (input_iterator_t first, input_iterator_t last, const selector_t &amp;selector)</td></tr>
<tr class="memdesc:a87785914520f41f313f3359e4a1cdf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a87785914520f41f313f3359e4a1cdf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4632879fe4e92c640c0382e32de2967"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ae4632879fe4e92c640c0382e32de2967"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967">to_list</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ae4632879fe4e92c640c0382e32de2967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ae4632879fe4e92c640c0382e32de2967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f37bb872c6ae514e52c00d5183a50c7"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a2f37bb872c6ae514e52c00d5183a50c7"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2f37bb872c6ae514e52c00d5183a50c7">to_list</a> (const std::initializer_list&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a2f37bb872c6ae514e52c00d5183a50c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an std::initializer_list &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a2f37bb872c6ae514e52c00d5183a50c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56d7345bb6c56ad7b55b25518e84ae1"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:af56d7345bb6c56ad7b55b25518e84ae1"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af56d7345bb6c56ad7b55b25518e84ae1">to_list</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:af56d7345bb6c56ad7b55b25518e84ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an collection_t.  <br /></td></tr>
<tr class="separator:af56d7345bb6c56ad7b55b25518e84ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4c298b0cc2654d7b726859f52f4341"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a3c4c298b0cc2654d7b726859f52f4341"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3c4c298b0cc2654d7b726859f52f4341">to_list</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a3c4c298b0cc2654d7b726859f52f4341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from iterators.  <br /></td></tr>
<tr class="separator:a3c4c298b0cc2654d7b726859f52f4341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade645587ccb269b8b05c4325989639be"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ade645587ccb269b8b05c4325989639be"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be">where</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ade645587ccb269b8b05c4325989639be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:ade645587ccb269b8b05c4325989639be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f5a1f6bde5387aa529acf9ad510fd4"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ab4f5a1f6bde5387aa529acf9ad510fd4"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab4f5a1f6bde5387aa529acf9ad510fd4">where</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ab4f5a1f6bde5387aa529acf9ad510fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:ab4f5a1f6bde5387aa529acf9ad510fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b767d8dec90302a51169029c37ba82d"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a8b767d8dec90302a51169029c37ba82d"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8b767d8dec90302a51169029c37ba82d">where</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a8b767d8dec90302a51169029c37ba82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a8b767d8dec90302a51169029c37ba82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daeaea8dafaa306901966cb1bcfcbc8"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a0daeaea8dafaa306901966cb1bcfcbc8"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0daeaea8dafaa306901966cb1bcfcbc8">where</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a0daeaea8dafaa306901966cb1bcfcbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a0daeaea8dafaa306901966cb1bcfcbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331f4ee242797bf6153cabbe14245143"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a331f4ee242797bf6153cabbe14245143"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a331f4ee242797bf6153cabbe14245143">where</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a331f4ee242797bf6153cabbe14245143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a331f4ee242797bf6153cabbe14245143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc47a682d6e3439a3b101c2127d10873"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:adc47a682d6e3439a3b101c2127d10873"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#adc47a682d6e3439a3b101c2127d10873">where</a> (const std::initializer_list&lt; source_t &gt; &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:adc47a682d6e3439a3b101c2127d10873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:adc47a682d6e3439a3b101c2127d10873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb0a5a4c4e600c6eff4c62b7829c274"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a4cb0a5a4c4e600c6eff4c62b7829c274"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4cb0a5a4c4e600c6eff4c62b7829c274">where</a> (const collection_t &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a4cb0a5a4c4e600c6eff4c62b7829c274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a4cb0a5a4c4e600c6eff4c62b7829c274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c0e3f162b8dcdc719edea9065aed7a"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a21c0e3f162b8dcdc719edea9065aed7a"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a21c0e3f162b8dcdc719edea9065aed7a">where</a> (input_iterator_t first, input_iterator_t last, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a21c0e3f162b8dcdc719edea9065aed7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a21c0e3f162b8dcdc719edea9065aed7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b93549961bf64c99497c5f00f2d0850" name="a9b93549961bf64c99497c5f00f2d0850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b93549961bf64c99497c5f00f2d0850">&#9670;&#160;</a></span>aggregate() <span class="overload">[1/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.hpp:10</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abe98058d15812a559f8be3da5df32f3b" name="abe98058d15812a559f8be3da5df32f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe98058d15812a559f8be3da5df32f3b">&#9670;&#160;</a></span>aggregate() <span class="overload">[2/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a154f1aff8fafef647831bc9554c9b48d" name="a154f1aff8fafef647831bc9554c9b48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154f1aff8fafef647831bc9554c9b48d">&#9670;&#160;</a></span>aggregate() <span class="overload">[3/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5e5e27b4f583424d1e482fff52e132f0" name="a5e5e27b4f583424d1e482fff52e132f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5e27b4f583424d1e482fff52e132f0">&#9670;&#160;</a></span>aggregate() <span class="overload">[4/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = enumerable::aggregate&lt;string&gt;(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    return next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
<div class="ttc" id="anamespacextd_1_1linq_html"><div class="ttname"><a href="namespacextd_1_1linq.html">xtd::linq</a></div><div class="ttdoc">Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).</div><div class="ttdef"><b>Definition</b> enumerable.hpp:27</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a30589beb45024a839978c362e81da5a9" name="a30589beb45024a839978c362e81da5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30589beb45024a839978c362e81da5a9">&#9670;&#160;</a></span>aggregate() <span class="overload">[5/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a486a099b2454f8e21f24dbbaabe02920" name="a486a099b2454f8e21f24dbbaabe02920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486a099b2454f8e21f24dbbaabe02920">&#9670;&#160;</a></span>aggregate() <span class="overload">[6/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab6acc19f96c13e626d8fc69d7bfc14c5" name="ab6acc19f96c13e626d8fc69d7bfc14c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6acc19f96c13e626d8fc69d7bfc14c5">&#9670;&#160;</a></span>aggregate() <span class="overload">[7/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adda77ef769372aed4db74698b6173d74" name="adda77ef769372aed4db74698b6173d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda77ef769372aed4db74698b6173d74">&#9670;&#160;</a></span>aggregate() <span class="overload">[8/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = enumerable::aggregate&lt;string&gt;(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    return next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3340ab0fa239b6fdb872931d7515b457" name="a3340ab0fa239b6fdb872931d7515b457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3340ab0fa239b6fdb872931d7515b457">&#9670;&#160;</a></span>aggregate() <span class="overload">[9/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
<div class="ttc" id="aclassxtd_1_1array_html"><div class="ttname"><a href="classxtd_1_1array.html">xtd::array</a></div><div class="ttdoc">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...</div><div class="ttdef"><b>Definition</b> array.hpp:58</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a22f3540f62b3b6140ecf188faf509842"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">xtd::collections::generic::extensions::enumerable::aggregate</a></div><div class="ttdeci">source_t aggregate(const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;func) const</div><div class="ttdoc">Applies an accumulator function over a sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:42</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aaf60bcfdb39219adf2dc7a06e11ed02b" name="aaf60bcfdb39219adf2dc7a06e11ed02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf60bcfdb39219adf2dc7a06e11ed02b">&#9670;&#160;</a></span>aggregate() <span class="overload">[10/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab1bdd7a08b78efc2a7debbb7f69a7e02" name="ab1bdd7a08b78efc2a7debbb7f69a7e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bdd7a08b78efc2a7debbb7f69a7e02">&#9670;&#160;</a></span>aggregate() <span class="overload">[11/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab46b4f242688699339f4b391055a6e72" name="ab46b4f242688699339f4b391055a6e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46b4f242688699339f4b391055a6e72">&#9670;&#160;</a></span>aggregate() <span class="overload">[12/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_a9b93549961bf64c99497c5f00f2d0850"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">xtd::linq::enumerable::aggregate</a></div><div class="ttdeci">static source_t aggregate(const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;func)</div><div class="ttdoc">Applies an accumulator function over a sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:61</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a19a2e351b94c0f26c7ee776cf501e3c5" name="a19a2e351b94c0f26c7ee776cf501e3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a2e351b94c0f26c7ee776cf501e3c5">&#9670;&#160;</a></span>aggregate() <span class="overload">[13/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3f0d88bae5dea4ff57a629a874aaf9c9" name="a3f0d88bae5dea4ff57a629a874aaf9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0d88bae5dea4ff57a629a874aaf9c9">&#9670;&#160;</a></span>aggregate() <span class="overload">[14/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a50f264b52a622ec32100c5a9ade3500c" name="a50f264b52a622ec32100c5a9ade3500c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f264b52a622ec32100c5a9ade3500c">&#9670;&#160;</a></span>aggregate() <span class="overload">[15/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename collection_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3b7e4b4e77fe80020fafce9b60441061" name="a3b7e4b4e77fe80020fafce9b60441061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7e4b4e77fe80020fafce9b60441061">&#9670;&#160;</a></span>aggregate() <span class="overload">[16/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename input_iterator_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa3bfe5c433036b8a3435984e84a879d0" name="aa3bfe5c433036b8a3435984e84a879d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bfe5c433036b8a3435984e84a879d0">&#9670;&#160;</a></span>aggregate() <span class="overload">[17/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_a4cc6be7fa93346c34256fb76e6dc4b3a"><div class="ttname"><a href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">xtd::basic_string::to_upper</a></div><div class="ttdeci">basic_string to_upper() const noexcept</div><div class="ttdoc">Returns a copy of the current xtd::basic_string converted to uppercase.</div><div class="ttdef"><b>Definition</b> basic_string.hpp:1953</div></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_aabfeb876a8fb51c80fa9adaa3663f232"><div class="ttname"><a href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">xtd::basic_string::length</a></div><div class="ttdeci">size_type length() const noexcept</div><div class="ttdoc">Gets the number of characters in the current xtd::basic_string object.</div><div class="ttdef"><b>Definition</b> basic_string.hpp:918</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acb5fac97ce4ed32fae2389ca8bd6f039" name="acb5fac97ce4ed32fae2389ca8bd6f039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5fac97ce4ed32fae2389ca8bd6f039">&#9670;&#160;</a></span>aggregate() <span class="overload">[18/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aadc1c09dd640d49cf46e47315353ed18" name="aadc1c09dd640d49cf46e47315353ed18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc1c09dd640d49cf46e47315353ed18">&#9670;&#160;</a></span>aggregate() <span class="overload">[19/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab86311e56c9cda909d08cdabdcf472b5" name="ab86311e56c9cda909d08cdabdcf472b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86311e56c9cda909d08cdabdcf472b5">&#9670;&#160;</a></span>aggregate() <span class="overload">[20/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8165ca22a410944137c96611dd9372c9" name="a8165ca22a410944137c96611dd9372c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8165ca22a410944137c96611dd9372c9">&#9670;&#160;</a></span>aggregate() <span class="overload">[21/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a669f7014e913a93da252d43ef79c8c5d" name="a669f7014e913a93da252d43ef79c8c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669f7014e913a93da252d43ef79c8c5d">&#9670;&#160;</a></span>aggregate() <span class="overload">[22/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1b6e9be709bf0d6bfb742135409e193c" name="a1b6e9be709bf0d6bfb742135409e193c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6e9be709bf0d6bfb742135409e193c">&#9670;&#160;</a></span>aggregate() <span class="overload">[23/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename result_t , typename collection_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2f1fb529106403a96744a6f0e409179c" name="a2f1fb529106403a96744a6f0e409179c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1fb529106403a96744a6f0e409179c">&#9670;&#160;</a></span>aggregate() <span class="overload">[24/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename result_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8a119ff990e2b66cf2f6e9767a5d2828" name="a8a119ff990e2b66cf2f6e9767a5d2828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a119ff990e2b66cf2f6e9767a5d2828">&#9670;&#160;</a></span>aggregate() <span class="overload">[25/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aefdb88934befdaed37829882eaadd797" name="aefdb88934befdaed37829882eaadd797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdb88934befdaed37829882eaadd797">&#9670;&#160;</a></span>aggregate() <span class="overload">[26/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0d3218c9c234c742982c4d85953286b9" name="a0d3218c9c234c742982c4d85953286b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3218c9c234c742982c4d85953286b9">&#9670;&#160;</a></span>aggregate() <span class="overload">[27/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename collection_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2f7ca162d5d735492ed63bc2d1f076fd" name="a2f7ca162d5d735492ed63bc2d1f076fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7ca162d5d735492ed63bc2d1f076fd">&#9670;&#160;</a></span>aggregate() <span class="overload">[28/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a400685e150fbc23f95103aec6038e0da" name="a400685e150fbc23f95103aec6038e0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400685e150fbc23f95103aec6038e0da">&#9670;&#160;</a></span>all() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a8c344a4319826da54bae2611d78f7e41"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">xtd::collections::generic::extensions::enumerable::all</a></div><div class="ttdeci">bool all(const std::function&lt; bool(const source_t &amp;)&gt; &amp;predicate) const</div><div class="ttdoc">Determines whether all elements of a sequence satisfy a condition.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:120</div></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:42</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9ea91e6e4f3bed614d28d5b30457714c" name="a9ea91e6e4f3bed614d28d5b30457714c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea91e6e4f3bed614d28d5b30457714c">&#9670;&#160;</a></span>all() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af5d2b50122ac7429831299a556be7efa" name="af5d2b50122ac7429831299a556be7efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d2b50122ac7429831299a556be7efa">&#9670;&#160;</a></span>all() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8fd7b35aaebdbea8331a5aaeea8cad9c" name="a8fd7b35aaebdbea8331a5aaeea8cad9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd7b35aaebdbea8331a5aaeea8cad9c">&#9670;&#160;</a></span>all() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aefce790cf7adf0d0c20ca7a74049c569" name="aefce790cf7adf0d0c20ca7a74049c569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefce790cf7adf0d0c20ca7a74049c569">&#9670;&#160;</a></span>all() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa10d530295951578e15a956cb1ad0d13" name="aa10d530295951578e15a956cb1ad0d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10d530295951578e15a956cb1ad0d13">&#9670;&#160;</a></span>all() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab5ec7f29327dfa3a235e192a697f88b7" name="ab5ec7f29327dfa3a235e192a697f88b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ec7f29327dfa3a235e192a697f88b7">&#9670;&#160;</a></span>all() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3bca3810844c7f42e4bb3f09c1b3820b" name="a3bca3810844c7f42e4bb3f09c1b3820b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bca3810844c7f42e4bb3f09c1b3820b">&#9670;&#160;</a></span>all() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = enumerable::all&lt;pet&gt;(pets.begin(), pets.end(), [](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    return pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aca7c3f84b83d0dad286c73c7b045a40c" name="aca7c3f84b83d0dad286c73c7b045a40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7c3f84b83d0dad286c73c7b045a40c">&#9670;&#160;</a></span>any() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to check for emptiness. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7d821ea84a7020c6dfe783a6974655c5" name="a7d821ea84a7020c6dfe783a6974655c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d821ea84a7020c6dfe783a6974655c5">&#9670;&#160;</a></span>any() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to check for emptiness. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa5fca6b9d7bc049f1eef56457c17a2bf" name="aa5fca6b9d7bc049f1eef56457c17a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fca6b9d7bc049f1eef56457c17a2bf">&#9670;&#160;</a></span>any() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The collection_t to check for emptiness. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5200b0bf55e0d4ca3bd76e300b34a3ca" name="a5200b0bf55e0d4ca3bd76e300b34a3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5200b0bf55e0d4ca3bd76e300b34a3ca">&#9670;&#160;</a></span>any() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2fa60ed473f8fad23f5890e348879599" name="a2fa60ed473f8fad23f5890e348879599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa60ed473f8fad23f5890e348879599">&#9670;&#160;</a></span>any() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae3b6725cee172b85da265823ff80d09e" name="ae3b6725cee172b85da265823ff80d09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b6725cee172b85da265823ff80d09e">&#9670;&#160;</a></span>any() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2270a08fffe2f4cce7944d2a77e21202" name="a2270a08fffe2f4cce7944d2a77e21202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2270a08fffe2f4cce7944d2a77e21202">&#9670;&#160;</a></span>any() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5f332f87f28c6c9ea9e7df729ed3d3b7" name="a5f332f87f28c6c9ea9e7df729ed3d3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f332f87f28c6c9ea9e7df729ed3d3b7">&#9670;&#160;</a></span>any() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa5d4d24a49cba2174fea98b2e45f15d1" name="aa5d4d24a49cba2174fea98b2e45f15d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d4d24a49cba2174fea98b2e45f15d1">&#9670;&#160;</a></span>any() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5cf6ff6617b38dc9496ecac90282768d" name="a5cf6ff6617b38dc9496ecac90282768d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf6ff6617b38dc9496ecac90282768d">&#9670;&#160;</a></span>any() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a782315b34c17c5bebb5e00277a8fe0c3" name="a782315b34c17c5bebb5e00277a8fe0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782315b34c17c5bebb5e00277a8fe0c3">&#9670;&#160;</a></span>any() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad4b3479936dce019d229f63ae01b51c5" name="ad4b3479936dce019d229f63ae01b51c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b3479936dce019d229f63ae01b51c5">&#9670;&#160;</a></span>any() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = enumerable::all&lt;pet&gt;(pets.begin(), pets.end(), [](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    return pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adf22bf866179b4de2e4272eabff559a0" name="adf22bf866179b4de2e4272eabff559a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf22bf866179b4de2e4272eabff559a0">&#9670;&#160;</a></span>append() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae5d2f992c66d3c0760bb1b299ceae73d">append</a>(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_a8a7a51d0792107dd537730634b8fff12"><div class="ttname"><a href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">xtd::basic_string::join</a></div><div class="ttdeci">static basic_string join(const basic_string separator, const collection_t &amp;values) noexcept</div><div class="ttdoc">Concatenates a specified separator basic_string between each element of a specified object array,...</div><div class="ttdef"><b>Definition</b> basic_string.hpp:2296</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_ae5d2f992c66d3c0760bb1b299ceae73d"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae5d2f992c66d3c0760bb1b299ceae73d">xtd::collections::generic::extensions::enumerable::append</a></div><div class="ttdeci">const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp; append(const source_t &amp;element) const noexcept</div><div class="ttdoc">Appends a value to the end of the sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:168</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1list_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a></div><div class="ttdoc">Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...</div><div class="ttdef"><b>Definition</b> list.hpp:71</div></div>
<div class="ttc" id="anamespacextd_1_1collections_1_1generic_html"><div class="ttname"><a href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a></div><div class="ttdoc">The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...</div><div class="ttdef"><b>Definition</b> comparer.hpp:15</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4ecb4005cf51493e0b9ae25e7b24c19c" name="a4ecb4005cf51493e0b9ae25e7b24c19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecb4005cf51493e0b9ae25e7b24c19c">&#9670;&#160;</a></span>append() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae5d2f992c66d3c0760bb1b299ceae73d">append</a>(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac8263fc7e8283eef962407c4313cc4a7" name="ac8263fc7e8283eef962407c4313cc4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8263fc7e8283eef962407c4313cc4a7">&#9670;&#160;</a></span>append() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae5d2f992c66d3c0760bb1b299ceae73d">append</a>(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0be188acb4bb748b0112589c342e8423" name="a0be188acb4bb748b0112589c342e8423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be188acb4bb748b0112589c342e8423">&#9670;&#160;</a></span>append() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">enumerable::append</a>(numbers.begin(), numbers.end(), 5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">enumerable::append</a>(numbers.begin(), numbers.end(), 5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">enumerable::append</a>(numbers.begin(), numbers.end(), 5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_adf22bf866179b4de2e4272eabff559a0"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">xtd::linq::enumerable::append</a></div><div class="ttdeci">static const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp; append(const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp;source, const source_t &amp;element) noexcept</div><div class="ttdoc">Appends a value to the end of the sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:713</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a25d172ff89909b3d3e27cf4c91116177" name="a25d172ff89909b3d3e27cf4c91116177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d172ff89909b3d3e27cf4c91116177">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5bb53ce6fab643cbe01dcb3925c698af" name="a5bb53ce6fab643cbe01dcb3925c698af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb53ce6fab643cbe01dcb3925c698af">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af90ec21b4abacec8eb0e29071f8efc97" name="af90ec21b4abacec8eb0e29071f8efc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90ec21b4abacec8eb0e29071f8efc97">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0a9518817b1581ae817e402b740bbb1f" name="a0a9518817b1581ae817e402b740bbb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9518817b1581ae817e402b740bbb1f">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a637ef7b9fc2bb6c501901d6d2eea0349" name="a637ef7b9fc2bb6c501901d6d2eea0349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637ef7b9fc2bb6c501901d6d2eea0349">&#9670;&#160;</a></span>average() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1981940673117d7d1a07bfadc4cd807e" name="a1981940673117d7d1a07bfadc4cd807e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1981940673117d7d1a07bfadc4cd807e">&#9670;&#160;</a></span>average() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of double values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b7d48767f0f4a494a6a2796ab1e5c00" name="a7b7d48767f0f4a494a6a2796ab1e5c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7d48767f0f4a494a6a2796ab1e5c00">&#9670;&#160;</a></span>average() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of float values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of float values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64dc3877d6633a433380dbc69feaae25" name="a64dc3877d6633a433380dbc69feaae25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dc3877d6633a433380dbc69feaae25">&#9670;&#160;</a></span>average() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a180145af875f8afdd754a57912662d7b" name="a180145af875f8afdd754a57912662d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180145af875f8afdd754a57912662d7b">&#9670;&#160;</a></span>average() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48e5bd4af93fd8b03d1ff9fb30b9da39" name="a48e5bd4af93fd8b03d1ff9fb30b9da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e5bd4af93fd8b03d1ff9fb30b9da39">&#9670;&#160;</a></span>average() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a43fcb0557ee8c42fbf6906e481478b73" name="a43fcb0557ee8c42fbf6906e481478b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fcb0557ee8c42fbf6906e481478b73">&#9670;&#160;</a></span>average() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional double values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="ad813a36db751d09ea896190063c987b9" name="ad813a36db751d09ea896190063c987b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad813a36db751d09ea896190063c987b9">&#9670;&#160;</a></span>average() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional float values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional float values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a11950bd1bc11a3e69ca92dd960ccaa83" name="a11950bd1bc11a3e69ca92dd960ccaa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11950bd1bc11a3e69ca92dd960ccaa83">&#9670;&#160;</a></span>average() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a9df923caaf850458512e70dd985df80d" name="a9df923caaf850458512e70dd985df80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df923caaf850458512e70dd985df80d">&#9670;&#160;</a></span>average() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="ab77239b8123b06e5f2d088fb74500995" name="ab77239b8123b06e5f2d088fb74500995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77239b8123b06e5f2d088fb74500995">&#9670;&#160;</a></span>first_or_default() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a1b5e0e9badb3b2fb329a9504b838c7be" name="a1b5e0e9badb3b2fb329a9504b838c7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5e0e9badb3b2fb329a9504b838c7be">&#9670;&#160;</a></span>first_or_default() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="ae6ebabc65a26f263c61c446dbef009b3" name="ae6ebabc65a26f263c61c446dbef009b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ebabc65a26f263c61c446dbef009b3">&#9670;&#160;</a></span>first_or_default() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="ae71c11e30879c9af8531c855b5eb8088" name="ae71c11e30879c9af8531c855b5eb8088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71c11e30879c9af8531c855b5eb8088">&#9670;&#160;</a></span>first_or_default() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="ab15732619b209ff177c90ad91b1a4bd3" name="ab15732619b209ff177c90ad91b1a4bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15732619b209ff177c90ad91b1a4bd3">&#9670;&#160;</a></span>first_or_default() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a1847ab0e3c969d868e81e84809beedec" name="a1847ab0e3c969d868e81e84809beedec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1847ab0e3c969d868e81e84809beedec">&#9670;&#160;</a></span>first_or_default() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a0e0922997a0fda313f2c308ece6841ac" name="a0e0922997a0fda313f2c308ece6841ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0922997a0fda313f2c308ece6841ac">&#9670;&#160;</a></span>first_or_default() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a8ef9173ba49b6d1ce79a2aa72d5d781a" name="a8ef9173ba49b6d1ce79a2aa72d5d781a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef9173ba49b6d1ce79a2aa72d5d781a">&#9670;&#160;</a></span>first_or_default() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a2ad0f9812852378c4ed08a50f39396cd" name="a2ad0f9812852378c4ed08a50f39396cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad0f9812852378c4ed08a50f39396cd">&#9670;&#160;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp; xtd::linq::enumerable::range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of integral numbers within a specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The value of the first integer in the sequence. </td></tr>
    <tr><td class="paramname">count</td><td>The number of sequential integers to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An xtd::collection::generic::ienumerable &lt;<a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a>&gt; that contains a range of sequential integral numbers. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`count` is less than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2df9541f109773859bcaaf42015b8cd" name="ae2df9541f109773859bcaaf42015b8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2df9541f109773859bcaaf42015b8cd">&#9670;&#160;</a></span>select() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a83ed748289d607a75c7cadd7d44438e7" name="a83ed748289d607a75c7cadd7d44438e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ed748289d607a75c7cadd7d44438e7">&#9670;&#160;</a></span>select() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a8cff7768a676655cf4e501cf207ba994" name="a8cff7768a676655cf4e501cf207ba994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cff7768a676655cf4e501cf207ba994">&#9670;&#160;</a></span>select() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a2d3159d59161a1a74114d24e228f4bf5" name="a2d3159d59161a1a74114d24e228f4bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3159d59161a1a74114d24e228f4bf5">&#9670;&#160;</a></span>select() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a85c7e6501518fc4f9fffdfc3f9938569" name="a85c7e6501518fc4f9fffdfc3f9938569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c7e6501518fc4f9fffdfc3f9938569">&#9670;&#160;</a></span>select() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t , typename selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const selector_t &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="ade4f8fbb6607356fb5e477dac9c649ef" name="ade4f8fbb6607356fb5e477dac9c649ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4f8fbb6607356fb5e477dac9c649ef">&#9670;&#160;</a></span>select() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t , typename selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const selector_t &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="ab99da5af6cddca634225d163aa10c62d" name="ab99da5af6cddca634225d163aa10c62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99da5af6cddca634225d163aa10c62d">&#9670;&#160;</a></span>select() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename collection_t , typename selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const selector_t &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="addae5520d1a61675e56e3884c930f0df" name="addae5520d1a61675e56e3884c930f0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addae5520d1a61675e56e3884c930f0df">&#9670;&#160;</a></span>select() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename input_iterator_t , typename selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const selector_t &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a18f003a07c40e6e294a3f0a7112b928a" name="a18f003a07c40e6e294a3f0a7112b928a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f003a07c40e6e294a3f0a7112b928a">&#9670;&#160;</a></span>select() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a7dcb14aeb0d0b46693e2ae6f0da5822e" name="a7dcb14aeb0d0b46693e2ae6f0da5822e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcb14aeb0d0b46693e2ae6f0da5822e">&#9670;&#160;</a></span>select() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a87e0db840e15ea8213f3f3bdf8e4f037" name="a87e0db840e15ea8213f3f3bdf8e4f037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e0db840e15ea8213f3f3bdf8e4f037">&#9670;&#160;</a></span>select() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a67de3d7bedf4a2b37263f3f8c80dd23b" name="a67de3d7bedf4a2b37263f3f8c80dd23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67de3d7bedf4a2b37263f3f8c80dd23b">&#9670;&#160;</a></span>select() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a3a3c2720e70eef7092b4bce8b8369dc7" name="a3a3c2720e70eef7092b4bce8b8369dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3c2720e70eef7092b4bce8b8369dc7">&#9670;&#160;</a></span>select() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const selector_t &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="aaf9e68ed442244553973d42ab8dbf244" name="aaf9e68ed442244553973d42ab8dbf244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9e68ed442244553973d42ab8dbf244">&#9670;&#160;</a></span>select() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const selector_t &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a7725606d2b6f446b3dc3fba8ebfc4bc9" name="a7725606d2b6f446b3dc3fba8ebfc4bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7725606d2b6f446b3dc3fba8ebfc4bc9">&#9670;&#160;</a></span>select() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const selector_t &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="a87785914520f41f313f3359e4a1cdf11" name="a87785914520f41f313f3359e4a1cdf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87785914520f41f313f3359e4a1cdf11">&#9670;&#160;</a></span>select() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const selector_t &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>

</div>
</div>
<a id="ae4632879fe4e92c640c0382e32de2967" name="ae4632879fe4e92c640c0382e32de2967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4632879fe4e92c640c0382e32de2967">&#9670;&#160;</a></span>to_list() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>

</div>
</div>
<a id="a2f37bb872c6ae514e52c00d5183a50c7" name="a2f37bb872c6ae514e52c00d5183a50c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f37bb872c6ae514e52c00d5183a50c7">&#9670;&#160;</a></span>to_list() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an std::initializer_list &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The std::initializer_list &lt;type_t&gt; to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>

</div>
</div>
<a id="af56d7345bb6c56ad7b55b25518e84ae1" name="af56d7345bb6c56ad7b55b25518e84ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56d7345bb6c56ad7b55b25518e84ae1">&#9670;&#160;</a></span>to_list() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an collection_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The collection_t to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>

</div>
</div>
<a id="a3c4c298b0cc2654d7b726859f52f4341" name="a3c4c298b0cc2654d7b726859f52f4341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4c298b0cc2654d7b726859f52f4341">&#9670;&#160;</a></span>to_list() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>

</div>
</div>
<a id="ade645587ccb269b8b05c4325989639be" name="ade645587ccb269b8b05c4325989639be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade645587ccb269b8b05c4325989639be">&#9670;&#160;</a></span>where() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>

</div>
</div>
<a id="ab4f5a1f6bde5387aa529acf9ad510fd4" name="ab4f5a1f6bde5387aa529acf9ad510fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f5a1f6bde5387aa529acf9ad510fd4">&#9670;&#160;</a></span>where() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>

</div>
</div>
<a id="a8b767d8dec90302a51169029c37ba82d" name="a8b767d8dec90302a51169029c37ba82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b767d8dec90302a51169029c37ba82d">&#9670;&#160;</a></span>where() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>

</div>
</div>
<a id="a0daeaea8dafaa306901966cb1bcfcbc8" name="a0daeaea8dafaa306901966cb1bcfcbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0daeaea8dafaa306901966cb1bcfcbc8">&#9670;&#160;</a></span>where() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>

</div>
</div>
<a id="a331f4ee242797bf6153cabbe14245143" name="a331f4ee242797bf6153cabbe14245143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331f4ee242797bf6153cabbe14245143">&#9670;&#160;</a></span>where() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>

</div>
</div>
<a id="adc47a682d6e3439a3b101c2127d10873" name="adc47a682d6e3439a3b101c2127d10873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc47a682d6e3439a3b101c2127d10873">&#9670;&#160;</a></span>where() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>

</div>
</div>
<a id="a4cb0a5a4c4e600c6eff4c62b7829c274" name="a4cb0a5a4c4e600c6eff4c62b7829c274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb0a5a4c4e600c6eff4c62b7829c274">&#9670;&#160;</a></span>where() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>

</div>
</div>
<a id="a21c0e3f162b8dcdc719edea9065aed7a" name="a21c0e3f162b8dcdc719edea9065aed7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c0e3f162b8dcdc719edea9065aed7a">&#9670;&#160;</a></span>where() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/linq/<a class="el" href="linq_2enumerable_8hpp_source.html">enumerable.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 27 2024 09:43:50 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
