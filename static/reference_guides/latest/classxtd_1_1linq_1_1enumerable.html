<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::linq::enumerable Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1linq.html">linq</a></li><li class="navelem"><a class="el" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1linq_1_1enumerable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::linq::enumerable Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__linq.html">linq</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::linq::enumerable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1linq_1_1enumerable.png" usemap="#xtd::linq::enumerable_map" alt=""/>
  <map id="xtd::linq::enumerable_map" name="xtd::linq::enumerable_map">
<area href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted)." alt="xtd::static_object" shape="rect" coords="0,0,125,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_t&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1static__object.html">xtd::static_object</a>;</div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html">xtd::linq::enumerable</a></div><div class="ttdoc">Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:48</div></div>
<div class="ttc" id="aclassxtd_1_1static__object_html"><div class="ttname"><a href="classxtd_1_1static__object.html">xtd::static_object</a></div><div class="ttdoc">Represent a static object. A static class can't be instantiated (constructors are deleted).</div><div class="ttdef"><b>Definition</b> static.hpp:20</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1linq.html" title="Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).">xtd::linq</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Alias</h2></td></tr>
<tr class="memitem:a2bd1889dc1967c50ef692411dc2c4b92"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:a2bd1889dc1967c50ef692411dc2c4b92"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; type_t &gt;</td></tr>
<tr class="memdesc:a2bd1889dc1967c50ef692411dc2c4b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:a2bd1889dc1967c50ef692411dc2c4b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff59be55b7be66d275f28741e2f1f0a"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:a4ff59be55b7be66d275f28741e2f1f0a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; type_t &gt;</td></tr>
<tr class="memdesc:a4ff59be55b7be66d275f28741e2f1f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a4ff59be55b7be66d275f28741e2f1f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:af1b0c29ab9f86199822152226ec0e90d"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:af1b0c29ab9f86199822152226ec0e90d"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">aggregate</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:af1b0c29ab9f86199822152226ec0e90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:af1b0c29ab9f86199822152226ec0e90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73718737f59ecba4bad8c6b5f64b6617"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a73718737f59ecba4bad8c6b5f64b6617"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a73718737f59ecba4bad8c6b5f64b6617">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a73718737f59ecba4bad8c6b5f64b6617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a73718737f59ecba4bad8c6b5f64b6617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154f1aff8fafef647831bc9554c9b48d"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a154f1aff8fafef647831bc9554c9b48d"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a154f1aff8fafef647831bc9554c9b48d">aggregate</a> (const collection_t &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a154f1aff8fafef647831bc9554c9b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a154f1aff8fafef647831bc9554c9b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5e27b4f583424d1e482fff52e132f0"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5e5e27b4f583424d1e482fff52e132f0"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5e5e27b4f583424d1e482fff52e132f0">aggregate</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a5e5e27b4f583424d1e482fff52e132f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a5e5e27b4f583424d1e482fff52e132f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a294984bf7327f7a8d213e75472a17"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename func_t &gt; </td></tr>
<tr class="memitem:ad0a294984bf7327f7a8d213e75472a17"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ad0a294984bf7327f7a8d213e75472a17">aggregate</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ad0a294984bf7327f7a8d213e75472a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:ad0a294984bf7327f7a8d213e75472a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6addb7f0841160d9efc1b1b12846ad47"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename func_t &gt; </td></tr>
<tr class="memitem:a6addb7f0841160d9efc1b1b12846ad47"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a6addb7f0841160d9efc1b1b12846ad47">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a6addb7f0841160d9efc1b1b12846ad47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a6addb7f0841160d9efc1b1b12846ad47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename func_t &gt; </td></tr>
<tr class="memitem:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab6acc19f96c13e626d8fc69d7bfc14c5">aggregate</a> (const collection_t &amp;source, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda77ef769372aed4db74698b6173d74"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename func_t &gt; </td></tr>
<tr class="memitem:adda77ef769372aed4db74698b6173d74"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#adda77ef769372aed4db74698b6173d74">aggregate</a> (input_iterator_t first, input_iterator_t last, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:adda77ef769372aed4db74698b6173d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:adda77ef769372aed4db74698b6173d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada50d6149117beb68a72da3343bd5407"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename source_t &gt; </td></tr>
<tr class="memitem:ada50d6149117beb68a72da3343bd5407"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ada50d6149117beb68a72da3343bd5407">aggregate</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ada50d6149117beb68a72da3343bd5407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ada50d6149117beb68a72da3343bd5407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02801dad8993626dcd7c2b7cc1fc4fec"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename source_t &gt; </td></tr>
<tr class="memitem:a02801dad8993626dcd7c2b7cc1fc4fec"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a02801dad8993626dcd7c2b7cc1fc4fec">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a02801dad8993626dcd7c2b7cc1fc4fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a02801dad8993626dcd7c2b7cc1fc4fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab1bdd7a08b78efc2a7debbb7f69a7e02">aggregate</a> (const collection_t &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46b4f242688699339f4b391055a6e72"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ab46b4f242688699339f4b391055a6e72"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab46b4f242688699339f4b391055a6e72">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab46b4f242688699339f4b391055a6e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ab46b4f242688699339f4b391055a6e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0486add1c7f960d10c282c70f79b910"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename source_t , typename func_t &gt; </td></tr>
<tr class="memitem:ab0486add1c7f960d10c282c70f79b910"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab0486add1c7f960d10c282c70f79b910">aggregate</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab0486add1c7f960d10c282c70f79b910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ab0486add1c7f960d10c282c70f79b910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4103c8e700221902e26628caca127a15"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename source_t , typename func_t &gt; </td></tr>
<tr class="memitem:a4103c8e700221902e26628caca127a15"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4103c8e700221902e26628caca127a15">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a4103c8e700221902e26628caca127a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a4103c8e700221902e26628caca127a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f264b52a622ec32100c5a9ade3500c"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename collection_t , typename func_t &gt; </td></tr>
<tr class="memitem:a50f264b52a622ec32100c5a9ade3500c"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a50f264b52a622ec32100c5a9ade3500c">aggregate</a> (const collection_t &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a50f264b52a622ec32100c5a9ade3500c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a50f264b52a622ec32100c5a9ade3500c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7e4b4e77fe80020fafce9b60441061"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename input_iterator_t , typename func_t &gt; </td></tr>
<tr class="memitem:a3b7e4b4e77fe80020fafce9b60441061"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3b7e4b4e77fe80020fafce9b60441061">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a3b7e4b4e77fe80020fafce9b60441061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a3b7e4b4e77fe80020fafce9b60441061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f79a4291dee3441cb093eb09c26c36f"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename accumulate_t , typename source_t &gt; </td></tr>
<tr class="memitem:a6f79a4291dee3441cb093eb09c26c36f"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a6f79a4291dee3441cb093eb09c26c36f">aggregate</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:a6f79a4291dee3441cb093eb09c26c36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a6f79a4291dee3441cb093eb09c26c36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd2e96cc0f12d577728c54cdbba34e5"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename accumulate_t , typename source_t &gt; </td></tr>
<tr class="memitem:abfd2e96cc0f12d577728c54cdbba34e5"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#abfd2e96cc0f12d577728c54cdbba34e5">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:abfd2e96cc0f12d577728c54cdbba34e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:abfd2e96cc0f12d577728c54cdbba34e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc1c09dd640d49cf46e47315353ed18"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename accumulate_t , typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:aadc1c09dd640d49cf46e47315353ed18"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aadc1c09dd640d49cf46e47315353ed18">aggregate</a> (const collection_t &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:aadc1c09dd640d49cf46e47315353ed18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:aadc1c09dd640d49cf46e47315353ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86311e56c9cda909d08cdabdcf472b5"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename accumulate_t , typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ab86311e56c9cda909d08cdabdcf472b5"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab86311e56c9cda909d08cdabdcf472b5">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:ab86311e56c9cda909d08cdabdcf472b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:ab86311e56c9cda909d08cdabdcf472b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8a07a5065fd13376fe11b875d2351e"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename accumulate_t , typename source_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a2f8a07a5065fd13376fe11b875d2351e"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2f8a07a5065fd13376fe11b875d2351e">aggregate</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a2f8a07a5065fd13376fe11b875d2351e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a2f8a07a5065fd13376fe11b875d2351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cadb72337035e42730b10e0a57803f"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename accumulate_t , typename source_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a68cadb72337035e42730b10e0a57803f"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a68cadb72337035e42730b10e0a57803f">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a68cadb72337035e42730b10e0a57803f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a68cadb72337035e42730b10e0a57803f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6e9be709bf0d6bfb742135409e193c"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename accumulate_t , typename collection_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a1b6e9be709bf0d6bfb742135409e193c"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a1b6e9be709bf0d6bfb742135409e193c">aggregate</a> (const collection_t &amp;collection, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a1b6e9be709bf0d6bfb742135409e193c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a1b6e9be709bf0d6bfb742135409e193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1fb529106403a96744a6f0e409179c"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename accumulate_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a2f1fb529106403a96744a6f0e409179c"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2f1fb529106403a96744a6f0e409179c">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a2f1fb529106403a96744a6f0e409179c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a2f1fb529106403a96744a6f0e409179c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ee26584bc2b6d5ef6ef80e0016eccf"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename source_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:ae7ee26584bc2b6d5ef6ef80e0016eccf"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae7ee26584bc2b6d5ef6ef80e0016eccf">aggregate</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:ae7ee26584bc2b6d5ef6ef80e0016eccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:ae7ee26584bc2b6d5ef6ef80e0016eccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15166396187c1a938680f6a1316b100b"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename source_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a15166396187c1a938680f6a1316b100b"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a15166396187c1a938680f6a1316b100b">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a15166396187c1a938680f6a1316b100b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a15166396187c1a938680f6a1316b100b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3218c9c234c742982c4d85953286b9"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename collection_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a0d3218c9c234c742982c4d85953286b9"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0d3218c9c234c742982c4d85953286b9">aggregate</a> (const collection_t &amp;collection, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a0d3218c9c234c742982c4d85953286b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a0d3218c9c234c742982c4d85953286b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2f7ca162d5d735492ed63bc2d1f076fd">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f22da0fbdff4367e59968b136a2844"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a26f22da0fbdff4367e59968b136a2844"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844">all</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a26f22da0fbdff4367e59968b136a2844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a26f22da0fbdff4367e59968b136a2844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c0f58808d470666722b1d3a40ed8c4"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a00c0f58808d470666722b1d3a40ed8c4"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a00c0f58808d470666722b1d3a40ed8c4">all</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a00c0f58808d470666722b1d3a40ed8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a00c0f58808d470666722b1d3a40ed8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d2b50122ac7429831299a556be7efa"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:af5d2b50122ac7429831299a556be7efa"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af5d2b50122ac7429831299a556be7efa">all</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:af5d2b50122ac7429831299a556be7efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:af5d2b50122ac7429831299a556be7efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8fd7b35aaebdbea8331a5aaeea8cad9c">all</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91f9e006465da4a57f64338c49b9eb2"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:aa91f9e006465da4a57f64338c49b9eb2"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa91f9e006465da4a57f64338c49b9eb2">all</a> (std::initializer_list&lt; source_t &gt; source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:aa91f9e006465da4a57f64338c49b9eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aa91f9e006465da4a57f64338c49b9eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ec7f29327dfa3a235e192a697f88b7"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:ab5ec7f29327dfa3a235e192a697f88b7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab5ec7f29327dfa3a235e192a697f88b7">all</a> (const collection_t &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ab5ec7f29327dfa3a235e192a697f88b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:ab5ec7f29327dfa3a235e192a697f88b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3bca3810844c7f42e4bb3f09c1b3820b">all</a> (input_iterator_t first, input_iterator_t last, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff1ae119439eb346f435f375d6ca74d"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a3ff1ae119439eb346f435f375d6ca74d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3ff1ae119439eb346f435f375d6ca74d">any</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a3ff1ae119439eb346f435f375d6ca74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a3ff1ae119439eb346f435f375d6ca74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a01ae8e0e45fb40cc7ae0c58bb2eb4dc6">any</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa5fca6b9d7bc049f1eef56457c17a2bf">any</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5200b0bf55e0d4ca3bd76e300b34a3ca">any</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eecec336b27b17378a85e7643de786"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a40eecec336b27b17378a85e7643de786"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a40eecec336b27b17378a85e7643de786">any</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a40eecec336b27b17378a85e7643de786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a40eecec336b27b17378a85e7643de786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1588879c5bede53fb6e8c3329138971"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ae1588879c5bede53fb6e8c3329138971"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae1588879c5bede53fb6e8c3329138971">any</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ae1588879c5bede53fb6e8c3329138971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:ae1588879c5bede53fb6e8c3329138971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2270a08fffe2f4cce7944d2a77e21202"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a2270a08fffe2f4cce7944d2a77e21202"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2270a08fffe2f4cce7944d2a77e21202">any</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a2270a08fffe2f4cce7944d2a77e21202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a2270a08fffe2f4cce7944d2a77e21202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5f332f87f28c6c9ea9e7df729ed3d3b7">any</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426fee4903820f2b103702eb1d5f36d9"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a426fee4903820f2b103702eb1d5f36d9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a426fee4903820f2b103702eb1d5f36d9">any</a> (std::initializer_list&lt; source_t &gt; source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a426fee4903820f2b103702eb1d5f36d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a426fee4903820f2b103702eb1d5f36d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782315b34c17c5bebb5e00277a8fe0c3"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a782315b34c17c5bebb5e00277a8fe0c3"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a782315b34c17c5bebb5e00277a8fe0c3">any</a> (const collection_t &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a782315b34c17c5bebb5e00277a8fe0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a782315b34c17c5bebb5e00277a8fe0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b3479936dce019d229f63ae01b51c5"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:ad4b3479936dce019d229f63ae01b51c5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ad4b3479936dce019d229f63ae01b51c5">any</a> (input_iterator_t first, input_iterator_t last, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ad4b3479936dce019d229f63ae01b51c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:ad4b3479936dce019d229f63ae01b51c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc66d0a2d96e7aa7f5a3569e5dbb40dd"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:abc66d0a2d96e7aa7f5a3569e5dbb40dd"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#abc66d0a2d96e7aa7f5a3569e5dbb40dd">append</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:abc66d0a2d96e7aa7f5a3569e5dbb40dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:abc66d0a2d96e7aa7f5a3569e5dbb40dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03000d97b38af9e8af2a8698206ece9f"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a03000d97b38af9e8af2a8698206ece9f"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a03000d97b38af9e8af2a8698206ece9f">append</a> (std::initializer_list&lt; source_t &gt; source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:a03000d97b38af9e8af2a8698206ece9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a03000d97b38af9e8af2a8698206ece9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e4ce55897fc6b4c49534500296ad3c"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a38e4ce55897fc6b4c49534500296ad3c"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a38e4ce55897fc6b4c49534500296ad3c">append</a> (const collection_t &amp;source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:a38e4ce55897fc6b4c49534500296ad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a38e4ce55897fc6b4c49534500296ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38caca4975ab5f85f5c5858a44ecffba"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a38caca4975ab5f85f5c5858a44ecffba"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a38caca4975ab5f85f5c5858a44ecffba">append</a> (input_iterator_t first, input_iterator_t last, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:a38caca4975ab5f85f5c5858a44ecffba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a38caca4975ab5f85f5c5858a44ecffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b07197f3c4238071667d89cecc032"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a844b07197f3c4238071667d89cecc032"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a844b07197f3c4238071667d89cecc032">as_enumerable</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a844b07197f3c4238071667d89cecc032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a844b07197f3c4238071667d89cecc032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccec3ba16804c51bb5e6f7597b9c28e"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a7ccec3ba16804c51bb5e6f7597b9c28e"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a7ccec3ba16804c51bb5e6f7597b9c28e">as_enumerable</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:a7ccec3ba16804c51bb5e6f7597b9c28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a7ccec3ba16804c51bb5e6f7597b9c28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90ec21b4abacec8eb0e29071f8efc97"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:af90ec21b4abacec8eb0e29071f8efc97"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af90ec21b4abacec8eb0e29071f8efc97">as_enumerable</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:af90ec21b4abacec8eb0e29071f8efc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:af90ec21b4abacec8eb0e29071f8efc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9518817b1581ae817e402b740bbb1f"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a0a9518817b1581ae817e402b740bbb1f"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0a9518817b1581ae817e402b740bbb1f">as_enumerable</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a0a9518817b1581ae817e402b740bbb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a0a9518817b1581ae817e402b740bbb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f45e5466740ff18c1f2dff890e6c457"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0f45e5466740ff18c1f2dff890e6c457">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a0f45e5466740ff18c1f2dff890e6c457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values.  <br /></td></tr>
<tr class="separator:a0f45e5466740ff18c1f2dff890e6c457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ece176030f8975cde72309753d32cb1"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a6ece176030f8975cde72309753d32cb1">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; double &gt; &amp;source)</td></tr>
<tr class="memdesc:a6ece176030f8975cde72309753d32cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of double values.  <br /></td></tr>
<tr class="separator:a6ece176030f8975cde72309753d32cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf18abab93837198d91f64e19fc7c04"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#abcf18abab93837198d91f64e19fc7c04">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; float &gt; &amp;source)</td></tr>
<tr class="memdesc:abcf18abab93837198d91f64e19fc7c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of float values.  <br /></td></tr>
<tr class="separator:abcf18abab93837198d91f64e19fc7c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db01ef4dcc146706ace27163a88c9ef"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3db01ef4dcc146706ace27163a88c9ef">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a3db01ef4dcc146706ace27163a88c9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values.  <br /></td></tr>
<tr class="separator:a3db01ef4dcc146706ace27163a88c9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f5e2995a613c7cd21a3a70d2725fa0"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a79f5e2995a613c7cd21a3a70d2725fa0">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a79f5e2995a613c7cd21a3a70d2725fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values.  <br /></td></tr>
<tr class="separator:a79f5e2995a613c7cd21a3a70d2725fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb1f246d0c1d7fcc244c109f932ee2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2cb1f246d0c1d7fcc244c109f932ee2a">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a2cb1f246d0c1d7fcc244c109f932ee2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values.  <br /></td></tr>
<tr class="separator:a2cb1f246d0c1d7fcc244c109f932ee2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99a80b764c342e0b097e6640693480d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab99a80b764c342e0b097e6640693480d">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ab99a80b764c342e0b097e6640693480d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional double values.  <br /></td></tr>
<tr class="separator:ab99a80b764c342e0b097e6640693480d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ea28ac2b9dade8ec13d986d19c8cf3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a25ea28ac2b9dade8ec13d986d19c8cf3">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a25ea28ac2b9dade8ec13d986d19c8cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional float values.  <br /></td></tr>
<tr class="separator:a25ea28ac2b9dade8ec13d986d19c8cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba45526a72fc218f272d378a69322d7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5ba45526a72fc218f272d378a69322d7">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a5ba45526a72fc218f272d378a69322d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values.  <br /></td></tr>
<tr class="separator:a5ba45526a72fc218f272d378a69322d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22ecd327aae18433bb93f8b07a270ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ad22ecd327aae18433bb93f8b07a270ee">average</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ad22ecd327aae18433bb93f8b07a270ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values.  <br /></td></tr>
<tr class="separator:ad22ecd327aae18433bb93f8b07a270ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2663a00546187353ff418c180d976687"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t &gt; </td></tr>
<tr class="memitem:a2663a00546187353ff418c180d976687"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2663a00546187353ff418c180d976687">cast</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a2663a00546187353ff418c180d976687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an xtd::collection::generic::ienumerable to the specified type.  <br /></td></tr>
<tr class="separator:a2663a00546187353ff418c180d976687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fda8b1ce0b4478fb8ae17ae0844955"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t &gt; </td></tr>
<tr class="memitem:ae9fda8b1ce0b4478fb8ae17ae0844955"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae9fda8b1ce0b4478fb8ae17ae0844955">cast</a> (const std::initializer_list&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ae9fda8b1ce0b4478fb8ae17ae0844955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an xtd::collection::generic::ienumerable to the specified type.  <br /></td></tr>
<tr class="separator:ae9fda8b1ce0b4478fb8ae17ae0844955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe89b24fc447af7a381f5b0db1903746"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename collection_t &gt; </td></tr>
<tr class="memitem:afe89b24fc447af7a381f5b0db1903746"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#afe89b24fc447af7a381f5b0db1903746">cast</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:afe89b24fc447af7a381f5b0db1903746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an xtd::collection::generic::ienumerable to the specified type.  <br /></td></tr>
<tr class="separator:afe89b24fc447af7a381f5b0db1903746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddbbe92bc30ea895ecef930419897c9"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:afddbbe92bc30ea895ecef930419897c9"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#afddbbe92bc30ea895ecef930419897c9">cast</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:afddbbe92bc30ea895ecef930419897c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an xtd::collection::generic::ienumerable to the specified type.  <br /></td></tr>
<tr class="separator:afddbbe92bc30ea895ecef930419897c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b247a0e769fe8eed5a37b3ab4e44fd"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a84b247a0e769fe8eed5a37b3ab4e44fd"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a84b247a0e769fe8eed5a37b3ab4e44fd">first_or_default</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:a84b247a0e769fe8eed5a37b3ab4e44fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:a84b247a0e769fe8eed5a37b3ab4e44fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00609035e3d3a3cdec40b3d9a8215af6"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a00609035e3d3a3cdec40b3d9a8215af6"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a00609035e3d3a3cdec40b3d9a8215af6">first_or_default</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:a00609035e3d3a3cdec40b3d9a8215af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:a00609035e3d3a3cdec40b3d9a8215af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e96859c92065e17479eca6ebe565f6"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a20e96859c92065e17479eca6ebe565f6"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a20e96859c92065e17479eca6ebe565f6">first_or_default</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:a20e96859c92065e17479eca6ebe565f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:a20e96859c92065e17479eca6ebe565f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb896f9df08594d736bd887ac932f5c6"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:abb896f9df08594d736bd887ac932f5c6"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#abb896f9df08594d736bd887ac932f5c6">first_or_default</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:abb896f9df08594d736bd887ac932f5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:abb896f9df08594d736bd887ac932f5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf71c1af3ba82f0df36809f98b58132"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:adaf71c1af3ba82f0df36809f98b58132"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#adaf71c1af3ba82f0df36809f98b58132">first_or_default</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) noexcept</td></tr>
<tr class="memdesc:adaf71c1af3ba82f0df36809f98b58132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:adaf71c1af3ba82f0df36809f98b58132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4e18397ef1ea198e2b022f2fa6b271"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:afc4e18397ef1ea198e2b022f2fa6b271"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#afc4e18397ef1ea198e2b022f2fa6b271">first_or_default</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) noexcept</td></tr>
<tr class="memdesc:afc4e18397ef1ea198e2b022f2fa6b271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:afc4e18397ef1ea198e2b022f2fa6b271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752542e2accb3781e99880a6ca89db05"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a752542e2accb3781e99880a6ca89db05"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a752542e2accb3781e99880a6ca89db05">first_or_default</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) noexcept</td></tr>
<tr class="memdesc:a752542e2accb3781e99880a6ca89db05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a752542e2accb3781e99880a6ca89db05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be82a0004d9317cfbe44a8759efa6f3"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a6be82a0004d9317cfbe44a8759efa6f3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a6be82a0004d9317cfbe44a8759efa6f3">first_or_default</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) noexcept</td></tr>
<tr class="memdesc:a6be82a0004d9317cfbe44a8759efa6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a6be82a0004d9317cfbe44a8759efa6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ab3f630eeaa5b8baa65bd53f4dd1d2"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a92ab3f630eeaa5b8baa65bd53f4dd1d2"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a92ab3f630eeaa5b8baa65bd53f4dd1d2">first_or_default</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:a92ab3f630eeaa5b8baa65bd53f4dd1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a92ab3f630eeaa5b8baa65bd53f4dd1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbe3f710d98adf47db973ae01b0220e"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:acdbe3f710d98adf47db973ae01b0220e"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#acdbe3f710d98adf47db973ae01b0220e">first_or_default</a> (std::initializer_list&lt; source_t &gt; source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:acdbe3f710d98adf47db973ae01b0220e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:acdbe3f710d98adf47db973ae01b0220e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ebabc65a26f263c61c446dbef009b3"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:ae6ebabc65a26f263c61c446dbef009b3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae6ebabc65a26f263c61c446dbef009b3">first_or_default</a> (const collection_t &amp;source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:ae6ebabc65a26f263c61c446dbef009b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ae6ebabc65a26f263c61c446dbef009b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71c11e30879c9af8531c855b5eb8088"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ae71c11e30879c9af8531c855b5eb8088"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae71c11e30879c9af8531c855b5eb8088">first_or_default</a> (input_iterator_t first, input_iterator_t last, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:ae71c11e30879c9af8531c855b5eb8088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ae71c11e30879c9af8531c855b5eb8088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14ce27216bdbb95d8c1bd14dfee5e40"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:af14ce27216bdbb95d8c1bd14dfee5e40"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af14ce27216bdbb95d8c1bd14dfee5e40">first_or_default</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:af14ce27216bdbb95d8c1bd14dfee5e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:af14ce27216bdbb95d8c1bd14dfee5e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a3310b7497b5ab2593a9d401a4bf7a"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a43a3310b7497b5ab2593a9d401a4bf7a"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a43a3310b7497b5ab2593a9d401a4bf7a">first_or_default</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:a43a3310b7497b5ab2593a9d401a4bf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a43a3310b7497b5ab2593a9d401a4bf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0922997a0fda313f2c308ece6841ac"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a0e0922997a0fda313f2c308ece6841ac"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0e0922997a0fda313f2c308ece6841ac">first_or_default</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:a0e0922997a0fda313f2c308ece6841ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a0e0922997a0fda313f2c308ece6841ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8ef9173ba49b6d1ce79a2aa72d5d781a">first_or_default</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab37948dddc316f841ba3a1c087cc41"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#abab37948dddc316f841ba3a1c087cc41">range</a> (<a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> start, <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> count)</td></tr>
<tr class="memdesc:abab37948dddc316f841ba3a1c087cc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of integral numbers within a specified range.  <br /></td></tr>
<tr class="separator:abab37948dddc316f841ba3a1c087cc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2085b7c27b0cfc0902baba251aca3409"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t &gt; </td></tr>
<tr class="memitem:a2085b7c27b0cfc0902baba251aca3409"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409">select</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a2085b7c27b0cfc0902baba251aca3409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a2085b7c27b0cfc0902baba251aca3409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdcc2b59b57857dc0d7f6497e94681e"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t &gt; </td></tr>
<tr class="memitem:a6bdcc2b59b57857dc0d7f6497e94681e"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a6bdcc2b59b57857dc0d7f6497e94681e">select</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a6bdcc2b59b57857dc0d7f6497e94681e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a6bdcc2b59b57857dc0d7f6497e94681e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598633727f61c78112a4049001f21d43"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a598633727f61c78112a4049001f21d43"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a598633727f61c78112a4049001f21d43">select</a> (const collection_t &amp;source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a598633727f61c78112a4049001f21d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a598633727f61c78112a4049001f21d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ab941b504b5593ae0c397ef2946e95"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a88ab941b504b5593ae0c397ef2946e95"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a88ab941b504b5593ae0c397ef2946e95">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a88ab941b504b5593ae0c397ef2946e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a88ab941b504b5593ae0c397ef2946e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0ff78cef1a4897bb2b19cf68385b09"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a6e0ff78cef1a4897bb2b19cf68385b09"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a6e0ff78cef1a4897bb2b19cf68385b09">select</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a6e0ff78cef1a4897bb2b19cf68385b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a6e0ff78cef1a4897bb2b19cf68385b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f5a6ce9d439bcd73d159513a21e617"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a95f5a6ce9d439bcd73d159513a21e617"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a95f5a6ce9d439bcd73d159513a21e617">select</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a95f5a6ce9d439bcd73d159513a21e617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a95f5a6ce9d439bcd73d159513a21e617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf19b7fc82fabb29d9f614901fb5e326"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:aaf19b7fc82fabb29d9f614901fb5e326"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aaf19b7fc82fabb29d9f614901fb5e326">select</a> (const collection_t &amp;source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:aaf19b7fc82fabb29d9f614901fb5e326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:aaf19b7fc82fabb29d9f614901fb5e326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b17c26a22158b3b08c85fdbc947c4a3"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a8b17c26a22158b3b08c85fdbc947c4a3"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8b17c26a22158b3b08c85fdbc947c4a3">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a8b17c26a22158b3b08c85fdbc947c4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a8b17c26a22158b3b08c85fdbc947c4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771aa96d8dd12d6835b54f03fe183db2"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t &gt; </td></tr>
<tr class="memitem:a771aa96d8dd12d6835b54f03fe183db2"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a771aa96d8dd12d6835b54f03fe183db2">select</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a771aa96d8dd12d6835b54f03fe183db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a771aa96d8dd12d6835b54f03fe183db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fc76a1b0b95dd49cb4a582df7d27c9"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t &gt; </td></tr>
<tr class="memitem:ad5fc76a1b0b95dd49cb4a582df7d27c9"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ad5fc76a1b0b95dd49cb4a582df7d27c9">select</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:ad5fc76a1b0b95dd49cb4a582df7d27c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:ad5fc76a1b0b95dd49cb4a582df7d27c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc79f18fa5428a052dd78e20315edbe"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:adbc79f18fa5428a052dd78e20315edbe"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#adbc79f18fa5428a052dd78e20315edbe">select</a> (const collection_t &amp;source, const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:adbc79f18fa5428a052dd78e20315edbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:adbc79f18fa5428a052dd78e20315edbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ad86117307c5c516ea6ed8b9ad2ab9"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a34ad86117307c5c516ea6ed8b9ad2ab9"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a34ad86117307c5c516ea6ed8b9ad2ab9">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a34ad86117307c5c516ea6ed8b9ad2ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a34ad86117307c5c516ea6ed8b9ad2ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57432770d30b0537eab55c627fa2220a"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a57432770d30b0537eab55c627fa2220a"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a57432770d30b0537eab55c627fa2220a">select</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a57432770d30b0537eab55c627fa2220a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a57432770d30b0537eab55c627fa2220a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f64fa34add18aae9985c6ee188127a"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a71f64fa34add18aae9985c6ee188127a"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a71f64fa34add18aae9985c6ee188127a">select</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a71f64fa34add18aae9985c6ee188127a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a71f64fa34add18aae9985c6ee188127a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8719ba9ed3e04fbdf25f7a526f4816f0"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a8719ba9ed3e04fbdf25f7a526f4816f0"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8719ba9ed3e04fbdf25f7a526f4816f0">select</a> (const collection_t &amp;source, const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a8719ba9ed3e04fbdf25f7a526f4816f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a8719ba9ed3e04fbdf25f7a526f4816f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bfa34756082bb9a787351079270309"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a73bfa34756082bb9a787351079270309"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a73bfa34756082bb9a787351079270309">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a73bfa34756082bb9a787351079270309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a73bfa34756082bb9a787351079270309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77e79912b5e22a2e85f501db226b888"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:af77e79912b5e22a2e85f501db226b888"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888">to_list</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:af77e79912b5e22a2e85f501db226b888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:af77e79912b5e22a2e85f501db226b888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a796001ef023b9a4130643de678ee1"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a39a796001ef023b9a4130643de678ee1"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a39a796001ef023b9a4130643de678ee1">to_list</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:a39a796001ef023b9a4130643de678ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an std::initializer_list &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a39a796001ef023b9a4130643de678ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56d7345bb6c56ad7b55b25518e84ae1"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:af56d7345bb6c56ad7b55b25518e84ae1"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af56d7345bb6c56ad7b55b25518e84ae1">to_list</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:af56d7345bb6c56ad7b55b25518e84ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an collection_t.  <br /></td></tr>
<tr class="separator:af56d7345bb6c56ad7b55b25518e84ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4c298b0cc2654d7b726859f52f4341"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a3c4c298b0cc2654d7b726859f52f4341"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3c4c298b0cc2654d7b726859f52f4341">to_list</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a3c4c298b0cc2654d7b726859f52f4341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from iterators.  <br /></td></tr>
<tr class="separator:a3c4c298b0cc2654d7b726859f52f4341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3223a01902cf99aae7fc1b8cde4dc01a"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a3223a01902cf99aae7fc1b8cde4dc01a"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3223a01902cf99aae7fc1b8cde4dc01a">where</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a3223a01902cf99aae7fc1b8cde4dc01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a3223a01902cf99aae7fc1b8cde4dc01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd6fae98925142e277c2bbcc8792965"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a7bd6fae98925142e277c2bbcc8792965"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a7bd6fae98925142e277c2bbcc8792965">where</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a7bd6fae98925142e277c2bbcc8792965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a7bd6fae98925142e277c2bbcc8792965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c54fb1a05b506f45c27b1782a471e2f"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a1c54fb1a05b506f45c27b1782a471e2f"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a1c54fb1a05b506f45c27b1782a471e2f">where</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a1c54fb1a05b506f45c27b1782a471e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a1c54fb1a05b506f45c27b1782a471e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8614930d54480bc34cce78794f288153"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a8614930d54480bc34cce78794f288153"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8614930d54480bc34cce78794f288153">where</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a8614930d54480bc34cce78794f288153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a8614930d54480bc34cce78794f288153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab629183c65b1df09aad43f485996075a"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ab629183c65b1df09aad43f485996075a"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab629183c65b1df09aad43f485996075a">where</a> (const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ab629183c65b1df09aad43f485996075a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:ab629183c65b1df09aad43f485996075a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5410f234e6f9d4c54ed784e7bbb30a5"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ab5410f234e6f9d4c54ed784e7bbb30a5"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab5410f234e6f9d4c54ed784e7bbb30a5">where</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ab5410f234e6f9d4c54ed784e7bbb30a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:ab5410f234e6f9d4c54ed784e7bbb30a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0617dad743646a7a13dd53da84d90749"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a0617dad743646a7a13dd53da84d90749"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0617dad743646a7a13dd53da84d90749">where</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a0617dad743646a7a13dd53da84d90749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a0617dad743646a7a13dd53da84d90749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2d7efd8e24b23e2498da91ae0def90"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a8d2d7efd8e24b23e2498da91ae0def90"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8d2d7efd8e24b23e2498da91ae0def90">where</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a8d2d7efd8e24b23e2498da91ae0def90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a8d2d7efd8e24b23e2498da91ae0def90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2bd1889dc1967c50ef692411dc2c4b92" name="a2bd1889dc1967c50ef692411dc2c4b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd1889dc1967c50ef692411dc2c4b92">&#9670;&#160;</a></span>ienumerable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">xtd::linq::enumerable::ienumerable</a> =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt;type_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the ienumerable value type. </p>

</div>
</div>
<a id="a4ff59be55b7be66d275f28741e2f1f0a" name="a4ff59be55b7be66d275f28741e2f1f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff59be55b7be66d275f28741e2f1f0a">&#9670;&#160;</a></span>list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">xtd::linq::enumerable::list</a> =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt;type_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the list value type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af1b0c29ab9f86199822152226ec0e90d" name="af1b0c29ab9f86199822152226ec0e90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b0c29ab9f86199822152226ec0e90d">&#9670;&#160;</a></span>aggregate() <span class="overload">[1/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.hpp:10</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a73718737f59ecba4bad8c6b5f64b6617" name="a73718737f59ecba4bad8c6b5f64b6617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73718737f59ecba4bad8c6b5f64b6617">&#9670;&#160;</a></span>aggregate() <span class="overload">[2/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a154f1aff8fafef647831bc9554c9b48d" name="a154f1aff8fafef647831bc9554c9b48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154f1aff8fafef647831bc9554c9b48d">&#9670;&#160;</a></span>aggregate() <span class="overload">[3/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5e5e27b4f583424d1e482fff52e132f0" name="a5e5e27b4f583424d1e482fff52e132f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5e27b4f583424d1e482fff52e132f0">&#9670;&#160;</a></span>aggregate() <span class="overload">[4/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = enumerable::aggregate&lt;string&gt;(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    return next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
<div class="ttc" id="anamespacextd_1_1linq_html"><div class="ttname"><a href="namespacextd_1_1linq.html">xtd::linq</a></div><div class="ttdoc">Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).</div><div class="ttdef"><b>Definition</b> enumerable.hpp:27</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad0a294984bf7327f7a8d213e75472a17" name="ad0a294984bf7327f7a8d213e75472a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a294984bf7327f7a8d213e75472a17">&#9670;&#160;</a></span>aggregate() <span class="overload">[5/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;source_t(const source_t&amp;, const source_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6addb7f0841160d9efc1b1b12846ad47" name="a6addb7f0841160d9efc1b1b12846ad47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6addb7f0841160d9efc1b1b12846ad47">&#9670;&#160;</a></span>aggregate() <span class="overload">[6/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;source_t(const source_t&amp;, const source_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab6acc19f96c13e626d8fc69d7bfc14c5" name="ab6acc19f96c13e626d8fc69d7bfc14c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6acc19f96c13e626d8fc69d7bfc14c5">&#9670;&#160;</a></span>aggregate() <span class="overload">[7/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;source_t(const source_t&amp;, const source_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adda77ef769372aed4db74698b6173d74" name="adda77ef769372aed4db74698b6173d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda77ef769372aed4db74698b6173d74">&#9670;&#160;</a></span>aggregate() <span class="overload">[8/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;source_t(const source_t&amp;, const source_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = enumerable::aggregate&lt;string&gt;(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    return next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ada50d6149117beb68a72da3343bd5407" name="ada50d6149117beb68a72da3343bd5407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada50d6149117beb68a72da3343bd5407">&#9670;&#160;</a></span>aggregate() <span class="overload">[9/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
<div class="ttc" id="aclassxtd_1_1array_html"><div class="ttname"><a href="classxtd_1_1array.html">xtd::array</a></div><div class="ttdoc">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...</div><div class="ttdef"><b>Definition</b> array.hpp:58</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a22f3540f62b3b6140ecf188faf509842"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">xtd::collections::generic::extensions::enumerable::aggregate</a></div><div class="ttdeci">source_t aggregate(const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;func) const</div><div class="ttdoc">Applies an accumulator function over a sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:54</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a02801dad8993626dcd7c2b7cc1fc4fec" name="a02801dad8993626dcd7c2b7cc1fc4fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02801dad8993626dcd7c2b7cc1fc4fec">&#9670;&#160;</a></span>aggregate() <span class="overload">[10/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab1bdd7a08b78efc2a7debbb7f69a7e02" name="ab1bdd7a08b78efc2a7debbb7f69a7e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bdd7a08b78efc2a7debbb7f69a7e02">&#9670;&#160;</a></span>aggregate() <span class="overload">[11/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab46b4f242688699339f4b391055a6e72" name="ab46b4f242688699339f4b391055a6e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46b4f242688699339f4b391055a6e72">&#9670;&#160;</a></span>aggregate() <span class="overload">[12/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_af1b0c29ab9f86199822152226ec0e90d"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">xtd::linq::enumerable::aggregate</a></div><div class="ttdeci">static source_t aggregate(const ienumerable&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;func)</div><div class="ttdoc">Applies an accumulator function over a sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:74</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab0486add1c7f960d10c282c70f79b910" name="ab0486add1c7f960d10c282c70f79b910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0486add1c7f960d10c282c70f79b910">&#9670;&#160;</a></span>aggregate() <span class="overload">[13/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename source_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4103c8e700221902e26628caca127a15" name="a4103c8e700221902e26628caca127a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4103c8e700221902e26628caca127a15">&#9670;&#160;</a></span>aggregate() <span class="overload">[14/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename source_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a50f264b52a622ec32100c5a9ade3500c" name="a50f264b52a622ec32100c5a9ade3500c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f264b52a622ec32100c5a9ade3500c">&#9670;&#160;</a></span>aggregate() <span class="overload">[15/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename collection_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3b7e4b4e77fe80020fafce9b60441061" name="a3b7e4b4e77fe80020fafce9b60441061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7e4b4e77fe80020fafce9b60441061">&#9670;&#160;</a></span>aggregate() <span class="overload">[16/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename input_iterator_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6f79a4291dee3441cb093eb09c26c36f" name="a6f79a4291dee3441cb093eb09c26c36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f79a4291dee3441cb093eb09c26c36f">&#9670;&#160;</a></span>aggregate() <span class="overload">[17/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename accumulate_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_a4cc6be7fa93346c34256fb76e6dc4b3a"><div class="ttname"><a href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">xtd::basic_string::to_upper</a></div><div class="ttdeci">basic_string to_upper() const noexcept</div><div class="ttdoc">Returns a copy of the current xtd::basic_string converted to uppercase.</div><div class="ttdef"><b>Definition</b> basic_string.hpp:1953</div></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_aabfeb876a8fb51c80fa9adaa3663f232"><div class="ttname"><a href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">xtd::basic_string::length</a></div><div class="ttdeci">size_type length() const noexcept</div><div class="ttdoc">Gets the number of characters in the current xtd::basic_string object.</div><div class="ttdef"><b>Definition</b> basic_string.hpp:918</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abfd2e96cc0f12d577728c54cdbba34e5" name="abfd2e96cc0f12d577728c54cdbba34e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd2e96cc0f12d577728c54cdbba34e5">&#9670;&#160;</a></span>aggregate() <span class="overload">[18/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename accumulate_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aadc1c09dd640d49cf46e47315353ed18" name="aadc1c09dd640d49cf46e47315353ed18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc1c09dd640d49cf46e47315353ed18">&#9670;&#160;</a></span>aggregate() <span class="overload">[19/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename accumulate_t , typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab86311e56c9cda909d08cdabdcf472b5" name="ab86311e56c9cda909d08cdabdcf472b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86311e56c9cda909d08cdabdcf472b5">&#9670;&#160;</a></span>aggregate() <span class="overload">[20/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename accumulate_t , typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2f8a07a5065fd13376fe11b875d2351e" name="a2f8a07a5065fd13376fe11b875d2351e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8a07a5065fd13376fe11b875d2351e">&#9670;&#160;</a></span>aggregate() <span class="overload">[21/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename accumulate_t , typename source_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">result_selector_t</td><td>The type of the result selector function as std::function&lt;result_t(const accumulate_t&amp;)&gt;. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a68cadb72337035e42730b10e0a57803f" name="a68cadb72337035e42730b10e0a57803f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cadb72337035e42730b10e0a57803f">&#9670;&#160;</a></span>aggregate() <span class="overload">[22/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename accumulate_t , typename source_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
    <tr><td class="paramname">result_selector_t</td><td>The type of the result selector function as std::function&lt;result_t(const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1b6e9be709bf0d6bfb742135409e193c" name="a1b6e9be709bf0d6bfb742135409e193c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6e9be709bf0d6bfb742135409e193c">&#9670;&#160;</a></span>aggregate() <span class="overload">[23/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename accumulate_t , typename collection_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
    <tr><td class="paramname">result_selector_t</td><td>The type of the result selector function as std::function&lt;result_t(const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2f1fb529106403a96744a6f0e409179c" name="a2f1fb529106403a96744a6f0e409179c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1fb529106403a96744a6f0e409179c">&#9670;&#160;</a></span>aggregate() <span class="overload">[24/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename accumulate_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
    <tr><td class="paramname">result_selector_t</td><td>The type of the result selector function as std::function&lt;result_t(const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae7ee26584bc2b6d5ef6ef80e0016eccf" name="ae7ee26584bc2b6d5ef6ef80e0016eccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ee26584bc2b6d5ef6ef80e0016eccf">&#9670;&#160;</a></span>aggregate() <span class="overload">[25/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename source_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
    <tr><td class="paramname">result_selector_t</td><td>The type of the result selector function as std::function&lt;result_t(const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a15166396187c1a938680f6a1316b100b" name="a15166396187c1a938680f6a1316b100b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15166396187c1a938680f6a1316b100b">&#9670;&#160;</a></span>aggregate() <span class="overload">[26/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename source_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
    <tr><td class="paramname">result_selector_t</td><td>The type of the result selector function as std::function&lt;result_t(const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0d3218c9c234c742982c4d85953286b9" name="a0d3218c9c234c742982c4d85953286b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3218c9c234c742982c4d85953286b9">&#9670;&#160;</a></span>aggregate() <span class="overload">[27/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename collection_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
    <tr><td class="paramname">result_selector_t</td><td>The type of the result selector function as std::function&lt;result_t(const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2f7ca162d5d735492ed63bc2d1f076fd" name="a2f7ca162d5d735492ed63bc2d1f076fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7ca162d5d735492ed63bc2d1f076fd">&#9670;&#160;</a></span>aggregate() <span class="overload">[28/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
    <tr><td class="paramname">func_t</td><td>The type of the function as std::function&lt;accumulate_t(const source_t&amp;, const accumulate_t&amp;)&gt;. </td></tr>
    <tr><td class="paramname">result_selector_t</td><td>The type of the result selector function as std::function&lt;result_t(const accumulate_t&amp;)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af1b0c29ab9f86199822152226ec0e90d">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a26f22da0fbdff4367e59968b136a2844" name="a26f22da0fbdff4367e59968b136a2844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f22da0fbdff4367e59968b136a2844">&#9670;&#160;</a></span>all() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a8c344a4319826da54bae2611d78f7e41"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">xtd::collections::generic::extensions::enumerable::all</a></div><div class="ttdeci">bool all(const std::function&lt; bool(const source_t &amp;)&gt; &amp;predicate) const</div><div class="ttdoc">Determines whether all elements of a sequence satisfy a condition.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:145</div></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:42</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a00c0f58808d470666722b1d3a40ed8c4" name="a00c0f58808d470666722b1d3a40ed8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c0f58808d470666722b1d3a40ed8c4">&#9670;&#160;</a></span>all() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af5d2b50122ac7429831299a556be7efa" name="af5d2b50122ac7429831299a556be7efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d2b50122ac7429831299a556be7efa">&#9670;&#160;</a></span>all() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8fd7b35aaebdbea8331a5aaeea8cad9c" name="a8fd7b35aaebdbea8331a5aaeea8cad9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd7b35aaebdbea8331a5aaeea8cad9c">&#9670;&#160;</a></span>all() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa91f9e006465da4a57f64338c49b9eb2" name="aa91f9e006465da4a57f64338c49b9eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91f9e006465da4a57f64338c49b9eb2">&#9670;&#160;</a></span>all() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab5ec7f29327dfa3a235e192a697f88b7" name="ab5ec7f29327dfa3a235e192a697f88b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ec7f29327dfa3a235e192a697f88b7">&#9670;&#160;</a></span>all() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3bca3810844c7f42e4bb3f09c1b3820b" name="a3bca3810844c7f42e4bb3f09c1b3820b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bca3810844c7f42e4bb3f09c1b3820b">&#9670;&#160;</a></span>all() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = enumerable::all&lt;pet&gt;(pets.begin(), pets.end(), [](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    return pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3ff1ae119439eb346f435f375d6ca74d" name="a3ff1ae119439eb346f435f375d6ca74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff1ae119439eb346f435f375d6ca74d">&#9670;&#160;</a></span>any() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to check for emptiness. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.any();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_a4ff59be55b7be66d275f28741e2f1f0a"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">xtd::linq::enumerable::list</a></div><div class="ttdeci">typename xtd::collections::generic::list&lt; type_t &gt; list</div><div class="ttdoc">Represents the list value type.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:59</div></div>
<div class="ttc" id="anamespacextd_1_1collections_1_1generic_html"><div class="ttname"><a href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a></div><div class="ttdoc">The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...</div><div class="ttdef"><b>Definition</b> comparer.hpp:15</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a01ae8e0e45fb40cc7ae0c58bb2eb4dc6" name="a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ae8e0e45fb40cc7ae0c58bb2eb4dc6">&#9670;&#160;</a></span>any() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to check for emptiness. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.any();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa5fca6b9d7bc049f1eef56457c17a2bf" name="aa5fca6b9d7bc049f1eef56457c17a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fca6b9d7bc049f1eef56457c17a2bf">&#9670;&#160;</a></span>any() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The collection_t to check for emptiness. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.any();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5200b0bf55e0d4ca3bd76e300b34a3ca" name="a5200b0bf55e0d4ca3bd76e300b34a3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5200b0bf55e0d4ca3bd76e300b34a3ca">&#9670;&#160;</a></span>any() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.any();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a40eecec336b27b17378a85e7643de786" name="a40eecec336b27b17378a85e7643de786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40eecec336b27b17378a85e7643de786">&#9670;&#160;</a></span>any() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae1588879c5bede53fb6e8c3329138971" name="ae1588879c5bede53fb6e8c3329138971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1588879c5bede53fb6e8c3329138971">&#9670;&#160;</a></span>any() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2270a08fffe2f4cce7944d2a77e21202" name="a2270a08fffe2f4cce7944d2a77e21202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2270a08fffe2f4cce7944d2a77e21202">&#9670;&#160;</a></span>any() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5f332f87f28c6c9ea9e7df729ed3d3b7" name="a5f332f87f28c6c9ea9e7df729ed3d3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f332f87f28c6c9ea9e7df729ed3d3b7">&#9670;&#160;</a></span>any() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a426fee4903820f2b103702eb1d5f36d9" name="a426fee4903820f2b103702eb1d5f36d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426fee4903820f2b103702eb1d5f36d9">&#9670;&#160;</a></span>any() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a782315b34c17c5bebb5e00277a8fe0c3" name="a782315b34c17c5bebb5e00277a8fe0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782315b34c17c5bebb5e00277a8fe0c3">&#9670;&#160;</a></span>any() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad4b3479936dce019d229f63ae01b51c5" name="ad4b3479936dce019d229f63ae01b51c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b3479936dce019d229f63ae01b51c5">&#9670;&#160;</a></span>any() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = enumerable::all&lt;pet&gt;(pets.begin(), pets.end(), [](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    return pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abc66d0a2d96e7aa7f5a3569e5dbb40dd" name="abc66d0a2d96e7aa7f5a3569e5dbb40dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc66d0a2d96e7aa7f5a3569e5dbb40dd">&#9670;&#160;</a></span>append() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.append(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_a8a7a51d0792107dd537730634b8fff12"><div class="ttname"><a href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">xtd::basic_string::join</a></div><div class="ttdeci">static basic_string join(const basic_string separator, const collection_t &amp;values) noexcept</div><div class="ttdoc">Concatenates a specified separator basic_string between each element of a specified object array,...</div><div class="ttdef"><b>Definition</b> basic_string.hpp:2296</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a03000d97b38af9e8af2a8698206ece9f" name="a03000d97b38af9e8af2a8698206ece9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03000d97b38af9e8af2a8698206ece9f">&#9670;&#160;</a></span>append() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.append(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a38e4ce55897fc6b4c49534500296ad3c" name="a38e4ce55897fc6b4c49534500296ad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e4ce55897fc6b4c49534500296ad3c">&#9670;&#160;</a></span>append() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.append(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a38caca4975ab5f85f5c5858a44ecffba" name="a38caca4975ab5f85f5c5858a44ecffba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38caca4975ab5f85f5c5858a44ecffba">&#9670;&#160;</a></span>append() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#abc66d0a2d96e7aa7f5a3569e5dbb40dd">enumerable::append</a>(numbers.begin(), numbers.end(), 5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#abc66d0a2d96e7aa7f5a3569e5dbb40dd">enumerable::append</a>(numbers.begin(), numbers.end(), 5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#abc66d0a2d96e7aa7f5a3569e5dbb40dd">enumerable::append</a>(numbers.begin(), numbers.end(), 5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_abc66d0a2d96e7aa7f5a3569e5dbb40dd"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html#abc66d0a2d96e7aa7f5a3569e5dbb40dd">xtd::linq::enumerable::append</a></div><div class="ttdeci">static const ienumerable&lt; source_t &gt; &amp; append(const ienumerable&lt; source_t &gt; &amp;source, const source_t &amp;element) noexcept</div><div class="ttdoc">Appends a value to the end of the sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:812</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a844b07197f3c4238071667d89cecc032" name="a844b07197f3c4238071667d89cecc032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844b07197f3c4238071667d89cecc032">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7ccec3ba16804c51bb5e6f7597b9c28e" name="a7ccec3ba16804c51bb5e6f7597b9c28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccec3ba16804c51bb5e6f7597b9c28e">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af90ec21b4abacec8eb0e29071f8efc97" name="af90ec21b4abacec8eb0e29071f8efc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90ec21b4abacec8eb0e29071f8efc97">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0a9518817b1581ae817e402b740bbb1f" name="a0a9518817b1581ae817e402b740bbb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9518817b1581ae817e402b740bbb1f">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0f45e5466740ff18c1f2dff890e6c457" name="a0f45e5466740ff18c1f2dff890e6c457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f45e5466740ff18c1f2dff890e6c457">&#9670;&#160;</a></span>average() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ece176030f8975cde72309753d32cb1" name="a6ece176030f8975cde72309753d32cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ece176030f8975cde72309753d32cb1">&#9670;&#160;</a></span>average() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of double values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcf18abab93837198d91f64e19fc7c04" name="abcf18abab93837198d91f64e19fc7c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf18abab93837198d91f64e19fc7c04">&#9670;&#160;</a></span>average() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of float values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of float values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3db01ef4dcc146706ace27163a88c9ef" name="a3db01ef4dcc146706ace27163a88c9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db01ef4dcc146706ace27163a88c9ef">&#9670;&#160;</a></span>average() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79f5e2995a613c7cd21a3a70d2725fa0" name="a79f5e2995a613c7cd21a3a70d2725fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f5e2995a613c7cd21a3a70d2725fa0">&#9670;&#160;</a></span>average() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cb1f246d0c1d7fcc244c109f932ee2a" name="a2cb1f246d0c1d7fcc244c109f932ee2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb1f246d0c1d7fcc244c109f932ee2a">&#9670;&#160;</a></span>average() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="ab99a80b764c342e0b097e6640693480d" name="ab99a80b764c342e0b097e6640693480d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99a80b764c342e0b097e6640693480d">&#9670;&#160;</a></span>average() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional double values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a25ea28ac2b9dade8ec13d986d19c8cf3" name="a25ea28ac2b9dade8ec13d986d19c8cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ea28ac2b9dade8ec13d986d19c8cf3">&#9670;&#160;</a></span>average() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional float values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional float values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a5ba45526a72fc218f272d378a69322d7" name="a5ba45526a72fc218f272d378a69322d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba45526a72fc218f272d378a69322d7">&#9670;&#160;</a></span>average() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="ad22ecd327aae18433bb93f8b07a270ee" name="ad22ecd327aae18433bb93f8b07a270ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22ecd327aae18433bb93f8b07a270ee">&#9670;&#160;</a></span>average() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a2663a00546187353ff418c180d976687" name="a2663a00546187353ff418c180d976687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2663a00546187353ff418c180d976687">&#9670;&#160;</a></span>cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the elements of an xtd::collection::generic::ienumerable to the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The xtd::collection::generic::ienumerable that contains the elements to be cast to type <code>result_t</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An xtd::collection::generic::ienumerable &lt;type_t&gt; that contains each element of the source sequence cast to the specified type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__cast__exception.html" title="The exception that is thrown for invalid casting or explicit conversion.">xtd::invalid_cast_exception</a></td><td>An element in the sequence cannot be cast to type `result_t`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="group__xtd__core.html#ga7950c22da6547a30812729fb21dcbea7" title="Casts a type into another type.">xtd::as</a> include file <code>#include &lt;xtd/as&gt;</code> is needeed to use this method. </dd></dl>

</div>
</div>
<a id="ae9fda8b1ce0b4478fb8ae17ae0844955" name="ae9fda8b1ce0b4478fb8ae17ae0844955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fda8b1ce0b4478fb8ae17ae0844955">&#9670;&#160;</a></span>cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::cast </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the elements of an xtd::collection::generic::ienumerable to the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The xtd::collection::generic::ienumerable that contains the elements to be cast to type <code>result_t</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An xtd::collection::generic::ienumerable &lt;type_t&gt; that contains each element of the source sequence cast to the specified type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__cast__exception.html" title="The exception that is thrown for invalid casting or explicit conversion.">xtd::invalid_cast_exception</a></td><td>An element in the sequence cannot be cast to type `result_t`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="group__xtd__core.html#ga7950c22da6547a30812729fb21dcbea7" title="Casts a type into another type.">xtd::as</a> include file <code>#include &lt;xtd/as&gt;</code> is needeed to use this method. </dd></dl>

</div>
</div>
<a id="afe89b24fc447af7a381f5b0db1903746" name="afe89b24fc447af7a381f5b0db1903746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe89b24fc447af7a381f5b0db1903746">&#9670;&#160;</a></span>cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::cast </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the elements of an xtd::collection::generic::ienumerable to the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The xtd::collection::generic::ienumerable that contains the elements to be cast to type <code>result_t</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An xtd::collection::generic::ienumerable &lt;type_t&gt; that contains each element of the source sequence cast to the specified type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__cast__exception.html" title="The exception that is thrown for invalid casting or explicit conversion.">xtd::invalid_cast_exception</a></td><td>An element in the sequence cannot be cast to type `result_t`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="group__xtd__core.html#ga7950c22da6547a30812729fb21dcbea7" title="Casts a type into another type.">xtd::as</a> include file <code>#include &lt;xtd/as&gt;</code> is needeed to use this method. </dd></dl>

</div>
</div>
<a id="afddbbe92bc30ea895ecef930419897c9" name="afddbbe92bc30ea895ecef930419897c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddbbe92bc30ea895ecef930419897c9">&#9670;&#160;</a></span>cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::cast </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the elements of an xtd::collection::generic::ienumerable to the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The xtd::collection::generic::ienumerable that contains the elements to be cast to type <code>result_t</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An xtd::collection::generic::ienumerable &lt;type_t&gt; that contains each element of the source sequence cast to the specified type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__cast__exception.html" title="The exception that is thrown for invalid casting or explicit conversion.">xtd::invalid_cast_exception</a></td><td>An element in the sequence cannot be cast to type `result_t`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="group__xtd__core.html#ga7950c22da6547a30812729fb21dcbea7" title="Casts a type into another type.">xtd::as</a> include file <code>#include &lt;xtd/as&gt;</code> is needeed to use this method. </dd></dl>

</div>
</div>
<a id="a84b247a0e769fe8eed5a37b3ab4e44fd" name="a84b247a0e769fe8eed5a37b3ab4e44fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b247a0e769fe8eed5a37b3ab4e44fd">&#9670;&#160;</a></span>first_or_default() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a00609035e3d3a3cdec40b3d9a8215af6" name="a00609035e3d3a3cdec40b3d9a8215af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00609035e3d3a3cdec40b3d9a8215af6">&#9670;&#160;</a></span>first_or_default() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a20e96859c92065e17479eca6ebe565f6" name="a20e96859c92065e17479eca6ebe565f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e96859c92065e17479eca6ebe565f6">&#9670;&#160;</a></span>first_or_default() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="abb896f9df08594d736bd887ac932f5c6" name="abb896f9df08594d736bd887ac932f5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb896f9df08594d736bd887ac932f5c6">&#9670;&#160;</a></span>first_or_default() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="adaf71c1af3ba82f0df36809f98b58132" name="adaf71c1af3ba82f0df36809f98b58132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf71c1af3ba82f0df36809f98b58132">&#9670;&#160;</a></span>first_or_default() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="afc4e18397ef1ea198e2b022f2fa6b271" name="afc4e18397ef1ea198e2b022f2fa6b271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4e18397ef1ea198e2b022f2fa6b271">&#9670;&#160;</a></span>first_or_default() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a752542e2accb3781e99880a6ca89db05" name="a752542e2accb3781e99880a6ca89db05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752542e2accb3781e99880a6ca89db05">&#9670;&#160;</a></span>first_or_default() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a6be82a0004d9317cfbe44a8759efa6f3" name="a6be82a0004d9317cfbe44a8759efa6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be82a0004d9317cfbe44a8759efa6f3">&#9670;&#160;</a></span>first_or_default() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a92ab3f630eeaa5b8baa65bd53f4dd1d2" name="a92ab3f630eeaa5b8baa65bd53f4dd1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ab3f630eeaa5b8baa65bd53f4dd1d2">&#9670;&#160;</a></span>first_or_default() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="acdbe3f710d98adf47db973ae01b0220e" name="acdbe3f710d98adf47db973ae01b0220e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbe3f710d98adf47db973ae01b0220e">&#9670;&#160;</a></span>first_or_default() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="ae6ebabc65a26f263c61c446dbef009b3" name="ae6ebabc65a26f263c61c446dbef009b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ebabc65a26f263c61c446dbef009b3">&#9670;&#160;</a></span>first_or_default() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="ae71c11e30879c9af8531c855b5eb8088" name="ae71c11e30879c9af8531c855b5eb8088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71c11e30879c9af8531c855b5eb8088">&#9670;&#160;</a></span>first_or_default() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="af14ce27216bdbb95d8c1bd14dfee5e40" name="af14ce27216bdbb95d8c1bd14dfee5e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14ce27216bdbb95d8c1bd14dfee5e40">&#9670;&#160;</a></span>first_or_default() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a43a3310b7497b5ab2593a9d401a4bf7a" name="a43a3310b7497b5ab2593a9d401a4bf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a3310b7497b5ab2593a9d401a4bf7a">&#9670;&#160;</a></span>first_or_default() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a0e0922997a0fda313f2c308ece6841ac" name="a0e0922997a0fda313f2c308ece6841ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0922997a0fda313f2c308ece6841ac">&#9670;&#160;</a></span>first_or_default() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a8ef9173ba49b6d1ce79a2aa72d5d781a" name="a8ef9173ba49b6d1ce79a2aa72d5d781a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef9173ba49b6d1ce79a2aa72d5d781a">&#9670;&#160;</a></span>first_or_default() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="abab37948dddc316f841ba3a1c087cc41" name="abab37948dddc316f841ba3a1c087cc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab37948dddc316f841ba3a1c087cc41">&#9670;&#160;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp; xtd::linq::enumerable::range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of integral numbers within a specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The value of the first integer in the sequence. </td></tr>
    <tr><td class="paramname">count</td><td>The number of sequential integers to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An xtd::collection::generic::ienumerable &lt;<a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a>&gt; that contains a range of sequential integral numbers. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`count` is less than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#abab37948dddc316f841ba3a1c087cc41" title="Generates a sequence of integral numbers within a specified range.">xtd::linq::enumerable::range</a> to generate a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2085b7c27b0cfc0902baba251aca3409" name="a2085b7c27b0cfc0902baba251aca3409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2085b7c27b0cfc0902baba251aca3409">&#9670;&#160;</a></span>select() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6bdcc2b59b57857dc0d7f6497e94681e" name="a6bdcc2b59b57857dc0d7f6497e94681e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdcc2b59b57857dc0d7f6497e94681e">&#9670;&#160;</a></span>select() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a598633727f61c78112a4049001f21d43" name="a598633727f61c78112a4049001f21d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598633727f61c78112a4049001f21d43">&#9670;&#160;</a></span>select() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a88ab941b504b5593ae0c397ef2946e95" name="a88ab941b504b5593ae0c397ef2946e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ab941b504b5593ae0c397ef2946e95">&#9670;&#160;</a></span>select() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6e0ff78cef1a4897bb2b19cf68385b09" name="a6e0ff78cef1a4897bb2b19cf68385b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0ff78cef1a4897bb2b19cf68385b09">&#9670;&#160;</a></span>select() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a95f5a6ce9d439bcd73d159513a21e617" name="a95f5a6ce9d439bcd73d159513a21e617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f5a6ce9d439bcd73d159513a21e617">&#9670;&#160;</a></span>select() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aaf19b7fc82fabb29d9f614901fb5e326" name="aaf19b7fc82fabb29d9f614901fb5e326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf19b7fc82fabb29d9f614901fb5e326">&#9670;&#160;</a></span>select() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8b17c26a22158b3b08c85fdbc947c4a3" name="a8b17c26a22158b3b08c85fdbc947c4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b17c26a22158b3b08c85fdbc947c4a3">&#9670;&#160;</a></span>select() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a771aa96d8dd12d6835b54f03fe183db2" name="a771aa96d8dd12d6835b54f03fe183db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771aa96d8dd12d6835b54f03fe183db2">&#9670;&#160;</a></span>select() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
<div class="ttc" id="aclassxtd_1_1console_html"><div class="ttname"><a href="classxtd_1_1console.html">xtd::console</a></div><div class="ttdoc">Represents the standard input, output, and error streams for console applications.</div><div class="ttdef"><b>Definition</b> console.hpp:36</div></div>
<div class="ttc" id="agroup__xtd__core_html_gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb"><div class="ttname"><a href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">xtd::uri_components::query</a></div><div class="ttdeci">@ query</div><div class="ttdoc">The xtd::uri::query data.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad5fc76a1b0b95dd49cb4a582df7d27c9" name="ad5fc76a1b0b95dd49cb4a582df7d27c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fc76a1b0b95dd49cb4a582df7d27c9">&#9670;&#160;</a></span>select() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adbc79f18fa5428a052dd78e20315edbe" name="adbc79f18fa5428a052dd78e20315edbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc79f18fa5428a052dd78e20315edbe">&#9670;&#160;</a></span>select() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a34ad86117307c5c516ea6ed8b9ad2ab9" name="a34ad86117307c5c516ea6ed8b9ad2ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ad86117307c5c516ea6ed8b9ad2ab9">&#9670;&#160;</a></span>select() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a57432770d30b0537eab55c627fa2220a" name="a57432770d30b0537eab55c627fa2220a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57432770d30b0537eab55c627fa2220a">&#9670;&#160;</a></span>select() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a71f64fa34add18aae9985c6ee188127a" name="a71f64fa34add18aae9985c6ee188127a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f64fa34add18aae9985c6ee188127a">&#9670;&#160;</a></span>select() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8719ba9ed3e04fbdf25f7a526f4816f0" name="a8719ba9ed3e04fbdf25f7a526f4816f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8719ba9ed3e04fbdf25f7a526f4816f0">&#9670;&#160;</a></span>select() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a73bfa34756082bb9a787351079270309" name="a73bfa34756082bb9a787351079270309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bfa34756082bb9a787351079270309">&#9670;&#160;</a></span>select() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2085b7c27b0cfc0902baba251aca3409" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af77e79912b5e22a2e85f501db226b888" name="af77e79912b5e22a2e85f501db226b888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77e79912b5e22a2e85f501db226b888">&#9670;&#160;</a></span>to_list() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> include file <code>#include &lt;xtd/collections/generic/lists&gt;</code> is needeed to use this method. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a xtd::collection::generic::list &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;size_t&gt;</a> lengths = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a69ca739f420b3ddd4df01845ce9bd979">select</a>&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).<a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888">to_list</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> length : lengths)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(length);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a69ca739f420b3ddd4df01845ce9bd979"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a69ca739f420b3ddd4df01845ce9bd979">xtd::collections::generic::extensions::enumerable::select</a></div><div class="ttdeci">const ienumerable&lt; result_t &gt; &amp; select(const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector) const</div><div class="ttdoc">Projects each element of a sequence into a new form.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:238</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1list_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a></div><div class="ttdoc">Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...</div><div class="ttdef"><b>Definition</b> list.hpp:71</div></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_af77e79912b5e22a2e85f501db226b888"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888">xtd::linq::enumerable::to_list</a></div><div class="ttdeci">static const list&lt; source_t &gt; &amp; to_list(const ienumerable&lt; source_t &gt; &amp;source) noexcept</div><div class="ttdoc">Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a39a796001ef023b9a4130643de678ee1" name="a39a796001ef023b9a4130643de678ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a796001ef023b9a4130643de678ee1">&#9670;&#160;</a></span>to_list() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">list</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an std::initializer_list &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The std::initializer_list &lt;type_t&gt; to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> include file <code>#include &lt;xtd/collections/generic/lists&gt;</code> is needeed to use this method. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a xtd::collection::generic::list &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;size_t&gt;</a> lengths = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a69ca739f420b3ddd4df01845ce9bd979">select</a>&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).<a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888">to_list</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> length : lengths)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(length);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af56d7345bb6c56ad7b55b25518e84ae1" name="af56d7345bb6c56ad7b55b25518e84ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56d7345bb6c56ad7b55b25518e84ae1">&#9670;&#160;</a></span>to_list() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an collection_t. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The collection_t to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> include file <code>#include &lt;xtd/collections/generic/lists&gt;</code> is needeed to use this method. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a xtd::collection::generic::list &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;size_t&gt;</a> lengths = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a69ca739f420b3ddd4df01845ce9bd979">select</a>&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).<a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888">to_list</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> length : lengths)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(length);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3c4c298b0cc2654d7b726859f52f4341" name="a3c4c298b0cc2654d7b726859f52f4341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4c298b0cc2654d7b726859f52f4341">&#9670;&#160;</a></span>to_list() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> include file <code>#include &lt;xtd/collections/generic/lists&gt;</code> is needeed to use this method. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a xtd::collection::generic::list &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;size_t&gt;</a> lengths = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a69ca739f420b3ddd4df01845ce9bd979">select</a>&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).<a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#af77e79912b5e22a2e85f501db226b888">to_list</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> length : lengths)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(length);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3223a01902cf99aae7fc1b8cde4dc01a" name="a3223a01902cf99aae7fc1b8cde4dc01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3223a01902cf99aae7fc1b8cde4dc01a">&#9670;&#160;</a></span>where() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3223a01902cf99aae7fc1b8cde4dc01a" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;string&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a>([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a669773bec96bcfe7a5b4f43068892620"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">xtd::collections::generic::extensions::enumerable::where</a></div><div class="ttdeci">const ienumerable&lt; source_t &gt; &amp; where(const std::function&lt; bool(const source_t &amp;)&gt; &amp;predicate) const</div><div class="ttdoc">Filters a sequence of values based on a predicate.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:287</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1ienumerable_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a></div><div class="ttdoc">Exposes the enumerator, which supports a simple iteration over a collection of a specified type.</div><div class="ttdef"><b>Definition</b> ienumerable.hpp:36</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7bd6fae98925142e277c2bbcc8792965" name="a7bd6fae98925142e277c2bbcc8792965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd6fae98925142e277c2bbcc8792965">&#9670;&#160;</a></span>where() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3223a01902cf99aae7fc1b8cde4dc01a" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;string&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a>([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1c54fb1a05b506f45c27b1782a471e2f" name="a1c54fb1a05b506f45c27b1782a471e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c54fb1a05b506f45c27b1782a471e2f">&#9670;&#160;</a></span>where() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3223a01902cf99aae7fc1b8cde4dc01a" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;string&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a>([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8614930d54480bc34cce78794f288153" name="a8614930d54480bc34cce78794f288153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8614930d54480bc34cce78794f288153">&#9670;&#160;</a></span>where() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3223a01902cf99aae7fc1b8cde4dc01a" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;string&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a>([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab629183c65b1df09aad43f485996075a" name="ab629183c65b1df09aad43f485996075a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab629183c65b1df09aad43f485996075a">&#9670;&#160;</a></span>where() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3223a01902cf99aae7fc1b8cde4dc01a" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, size_t)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;int&gt;</a> numbers = {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;int&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a>([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> &lt;= int(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
<div class="ttc" id="agroup__xtd__core_html_gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df"><div class="ttname"><a href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">xtd::number_styles::number</a></div><div class="ttdeci">@ number</div><div class="ttdoc">Indicates that the allow_leading_white, allow_trailing_white, allow_leading_sign, allow_trailing_sign...</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab5410f234e6f9d4c54ed784e7bbb30a5" name="ab5410f234e6f9d4c54ed784e7bbb30a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5410f234e6f9d4c54ed784e7bbb30a5">&#9670;&#160;</a></span>where() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3223a01902cf99aae7fc1b8cde4dc01a" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, size_t)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;int&gt;</a> numbers = {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;int&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a>([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> &lt;= int(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0617dad743646a7a13dd53da84d90749" name="a0617dad743646a7a13dd53da84d90749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0617dad743646a7a13dd53da84d90749">&#9670;&#160;</a></span>where() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3223a01902cf99aae7fc1b8cde4dc01a" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, size_t)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;int&gt;</a> numbers = {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;int&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a>([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> &lt;= int(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8d2d7efd8e24b23e2498da91ae0def90" name="a8d2d7efd8e24b23e2498da91ae0def90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2d7efd8e24b23e2498da91ae0def90">&#9670;&#160;</a></span>where() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3223a01902cf99aae7fc1b8cde4dc01a" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, size_t)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;int&gt;</a> numbers = {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;int&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a>([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> &lt;= int(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/linq/<a class="el" href="linq_2enumerable_8hpp_source.html">enumerable.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 30 2024 11:17:22 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
