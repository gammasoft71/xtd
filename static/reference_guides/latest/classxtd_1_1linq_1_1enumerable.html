<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::linq::enumerable Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1linq.html">linq</a></li><li class="navelem"><a class="el" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classxtd_1_1linq_1_1enumerable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::linq::enumerable Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__linq.html">linq</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::linq::enumerable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1linq_1_1enumerable.png" usemap="#xtd::linq::enumerable_map" alt=""/>
  <map id="xtd::linq::enumerable_map" name="xtd::linq::enumerable_map">
<area href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted)." alt="xtd::static_object" shape="rect" coords="0,0,125,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> type_t&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1static__object.html">xtd::static_object</a>;</div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html">xtd::linq::enumerable</a></div><div class="ttdoc">Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:62</div></div>
<div class="ttc" id="aclassxtd_1_1static__object_html"><div class="ttname"><a href="classxtd_1_1static__object.html">xtd::static_object</a></div><div class="ttdoc">Represent a static object. A static class can&#39;t be instantiated (constructors are deleted).</div><div class="ttdef"><b>Definition</b> static.hpp:20</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1linq.html" title="Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).">xtd::linq</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:a2ddf87538e12a66991705171183f8d5b" id="r_a2ddf87538e12a66991705171183f8d5b"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:a2ddf87538e12a66991705171183f8d5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ddf87538e12a66991705171183f8d5b">enumerator</a></td></tr>
<tr class="memdesc:a2ddf87538e12a66991705171183f8d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the enumerator value type.  <br /></td></tr>
<tr class="separator:a2ddf87538e12a66991705171183f8d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bbe9fcf3dfc4dae1ad074550a1e37a" id="r_a49bbe9fcf3dfc4dae1ad074550a1e37a"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:a49bbe9fcf3dfc4dae1ad074550a1e37a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49bbe9fcf3dfc4dae1ad074550a1e37a">iequality_comparer</a></td></tr>
<tr class="memdesc:a49bbe9fcf3dfc4dae1ad074550a1e37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:a49bbe9fcf3dfc4dae1ad074550a1e37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd1889dc1967c50ef692411dc2c4b92" id="r_a2bd1889dc1967c50ef692411dc2c4b92"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:a2bd1889dc1967c50ef692411dc2c4b92"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a></td></tr>
<tr class="memdesc:a2bd1889dc1967c50ef692411dc2c4b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:a2bd1889dc1967c50ef692411dc2c4b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff59be55b7be66d275f28741e2f1f0a" id="r_a4ff59be55b7be66d275f28741e2f1f0a"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:a4ff59be55b7be66d275f28741e2f1f0a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ff59be55b7be66d275f28741e2f1f0a">list</a></td></tr>
<tr class="memdesc:a4ff59be55b7be66d275f28741e2f1f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a4ff59be55b7be66d275f28741e2f1f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa2aa9384131fb9d7c0b02830e55050" id="r_acaa2aa9384131fb9d7c0b02830e55050"><td class="memTemplParams" colspan="2">template&lt;class key_t, class value_t&gt; </td></tr>
<tr class="memitem:acaa2aa9384131fb9d7c0b02830e55050"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acaa2aa9384131fb9d7c0b02830e55050">key_value_pair</a></td></tr>
<tr class="memdesc:acaa2aa9384131fb9d7c0b02830e55050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the key value pair value type.  <br /></td></tr>
<tr class="separator:acaa2aa9384131fb9d7c0b02830e55050"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:af1b0c29ab9f86199822152226ec0e90d" id="r_af1b0c29ab9f86199822152226ec0e90d"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:af1b0c29ab9f86199822152226ec0e90d"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1b0c29ab9f86199822152226ec0e90d">aggregate</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>)</td></tr>
<tr class="memdesc:af1b0c29ab9f86199822152226ec0e90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:af1b0c29ab9f86199822152226ec0e90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad298961901a3bb9e64a04b9f4ea2d6ff" id="r_ad298961901a3bb9e64a04b9f4ea2d6ff"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:ad298961901a3bb9e64a04b9f4ea2d6ff"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad298961901a3bb9e64a04b9f4ea2d6ff">aggregate</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;seed, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>)</td></tr>
<tr class="memdesc:ad298961901a3bb9e64a04b9f4ea2d6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ad298961901a3bb9e64a04b9f4ea2d6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada50d6149117beb68a72da3343bd5407" id="r_ada50d6149117beb68a72da3343bd5407"><td class="memTemplParams" colspan="2">template&lt;class accumulate_t, class source_t&gt; </td></tr>
<tr class="memitem:ada50d6149117beb68a72da3343bd5407"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada50d6149117beb68a72da3343bd5407">aggregate</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>)</td></tr>
<tr class="memdesc:ada50d6149117beb68a72da3343bd5407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ada50d6149117beb68a72da3343bd5407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467df4b87b33cbdd30aa1021f0805066" id="r_a467df4b87b33cbdd30aa1021f0805066"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a467df4b87b33cbdd30aa1021f0805066"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a467df4b87b33cbdd30aa1021f0805066">aggregate</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;seed, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:a467df4b87b33cbdd30aa1021f0805066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a467df4b87b33cbdd30aa1021f0805066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f79a4291dee3441cb093eb09c26c36f" id="r_a6f79a4291dee3441cb093eb09c26c36f"><td class="memTemplParams" colspan="2">template&lt;class result_t, class accumulate_t, class source_t&gt; </td></tr>
<tr class="memitem:a6f79a4291dee3441cb093eb09c26c36f"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f79a4291dee3441cb093eb09c26c36f">aggregate</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga17814178399a734d83f7c7ee1ca15365">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:a6f79a4291dee3441cb093eb09c26c36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a6f79a4291dee3441cb093eb09c26c36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f22da0fbdff4367e59968b136a2844" id="r_a26f22da0fbdff4367e59968b136a2844"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a26f22da0fbdff4367e59968b136a2844"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26f22da0fbdff4367e59968b136a2844">all</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>)</td></tr>
<tr class="memdesc:a26f22da0fbdff4367e59968b136a2844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a26f22da0fbdff4367e59968b136a2844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff1ae119439eb346f435f375d6ca74d" id="r_a3ff1ae119439eb346f435f375d6ca74d"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a3ff1ae119439eb346f435f375d6ca74d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ff1ae119439eb346f435f375d6ca74d">any</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a3ff1ae119439eb346f435f375d6ca74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a3ff1ae119439eb346f435f375d6ca74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eecec336b27b17378a85e7643de786" id="r_a40eecec336b27b17378a85e7643de786"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a40eecec336b27b17378a85e7643de786"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40eecec336b27b17378a85e7643de786">any</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>)</td></tr>
<tr class="memdesc:a40eecec336b27b17378a85e7643de786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a40eecec336b27b17378a85e7643de786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16290a393e0688753e2e56ad70780909" id="r_a16290a393e0688753e2e56ad70780909"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a16290a393e0688753e2e56ad70780909"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16290a393e0688753e2e56ad70780909">append</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:a16290a393e0688753e2e56ad70780909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a16290a393e0688753e2e56ad70780909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4742ce7a6c1be25c31ee80f9d8c442e9" id="r_a4742ce7a6c1be25c31ee80f9d8c442e9"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a4742ce7a6c1be25c31ee80f9d8c442e9"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4742ce7a6c1be25c31ee80f9d8c442e9">as_enumerable</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a4742ce7a6c1be25c31ee80f9d8c442e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a4742ce7a6c1be25c31ee80f9d8c442e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75255b2bd38c597f21f211a0b15ef8b" id="r_ad75255b2bd38c597f21f211a0b15ef8b"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:ad75255b2bd38c597f21f211a0b15ef8b"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad75255b2bd38c597f21f211a0b15ef8b">as_enumerable</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:ad75255b2bd38c597f21f211a0b15ef8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ad75255b2bd38c597f21f211a0b15ef8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76de508f19e5b67c38103a528c024be" id="r_af76de508f19e5b67c38103a528c024be"><td class="memTemplParams" colspan="2">template&lt;class collection_t&gt; </td></tr>
<tr class="memitem:af76de508f19e5b67c38103a528c024be"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af76de508f19e5b67c38103a528c024be">as_enumerable</a> (collection_t &amp;&amp;source) noexcept</td></tr>
<tr class="memdesc:af76de508f19e5b67c38103a528c024be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:af76de508f19e5b67c38103a528c024be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394e89243cb4868835e860ccde245f1d" id="r_a394e89243cb4868835e860ccde245f1d"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t&gt; </td></tr>
<tr class="memitem:a394e89243cb4868835e860ccde245f1d"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a394e89243cb4868835e860ccde245f1d">as_enumerable</a> (input_iterator_t <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, input_iterator_t <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>) noexcept</td></tr>
<tr class="memdesc:a394e89243cb4868835e860ccde245f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a394e89243cb4868835e860ccde245f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e713623f82387befefc7bed31ec8369" id="r_a1e713623f82387befefc7bed31ec8369"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t&gt; </td></tr>
<tr class="memitem:a1e713623f82387befefc7bed31ec8369"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e713623f82387befefc7bed31ec8369">as_enumerable</a> (input_iterator_t iterator, size_t <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>) noexcept</td></tr>
<tr class="memdesc:a1e713623f82387befefc7bed31ec8369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a1e713623f82387befefc7bed31ec8369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7692b03dae1cec8b7963fbc7416f2e2" id="r_ab7692b03dae1cec8b7963fbc7416f2e2"><td class="memTemplParams" colspan="2">template&lt;class source_t, size_t length&gt; </td></tr>
<tr class="memitem:ab7692b03dae1cec8b7963fbc7416f2e2"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7692b03dae1cec8b7963fbc7416f2e2">as_enumerable</a> (const source_t(&amp;<a class="el" href="classxtd_1_1array.html">array</a>)[<a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>]) noexcept</td></tr>
<tr class="memdesc:ab7692b03dae1cec8b7963fbc7416f2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ab7692b03dae1cec8b7963fbc7416f2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f45e5466740ff18c1f2dff890e6c457" id="r_a0f45e5466740ff18c1f2dff890e6c457"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f45e5466740ff18c1f2dff890e6c457">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a0f45e5466740ff18c1f2dff890e6c457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values.  <br /></td></tr>
<tr class="separator:a0f45e5466740ff18c1f2dff890e6c457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ece176030f8975cde72309753d32cb1" id="r_a6ece176030f8975cde72309753d32cb1"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ece176030f8975cde72309753d32cb1">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; double &gt; &amp;source)</td></tr>
<tr class="memdesc:a6ece176030f8975cde72309753d32cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of double values.  <br /></td></tr>
<tr class="separator:a6ece176030f8975cde72309753d32cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf18abab93837198d91f64e19fc7c04" id="r_abcf18abab93837198d91f64e19fc7c04"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcf18abab93837198d91f64e19fc7c04">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; float &gt; &amp;source)</td></tr>
<tr class="memdesc:abcf18abab93837198d91f64e19fc7c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of float values.  <br /></td></tr>
<tr class="separator:abcf18abab93837198d91f64e19fc7c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db01ef4dcc146706ace27163a88c9ef" id="r_a3db01ef4dcc146706ace27163a88c9ef"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3db01ef4dcc146706ace27163a88c9ef">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">xtd::int32</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a3db01ef4dcc146706ace27163a88c9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">xtd::int32</a> values.  <br /></td></tr>
<tr class="separator:a3db01ef4dcc146706ace27163a88c9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f5e2995a613c7cd21a3a70d2725fa0" id="r_a79f5e2995a613c7cd21a3a70d2725fa0"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79f5e2995a613c7cd21a3a70d2725fa0">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a79f5e2995a613c7cd21a3a70d2725fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9" title="Represents a 64-bit signed integer.">xtd::int64</a> values.  <br /></td></tr>
<tr class="separator:a79f5e2995a613c7cd21a3a70d2725fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb1f246d0c1d7fcc244c109f932ee2a" id="r_a2cb1f246d0c1d7fcc244c109f932ee2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cb1f246d0c1d7fcc244c109f932ee2a">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a2cb1f246d0c1d7fcc244c109f932ee2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values.  <br /></td></tr>
<tr class="separator:a2cb1f246d0c1d7fcc244c109f932ee2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99a80b764c342e0b097e6640693480d" id="r_ab99a80b764c342e0b097e6640693480d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab99a80b764c342e0b097e6640693480d">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; double &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ab99a80b764c342e0b097e6640693480d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional double values.  <br /></td></tr>
<tr class="separator:ab99a80b764c342e0b097e6640693480d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ea28ac2b9dade8ec13d986d19c8cf3" id="r_a25ea28ac2b9dade8ec13d986d19c8cf3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25ea28ac2b9dade8ec13d986d19c8cf3">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; float &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a25ea28ac2b9dade8ec13d986d19c8cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional float values.  <br /></td></tr>
<tr class="separator:a25ea28ac2b9dade8ec13d986d19c8cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba45526a72fc218f272d378a69322d7" id="r_a5ba45526a72fc218f272d378a69322d7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ba45526a72fc218f272d378a69322d7">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">xtd::int32</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a5ba45526a72fc218f272d378a69322d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">xtd::int32</a> values.  <br /></td></tr>
<tr class="separator:a5ba45526a72fc218f272d378a69322d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22ecd327aae18433bb93f8b07a270ee" id="r_ad22ecd327aae18433bb93f8b07a270ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad22ecd327aae18433bb93f8b07a270ee">average</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ad22ecd327aae18433bb93f8b07a270ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9" title="Represents a 64-bit signed integer.">xtd::int64</a> values.  <br /></td></tr>
<tr class="separator:ad22ecd327aae18433bb93f8b07a270ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3282feb43c50683f20b126a7c858566e" id="r_a3282feb43c50683f20b126a7c858566e"><td class="memTemplParams" colspan="2">template&lt;class result_t, class source_t&gt; </td></tr>
<tr class="memitem:a3282feb43c50683f20b126a7c858566e"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3282feb43c50683f20b126a7c858566e">cast</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a3282feb43c50683f20b126a7c858566e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> to the specified type.  <br /></td></tr>
<tr class="separator:a3282feb43c50683f20b126a7c858566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6678a1a04ce77c3ba1f30679df8ef741" id="r_a6678a1a04ce77c3ba1f30679df8ef741"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a6678a1a04ce77c3ba1f30679df8ef741"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6678a1a04ce77c3ba1f30679df8ef741">chunk</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">size</a>)</td></tr>
<tr class="memdesc:a6678a1a04ce77c3ba1f30679df8ef741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the elements of a sequence into chunks of size at most size.  <br /></td></tr>
<tr class="separator:a6678a1a04ce77c3ba1f30679df8ef741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2437294617d23a475ace0d55303913c" id="r_aa2437294617d23a475ace0d55303913c"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:aa2437294617d23a475ace0d55303913c"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2437294617d23a475ace0d55303913c">concat</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;<a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;second) noexcept</td></tr>
<tr class="memdesc:aa2437294617d23a475ace0d55303913c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two sequences.  <br /></td></tr>
<tr class="separator:aa2437294617d23a475ace0d55303913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70130adc31e5bbd6b659b978b79d9415" id="r_a70130adc31e5bbd6b659b978b79d9415"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a70130adc31e5bbd6b659b978b79d9415"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70130adc31e5bbd6b659b978b79d9415">contains</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;value) noexcept</td></tr>
<tr class="memdesc:a70130adc31e5bbd6b659b978b79d9415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using the default equality comparer.  <br /></td></tr>
<tr class="separator:a70130adc31e5bbd6b659b978b79d9415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4773dd73686692f45cdcfbe016e1e499" id="r_a4773dd73686692f45cdcfbe016e1e499"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a4773dd73686692f45cdcfbe016e1e499"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4773dd73686692f45cdcfbe016e1e499">contains</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;value, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;comparer) noexcept</td></tr>
<tr class="memdesc:a4773dd73686692f45cdcfbe016e1e499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using a specified equality comparer.  <br /></td></tr>
<tr class="separator:a4773dd73686692f45cdcfbe016e1e499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8deab4a1605619cb40cd56504a5b54c" id="r_ae8deab4a1605619cb40cd56504a5b54c"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:ae8deab4a1605619cb40cd56504a5b54c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8deab4a1605619cb40cd56504a5b54c">count</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ae8deab4a1605619cb40cd56504a5b54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a sequence.  <br /></td></tr>
<tr class="separator:ae8deab4a1605619cb40cd56504a5b54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b2c99b2315f698741d2f45b0d4db92" id="r_ad9b2c99b2315f698741d2f45b0d4db92"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:ad9b2c99b2315f698741d2f45b0d4db92"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9b2c99b2315f698741d2f45b0d4db92">count</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) noexcept</td></tr>
<tr class="memdesc:ad9b2c99b2315f698741d2f45b0d4db92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number that represents how many elements in the specified sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:ad9b2c99b2315f698741d2f45b0d4db92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e48c512a31e2e0e01756da8e68acb4" id="r_af7e48c512a31e2e0e01756da8e68acb4"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:af7e48c512a31e2e0e01756da8e68acb4"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af7e48c512a31e2e0e01756da8e68acb4">count</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;value) noexcept</td></tr>
<tr class="memdesc:af7e48c512a31e2e0e01756da8e68acb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with the specified value.  <br /></td></tr>
<tr class="separator:af7e48c512a31e2e0e01756da8e68acb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fcd2e099e280f4c2c6cdfa9ce2423b" id="r_ac4fcd2e099e280f4c2c6cdfa9ce2423b"><td class="memTemplParams" colspan="2">template&lt;class key_t, class source_t&gt; </td></tr>
<tr class="memitem:ac4fcd2e099e280f4c2c6cdfa9ce2423b"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4fcd2e099e280f4c2c6cdfa9ce2423b">count_by</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector) noexcept</td></tr>
<tr class="memdesc:ac4fcd2e099e280f4c2c6cdfa9ce2423b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the source sequence grouped by key.  <br /></td></tr>
<tr class="separator:ac4fcd2e099e280f4c2c6cdfa9ce2423b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de298080285ff1e2fc75849e4a2b1b7" id="r_a0de298080285ff1e2fc75849e4a2b1b7"><td class="memTemplParams" colspan="2">template&lt;class key_t, class source_t&gt; </td></tr>
<tr class="memitem:a0de298080285ff1e2fc75849e4a2b1b7"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0de298080285ff1e2fc75849e4a2b1b7">count_by</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector, const <a class="el" href="#a49bbe9fcf3dfc4dae1ad074550a1e37a">iequality_comparer</a>&lt; key_t &gt; &amp;key_comparer) noexcept</td></tr>
<tr class="memdesc:a0de298080285ff1e2fc75849e4a2b1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the source sequence grouped by key.  <br /></td></tr>
<tr class="separator:a0de298080285ff1e2fc75849e4a2b1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6d60a2871618535d7238d9ee876426" id="r_a0f6d60a2871618535d7238d9ee876426"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a0f6d60a2871618535d7238d9ee876426"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f6d60a2871618535d7238d9ee876426">default_if_empty</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a0f6d60a2871618535d7238d9ee876426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty.  <br /></td></tr>
<tr class="separator:a0f6d60a2871618535d7238d9ee876426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92747965c96b64bcaf7246ac0907f6a3" id="r_a92747965c96b64bcaf7246ac0907f6a3"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a92747965c96b64bcaf7246ac0907f6a3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92747965c96b64bcaf7246ac0907f6a3">default_if_empty</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:a92747965c96b64bcaf7246ac0907f6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty.  <br /></td></tr>
<tr class="separator:a92747965c96b64bcaf7246ac0907f6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd13075c29205d18a320e2cf44c83cc" id="r_aadd13075c29205d18a320e2cf44c83cc"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:aadd13075c29205d18a320e2cf44c83cc"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aadd13075c29205d18a320e2cf44c83cc">distinct</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:aadd13075c29205d18a320e2cf44c83cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distinct elements from a sequence by using the default equality comparer to compare values.  <br /></td></tr>
<tr class="separator:aadd13075c29205d18a320e2cf44c83cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc700fbc3281508f048620b36aad840" id="r_a4cc700fbc3281508f048620b36aad840"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a4cc700fbc3281508f048620b36aad840"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4cc700fbc3281508f048620b36aad840">distinct</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;comparer) noexcept</td></tr>
<tr class="memdesc:a4cc700fbc3281508f048620b36aad840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distinct elements from a sequence by using a specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; to compare values.  <br /></td></tr>
<tr class="separator:a4cc700fbc3281508f048620b36aad840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b247a0e769fe8eed5a37b3ab4e44fd" id="r_a84b247a0e769fe8eed5a37b3ab4e44fd"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a84b247a0e769fe8eed5a37b3ab4e44fd"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a84b247a0e769fe8eed5a37b3ab4e44fd">first_or_default</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:a84b247a0e769fe8eed5a37b3ab4e44fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:a84b247a0e769fe8eed5a37b3ab4e44fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf71c1af3ba82f0df36809f98b58132" id="r_adaf71c1af3ba82f0df36809f98b58132"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:adaf71c1af3ba82f0df36809f98b58132"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adaf71c1af3ba82f0df36809f98b58132">first_or_default</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>) noexcept</td></tr>
<tr class="memdesc:adaf71c1af3ba82f0df36809f98b58132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:adaf71c1af3ba82f0df36809f98b58132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ab3f630eeaa5b8baa65bd53f4dd1d2" id="r_a92ab3f630eeaa5b8baa65bd53f4dd1d2"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a92ab3f630eeaa5b8baa65bd53f4dd1d2"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92ab3f630eeaa5b8baa65bd53f4dd1d2">first_or_default</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:a92ab3f630eeaa5b8baa65bd53f4dd1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a92ab3f630eeaa5b8baa65bd53f4dd1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14ce27216bdbb95d8c1bd14dfee5e40" id="r_af14ce27216bdbb95d8c1bd14dfee5e40"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:af14ce27216bdbb95d8c1bd14dfee5e40"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af14ce27216bdbb95d8c1bd14dfee5e40">first_or_default</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:af14ce27216bdbb95d8c1bd14dfee5e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:af14ce27216bdbb95d8c1bd14dfee5e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f2b197a8f9e4e52710edcdd59870e9" id="r_ad3f2b197a8f9e4e52710edcdd59870e9"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:ad3f2b197a8f9e4e52710edcdd59870e9"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad3f2b197a8f9e4e52710edcdd59870e9">range</a> (type_t <a class="el" href="#ae8deab4a1605619cb40cd56504a5b54c">count</a>)</td></tr>
<tr class="memdesc:ad3f2b197a8f9e4e52710edcdd59870e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of integral numbers within a specified range.  <br /></td></tr>
<tr class="separator:ad3f2b197a8f9e4e52710edcdd59870e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfbc30cd929383ef82cb28ebd4cb7da" id="r_a4cfbc30cd929383ef82cb28ebd4cb7da"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:a4cfbc30cd929383ef82cb28ebd4cb7da"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4cfbc30cd929383ef82cb28ebd4cb7da">range</a> (type_t start, type_t <a class="el" href="#ae8deab4a1605619cb40cd56504a5b54c">count</a>)</td></tr>
<tr class="memdesc:a4cfbc30cd929383ef82cb28ebd4cb7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of integral numbers within a specified range.  <br /></td></tr>
<tr class="separator:a4cfbc30cd929383ef82cb28ebd4cb7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c9248a6f7a6114a7afd708f159de3b" id="r_aa2c9248a6f7a6114a7afd708f159de3b"><td class="memTemplParams" colspan="2">template&lt;class type_t&gt; </td></tr>
<tr class="memitem:aa2c9248a6f7a6114a7afd708f159de3b"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2c9248a6f7a6114a7afd708f159de3b">range</a> (type_t start, type_t <a class="el" href="#ae8deab4a1605619cb40cd56504a5b54c">count</a>, type_t step)</td></tr>
<tr class="memdesc:aa2c9248a6f7a6114a7afd708f159de3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of integral numbers within a specified range and step.  <br /></td></tr>
<tr class="separator:aa2c9248a6f7a6114a7afd708f159de3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa2c9615978fa0495b6a69a71a72508" id="r_aeaa2c9615978fa0495b6a69a71a72508"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:aeaa2c9615978fa0495b6a69a71a72508"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeaa2c9615978fa0495b6a69a71a72508">from</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:aeaa2c9615978fa0495b6a69a71a72508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:aeaa2c9615978fa0495b6a69a71a72508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d2ecce5f6d3f0cf3a64fc90cf2727e" id="r_a90d2ecce5f6d3f0cf3a64fc90cf2727e"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a90d2ecce5f6d3f0cf3a64fc90cf2727e"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90d2ecce5f6d3f0cf3a64fc90cf2727e">from</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:a90d2ecce5f6d3f0cf3a64fc90cf2727e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a90d2ecce5f6d3f0cf3a64fc90cf2727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02b04237e05737f363d199242f7df3a" id="r_ac02b04237e05737f363d199242f7df3a"><td class="memTemplParams" colspan="2">template&lt;class collection_t&gt; </td></tr>
<tr class="memitem:ac02b04237e05737f363d199242f7df3a"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac02b04237e05737f363d199242f7df3a">from</a> (collection_t &amp;&amp;source) noexcept</td></tr>
<tr class="memdesc:ac02b04237e05737f363d199242f7df3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ac02b04237e05737f363d199242f7df3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2572f6159407e59e7076ff715cefe546" id="r_a2572f6159407e59e7076ff715cefe546"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t&gt; </td></tr>
<tr class="memitem:a2572f6159407e59e7076ff715cefe546"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2572f6159407e59e7076ff715cefe546">from</a> (input_iterator_t <a class="el" href="namespacextd.html#a31261a8eef815d75bbe44a418ea4023f">first</a>, input_iterator_t <a class="el" href="namespacextd.html#a4587cc977656d48247ea110023c4d79d">last</a>) noexcept</td></tr>
<tr class="memdesc:a2572f6159407e59e7076ff715cefe546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a2572f6159407e59e7076ff715cefe546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65887d1a4155d7a8eef24dc74343eafa" id="r_a65887d1a4155d7a8eef24dc74343eafa"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t&gt; </td></tr>
<tr class="memitem:a65887d1a4155d7a8eef24dc74343eafa"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65887d1a4155d7a8eef24dc74343eafa">from</a> (input_iterator_t iterator, size_t <a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>) noexcept</td></tr>
<tr class="memdesc:a65887d1a4155d7a8eef24dc74343eafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a65887d1a4155d7a8eef24dc74343eafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348b7154bf4fbc6ddfa03f9bf8de4a1f" id="r_a348b7154bf4fbc6ddfa03f9bf8de4a1f"><td class="memTemplParams" colspan="2">template&lt;class source_t, size_t length&gt; </td></tr>
<tr class="memitem:a348b7154bf4fbc6ddfa03f9bf8de4a1f"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a348b7154bf4fbc6ddfa03f9bf8de4a1f">from</a> (const source_t(&amp;<a class="el" href="classxtd_1_1array.html">array</a>)[<a class="el" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>]) noexcept</td></tr>
<tr class="memdesc:a348b7154bf4fbc6ddfa03f9bf8de4a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a348b7154bf4fbc6ddfa03f9bf8de4a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91fb65cb8ea3b6269c8982385d4b93c" id="r_ab91fb65cb8ea3b6269c8982385d4b93c"><td class="memTemplParams" colspan="2">template&lt;class key_t, class source_t&gt; </td></tr>
<tr class="memitem:ab91fb65cb8ea3b6269c8982385d4b93c"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab91fb65cb8ea3b6269c8982385d4b93c">order_by</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector)</td></tr>
<tr class="memdesc:ab91fb65cb8ea3b6269c8982385d4b93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order according to a key.  <br /></td></tr>
<tr class="separator:ab91fb65cb8ea3b6269c8982385d4b93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85ee3d04c5083251b55a7836b081580" id="r_ab85ee3d04c5083251b55a7836b081580"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:ab85ee3d04c5083251b55a7836b081580"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab85ee3d04c5083251b55a7836b081580">order_by</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;key_selector)</td></tr>
<tr class="memdesc:ab85ee3d04c5083251b55a7836b081580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a sequence in ascending order according to a key.  <br /></td></tr>
<tr class="separator:ab85ee3d04c5083251b55a7836b081580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5849798f7b5ae566dd5e7c175dfe3d" id="r_a0d5849798f7b5ae566dd5e7c175dfe3d"><td class="memTemplParams" colspan="2">template&lt;class result_t, class source_t&gt; </td></tr>
<tr class="memitem:a0d5849798f7b5ae566dd5e7c175dfe3d"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d5849798f7b5ae566dd5e7c175dfe3d">select</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a0d5849798f7b5ae566dd5e7c175dfe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a0d5849798f7b5ae566dd5e7c175dfe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c31ff77b347ca19c6a15c9e61f112b9" id="r_a9c31ff77b347ca19c6a15c9e61f112b9"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a9c31ff77b347ca19c6a15c9e61f112b9"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c31ff77b347ca19c6a15c9e61f112b9">select</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a9c31ff77b347ca19c6a15c9e61f112b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a9c31ff77b347ca19c6a15c9e61f112b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e2d6d5c1e8dc39d688b274e6681d81" id="r_a65e2d6d5c1e8dc39d688b274e6681d81"><td class="memTemplParams" colspan="2">template&lt;class result_t, class source_t&gt; </td></tr>
<tr class="memitem:a65e2d6d5c1e8dc39d688b274e6681d81"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65e2d6d5c1e8dc39d688b274e6681d81">select</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; result_t(const source_t &amp;, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a65e2d6d5c1e8dc39d688b274e6681d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a65e2d6d5c1e8dc39d688b274e6681d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6c8465cd791e35bb31259209ab4eed" id="r_a8c6c8465cd791e35bb31259209ab4eed"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a8c6c8465cd791e35bb31259209ab4eed"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c6c8465cd791e35bb31259209ab4eed">select</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a8c6c8465cd791e35bb31259209ab4eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a8c6c8465cd791e35bb31259209ab4eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452f69ae6e7daea4c93977fc2ba8b044" id="r_a452f69ae6e7daea4c93977fc2ba8b044"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a452f69ae6e7daea4c93977fc2ba8b044"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a452f69ae6e7daea4c93977fc2ba8b044">to_list</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a452f69ae6e7daea4c93977fc2ba8b044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a452f69ae6e7daea4c93977fc2ba8b044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03a53b77498111f8869505458df9915" id="r_ac03a53b77498111f8869505458df9915"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:ac03a53b77498111f8869505458df9915"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac03a53b77498111f8869505458df9915">where</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>)</td></tr>
<tr class="memdesc:ac03a53b77498111f8869505458df9915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:ac03a53b77498111f8869505458df9915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a7ff5cfe600860118447531bf188a3" id="r_a81a7ff5cfe600860118447531bf188a3"><td class="memTemplParams" colspan="2">template&lt;class source_t&gt; </td></tr>
<tr class="memitem:a81a7ff5cfe600860118447531bf188a3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81a7ff5cfe600860118447531bf188a3">where</a> (const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>)&gt; &amp;<a class="el" href="group__xtd__core.html#ga3191b459d2e42564bbf79ab35304ceab">predicate</a>)</td></tr>
<tr class="memdesc:a81a7ff5cfe600860118447531bf188a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a81a7ff5cfe600860118447531bf188a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2ddf87538e12a66991705171183f8d5b" name="a2ddf87538e12a66991705171183f8d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddf87538e12a66991705171183f8d5b">&#9670;&#160;</a></span>enumerator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2ddf87538e12a66991705171183f8d5b">xtd::linq::enumerable::enumerator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the enumerator value type. </p>

</div>
</div>
<a id="a49bbe9fcf3dfc4dae1ad074550a1e37a" name="a49bbe9fcf3dfc4dae1ad074550a1e37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bbe9fcf3dfc4dae1ad074550a1e37a">&#9670;&#160;</a></span>iequality_comparer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a49bbe9fcf3dfc4dae1ad074550a1e37a">xtd::linq::enumerable::iequality_comparer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the ienumerable value type. </p>

</div>
</div>
<a id="a2bd1889dc1967c50ef692411dc2c4b92" name="a2bd1889dc1967c50ef692411dc2c4b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd1889dc1967c50ef692411dc2c4b92">&#9670;&#160;</a></span>ienumerable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">xtd::linq::enumerable::ienumerable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the ienumerable value type. </p>

</div>
</div>
<a id="a4ff59be55b7be66d275f28741e2f1f0a" name="a4ff59be55b7be66d275f28741e2f1f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff59be55b7be66d275f28741e2f1f0a">&#9670;&#160;</a></span>list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4ff59be55b7be66d275f28741e2f1f0a">xtd::linq::enumerable::list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the list value type. </p>

</div>
</div>
<a id="acaa2aa9384131fb9d7c0b02830e55050" name="acaa2aa9384131fb9d7c0b02830e55050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa2aa9384131fb9d7c0b02830e55050">&#9670;&#160;</a></span>key_value_pair</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class value_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acaa2aa9384131fb9d7c0b02830e55050">xtd::linq::enumerable::key_value_pair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the key value pair value type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af1b0c29ab9f86199822152226ec0e90d" name="af1b0c29ab9f86199822152226ec0e90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b0c29ab9f86199822152226ec0e90d">&#9670;&#160;</a></span>aggregate() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad298961901a3bb9e64a04b9f4ea2d6ff" name="ad298961901a3bb9e64a04b9f4ea2d6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad298961901a3bb9e64a04b9f4ea2d6ff">&#9670;&#160;</a></span>aggregate() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.aggregate(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
<div class="ttc" id="aclassxtd_1_1array_html"><div class="ttname"><a href="classxtd_1_1array.html">xtd::array</a></div><div class="ttdoc">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...</div><div class="ttdef"><b>Definition</b> array.hpp:63</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ada50d6149117beb68a72da3343bd5407" name="ada50d6149117beb68a72da3343bd5407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada50d6149117beb68a72da3343bd5407">&#9670;&#160;</a></span>aggregate() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class accumulate_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.aggregate(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a467df4b87b33cbdd30aa1021f0805066" name="a467df4b87b33cbdd30aa1021f0805066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467df4b87b33cbdd30aa1021f0805066">&#9670;&#160;</a></span>aggregate() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result_selector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name = fruits.aggregate(<span class="stringliteral">&quot;bananas&quot;</span>,</div>
<div class="line">     [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">     <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">     [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.to_upper();});</div>
<div class="line"> </div>
<div class="line">  console::write_line(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6f79a4291dee3441cb093eb09c26c36f" name="a6f79a4291dee3441cb093eb09c26c36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f79a4291dee3441cb093eb09c26c36f">&#9670;&#160;</a></span>aggregate() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class result_t, class accumulate_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result_selector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">accumulate_t</td><td>The type of the accumulator value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#af1b0c29ab9f86199822152226ec0e90d" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name = fruits.aggregate(<span class="stringliteral">&quot;bananas&quot;</span>,</div>
<div class="line">     [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">     <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">     [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.to_upper();});</div>
<div class="line"> </div>
<div class="line">  console::write_line(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a26f22da0fbdff4367e59968b136a2844" name="a26f22da0fbdff4367e59968b136a2844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f22da0fbdff4367e59968b136a2844">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, <code>false</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is <code>true</code> if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.all([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  console::write_line(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3ff1ae119439eb346f435f375d6ca74d" name="a3ff1ae119439eb346f435f375d6ca74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff1ae119439eb346f435f375d6ca74d">&#9670;&#160;</a></span>any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to check for emptiness. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the source sequence contains any elements; otherwise, <code>false</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.any();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_a4ff59be55b7be66d275f28741e2f1f0a"><div class="ttname"><a href="#a4ff59be55b7be66d275f28741e2f1f0a">xtd::linq::enumerable::list</a></div><div class="ttdeci">typename xtd::collections::generic::list&lt; type_t &gt; list</div><div class="ttdoc">Represents the list value type.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:81</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a40eecec336b27b17378a85e7643de786" name="a40eecec336b27b17378a85e7643de786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40eecec336b27b17378a85e7643de786">&#9670;&#160;</a></span>any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, <code>false</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#a26f22da0fbdff4367e59968b136a2844" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is <code>true</code> if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.all([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  console::write_line(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a16290a393e0688753e2e56ad70780909" name="a16290a393e0688753e2e56ad70780909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16290a393e0688753e2e56ad70780909">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>element</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_typedef" href="#a4ff59be55b7be66d275f28741e2f1f0a">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.append(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(string::join(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(string::join(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(string::join(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4742ce7a6c1be25c31ee80f9d8c442e9" name="a4742ce7a6c1be25c31ee80f9d8c442e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4742ce7a6c1be25c31ee80f9d8c442e9">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad75255b2bd38c597f21f211a0b15ef8b" name="ad75255b2bd38c597f21f211a0b15ef8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75255b2bd38c597f21f211a0b15ef8b">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af76de508f19e5b67c38103a528c024be" name="af76de508f19e5b67c38103a528c024be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76de508f19e5b67c38103a528c024be">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class collection_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">collection_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a394e89243cb4868835e860ccde245f1d" name="a394e89243cb4868835e860ccde245f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394e89243cb4868835e860ccde245f1d">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class input_iterator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1e713623f82387befefc7bed31ec8369" name="a1e713623f82387befefc7bed31ec8369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e713623f82387befefc7bed31ec8369">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class input_iterator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>iterator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>The iterator. </td></tr>
    <tr><td class="paramname">legnth</td><td>The le,gth to iterate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab7692b03dae1cec8b7963fbc7416f2e2" name="ab7692b03dae1cec8b7963fbc7416f2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7692b03dae1cec8b7963fbc7416f2e2">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t, size_t length&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">const source_t(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[length]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the source array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The native array. </td></tr>
    <tr><td class="paramname">legnth</td><td>The length of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0f45e5466740ff18c1f2dff890e6c457" name="a0f45e5466740ff18c1f2dff890e6c457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f45e5466740ff18c1f2dff890e6c457">&#9670;&#160;</a></span>average() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a> xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ece176030f8975cde72309753d32cb1" name="a6ece176030f8975cde72309753d32cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ece176030f8975cde72309753d32cb1">&#9670;&#160;</a></span>average() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of double values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcf18abab93837198d91f64e19fc7c04" name="abcf18abab93837198d91f64e19fc7c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf18abab93837198d91f64e19fc7c04">&#9670;&#160;</a></span>average() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of float values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of float values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3db01ef4dcc146706ace27163a88c9ef" name="a3db01ef4dcc146706ace27163a88c9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db01ef4dcc146706ace27163a88c9ef">&#9670;&#160;</a></span>average() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">xtd::int32</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">xtd::int32</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">xtd::int32</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79f5e2995a613c7cd21a3a70d2725fa0" name="a79f5e2995a613c7cd21a3a70d2725fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f5e2995a613c7cd21a3a70d2725fa0">&#9670;&#160;</a></span>average() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9" title="Represents a 64-bit signed integer.">xtd::int64</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9" title="Represents a 64-bit signed integer.">xtd::int64</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cb1f246d0c1d7fcc244c109f932ee2a" name="a2cb1f246d0c1d7fcc244c109f932ee2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb1f246d0c1d7fcc244c109f932ee2a">&#9670;&#160;</a></span>average() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a> &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd">xtd::decimal</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga7d41c91f9bcab8feb762da96973525fd" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="ab99a80b764c342e0b097e6640693480d" name="ab99a80b764c342e0b097e6640693480d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99a80b764c342e0b097e6640693480d">&#9670;&#160;</a></span>average() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; double &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional double values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a25ea28ac2b9dade8ec13d986d19c8cf3" name="a25ea28ac2b9dade8ec13d986d19c8cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ea28ac2b9dade8ec13d986d19c8cf3">&#9670;&#160;</a></span>average() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; float &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; float &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional float values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional float values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a5ba45526a72fc218f272d378a69322d7" name="a5ba45526a72fc218f272d378a69322d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba45526a72fc218f272d378a69322d7">&#9670;&#160;</a></span>average() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5">xtd::int32</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">xtd::int32</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">xtd::int32</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="ad22ecd327aae18433bb93f8b07a270ee" name="ad22ecd327aae18433bb93f8b07a270ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22ecd327aae18433bb93f8b07a270ee">&#9670;&#160;</a></span>average() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; <a class="el" href="group__types.html#gac3e508084ce85854c55799f802c7e7ce">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9">xtd::int64</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9" title="Represents a 64-bit signed integer.">xtd::int64</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga0eb6dff59ca8406d303e3e4b7eaf2cc9" title="Represents a 64-bit signed integer.">xtd::int64</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a3282feb43c50683f20b126a7c858566e" name="a3282feb43c50683f20b126a7c858566e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3282feb43c50683f20b126a7c858566e">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class result_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the elements of an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> to the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> that contains the elements to be cast to type <code>result_t</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains each element of the source sequence cast to the specified type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__cast__exception.html" title="The exception that is thrown for invalid casting or explicit conversion.">xtd::invalid_cast_exception</a></td><td>An element in the sequence cannot be cast to type `result_t`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="group__xtd__core.html#ga7950c22da6547a30812729fb21dcbea7" title="Casts a type into another type.">xtd::as</a> include file <code>#include &lt;xtd/as&gt;</code> is needeed to use this method. </dd></dl>

</div>
</div>
<a id="a6678a1a04ce77c3ba1f30679df8ef741" name="a6678a1a04ce77c3ba1f30679df8ef741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6678a1a04ce77c3ba1f30679df8ef741">&#9670;&#160;</a></span>chunk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::chunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the elements of a sequence into chunks of size at most size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to chunk. </td></tr>
    <tr><td class="paramname">size</td><td>The maximum size of each chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence of chunks of size at most size. @zxception <a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a> <code>size</code> is equal to 0. </dd></dl>

</div>
</div>
<a id="aa2437294617d23a475ace0d55303913c" name="aa2437294617d23a475ace0d55303913c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2437294617d23a475ace0d55303913c">&#9670;&#160;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two sequences. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first sequence to concatenate. </td></tr>
    <tr><td class="paramname">second</td><td>The sequence to concatenate to the first sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the concatenated elements of the two input sequences. </dd></dl>

</div>
</div>
<a id="a70130adc31e5bbd6b659b978b79d9415" name="a70130adc31e5bbd6b659b978b79d9415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70130adc31e5bbd6b659b978b79d9415">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains a specified element by using the default equality comparer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence in which to locate a value. </td></tr>
    <tr><td class="paramname">value</td><td>The value to locate in the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the source sequence contains an element that has the specified value; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4773dd73686692f45cdcfbe016e1e499" name="a4773dd73686692f45cdcfbe016e1e499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4773dd73686692f45cdcfbe016e1e499">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains a specified element by using a specified equality comparer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence in which to locate a value. </td></tr>
    <tr><td class="paramname">value</td><td>The value to locate in the sequence. </td></tr>
    <tr><td class="paramname">comparer</td><td>An equality comparer to compare values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the source sequence contains an element that has the specified value; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae8deab4a1605619cb40cd56504a5b54c" name="ae8deab4a1605619cb40cd56504a5b54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8deab4a1605619cb40cd56504a5b54c">&#9670;&#160;</a></span>count() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> xtd::linq::enumerable::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence that contains elements to be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the input sequence. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#ae8deab4a1605619cb40cd56504a5b54c" title="Returns the number of elements in a sequence.">xtd::linq::enumerable::count</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;) to count the elements in a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> number_of_fruits = fruits.enumerable::count();</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;There are {0} fruits in the collection.&quot;</span>, number_of_fruits);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// There are 6 fruits in the collection.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad9b2c99b2315f698741d2f45b0d4db92" name="ad9b2c99b2315f698741d2f45b0d4db92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b2c99b2315f698741d2f45b0d4db92">&#9670;&#160;</a></span>count() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> xtd::linq::enumerable::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a number that represents how many elements in the specified sequence satisfy a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence that contains elements to be tested and counted. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A number that represents how many elements in the sequence satisfy the condition in the predicate function. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#ae8deab4a1605619cb40cd56504a5b54c" title="Returns the number of elements in a sequence.">xtd::linq::enumerable::count</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;bool(const source_t&amp;)&gt;&amp;) to count the elements in a sequence that satisfy a condition. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>pet {</div>
<div class="line">  <span class="keywordtype">string</span> name;</div>
<div class="line">  <span class="keywordtype">bool</span> vaccinated = <span class="keyword">false</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> pet&amp; lhs, <span class="keyword">const</span> pet&amp; rhs) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">return</span> lhs.name == rhs.name &amp;&amp; lhs.vaccinated == rhs.vaccinated;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {.name = <span class="stringliteral">&quot;Barley&quot;</span>, .vaccinated = <span class="keyword">true</span>},</div>
<div class="line">    pet {.name = <span class="stringliteral">&quot;Boots&quot;</span>, .vaccinated = <span class="keyword">false</span>},</div>
<div class="line">    pet {.name = <span class="stringliteral">&quot;Whiskers&quot;</span>, .vaccinated = <span class="keyword">false</span>}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> number_unvaccinated = pets.<a class="code hl_function" href="classxtd_1_1basic__array.html#a2e50b538f5aa4913d3180fcee49499c2">count</a>([](<span class="keyword">const</span> pet&amp; pet) {<span class="keywordflow">return</span> !pet.vaccinated;});</div>
<div class="line">  console::write_line(<span class="stringliteral">&quot;There are {} unvaccinated animals.&quot;</span>, number_unvaccinated);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// There are 2 unvaccinated animals.</span></div>
<div class="ttc" id="aclassxtd_1_1basic__array_html_a2e50b538f5aa4913d3180fcee49499c2"><div class="ttname"><a href="classxtd_1_1basic__array.html#a2e50b538f5aa4913d3180fcee49499c2">xtd::basic_array::count</a></div><div class="ttdeci">size_type count() const noexcept override</div><div class="ttdoc">Gets the number of elements contained in the xtd::array &lt;type_t&gt;.</div><div class="ttdef"><b>Definition</b> basic_array.hpp:134</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af7e48c512a31e2e0e01756da8e68acb4" name="af7e48c512a31e2e0e01756da8e68acb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e48c512a31e2e0e01756da8e68acb4">&#9670;&#160;</a></span>count() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a> xtd::linq::enumerable::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with the specified value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence that contains elements to be tested and counted. </td></tr>
    <tr><td class="paramname">value</td><td>The value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A number representing the number of elements in the sequence that are equal to the <code>value</code>. </dd></dl>

</div>
</div>
<a id="ac4fcd2e099e280f4c2c6cdfa9ce2423b" name="ac4fcd2e099e280f4c2c6cdfa9ce2423b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fcd2e099e280f4c2c6cdfa9ce2423b">&#9670;&#160;</a></span>count_by() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::count_by </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; key_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the count of elements in the source sequence grouped by key. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">key_t</td><td>The type of the key returned by <code>key_selector</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence that contains elements to be counted. </td></tr>
    <tr><td class="paramname">key_selector</td><td>A function to extract the key for each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enumerable containing the frequencies of each key occurrence in <code>source</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#ac4fcd2e099e280f4c2c6cdfa9ce2423b" title="Returns the count of elements in the source sequence grouped by key.">xtd::linq::enumerable::count_by</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;key_t(const source_t&amp;)&gt;&amp;) to count the number of elements in a sequence grouped by key. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>student : <a class="code hl_class" href="classxtd_1_1iequatable.html">iequatable</a>&lt;student&gt; {</div>
<div class="line">  student() = <span class="keywordflow">default</span>;</div>
<div class="line">  student(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; score) : name {name}, score {score} {}</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">string</span> name;</div>
<div class="line">  <span class="keywordtype">string</span> score;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a>(<span class="keyword">const</span> student&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> {</div>
<div class="line">    <span class="keywordflow">return</span> name == <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.name &amp;&amp; score == <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.score;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> students = array&lt;student&gt; {</div>
<div class="line">    {<span class="stringliteral">&quot;Alice&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Bob&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Charlie&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;David&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Eve&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = students.count_by&lt;<span class="keywordtype">string</span>&gt;([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; student) {<span class="keywordflow">return</span> student.score;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [score, count] : query)</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Students with a {}-score: {}&quot;</span>, score, count);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Students with a A-score: 2</span></div>
<div class="line"><span class="comment">// Students with a B-score: 2</span></div>
<div class="line"><span class="comment">// Students with a C-score: 1</span></div>
<div class="ttc" id="aclassxtd_1_1iequatable_html"><div class="ttname"><a href="classxtd_1_1iequatable.html">xtd::iequatable</a></div><div class="ttdoc">Defines a generalized method that a value type or class implements to create a type-specific method f...</div><div class="ttdef"><b>Definition</b> iequatable.hpp:22</div></div>
<div class="ttc" id="aclassxtd_1_1iequatable_html_a1f8bbde943d2e5ecf565734c60e23903"><div class="ttname"><a href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">xtd::iequatable::equals</a></div><div class="ttdeci">virtual bool equals(const type_t &amp;) const noexcept=0</div><div class="ttdoc">Indicates whether the current object is equal to another object of the same type.</div></div>
<div class="ttc" id="agroup__xtd__core_html_gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb"><div class="ttname"><a href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">xtd::uri_components::query</a></div><div class="ttdeci">@ query</div><div class="ttdoc">The xtd::uri::query data.</div><div class="ttdef"><b>Definition</b> uri_components.hpp:29</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf"><div class="ttname"><a href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">xtd::platform_id::other</a></div><div class="ttdeci">@ other</div><div class="ttdoc">The operating system is other.</div><div class="ttdef"><b>Definition</b> platform_id.hpp:58</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0de298080285ff1e2fc75849e4a2b1b7" name="a0de298080285ff1e2fc75849e4a2b1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de298080285ff1e2fc75849e4a2b1b7">&#9670;&#160;</a></span>count_by() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::count_by </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; key_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a49bbe9fcf3dfc4dae1ad074550a1e37a">iequality_comparer</a>&lt; key_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_comparer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the count of elements in the source sequence grouped by key. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
    <tr><td class="paramname">key_t</td><td>The type of the key returned by <code>key_selector</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence that contains elements to be counted. </td></tr>
    <tr><td class="paramname">key_selector</td><td>A function to extract the key for each element. </td></tr>
    <tr><td class="paramname">key_comparer</td><td>An equality comparer to compare keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enumerable containing the frequencies of each key occurrence in <code>source</code>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#ac4fcd2e099e280f4c2c6cdfa9ce2423b" title="Returns the count of elements in the source sequence grouped by key.">xtd::linq::enumerable::count_by</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;key_t(const source_t&amp;)&gt;&amp;) to count the number of elements in a sequence grouped by key. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>student : <a class="code hl_class" href="classxtd_1_1iequatable.html">iequatable</a>&lt;student&gt; {</div>
<div class="line">  student() = <span class="keywordflow">default</span>;</div>
<div class="line">  student(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; score) : name {name}, score {score} {}</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">string</span> name;</div>
<div class="line">  <span class="keywordtype">string</span> score;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a>(<span class="keyword">const</span> student&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> {</div>
<div class="line">    <span class="keywordflow">return</span> name == <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.name &amp;&amp; score == <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.score;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> students = array&lt;student&gt; {</div>
<div class="line">    {<span class="stringliteral">&quot;Alice&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Bob&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Charlie&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;David&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;Eve&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = students.count_by&lt;<span class="keywordtype">string</span>&gt;([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; student) {<span class="keywordflow">return</span> student.score;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [score, count] : query)</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;Students with a {}-score: {}&quot;</span>, score, count);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Students with a A-score: 2</span></div>
<div class="line"><span class="comment">// Students with a B-score: 2</span></div>
<div class="line"><span class="comment">// Students with a C-score: 1</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0f6d60a2871618535d7238d9ee876426" name="a0f6d60a2871618535d7238d9ee876426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6d60a2871618535d7238d9ee876426">&#9670;&#160;</a></span>default_if_empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::default_if_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The sequence to return a default value for if it is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains default_value if source is empty; otherwise, source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#a0f6d60a2871618535d7238d9ee876426" title="Returns the elements of the specified sequence or the type parameter&#39;s default value in a singleton c...">xtd::linq::enumerable::default_if_empty</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;) to return a default value if a sequence is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>pet {</div>
<div class="line">  <span class="keywordtype">string</span> name;</div>
<div class="line">  <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> pet&amp; lhs, <span class="keyword">const</span> pet&amp; rhs) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">return</span> lhs.name == rhs.name &amp;&amp; lhs.age == rhs.age;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> pets1 = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;pet&gt;</a> {</div>
<div class="line">    {.name=<span class="stringliteral">&quot;Barley&quot;</span>, .age=8},</div>
<div class="line">    {.name=<span class="stringliteral">&quot;Boots&quot;</span>, .age=4},</div>
<div class="line">    {.name=<span class="stringliteral">&quot;Whiskers&quot;</span>, .age=1}</div>
<div class="line">  };</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [name, age] : pets1.default_if_empty())</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;pet {{name={}, age={}}}&quot;</span>, name, age);</div>
<div class="line">  console::write_line();</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> pets2 = array&lt;pet&gt; {};</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [name, age] : pets2.default_if_empty())</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;pet {{name={}, age={}}}&quot;</span>, name, age);</div>
<div class="line">  console::write_line();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// pet {name=Barley, age=8}</span></div>
<div class="line"><span class="comment">// pet {name=Boots, age=4}</span></div>
<div class="line"><span class="comment">// pet {name=Whiskers, age=1}</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// pet {name=, age=0}</span></div>
<div class="line"><span class="comment">//</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a92747965c96b64bcaf7246ac0907f6a3" name="a92747965c96b64bcaf7246ac0907f6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92747965c96b64bcaf7246ac0907f6a3">&#9670;&#160;</a></span>default_if_empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::default_if_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The sequence to return a default value for if it is empty. </td></tr>
    <tr><td class="paramname">default_value</td><td>The value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains default_value if source is empty; otherwise, source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#a0f6d60a2871618535d7238d9ee876426" title="Returns the elements of the specified sequence or the type parameter&#39;s default value in a singleton c...">xtd::linq::enumerable::default_if_empty</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const source_t&amp;) to return a default value if a sequence is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>pet {</div>
<div class="line">  <span class="keywordtype">string</span> name;</div>
<div class="line">  <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">static</span> pet default_pet;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> pet&amp; lhs, <span class="keyword">const</span> pet&amp; rhs) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">return</span> lhs.name == rhs.name &amp;&amp; lhs.age == rhs.age;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">pet pet::default_pet {.name = <span class="stringliteral">&quot;Default pet&quot;</span>, .age = 0};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> pets1 = array&lt;pet&gt; {</div>
<div class="line">    {.name=<span class="stringliteral">&quot;Barley&quot;</span>, .age=8},</div>
<div class="line">    {.name=<span class="stringliteral">&quot;Boots&quot;</span>, .age=4},</div>
<div class="line">    {.name=<span class="stringliteral">&quot;Whiskers&quot;</span>, .age=1}</div>
<div class="line">  };</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [name, age] : pets1.default_if_empty(pet::default_pet))</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;pet {{name={}, age={}}}&quot;</span>, name, age);</div>
<div class="line">  console::write_line();</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> pets2 = array&lt;pet&gt; {};</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [name, age] : pets2.default_if_empty(pet::default_pet))</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;pet {{name={}, age={}}}&quot;</span>, name, age);</div>
<div class="line">  console::write_line();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// pet {name=Barley, age=8}</span></div>
<div class="line"><span class="comment">// pet {name=Boots, age=4}</span></div>
<div class="line"><span class="comment">// pet {name=Whiskers, age=1}</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// pet {name=Default pet, age=0}</span></div>
<div class="line"><span class="comment">//</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aadd13075c29205d18a320e2cf44c83cc" name="aadd13075c29205d18a320e2cf44c83cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd13075c29205d18a320e2cf44c83cc">&#9670;&#160;</a></span>distinct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::distinct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns distinct elements from a sequence by using the default equality comparer to compare values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The sequence to remove duplicate elements from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enumerable distinct elements from the source sequence. </dd></dl>

</div>
</div>
<a id="a4cc700fbc3281508f048620b36aad840" name="a4cc700fbc3281508f048620b36aad840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc700fbc3281508f048620b36aad840">&#9670;&#160;</a></span>distinct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::distinct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>comparer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns distinct elements from a sequence by using a specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; to compare values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The sequence to remove duplicate elements from. </td></tr>
    <tr><td class="paramname">comparer</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; to compare values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enumerable distinct elements from the source sequence. </dd></dl>

</div>
</div>
<a id="a84b247a0e769fe8eed5a37b3ab4e44fd" name="a84b247a0e769fe8eed5a37b3ab4e44fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b247a0e769fe8eed5a37b3ab4e44fd">&#9670;&#160;</a></span>first_or_default() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="adaf71c1af3ba82f0df36809f98b58132" name="adaf71c1af3ba82f0df36809f98b58132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf71c1af3ba82f0df36809f98b58132">&#9670;&#160;</a></span>first_or_default() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a92ab3f630eeaa5b8baa65bd53f4dd1d2" name="a92ab3f630eeaa5b8baa65bd53f4dd1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ab3f630eeaa5b8baa65bd53f4dd1d2">&#9670;&#160;</a></span>first_or_default() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="af14ce27216bdbb95d8c1bd14dfee5e40" name="af14ce27216bdbb95d8c1bd14dfee5e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14ce27216bdbb95d8c1bd14dfee5e40">&#9670;&#160;</a></span>first_or_default() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="ad3f2b197a8f9e4e52710edcdd59870e9" name="ad3f2b197a8f9e4e52710edcdd59870e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f2b197a8f9e4e52710edcdd59870e9">&#9670;&#160;</a></span>range() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::range </td>
          <td>(</td>
          <td class="paramtype">type_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of integral numbers within a specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of sequential integers to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;<a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">xtd::int32</a>&gt; that contains a range of sequential integral numbers. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`count` is less than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#ad3f2b197a8f9e4e52710edcdd59870e9" title="Generates a sequence of integral numbers within a specified range.">xtd::linq::enumerable::range</a> to generate a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; squares = <a class="code hl_function" href="#ad3f2b197a8f9e4e52710edcdd59870e9">enumerable::range</a>(1, 10).select([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) {<span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a> * <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> num : squares)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(num);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1</span></div>
<div class="line"><span class="comment">// 4</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 16</span></div>
<div class="line"><span class="comment">// 25</span></div>
<div class="line"><span class="comment">// 36</span></div>
<div class="line"><span class="comment">// 49</span></div>
<div class="line"><span class="comment">// 64</span></div>
<div class="line"><span class="comment">// 81</span></div>
<div class="line"><span class="comment">// 100</span></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_ad3f2b197a8f9e4e52710edcdd59870e9"><div class="ttname"><a href="#ad3f2b197a8f9e4e52710edcdd59870e9">xtd::linq::enumerable::range</a></div><div class="ttdeci">static auto range(type_t count)</div><div class="ttdoc">Generates a sequence of integral numbers within a specified range.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:650</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">xtd::console_key::x</a></div><div class="ttdeci">@ x</div><div class="ttdoc">The X key.</div><div class="ttdef"><b>Definition</b> console_key.hpp:134</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4cfbc30cd929383ef82cb28ebd4cb7da" name="a4cfbc30cd929383ef82cb28ebd4cb7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfbc30cd929383ef82cb28ebd4cb7da">&#9670;&#160;</a></span>range() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::range </td>
          <td>(</td>
          <td class="paramtype">type_t</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of integral numbers within a specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The value of the first integer in the sequence. </td></tr>
    <tr><td class="paramname">count</td><td>The number of sequential integers to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;<a class="el" href="group__types.html#gaa9a6cd7d720cd7466a0acb01f807b0c5" title="Represents a 32-bit signed integer.">xtd::int32</a>&gt; that contains a range of sequential integral numbers. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`count` is less than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#ad3f2b197a8f9e4e52710edcdd59870e9" title="Generates a sequence of integral numbers within a specified range.">xtd::linq::enumerable::range</a> to generate a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; squares = <a class="code hl_function" href="#ad3f2b197a8f9e4e52710edcdd59870e9">enumerable::range</a>(1, 10).select([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) {<span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a> * <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> num : squares)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(num);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1</span></div>
<div class="line"><span class="comment">// 4</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 16</span></div>
<div class="line"><span class="comment">// 25</span></div>
<div class="line"><span class="comment">// 36</span></div>
<div class="line"><span class="comment">// 49</span></div>
<div class="line"><span class="comment">// 64</span></div>
<div class="line"><span class="comment">// 81</span></div>
<div class="line"><span class="comment">// 100</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa2c9248a6f7a6114a7afd708f159de3b" name="aa2c9248a6f7a6114a7afd708f159de3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c9248a6f7a6114a7afd708f159de3b">&#9670;&#160;</a></span>range() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class type_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::range </td>
          <td>(</td>
          <td class="paramtype">type_t</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t</td>          <td class="paramname"><span class="paramname"><em>step</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of integral numbers within a specified range and step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The value of the first integer in the sequence. </td></tr>
    <tr><td class="paramname">count</td><td>The number of sequential integers to generate. </td></tr>
    <tr><td class="paramname">step</td><td>The integer number specifying the incrementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> that contains a range of sequential integral numbers. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`count` is less than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaa2c9615978fa0495b6a69a71a72508" name="aeaa2c9615978fa0495b6a69a71a72508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa2c9615978fa0495b6a69a71a72508">&#9670;&#160;</a></span>from() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Same as as_enemerable(const ienumerable&lt;source_t&gt;&amp; source). </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6" title="Returns the input typed as xtd::collections::generic::ienumerable &lt;type_t&gt;.">xtd::linq::from</a> to create a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> items = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;One&quot;</span>, <span class="stringliteral">&quot;Two&quot;</span>, <span class="stringliteral">&quot;Three&quot;</span>, <span class="stringliteral">&quot;Four&quot;</span>, <span class="stringliteral">&quot;Five&quot;</span>};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> = <a class="code hl_function" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6">from</a>(items);</div>
<div class="line">  <span class="keyword">auto</span> enumerator = <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a>.get_enumerator();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">while</span> (enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#ad461ec52e959712ab699f6ca3aa5ec3d">move_next</a>())</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#a56ef2e4d105ed3260d33bd1989b43f3b">current</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// One</span></div>
<div class="line"><span class="comment">// Two</span></div>
<div class="line"><span class="comment">// Three</span></div>
<div class="line"><span class="comment">// Four</span></div>
<div class="line"><span class="comment">// Five</span></div>
<div class="line"> </div>
<div class="ttc" id="agroup__linq_html_ga415cf78e6a2102413a1b88ccd0516df6"><div class="ttname"><a href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6">xtd::linq::from</a></div><div class="ttdeci">auto from(collection_t &amp;&amp;source) noexcept</div><div class="ttdoc">Returns the input typed as xtd::collections::generic::ienumerable &lt;type_t&gt;.</div><div class="ttdef"><b>Definition</b> from.hpp:28</div></div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1enumerator_html_a56ef2e4d105ed3260d33bd1989b43f3b"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1enumerator.html#a56ef2e4d105ed3260d33bd1989b43f3b">xtd::collections::generic::enumerator::current</a></div><div class="ttdeci">const type_t &amp; current() const override</div><div class="ttdoc">Gets the element in the collection at the current position of the enumerator.</div><div class="ttdef"><b>Definition</b> enumerator.hpp:62</div></div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1enumerator_html_ad461ec52e959712ab699f6ca3aa5ec3d"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1enumerator.html#ad461ec52e959712ab699f6ca3aa5ec3d">xtd::collections::generic::enumerator::move_next</a></div><div class="ttdeci">bool move_next() override</div><div class="ttdoc">Advances the enumerator to the next element of the collection.</div><div class="ttdef"><b>Definition</b> enumerator.hpp:71</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a90d2ecce5f6d3f0cf3a64fc90cf2727e" name="a90d2ecce5f6d3f0cf3a64fc90cf2727e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d2ecce5f6d3f0cf3a64fc90cf2727e">&#9670;&#160;</a></span>from() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::from </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Same as as_enemerable(std::initializer_list&lt;source_t&gt; source). </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6" title="Returns the input typed as xtd::collections::generic::ienumerable &lt;type_t&gt;.">xtd::linq::from</a> to create a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> items = std::initializer_list&lt;string&gt; {<span class="stringliteral">&quot;One&quot;</span>, <span class="stringliteral">&quot;Two&quot;</span>, <span class="stringliteral">&quot;Three&quot;</span>, <span class="stringliteral">&quot;Four&quot;</span>, <span class="stringliteral">&quot;Five&quot;</span>};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> = <a class="code hl_function" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6">from</a>(items);</div>
<div class="line">  <span class="keyword">auto</span> enumerator = <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a>.get_enumerator();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">while</span> (enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#ad461ec52e959712ab699f6ca3aa5ec3d">move_next</a>())</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#a56ef2e4d105ed3260d33bd1989b43f3b">current</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// One</span></div>
<div class="line"><span class="comment">// Two</span></div>
<div class="line"><span class="comment">// Three</span></div>
<div class="line"><span class="comment">// Four</span></div>
<div class="line"><span class="comment">// Five</span></div>
<div class="line"> </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac02b04237e05737f363d199242f7df3a" name="ac02b04237e05737f363d199242f7df3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02b04237e05737f363d199242f7df3a">&#9670;&#160;</a></span>from() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class collection_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::from </td>
          <td>(</td>
          <td class="paramtype">collection_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">collection_t</td><td>The type of the source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Same as as_enemerable(const collection_t&amp; source). </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6" title="Returns the input typed as xtd::collections::generic::ienumerable &lt;type_t&gt;.">xtd::linq::from</a> to create a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> items = std::vector {<span class="stringliteral">&quot;One&quot;</span>, <span class="stringliteral">&quot;Two&quot;</span>, <span class="stringliteral">&quot;Three&quot;</span>, <span class="stringliteral">&quot;Four&quot;</span>, <span class="stringliteral">&quot;Five&quot;</span>};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> = <a class="code hl_function" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6">from</a>(items);</div>
<div class="line">  <span class="keyword">auto</span> enumerator = <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a>.get_enumerator();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">while</span> (enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#ad461ec52e959712ab699f6ca3aa5ec3d">move_next</a>())</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#a56ef2e4d105ed3260d33bd1989b43f3b">current</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// One</span></div>
<div class="line"><span class="comment">// Two</span></div>
<div class="line"><span class="comment">// Three</span></div>
<div class="line"><span class="comment">// Four</span></div>
<div class="line"><span class="comment">// Five</span></div>
<div class="line"> </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2572f6159407e59e7076ff715cefe546" name="a2572f6159407e59e7076ff715cefe546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2572f6159407e59e7076ff715cefe546">&#9670;&#160;</a></span>from() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class input_iterator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::from </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Same as as_enemerable(input_iterator_t first, input_iterator_t last). </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6" title="Returns the input typed as xtd::collections::generic::ienumerable &lt;type_t&gt;.">xtd::linq::from</a> to create a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> items = std::vector {<span class="stringliteral">&quot;One&quot;</span>, <span class="stringliteral">&quot;Two&quot;</span>, <span class="stringliteral">&quot;Three&quot;</span>, <span class="stringliteral">&quot;Four&quot;</span>, <span class="stringliteral">&quot;Five&quot;</span>};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> = <a class="code hl_function" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6">from</a>(items.begin(), items.end());</div>
<div class="line">  <span class="keyword">auto</span> enumerator = <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a>.get_enumerator();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">while</span> (enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#ad461ec52e959712ab699f6ca3aa5ec3d">move_next</a>())</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#a56ef2e4d105ed3260d33bd1989b43f3b">current</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// One</span></div>
<div class="line"><span class="comment">// Two</span></div>
<div class="line"><span class="comment">// Three</span></div>
<div class="line"><span class="comment">// Four</span></div>
<div class="line"><span class="comment">// Five</span></div>
<div class="line"> </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a65887d1a4155d7a8eef24dc74343eafa" name="a65887d1a4155d7a8eef24dc74343eafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65887d1a4155d7a8eef24dc74343eafa">&#9670;&#160;</a></span>from() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class input_iterator_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::from </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t</td>          <td class="paramname"><span class="paramname"><em>iterator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_iterator_t</td><td>The type of the source iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>The iterator. </td></tr>
    <tr><td class="paramname">legnth</td><td>The le,gth to iterate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Same as as_enemerable(input_iterator_t iterator, size_t length). </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6" title="Returns the input typed as xtd::collections::generic::ienumerable &lt;type_t&gt;.">xtd::linq::from</a> to create a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> items = std::vector {<span class="stringliteral">&quot;One&quot;</span>, <span class="stringliteral">&quot;Two&quot;</span>, <span class="stringliteral">&quot;Three&quot;</span>, <span class="stringliteral">&quot;Four&quot;</span>, <span class="stringliteral">&quot;Five&quot;</span>};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> = <a class="code hl_function" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6">from</a>(items.begin(), 5);</div>
<div class="line">  <span class="keyword">auto</span> enumerator = <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a>.get_enumerator();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">while</span> (enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#ad461ec52e959712ab699f6ca3aa5ec3d">move_next</a>())</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#a56ef2e4d105ed3260d33bd1989b43f3b">current</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// One</span></div>
<div class="line"><span class="comment">// Two</span></div>
<div class="line"><span class="comment">// Three</span></div>
<div class="line"><span class="comment">// Four</span></div>
<div class="line"><span class="comment">// Five</span></div>
<div class="line"> </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a348b7154bf4fbc6ddfa03f9bf8de4a1f" name="a348b7154bf4fbc6ddfa03f9bf8de4a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348b7154bf4fbc6ddfa03f9bf8de4a1f">&#9670;&#160;</a></span>from() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t, size_t length&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::from </td>
          <td>(</td>
          <td class="paramtype">const source_t(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[length]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the source array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The native array. </td></tr>
    <tr><td class="paramname">legnth</td><td>The length of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Same as as_enemerable(const source_t (&amp;array)[length]). </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6" title="Returns the input typed as xtd::collections::generic::ienumerable &lt;type_t&gt;.">xtd::linq::from</a> to create a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* items[] = {<span class="stringliteral">&quot;One&quot;</span>, <span class="stringliteral">&quot;Two&quot;</span>, <span class="stringliteral">&quot;Three&quot;</span>, <span class="stringliteral">&quot;Four&quot;</span>, <span class="stringliteral">&quot;Five&quot;</span>};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> = <a class="code hl_function" href="group__linq.html#ga415cf78e6a2102413a1b88ccd0516df6">from</a>(items);</div>
<div class="line">  <span class="keyword">auto</span> enumerator = <a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a>.get_enumerator();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">while</span> (enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#ad461ec52e959712ab699f6ca3aa5ec3d">move_next</a>())</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(enumerator.<a class="code hl_function" href="structxtd_1_1collections_1_1generic_1_1enumerator.html#a56ef2e4d105ed3260d33bd1989b43f3b">current</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// One</span></div>
<div class="line"><span class="comment">// Two</span></div>
<div class="line"><span class="comment">// Three</span></div>
<div class="line"><span class="comment">// Four</span></div>
<div class="line"><span class="comment">// Five</span></div>
<div class="line"> </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab91fb65cb8ea3b6269c8982385d4b93c" name="ab91fb65cb8ea3b6269c8982385d4b93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91fb65cb8ea3b6269c8982385d4b93c">&#9670;&#160;</a></span>order_by() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::order_by </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; key_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a sequence in ascending order according to a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to order. </td></tr>
    <tr><td class="paramname">key_selector</td><td>A function to extract a key from an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use order_by&lt;key_t,âsource_t&gt;(ienumerable &lt;source_t&gt;,âstd::function&lt;key_t(const source_t&amp;)&gt;) to sort the elements of a sequence. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab85ee3d04c5083251b55a7836b081580" name="ab85ee3d04c5083251b55a7836b081580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85ee3d04c5083251b55a7836b081580">&#9670;&#160;</a></span>order_by() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::order_by </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>key_selector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a sequence in ascending order according to a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to order. </td></tr>
    <tr><td class="paramname">key_selector</td><td>A function to extract a key from an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use order_by&lt;source_t,âsource_t&gt;(ienumerable &lt;source_t&gt;,âstd::function&lt;source_t(const source_t&amp;)&gt;) to sort the elements of a sequence. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0d5849798f7b5ae566dd5e7c175dfe3d" name="a0d5849798f7b5ae566dd5e7c175dfe3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5849798f7b5ae566dd5e7c175dfe3d">&#9670;&#160;</a></span>select() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class result_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#a0d5849798f7b5ae566dd5e7c175dfe3d" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; squares = <a class="code hl_function" href="#ad3f2b197a8f9e4e52710edcdd59870e9">enumerable::range</a>(1, 10).select([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) {<span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a> * <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> num : squares)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(num);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1</span></div>
<div class="line"><span class="comment">// 4</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 16</span></div>
<div class="line"><span class="comment">// 25</span></div>
<div class="line"><span class="comment">// 36</span></div>
<div class="line"><span class="comment">// 49</span></div>
<div class="line"><span class="comment">// 64</span></div>
<div class="line"><span class="comment">// 81</span></div>
<div class="line"><span class="comment">// 100</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9c31ff77b347ca19c6a15c9e61f112b9" name="a9c31ff77b347ca19c6a15c9e61f112b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c31ff77b347ca19c6a15c9e61f112b9">&#9670;&#160;</a></span>select() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#a0d5849798f7b5ae566dd5e7c175dfe3d" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; squares = <a class="code hl_function" href="#ad3f2b197a8f9e4e52710edcdd59870e9">enumerable::range</a>(1, 10).select([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) {<span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a> * <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> num : squares)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(num);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1</span></div>
<div class="line"><span class="comment">// 4</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 16</span></div>
<div class="line"><span class="comment">// 25</span></div>
<div class="line"><span class="comment">// 36</span></div>
<div class="line"><span class="comment">// 49</span></div>
<div class="line"><span class="comment">// 64</span></div>
<div class="line"><span class="comment">// 81</span></div>
<div class="line"><span class="comment">// 100</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a65e2d6d5c1e8dc39d688b274e6681d81" name="a65e2d6d5c1e8dc39d688b274e6681d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e2d6d5c1e8dc39d688b274e6681d81">&#9670;&#160;</a></span>select() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class result_t, class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the resulting value. </td></tr>
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#a0d5849798f7b5ae566dd5e7c175dfe3d" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, xtd::size)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8c6c8465cd791e35bb31259209ab4eed" name="a8c6c8465cd791e35bb31259209ab4eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6c8465cd791e35bb31259209ab4eed">&#9670;&#160;</a></span>select() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>selector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#a0d5849798f7b5ae566dd5e7c175dfe3d" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, xtd::size)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select&lt;std::tuple&lt;size_t, string&gt;&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.substring(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a452f69ae6e7daea4c93977fc2ba8b044" name="a452f69ae6e7daea4c93977fc2ba8b044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452f69ae6e7daea4c93977fc2ba8b044">&#9670;&#160;</a></span>to_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> include file <code>#include &lt;xtd/collections/generic/lists&gt;</code> is needeed to use this method. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#a452f69ae6e7daea4c93977fc2ba8b044" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  list&lt;size_t&gt; lengths = fruits.select&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_function" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a> : lengths)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">length</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
<div class="ttc" id="anamespacextd_html_aa9cc6219bcf151f5a94b26a70ba8654b"><div class="ttname"><a href="namespacextd.html#aa9cc6219bcf151f5a94b26a70ba8654b">xtd::length</a></div><div class="ttdeci">constexpr size_type length() const noexcept</div><div class="ttdoc">Returns the length of the current read_only_span.</div><div class="ttdef"><b>Definition</b> read_only_span.hpp:229</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac03a53b77498111f8869505458df9915" name="ac03a53b77498111f8869505458df9915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03a53b77498111f8869505458df9915">&#9670;&#160;</a></span>where() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#ac03a53b77498111f8869505458df9915" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.where([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a81a7ff5cfe600860118447531bf188a3" name="a81a7ff5cfe600860118447531bf188a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a7ff5cfe600860118447531bf188a3">&#9670;&#160;</a></span>where() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class source_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2bd1889dc1967c50ef692411dc2c4b92">ienumerable</a>&lt; source_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, <a class="el" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a>)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">source_t</td><td>The type of the elements of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="#ac03a53b77498111f8869505458df9915" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const ienumerable &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, xtd::size)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.where([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <a class="code hl_typedef" href="group__types.html#ga221e5b824352c9046d353e4659af5b87">size</a> index) {</div>
<div class="line">    <span class="keywordflow">return</span> number &lt;= as&lt;int&gt;(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
<div class="ttc" id="agroup__types_html_ga221e5b824352c9046d353e4659af5b87"><div class="ttname"><a href="group__types.html#ga221e5b824352c9046d353e4659af5b87">xtd::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">Represents a size of any object in bytes.</div><div class="ttdef"><b>Definition</b> size.hpp:23</div></div>
<div class="ttc" id="agroup__xtd__core_html_gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df"><div class="ttname"><a href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">xtd::number_styles::number</a></div><div class="ttdeci">@ number</div><div class="ttdoc">Indicates that the allow_leading_white, allow_trailing_white, allow_leading_sign, allow_trailing_sign...</div><div class="ttdef"><b>Definition</b> number_styles.hpp:46</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/linq/<a class="el" href="linq_2enumerable_8hpp_source.html">enumerable.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 31 2025 17:35:55 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
