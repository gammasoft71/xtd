<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::linq::enumerable Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1linq.html">linq</a></li><li class="navelem"><a class="el" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1linq_1_1enumerable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::linq::enumerable Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__linq.html">linq</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::linq::enumerable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1linq_1_1enumerable.png" usemap="#xtd::linq::enumerable_map" alt=""/>
  <map id="xtd::linq::enumerable_map" name="xtd::linq::enumerable_map">
<area href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted)." alt="xtd::static_object" shape="rect" coords="0,0,125,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_t&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1linq_1_1enumerable.html">enumerable</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1static__object.html">xtd::static_object</a>;</div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html">xtd::linq::enumerable</a></div><div class="ttdoc">Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:48</div></div>
<div class="ttc" id="aclassxtd_1_1static__object_html"><div class="ttname"><a href="classxtd_1_1static__object.html">xtd::static_object</a></div><div class="ttdoc">Represent a static object. A static class can't be instantiated (constructors are deleted).</div><div class="ttdef"><b>Definition</b> static.hpp:20</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1linq.html" title="Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).">xtd::linq</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:a9b93549961bf64c99497c5f00f2d0850"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a9b93549961bf64c99497c5f00f2d0850"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a9b93549961bf64c99497c5f00f2d0850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a9b93549961bf64c99497c5f00f2d0850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73718737f59ecba4bad8c6b5f64b6617"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a73718737f59ecba4bad8c6b5f64b6617"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a73718737f59ecba4bad8c6b5f64b6617">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a73718737f59ecba4bad8c6b5f64b6617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a73718737f59ecba4bad8c6b5f64b6617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154f1aff8fafef647831bc9554c9b48d"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a154f1aff8fafef647831bc9554c9b48d"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a154f1aff8fafef647831bc9554c9b48d">aggregate</a> (const collection_t &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a154f1aff8fafef647831bc9554c9b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a154f1aff8fafef647831bc9554c9b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5e27b4f583424d1e482fff52e132f0"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5e5e27b4f583424d1e482fff52e132f0"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5e5e27b4f583424d1e482fff52e132f0">aggregate</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a5e5e27b4f583424d1e482fff52e132f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a5e5e27b4f583424d1e482fff52e132f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30589beb45024a839978c362e81da5a9"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename func_t &gt; </td></tr>
<tr class="memitem:a30589beb45024a839978c362e81da5a9"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a30589beb45024a839978c362e81da5a9">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a30589beb45024a839978c362e81da5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a30589beb45024a839978c362e81da5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6addb7f0841160d9efc1b1b12846ad47"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename func_t &gt; </td></tr>
<tr class="memitem:a6addb7f0841160d9efc1b1b12846ad47"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a6addb7f0841160d9efc1b1b12846ad47">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a6addb7f0841160d9efc1b1b12846ad47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a6addb7f0841160d9efc1b1b12846ad47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename func_t &gt; </td></tr>
<tr class="memitem:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab6acc19f96c13e626d8fc69d7bfc14c5">aggregate</a> (const collection_t &amp;source, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:ab6acc19f96c13e626d8fc69d7bfc14c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda77ef769372aed4db74698b6173d74"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename func_t &gt; </td></tr>
<tr class="memitem:adda77ef769372aed4db74698b6173d74"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#adda77ef769372aed4db74698b6173d74">aggregate</a> (input_iterator_t first, input_iterator_t last, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:adda77ef769372aed4db74698b6173d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:adda77ef769372aed4db74698b6173d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3340ab0fa239b6fdb872931d7515b457"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t &gt; </td></tr>
<tr class="memitem:a3340ab0fa239b6fdb872931d7515b457"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3340ab0fa239b6fdb872931d7515b457">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a3340ab0fa239b6fdb872931d7515b457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a3340ab0fa239b6fdb872931d7515b457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02801dad8993626dcd7c2b7cc1fc4fec"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t &gt; </td></tr>
<tr class="memitem:a02801dad8993626dcd7c2b7cc1fc4fec"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a02801dad8993626dcd7c2b7cc1fc4fec">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a02801dad8993626dcd7c2b7cc1fc4fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a02801dad8993626dcd7c2b7cc1fc4fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename collection_t &gt; </td></tr>
<tr class="memitem:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab1bdd7a08b78efc2a7debbb7f69a7e02">aggregate</a> (const collection_t &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ab1bdd7a08b78efc2a7debbb7f69a7e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46b4f242688699339f4b391055a6e72"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ab46b4f242688699339f4b391055a6e72"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab46b4f242688699339f4b391055a6e72">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:ab46b4f242688699339f4b391055a6e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:ab46b4f242688699339f4b391055a6e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a2e351b94c0f26c7ee776cf501e3c5"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename func_t &gt; </td></tr>
<tr class="memitem:a19a2e351b94c0f26c7ee776cf501e3c5"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a19a2e351b94c0f26c7ee776cf501e3c5">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a19a2e351b94c0f26c7ee776cf501e3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a19a2e351b94c0f26c7ee776cf501e3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4103c8e700221902e26628caca127a15"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename func_t &gt; </td></tr>
<tr class="memitem:a4103c8e700221902e26628caca127a15"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4103c8e700221902e26628caca127a15">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a4103c8e700221902e26628caca127a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a4103c8e700221902e26628caca127a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f264b52a622ec32100c5a9ade3500c"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename collection_t , typename func_t &gt; </td></tr>
<tr class="memitem:a50f264b52a622ec32100c5a9ade3500c"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a50f264b52a622ec32100c5a9ade3500c">aggregate</a> (const collection_t &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a50f264b52a622ec32100c5a9ade3500c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a50f264b52a622ec32100c5a9ade3500c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7e4b4e77fe80020fafce9b60441061"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename input_iterator_t , typename func_t &gt; </td></tr>
<tr class="memitem:a3b7e4b4e77fe80020fafce9b60441061"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3b7e4b4e77fe80020fafce9b60441061">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>)</td></tr>
<tr class="memdesc:a3b7e4b4e77fe80020fafce9b60441061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a3b7e4b4e77fe80020fafce9b60441061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bfe5c433036b8a3435984e84a879d0"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t &gt; </td></tr>
<tr class="memitem:aa3bfe5c433036b8a3435984e84a879d0"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa3bfe5c433036b8a3435984e84a879d0">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:aa3bfe5c433036b8a3435984e84a879d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:aa3bfe5c433036b8a3435984e84a879d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd2e96cc0f12d577728c54cdbba34e5"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t &gt; </td></tr>
<tr class="memitem:abfd2e96cc0f12d577728c54cdbba34e5"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#abfd2e96cc0f12d577728c54cdbba34e5">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:abfd2e96cc0f12d577728c54cdbba34e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:abfd2e96cc0f12d577728c54cdbba34e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc1c09dd640d49cf46e47315353ed18"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t , typename collection_t &gt; </td></tr>
<tr class="memitem:aadc1c09dd640d49cf46e47315353ed18"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aadc1c09dd640d49cf46e47315353ed18">aggregate</a> (const collection_t &amp;source, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:aadc1c09dd640d49cf46e47315353ed18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:aadc1c09dd640d49cf46e47315353ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86311e56c9cda909d08cdabdcf472b5"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ab86311e56c9cda909d08cdabdcf472b5"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab86311e56c9cda909d08cdabdcf472b5">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector)</td></tr>
<tr class="memdesc:ab86311e56c9cda909d08cdabdcf472b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:ab86311e56c9cda909d08cdabdcf472b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8165ca22a410944137c96611dd9372c9"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a8165ca22a410944137c96611dd9372c9"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8165ca22a410944137c96611dd9372c9">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a8165ca22a410944137c96611dd9372c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a8165ca22a410944137c96611dd9372c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cadb72337035e42730b10e0a57803f"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename result_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a68cadb72337035e42730b10e0a57803f"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a68cadb72337035e42730b10e0a57803f">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a68cadb72337035e42730b10e0a57803f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a68cadb72337035e42730b10e0a57803f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6e9be709bf0d6bfb742135409e193c"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename result_t , typename collection_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a1b6e9be709bf0d6bfb742135409e193c"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a1b6e9be709bf0d6bfb742135409e193c">aggregate</a> (const collection_t &amp;collection, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a1b6e9be709bf0d6bfb742135409e193c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a1b6e9be709bf0d6bfb742135409e193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1fb529106403a96744a6f0e409179c"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename result_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a2f1fb529106403a96744a6f0e409179c"><td class="memTemplItemLeft" align="right" valign="top">static result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2f1fb529106403a96744a6f0e409179c">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a2f1fb529106403a96744a6f0e409179c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a2f1fb529106403a96744a6f0e409179c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a119ff990e2b66cf2f6e9767a5d2828"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a8a119ff990e2b66cf2f6e9767a5d2828"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8a119ff990e2b66cf2f6e9767a5d2828">aggregate</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a8a119ff990e2b66cf2f6e9767a5d2828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a8a119ff990e2b66cf2f6e9767a5d2828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15166396187c1a938680f6a1316b100b"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename accumulate_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a15166396187c1a938680f6a1316b100b"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a15166396187c1a938680f6a1316b100b">aggregate</a> (std::initializer_list&lt; source_t &gt; source, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a15166396187c1a938680f6a1316b100b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a15166396187c1a938680f6a1316b100b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3218c9c234c742982c4d85953286b9"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename collection_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a0d3218c9c234c742982c4d85953286b9"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0d3218c9c234c742982c4d85953286b9">aggregate</a> (const collection_t &amp;collection, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a0d3218c9c234c742982c4d85953286b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a0d3218c9c234c742982c4d85953286b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </td></tr>
<tr class="memitem:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="memTemplItemLeft" align="right" valign="top">static accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2f7ca162d5d735492ed63bc2d1f076fd">aggregate</a> (input_iterator_t first, input_iterator_t last, const accumulate_t &amp;seed, const func_t &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const result_selector_t &amp;result_selector)</td></tr>
<tr class="memdesc:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a2f7ca162d5d735492ed63bc2d1f076fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400685e150fbc23f95103aec6038e0da"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a400685e150fbc23f95103aec6038e0da"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da">all</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a400685e150fbc23f95103aec6038e0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a400685e150fbc23f95103aec6038e0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c0f58808d470666722b1d3a40ed8c4"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a00c0f58808d470666722b1d3a40ed8c4"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a00c0f58808d470666722b1d3a40ed8c4">all</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a00c0f58808d470666722b1d3a40ed8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a00c0f58808d470666722b1d3a40ed8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d2b50122ac7429831299a556be7efa"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:af5d2b50122ac7429831299a556be7efa"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af5d2b50122ac7429831299a556be7efa">all</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:af5d2b50122ac7429831299a556be7efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:af5d2b50122ac7429831299a556be7efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8fd7b35aaebdbea8331a5aaeea8cad9c">all</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a8fd7b35aaebdbea8331a5aaeea8cad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91f9e006465da4a57f64338c49b9eb2"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:aa91f9e006465da4a57f64338c49b9eb2"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa91f9e006465da4a57f64338c49b9eb2">all</a> (std::initializer_list&lt; source_t &gt; source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:aa91f9e006465da4a57f64338c49b9eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aa91f9e006465da4a57f64338c49b9eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ec7f29327dfa3a235e192a697f88b7"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:ab5ec7f29327dfa3a235e192a697f88b7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab5ec7f29327dfa3a235e192a697f88b7">all</a> (const collection_t &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ab5ec7f29327dfa3a235e192a697f88b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:ab5ec7f29327dfa3a235e192a697f88b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3bca3810844c7f42e4bb3f09c1b3820b">all</a> (input_iterator_t first, input_iterator_t last, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a3bca3810844c7f42e4bb3f09c1b3820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c3f84b83d0dad286c73c7b045a40c"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:aca7c3f84b83d0dad286c73c7b045a40c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aca7c3f84b83d0dad286c73c7b045a40c">any</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:aca7c3f84b83d0dad286c73c7b045a40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:aca7c3f84b83d0dad286c73c7b045a40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a01ae8e0e45fb40cc7ae0c58bb2eb4dc6">any</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa5fca6b9d7bc049f1eef56457c17a2bf">any</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:aa5fca6b9d7bc049f1eef56457c17a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5200b0bf55e0d4ca3bd76e300b34a3ca">any</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a5200b0bf55e0d4ca3bd76e300b34a3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa60ed473f8fad23f5890e348879599"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a2fa60ed473f8fad23f5890e348879599"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2fa60ed473f8fad23f5890e348879599">any</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a2fa60ed473f8fad23f5890e348879599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a2fa60ed473f8fad23f5890e348879599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1588879c5bede53fb6e8c3329138971"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ae1588879c5bede53fb6e8c3329138971"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae1588879c5bede53fb6e8c3329138971">any</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ae1588879c5bede53fb6e8c3329138971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:ae1588879c5bede53fb6e8c3329138971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2270a08fffe2f4cce7944d2a77e21202"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a2270a08fffe2f4cce7944d2a77e21202"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2270a08fffe2f4cce7944d2a77e21202">any</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a2270a08fffe2f4cce7944d2a77e21202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a2270a08fffe2f4cce7944d2a77e21202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a5f332f87f28c6c9ea9e7df729ed3d3b7">any</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a5f332f87f28c6c9ea9e7df729ed3d3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426fee4903820f2b103702eb1d5f36d9"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a426fee4903820f2b103702eb1d5f36d9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a426fee4903820f2b103702eb1d5f36d9">any</a> (std::initializer_list&lt; source_t &gt; source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a426fee4903820f2b103702eb1d5f36d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a426fee4903820f2b103702eb1d5f36d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782315b34c17c5bebb5e00277a8fe0c3"><td class="memTemplParams" colspan="2">template&lt;typename collection_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:a782315b34c17c5bebb5e00277a8fe0c3"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a782315b34c17c5bebb5e00277a8fe0c3">any</a> (const collection_t &amp;source, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a782315b34c17c5bebb5e00277a8fe0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a782315b34c17c5bebb5e00277a8fe0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b3479936dce019d229f63ae01b51c5"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t , typename predicate_t &gt; </td></tr>
<tr class="memitem:ad4b3479936dce019d229f63ae01b51c5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ad4b3479936dce019d229f63ae01b51c5">any</a> (input_iterator_t first, input_iterator_t last, const predicate_t &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ad4b3479936dce019d229f63ae01b51c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:ad4b3479936dce019d229f63ae01b51c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf22bf866179b4de2e4272eabff559a0"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:adf22bf866179b4de2e4272eabff559a0"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">append</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:adf22bf866179b4de2e4272eabff559a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:adf22bf866179b4de2e4272eabff559a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a906017d571e0a1e73912f87489b40"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a52a906017d571e0a1e73912f87489b40"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a52a906017d571e0a1e73912f87489b40">append</a> (std::initializer_list&lt; source_t &gt; source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:a52a906017d571e0a1e73912f87489b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a52a906017d571e0a1e73912f87489b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8263fc7e8283eef962407c4313cc4a7"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:ac8263fc7e8283eef962407c4313cc4a7"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ac8263fc7e8283eef962407c4313cc4a7">append</a> (const collection_t &amp;source, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:ac8263fc7e8283eef962407c4313cc4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:ac8263fc7e8283eef962407c4313cc4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be188acb4bb748b0112589c342e8423"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a0be188acb4bb748b0112589c342e8423"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0be188acb4bb748b0112589c342e8423">append</a> (input_iterator_t first, input_iterator_t last, const source_t &amp;element) noexcept</td></tr>
<tr class="memdesc:a0be188acb4bb748b0112589c342e8423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a0be188acb4bb748b0112589c342e8423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d172ff89909b3d3e27cf4c91116177"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a25d172ff89909b3d3e27cf4c91116177"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a25d172ff89909b3d3e27cf4c91116177">as_enumerable</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a25d172ff89909b3d3e27cf4c91116177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a25d172ff89909b3d3e27cf4c91116177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cf222a70f4ada78f0bfc805d81739a"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a71cf222a70f4ada78f0bfc805d81739a"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a71cf222a70f4ada78f0bfc805d81739a">as_enumerable</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:a71cf222a70f4ada78f0bfc805d81739a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a71cf222a70f4ada78f0bfc805d81739a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90ec21b4abacec8eb0e29071f8efc97"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:af90ec21b4abacec8eb0e29071f8efc97"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af90ec21b4abacec8eb0e29071f8efc97">as_enumerable</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:af90ec21b4abacec8eb0e29071f8efc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:af90ec21b4abacec8eb0e29071f8efc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9518817b1581ae817e402b740bbb1f"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a0a9518817b1581ae817e402b740bbb1f"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0a9518817b1581ae817e402b740bbb1f">as_enumerable</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a0a9518817b1581ae817e402b740bbb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a0a9518817b1581ae817e402b740bbb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637ef7b9fc2bb6c501901d6d2eea0349"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a637ef7b9fc2bb6c501901d6d2eea0349">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a637ef7b9fc2bb6c501901d6d2eea0349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values.  <br /></td></tr>
<tr class="separator:a637ef7b9fc2bb6c501901d6d2eea0349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1981940673117d7d1a07bfadc4cd807e"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a1981940673117d7d1a07bfadc4cd807e">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; double &gt; &amp;source)</td></tr>
<tr class="memdesc:a1981940673117d7d1a07bfadc4cd807e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of double values.  <br /></td></tr>
<tr class="separator:a1981940673117d7d1a07bfadc4cd807e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d48767f0f4a494a6a2796ab1e5c00"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a7b7d48767f0f4a494a6a2796ab1e5c00">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; float &gt; &amp;source)</td></tr>
<tr class="memdesc:a7b7d48767f0f4a494a6a2796ab1e5c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of float values.  <br /></td></tr>
<tr class="separator:a7b7d48767f0f4a494a6a2796ab1e5c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dc3877d6633a433380dbc69feaae25"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a64dc3877d6633a433380dbc69feaae25">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a64dc3877d6633a433380dbc69feaae25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values.  <br /></td></tr>
<tr class="separator:a64dc3877d6633a433380dbc69feaae25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180145af875f8afdd754a57912662d7b"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a180145af875f8afdd754a57912662d7b">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &amp;source)</td></tr>
<tr class="memdesc:a180145af875f8afdd754a57912662d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values.  <br /></td></tr>
<tr class="separator:a180145af875f8afdd754a57912662d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e5bd4af93fd8b03d1ff9fb30b9da39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a48e5bd4af93fd8b03d1ff9fb30b9da39">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a48e5bd4af93fd8b03d1ff9fb30b9da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values.  <br /></td></tr>
<tr class="separator:a48e5bd4af93fd8b03d1ff9fb30b9da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fcb0557ee8c42fbf6906e481478b73"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a43fcb0557ee8c42fbf6906e481478b73">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a43fcb0557ee8c42fbf6906e481478b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional double values.  <br /></td></tr>
<tr class="separator:a43fcb0557ee8c42fbf6906e481478b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813a36db751d09ea896190063c987b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ad813a36db751d09ea896190063c987b9">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ad813a36db751d09ea896190063c987b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional float values.  <br /></td></tr>
<tr class="separator:ad813a36db751d09ea896190063c987b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11950bd1bc11a3e69ca92dd960ccaa83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a11950bd1bc11a3e69ca92dd960ccaa83">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a11950bd1bc11a3e69ca92dd960ccaa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values.  <br /></td></tr>
<tr class="separator:a11950bd1bc11a3e69ca92dd960ccaa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df923caaf850458512e70dd985df80d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9df923caaf850458512e70dd985df80d">average</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a9df923caaf850458512e70dd985df80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of optional <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values.  <br /></td></tr>
<tr class="separator:a9df923caaf850458512e70dd985df80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77239b8123b06e5f2d088fb74500995"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ab77239b8123b06e5f2d088fb74500995"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab77239b8123b06e5f2d088fb74500995">first_or_default</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:ab77239b8123b06e5f2d088fb74500995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ab77239b8123b06e5f2d088fb74500995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbe3f710d98adf47db973ae01b0220e"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:acdbe3f710d98adf47db973ae01b0220e"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#acdbe3f710d98adf47db973ae01b0220e">first_or_default</a> (std::initializer_list&lt; source_t &gt; source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:acdbe3f710d98adf47db973ae01b0220e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:acdbe3f710d98adf47db973ae01b0220e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ebabc65a26f263c61c446dbef009b3"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:ae6ebabc65a26f263c61c446dbef009b3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae6ebabc65a26f263c61c446dbef009b3">first_or_default</a> (const collection_t &amp;source, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:ae6ebabc65a26f263c61c446dbef009b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ae6ebabc65a26f263c61c446dbef009b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71c11e30879c9af8531c855b5eb8088"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:ae71c11e30879c9af8531c855b5eb8088"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae71c11e30879c9af8531c855b5eb8088">first_or_default</a> (input_iterator_t first, input_iterator_t last, const source_t &amp;default_value) noexcept</td></tr>
<tr class="memdesc:ae71c11e30879c9af8531c855b5eb8088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ae71c11e30879c9af8531c855b5eb8088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15732619b209ff177c90ad91b1a4bd3"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ab15732619b209ff177c90ad91b1a4bd3"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab15732619b209ff177c90ad91b1a4bd3">first_or_default</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ab15732619b209ff177c90ad91b1a4bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:ab15732619b209ff177c90ad91b1a4bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a3310b7497b5ab2593a9d401a4bf7a"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a43a3310b7497b5ab2593a9d401a4bf7a"><td class="memTemplItemLeft" align="right" valign="top">static source_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a43a3310b7497b5ab2593a9d401a4bf7a">first_or_default</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:a43a3310b7497b5ab2593a9d401a4bf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a43a3310b7497b5ab2593a9d401a4bf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0922997a0fda313f2c308ece6841ac"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:a0e0922997a0fda313f2c308ece6841ac"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0e0922997a0fda313f2c308ece6841ac">first_or_default</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:a0e0922997a0fda313f2c308ece6841ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a0e0922997a0fda313f2c308ece6841ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8ef9173ba49b6d1ce79a2aa72d5d781a">first_or_default</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a8ef9173ba49b6d1ce79a2aa72d5d781a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad0f9812852378c4ed08a50f39396cd"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2ad0f9812852378c4ed08a50f39396cd">range</a> (<a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> start, <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> count)</td></tr>
<tr class="memdesc:a2ad0f9812852378c4ed08a50f39396cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of integral numbers within a specified range.  <br /></td></tr>
<tr class="separator:a2ad0f9812852378c4ed08a50f39396cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2df9541f109773859bcaaf42015b8cd"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t &gt; </td></tr>
<tr class="memitem:ae2df9541f109773859bcaaf42015b8cd"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd">select</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:ae2df9541f109773859bcaaf42015b8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:ae2df9541f109773859bcaaf42015b8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b515d60afc6b91c90f992d75a8b839"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t &gt; </td></tr>
<tr class="memitem:a56b515d60afc6b91c90f992d75a8b839"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a56b515d60afc6b91c90f992d75a8b839">select</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a56b515d60afc6b91c90f992d75a8b839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a56b515d60afc6b91c90f992d75a8b839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cff7768a676655cf4e501cf207ba994"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a8cff7768a676655cf4e501cf207ba994"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8cff7768a676655cf4e501cf207ba994">select</a> (const collection_t &amp;source, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a8cff7768a676655cf4e501cf207ba994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a8cff7768a676655cf4e501cf207ba994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3159d59161a1a74114d24e228f4bf5"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a2d3159d59161a1a74114d24e228f4bf5"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2d3159d59161a1a74114d24e228f4bf5">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a2d3159d59161a1a74114d24e228f4bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a2d3159d59161a1a74114d24e228f4bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f003a07c40e6e294a3f0a7112b928a"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a18f003a07c40e6e294a3f0a7112b928a"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a18f003a07c40e6e294a3f0a7112b928a">select</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a18f003a07c40e6e294a3f0a7112b928a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a18f003a07c40e6e294a3f0a7112b928a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843120789f3e7358378d8890cf3af627"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a843120789f3e7358378d8890cf3af627"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a843120789f3e7358378d8890cf3af627">select</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a843120789f3e7358378d8890cf3af627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a843120789f3e7358378d8890cf3af627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e0db840e15ea8213f3f3bdf8e4f037"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a87e0db840e15ea8213f3f3bdf8e4f037"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a87e0db840e15ea8213f3f3bdf8e4f037">select</a> (const collection_t &amp;source, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a87e0db840e15ea8213f3f3bdf8e4f037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a87e0db840e15ea8213f3f3bdf8e4f037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67de3d7bedf4a2b37263f3f8c80dd23b"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a67de3d7bedf4a2b37263f3f8c80dd23b"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a67de3d7bedf4a2b37263f3f8c80dd23b">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a67de3d7bedf4a2b37263f3f8c80dd23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a67de3d7bedf4a2b37263f3f8c80dd23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa225ac00bee37ae20612746f59384344"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t &gt; </td></tr>
<tr class="memitem:aa225ac00bee37ae20612746f59384344"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#aa225ac00bee37ae20612746f59384344">select</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:aa225ac00bee37ae20612746f59384344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:aa225ac00bee37ae20612746f59384344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03066643bc764582c7e781399008631f"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t &gt; </td></tr>
<tr class="memitem:a03066643bc764582c7e781399008631f"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a03066643bc764582c7e781399008631f">select</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a03066643bc764582c7e781399008631f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a03066643bc764582c7e781399008631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229157d01b404b5f9586130bae8a2df5"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a229157d01b404b5f9586130bae8a2df5"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a229157d01b404b5f9586130bae8a2df5">select</a> (const collection_t &amp;source, const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a229157d01b404b5f9586130bae8a2df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a229157d01b404b5f9586130bae8a2df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eab51d38cf021721ab219b4becb3b93"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename result_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a0eab51d38cf021721ab219b4becb3b93"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0eab51d38cf021721ab219b4becb3b93">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a0eab51d38cf021721ab219b4becb3b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a0eab51d38cf021721ab219b4becb3b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9688e81bbe3661c777ca294ace9d477"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ab9688e81bbe3661c777ca294ace9d477"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ab9688e81bbe3661c777ca294ace9d477">select</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:ab9688e81bbe3661c777ca294ace9d477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:ab9688e81bbe3661c777ca294ace9d477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920f715ad95a5810f4514b2612dcf8a9"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a920f715ad95a5810f4514b2612dcf8a9"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a920f715ad95a5810f4514b2612dcf8a9">select</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a920f715ad95a5810f4514b2612dcf8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a920f715ad95a5810f4514b2612dcf8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b97fec0f5183fd8fb75c4e8c859a07a"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a1b97fec0f5183fd8fb75c4e8c859a07a"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a1b97fec0f5183fd8fb75c4e8c859a07a">select</a> (const collection_t &amp;source, const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a1b97fec0f5183fd8fb75c4e8c859a07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a1b97fec0f5183fd8fb75c4e8c859a07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438cf6d4294b5d07a8a9805b6e0eb3de"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a438cf6d4294b5d07a8a9805b6e0eb3de"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a438cf6d4294b5d07a8a9805b6e0eb3de">select</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a438cf6d4294b5d07a8a9805b6e0eb3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a438cf6d4294b5d07a8a9805b6e0eb3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4632879fe4e92c640c0382e32de2967"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ae4632879fe4e92c640c0382e32de2967"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967">to_list</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:ae4632879fe4e92c640c0382e32de2967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ae4632879fe4e92c640c0382e32de2967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55daa0b846f9aedeced89d51b29d219"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ad55daa0b846f9aedeced89d51b29d219"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ad55daa0b846f9aedeced89d51b29d219">to_list</a> (std::initializer_list&lt; source_t &gt; source) noexcept</td></tr>
<tr class="memdesc:ad55daa0b846f9aedeced89d51b29d219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an std::initializer_list &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ad55daa0b846f9aedeced89d51b29d219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56d7345bb6c56ad7b55b25518e84ae1"><td class="memTemplParams" colspan="2">template&lt;typename collection_t &gt; </td></tr>
<tr class="memitem:af56d7345bb6c56ad7b55b25518e84ae1"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#af56d7345bb6c56ad7b55b25518e84ae1">to_list</a> (const collection_t &amp;source) noexcept</td></tr>
<tr class="memdesc:af56d7345bb6c56ad7b55b25518e84ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an collection_t.  <br /></td></tr>
<tr class="separator:af56d7345bb6c56ad7b55b25518e84ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4c298b0cc2654d7b726859f52f4341"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a3c4c298b0cc2654d7b726859f52f4341"><td class="memTemplItemLeft" align="right" valign="top">static const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3c4c298b0cc2654d7b726859f52f4341">to_list</a> (input_iterator_t first, input_iterator_t last) noexcept</td></tr>
<tr class="memdesc:a3c4c298b0cc2654d7b726859f52f4341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from iterators.  <br /></td></tr>
<tr class="separator:a3c4c298b0cc2654d7b726859f52f4341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade645587ccb269b8b05c4325989639be"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:ade645587ccb269b8b05c4325989639be"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be">where</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:ade645587ccb269b8b05c4325989639be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:ade645587ccb269b8b05c4325989639be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc3f019ba074a6c7a8904919d887222"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a3dc3f019ba074a6c7a8904919d887222"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a3dc3f019ba074a6c7a8904919d887222">where</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a3dc3f019ba074a6c7a8904919d887222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a3dc3f019ba074a6c7a8904919d887222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b767d8dec90302a51169029c37ba82d"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a8b767d8dec90302a51169029c37ba82d"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a8b767d8dec90302a51169029c37ba82d">where</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a8b767d8dec90302a51169029c37ba82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a8b767d8dec90302a51169029c37ba82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daeaea8dafaa306901966cb1bcfcbc8"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a0daeaea8dafaa306901966cb1bcfcbc8"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a0daeaea8dafaa306901966cb1bcfcbc8">where</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a0daeaea8dafaa306901966cb1bcfcbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a0daeaea8dafaa306901966cb1bcfcbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcca88e9ad7db7466f0be1b26a2ebdd"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:acdcca88e9ad7db7466f0be1b26a2ebdd"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#acdcca88e9ad7db7466f0be1b26a2ebdd">where</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;source, const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:acdcca88e9ad7db7466f0be1b26a2ebdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:acdcca88e9ad7db7466f0be1b26a2ebdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11238bde49fa3d58954790a1f3d0028d"><td class="memTemplParams" colspan="2">template&lt;typename source_t &gt; </td></tr>
<tr class="memitem:a11238bde49fa3d58954790a1f3d0028d"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a11238bde49fa3d58954790a1f3d0028d">where</a> (std::initializer_list&lt; source_t &gt; source, const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a11238bde49fa3d58954790a1f3d0028d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a11238bde49fa3d58954790a1f3d0028d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001fb1729defd31bfc98840b1127f05c"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename collection_t &gt; </td></tr>
<tr class="memitem:a001fb1729defd31bfc98840b1127f05c"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a001fb1729defd31bfc98840b1127f05c">where</a> (const collection_t &amp;source, const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;selector)</td></tr>
<tr class="memdesc:a001fb1729defd31bfc98840b1127f05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a001fb1729defd31bfc98840b1127f05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7969a0e7e527596c1a682f9e872114bb"><td class="memTemplParams" colspan="2">template&lt;typename source_t , typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a7969a0e7e527596c1a682f9e872114bb"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1linq_1_1enumerable.html#a7969a0e7e527596c1a682f9e872114bb">where</a> (input_iterator_t first, input_iterator_t last, const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>)</td></tr>
<tr class="memdesc:a7969a0e7e527596c1a682f9e872114bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a7969a0e7e527596c1a682f9e872114bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b93549961bf64c99497c5f00f2d0850" name="a9b93549961bf64c99497c5f00f2d0850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b93549961bf64c99497c5f00f2d0850">&#9670;&#160;</a></span>aggregate() <span class="overload">[1/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.hpp:10</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a73718737f59ecba4bad8c6b5f64b6617" name="a73718737f59ecba4bad8c6b5f64b6617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73718737f59ecba4bad8c6b5f64b6617">&#9670;&#160;</a></span>aggregate() <span class="overload">[2/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a154f1aff8fafef647831bc9554c9b48d" name="a154f1aff8fafef647831bc9554c9b48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154f1aff8fafef647831bc9554c9b48d">&#9670;&#160;</a></span>aggregate() <span class="overload">[3/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5e5e27b4f583424d1e482fff52e132f0" name="a5e5e27b4f583424d1e482fff52e132f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5e27b4f583424d1e482fff52e132f0">&#9670;&#160;</a></span>aggregate() <span class="overload">[4/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = enumerable::aggregate&lt;string&gt;(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    return next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
<div class="ttc" id="anamespacextd_1_1linq_html"><div class="ttname"><a href="namespacextd_1_1linq.html">xtd::linq</a></div><div class="ttdoc">Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).</div><div class="ttdef"><b>Definition</b> enumerable.hpp:27</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a30589beb45024a839978c362e81da5a9" name="a30589beb45024a839978c362e81da5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30589beb45024a839978c362e81da5a9">&#9670;&#160;</a></span>aggregate() <span class="overload">[5/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6addb7f0841160d9efc1b1b12846ad47" name="a6addb7f0841160d9efc1b1b12846ad47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6addb7f0841160d9efc1b1b12846ad47">&#9670;&#160;</a></span>aggregate() <span class="overload">[6/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab6acc19f96c13e626d8fc69d7bfc14c5" name="ab6acc19f96c13e626d8fc69d7bfc14c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6acc19f96c13e626d8fc69d7bfc14c5">&#9670;&#160;</a></span>aggregate() <span class="overload">[7/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = words.aggregate([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    <span class="keywordflow">return</span> next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adda77ef769372aed4db74698b6173d74" name="adda77ef769372aed4db74698b6173d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda77ef769372aed4db74698b6173d74">&#9670;&#160;</a></span>aggregate() <span class="overload">[8/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to reverse the order of words in a string by using <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> sentence = <span class="stringliteral">&quot;the quick brown fox jumps over the lazy dog&quot;</span>_s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Split the string into individual words.</span></div>
<div class="line">  <span class="keyword">auto</span> words = sentence.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Prepend each word to the beginning of the new sentence to reverse the word order.</span></div>
<div class="line">  <span class="keyword">auto</span> reversed = enumerable::aggregate&lt;string&gt;(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; working_sentence, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {</div>
<div class="line">    return next + <span class="stringliteral">&quot; &quot;</span> + working_sentence;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(reversed.quoted());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &quot;dog lazy the over jumps fox brown quick the&quot;</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3340ab0fa239b6fdb872931d7515b457" name="a3340ab0fa239b6fdb872931d7515b457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3340ab0fa239b6fdb872931d7515b457">&#9670;&#160;</a></span>aggregate() <span class="overload">[9/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
<div class="ttc" id="aclassxtd_1_1array_html"><div class="ttname"><a href="classxtd_1_1array.html">xtd::array</a></div><div class="ttdoc">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...</div><div class="ttdef"><b>Definition</b> array.hpp:58</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a22f3540f62b3b6140ecf188faf509842"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">xtd::collections::generic::extensions::enumerable::aggregate</a></div><div class="ttdeci">source_t aggregate(const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;func) const</div><div class="ttdoc">Applies an accumulator function over a sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:42</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a02801dad8993626dcd7c2b7cc1fc4fec" name="a02801dad8993626dcd7c2b7cc1fc4fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02801dad8993626dcd7c2b7cc1fc4fec">&#9670;&#160;</a></span>aggregate() <span class="overload">[10/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab1bdd7a08b78efc2a7debbb7f69a7e02" name="ab1bdd7a08b78efc2a7debbb7f69a7e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bdd7a08b78efc2a7debbb7f69a7e02">&#9670;&#160;</a></span>aggregate() <span class="overload">[11/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab46b4f242688699339f4b391055a6e72" name="ab46b4f242688699339f4b391055a6e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46b4f242688699339f4b391055a6e72">&#9670;&#160;</a></span>aggregate() <span class="overload">[12/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_a9b93549961bf64c99497c5f00f2d0850"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">xtd::linq::enumerable::aggregate</a></div><div class="ttdeci">static source_t aggregate(const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp;source, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;func)</div><div class="ttdoc">Applies an accumulator function over a sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:61</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a19a2e351b94c0f26c7ee776cf501e3c5" name="a19a2e351b94c0f26c7ee776cf501e3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a2e351b94c0f26c7ee776cf501e3c5">&#9670;&#160;</a></span>aggregate() <span class="overload">[13/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4103c8e700221902e26628caca127a15" name="a4103c8e700221902e26628caca127a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4103c8e700221902e26628caca127a15">&#9670;&#160;</a></span>aggregate() <span class="overload">[14/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = ints.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    <span class="keywordflow">return</span> next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a50f264b52a622ec32100c5a9ade3500c" name="a50f264b52a622ec32100c5a9ade3500c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f264b52a622ec32100c5a9ade3500c">&#9670;&#160;</a></span>aggregate() <span class="overload">[15/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename collection_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3b7e4b4e77fe80020fafce9b60441061" name="a3b7e4b4e77fe80020fafce9b60441061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7e4b4e77fe80020fafce9b60441061">&#9670;&#160;</a></span>aggregate() <span class="overload">[16/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename input_iterator_t , typename func_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa3bfe5c433036b8a3435984e84a879d0" name="aa3bfe5c433036b8a3435984e84a879d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bfe5c433036b8a3435984e84a879d0">&#9670;&#160;</a></span>aggregate() <span class="overload">[17/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_a4cc6be7fa93346c34256fb76e6dc4b3a"><div class="ttname"><a href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">xtd::basic_string::to_upper</a></div><div class="ttdeci">basic_string to_upper() const noexcept</div><div class="ttdoc">Returns a copy of the current xtd::basic_string converted to uppercase.</div><div class="ttdef"><b>Definition</b> basic_string.hpp:1953</div></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_aabfeb876a8fb51c80fa9adaa3663f232"><div class="ttname"><a href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">xtd::basic_string::length</a></div><div class="ttdeci">size_type length() const noexcept</div><div class="ttdoc">Gets the number of characters in the current xtd::basic_string object.</div><div class="ttdef"><b>Definition</b> basic_string.hpp:918</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abfd2e96cc0f12d577728c54cdbba34e5" name="abfd2e96cc0f12d577728c54cdbba34e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd2e96cc0f12d577728c54cdbba34e5">&#9670;&#160;</a></span>aggregate() <span class="overload">[18/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aadc1c09dd640d49cf46e47315353ed18" name="aadc1c09dd640d49cf46e47315353ed18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc1c09dd640d49cf46e47315353ed18">&#9670;&#160;</a></span>aggregate() <span class="overload">[19/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab86311e56c9cda909d08cdabdcf472b5" name="ab86311e56c9cda909d08cdabdcf472b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86311e56c9cda909d08cdabdcf472b5">&#9670;&#160;</a></span>aggregate() <span class="overload">[20/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> ints = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {4, 8, 8, 3, 9, 0, 7, 8, 2};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></div>
<div class="line">  <span class="keyword">auto</span> num_even = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(ints.begin(), ints.end(), 0, [](<span class="keywordtype">int</span> total, <span class="keywordtype">int</span> next) {</div>
<div class="line">    return next % 2 == 0 ? total + 1 : total;</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The number of even integers is: {}&quot;</span>, num_even);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The number of even integers is: 6</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8165ca22a410944137c96611dd9372c9" name="a8165ca22a410944137c96611dd9372c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8165ca22a410944137c96611dd9372c9">&#9670;&#160;</a></span>aggregate() <span class="overload">[21/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a68cadb72337035e42730b10e0a57803f" name="a68cadb72337035e42730b10e0a57803f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cadb72337035e42730b10e0a57803f">&#9670;&#160;</a></span>aggregate() <span class="overload">[22/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename result_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1b6e9be709bf0d6bfb742135409e193c" name="a1b6e9be709bf0d6bfb742135409e193c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6e9be709bf0d6bfb742135409e193c">&#9670;&#160;</a></span>aggregate() <span class="overload">[23/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename result_t , typename collection_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2f1fb529106403a96744a6f0e409179c" name="a2f1fb529106403a96744a6f0e409179c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1fb529106403a96744a6f0e409179c">&#9670;&#160;</a></span>aggregate() <span class="overload">[24/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename result_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8a119ff990e2b66cf2f6e9767a5d2828" name="a8a119ff990e2b66cf2f6e9767a5d2828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a119ff990e2b66cf2f6e9767a5d2828">&#9670;&#160;</a></span>aggregate() <span class="overload">[25/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a15166396187c1a938680f6a1316b100b" name="a15166396187c1a938680f6a1316b100b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15166396187c1a938680f6a1316b100b">&#9670;&#160;</a></span>aggregate() <span class="overload">[26/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename accumulate_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_Selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a>(<span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {<span class="keywordflow">return</span> next.length() &gt; longest.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a>();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0d3218c9c234c742982c4d85953286b9" name="a0d3218c9c234c742982c4d85953286b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3218c9c234c742982c4d85953286b9">&#9670;&#160;</a></span>aggregate() <span class="overload">[27/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename collection_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t collection to aggregate over. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2f7ca162d5d735492ed63bc2d1f076fd" name="a2f7ca162d5d735492ed63bc2d1f076fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7ca162d5d735492ed63bc2d1f076fd">&#9670;&#160;</a></span>aggregate() <span class="overload">[28/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename accumulate_t , typename input_iterator_t , typename func_t , typename result_selector_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static accumulate_t xtd::linq::enumerable::aggregate </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accumulate_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const func_t &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const result_selector_t &amp;&#160;</td>
          <td class="paramname"><em>result_selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">seed</td><td>The initial accumulator value. </td></tr>
    <tr><td class="paramname">func</td><td>An accumulator function to be invoked on each element. </td></tr>
    <tr><td class="paramname">result_selector</td><td>A function to transform the final accumulator value into the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed final accumulator value. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850" title="Applies an accumulator function over a sequence.">xtd::linq::enumerable::aggregate</a> to apply an accumulator function and use a seed value. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></div>
<div class="line">  <span class="keyword">auto</span> longest_name =</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#a9b93549961bf64c99497c5f00f2d0850">enumerable::aggregate</a>(fruits.begin(), fruits.end(), <span class="stringliteral">&quot;bananas&quot;</span>_s,</div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; longest, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; next) {return next.length() &gt; longest.length() ? next : longest;},</div>
<div class="line">                        <span class="comment">// Return the final result as an upper case string.</span></div>
<div class="line">                        [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {return fruit.to_upper();});</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The fruit with the longest name is {}&quot;</span>, longest_name);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a400685e150fbc23f95103aec6038e0da" name="a400685e150fbc23f95103aec6038e0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400685e150fbc23f95103aec6038e0da">&#9670;&#160;</a></span>all() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a8c344a4319826da54bae2611d78f7e41"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">xtd::collections::generic::extensions::enumerable::all</a></div><div class="ttdeci">bool all(const std::function&lt; bool(const source_t &amp;)&gt; &amp;predicate) const</div><div class="ttdoc">Determines whether all elements of a sequence satisfy a condition.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:120</div></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:42</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a00c0f58808d470666722b1d3a40ed8c4" name="a00c0f58808d470666722b1d3a40ed8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c0f58808d470666722b1d3a40ed8c4">&#9670;&#160;</a></span>all() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af5d2b50122ac7429831299a556be7efa" name="af5d2b50122ac7429831299a556be7efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d2b50122ac7429831299a556be7efa">&#9670;&#160;</a></span>all() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8fd7b35aaebdbea8331a5aaeea8cad9c" name="a8fd7b35aaebdbea8331a5aaeea8cad9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd7b35aaebdbea8331a5aaeea8cad9c">&#9670;&#160;</a></span>all() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa91f9e006465da4a57f64338c49b9eb2" name="aa91f9e006465da4a57f64338c49b9eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91f9e006465da4a57f64338c49b9eb2">&#9670;&#160;</a></span>all() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab5ec7f29327dfa3a235e192a697f88b7" name="ab5ec7f29327dfa3a235e192a697f88b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ec7f29327dfa3a235e192a697f88b7">&#9670;&#160;</a></span>all() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3bca3810844c7f42e4bb3f09c1b3820b" name="a3bca3810844c7f42e4bb3f09c1b3820b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bca3810844c7f42e4bb3f09c1b3820b">&#9670;&#160;</a></span>all() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::all </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = enumerable::all&lt;pet&gt;(pets.begin(), pets.end(), [](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    return pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aca7c3f84b83d0dad286c73c7b045a40c" name="aca7c3f84b83d0dad286c73c7b045a40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7c3f84b83d0dad286c73c7b045a40c">&#9670;&#160;</a></span>any() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to check for emptiness. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">any</a>();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a25e647f592add925edc5682334fa2b29"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">xtd::collections::generic::extensions::enumerable::any</a></div><div class="ttdeci">bool any() const noexcept</div><div class="ttdoc">Determines whether a sequence contains any elements.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:129</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1list_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a></div><div class="ttdoc">Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...</div><div class="ttdef"><b>Definition</b> list.hpp:71</div></div>
<div class="ttc" id="anamespacextd_1_1collections_1_1generic_html"><div class="ttname"><a href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a></div><div class="ttdoc">The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...</div><div class="ttdef"><b>Definition</b> comparer.hpp:15</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a01ae8e0e45fb40cc7ae0c58bb2eb4dc6" name="a01ae8e0e45fb40cc7ae0c58bb2eb4dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ae8e0e45fb40cc7ae0c58bb2eb4dc6">&#9670;&#160;</a></span>any() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to check for emptiness. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">any</a>();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa5fca6b9d7bc049f1eef56457c17a2bf" name="aa5fca6b9d7bc049f1eef56457c17a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fca6b9d7bc049f1eef56457c17a2bf">&#9670;&#160;</a></span>any() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The collection_t to check for emptiness. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">any</a>();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5200b0bf55e0d4ca3bd76e300b34a3ca" name="a5200b0bf55e0d4ca3bd76e300b34a3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5200b0bf55e0d4ca3bd76e300b34a3ca">&#9670;&#160;</a></span>any() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a sequence contains any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the source sequence contains any elements; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Any to determine whether a sequence contains any elements. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2};</div>
<div class="line">  <span class="keyword">auto</span> has_elements = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">any</a>();</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;The list {0} empty.&quot;</span>, has_elements ? <span class="stringliteral">&quot;is not&quot;</span> : <span class="stringliteral">&quot;is&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The list is not empty.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2fa60ed473f8fad23f5890e348879599" name="a2fa60ed473f8fad23f5890e348879599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa60ed473f8fad23f5890e348879599">&#9670;&#160;</a></span>any() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae1588879c5bede53fb6e8c3329138971" name="ae1588879c5bede53fb6e8c3329138971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1588879c5bede53fb6e8c3329138971">&#9670;&#160;</a></span>any() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2270a08fffe2f4cce7944d2a77e21202" name="a2270a08fffe2f4cce7944d2a77e21202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2270a08fffe2f4cce7944d2a77e21202">&#9670;&#160;</a></span>any() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any element of a sequence satisfies a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5f332f87f28c6c9ea9e7df729ed3d3b7" name="a5f332f87f28c6c9ea9e7df729ed3d3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f332f87f28c6c9ea9e7df729ed3d3b7">&#9670;&#160;</a></span>any() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a426fee4903820f2b103702eb1d5f36d9" name="a426fee4903820f2b103702eb1d5f36d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426fee4903820f2b103702eb1d5f36d9">&#9670;&#160;</a></span>any() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a782315b34c17c5bebb5e00277a8fe0c3" name="a782315b34c17c5bebb5e00277a8fe0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782315b34c17c5bebb5e00277a8fe0c3">&#9670;&#160;</a></span>any() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A collection_t that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = pets.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a>([](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    <span class="keywordflow">return</span> pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad4b3479936dce019d229f63ae01b51c5" name="ad4b3479936dce019d229f63ae01b51c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b3479936dce019d229f63ae01b51c5">&#9670;&#160;</a></span>any() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t , typename predicate_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::linq::enumerable::any </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate_t &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any elements of a sequence satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains the elements to apply the predicate to. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a400685e150fbc23f95103aec6038e0da" title="Determines whether all elements of a sequence satisfy a condition.">xtd::linq::enumerable::all</a> &lt;source_t&gt; to determine whether all the elements in a sequence satisfy a condition. Variable all_start_with_B is true if all the pet names start with "B" or if the pets array is empty. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">struct </span>pet : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">object</a> {</div>
<div class="line">    pet() = <span class="keywordflow">default</span>;</div>
<div class="line">    pet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name, <span class="keywordtype">int</span> age) : name {name}, age {age} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> age = 0;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Create an array of pets.</span></div>
<div class="line">  <span class="keyword">auto</span> pets = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {</div>
<div class="line">    pet {<span class="stringliteral">&quot;Barley&quot;</span>, 10},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Boots&quot;</span>, 4},</div>
<div class="line">    pet {<span class="stringliteral">&quot;Whiskers&quot;</span>, 6}</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Determine whether all pet names in the array start with &#39;B&#39;.</span></div>
<div class="line">  <span class="keywordtype">bool</span> all_start_with_b = enumerable::all&lt;pet&gt;(pets.begin(), pets.end(), [](<span class="keyword">const</span> pet&amp; pet) {</div>
<div class="line">    return pet.name.starts_with(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;{} pet names start with &#39;B&#39;.&quot;</span>, all_start_with_b ? <span class="stringliteral">&quot;All&quot;</span> : <span class="stringliteral">&quot;Not all&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Not all pet names start with &#39;B&#39;.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adf22bf866179b4de2e4272eabff559a0" name="adf22bf866179b4de2e4272eabff559a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf22bf866179b4de2e4272eabff559a0">&#9670;&#160;</a></span>append() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae5d2f992c66d3c0760bb1b299ceae73d">append</a>(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_a8a7a51d0792107dd537730634b8fff12"><div class="ttname"><a href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">xtd::basic_string::join</a></div><div class="ttdeci">static basic_string join(const basic_string separator, const collection_t &amp;values) noexcept</div><div class="ttdoc">Concatenates a specified separator basic_string between each element of a specified object array,...</div><div class="ttdef"><b>Definition</b> basic_string.hpp:2296</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_ae5d2f992c66d3c0760bb1b299ceae73d"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae5d2f992c66d3c0760bb1b299ceae73d">xtd::collections::generic::extensions::enumerable::append</a></div><div class="ttdeci">const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp; append(const source_t &amp;element) const noexcept</div><div class="ttdoc">Appends a value to the end of the sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:148</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a52a906017d571e0a1e73912f87489b40" name="a52a906017d571e0a1e73912f87489b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a906017d571e0a1e73912f87489b40">&#9670;&#160;</a></span>append() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae5d2f992c66d3c0760bb1b299ceae73d">append</a>(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac8263fc7e8283eef962407c4313cc4a7" name="ac8263fc7e8283eef962407c4313cc4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8263fc7e8283eef962407c4313cc4a7">&#9670;&#160;</a></span>append() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ae5d2f992c66d3c0760bb1b299ceae73d">append</a>(5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers.append(5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = numbers.append(5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0be188acb4bb748b0112589c342e8423" name="a0be188acb4bb748b0112589c342e8423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be188acb4bb748b0112589c342e8423">&#9670;&#160;</a></span>append() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::append </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">element</td><td>The value to append to source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new sequence that ends with element. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use Append to append a value to the end of the sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/linq/enumerable&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1linq.html">xtd::linq</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="comment">// Creating a list of numbers</span></div>
<div class="line">  <span class="keyword">auto</span> numbers = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list</a> {1, 2, 3, 4};</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Trying to append any value of the same type</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">enumerable::append</a>(numbers.begin(), numbers.end(), 5);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It doesn&#39;t work because the original list has not been changed</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, numbers));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// It works now because we are using a changed copy of the original list</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">enumerable::append</a>(numbers.begin(), numbers.end(), 5)));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// If you prefer, you can create a new list explicitly</span></div>
<div class="line">  <span class="keyword">auto</span> new_numbers = <a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">enumerable::append</a>(numbers.begin(), numbers.end(), 5).to_list();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// And then write to the console output</span></div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<a class="code hl_function" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">string::join</a>(<span class="stringliteral">&quot;, &quot;</span>, new_numbers));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="line"><span class="comment">// 1, 2, 3, 4, 5</span></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_adf22bf866179b4de2e4272eabff559a0"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html#adf22bf866179b4de2e4272eabff559a0">xtd::linq::enumerable::append</a></div><div class="ttdeci">static const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp; append(const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp;source, const source_t &amp;element) noexcept</div><div class="ttdoc">Appends a value to the end of the sequence.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:691</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a25d172ff89909b3d3e27cf4c91116177" name="a25d172ff89909b3d3e27cf4c91116177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d172ff89909b3d3e27cf4c91116177">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a71cf222a70f4ada78f0bfc805d81739a" name="a71cf222a70f4ada78f0bfc805d81739a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cf222a70f4ada78f0bfc805d81739a">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af90ec21b4abacec8eb0e29071f8efc97" name="af90ec21b4abacec8eb0e29071f8efc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90ec21b4abacec8eb0e29071f8efc97">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0a9518817b1581ae817e402b740bbb1f" name="a0a9518817b1581ae817e402b740bbb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9518817b1581ae817e402b740bbb1f">&#9670;&#160;</a></span>as_enumerable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::as_enumerable </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input sequence typed as xtd::collection::generic::ienumerable &lt;type_t&gt;. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following code example demonstrates how to use as_enumerable &lt;source_t&gt;(ienumerable &lt;source_t&gt;) to hide a type's custom Where method when the standard query operator implementation is desired. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a637ef7b9fc2bb6c501901d6d2eea0349" name="a637ef7b9fc2bb6c501901d6d2eea0349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637ef7b9fc2bb6c501901d6d2eea0349">&#9670;&#160;</a></span>average() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1981940673117d7d1a07bfadc4cd807e" name="a1981940673117d7d1a07bfadc4cd807e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1981940673117d7d1a07bfadc4cd807e">&#9670;&#160;</a></span>average() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of double values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b7d48767f0f4a494a6a2796ab1e5c00" name="a7b7d48767f0f4a494a6a2796ab1e5c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7d48767f0f4a494a6a2796ab1e5c00">&#9670;&#160;</a></span>average() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of float values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of float values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64dc3877d6633a433380dbc69feaae25" name="a64dc3877d6633a433380dbc69feaae25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dc3877d6633a433380dbc69feaae25">&#9670;&#160;</a></span>average() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a180145af875f8afdd754a57912662d7b" name="a180145af875f8afdd754a57912662d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180145af875f8afdd754a57912662d7b">&#9670;&#160;</a></span>average() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1invalid__operation__exception.html" title="The exception that is thrown when the format of an argument does not meet the parameter specification...">xtd::invalid_operation_exception</a></td><td>`source` contains no elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48e5bd4af93fd8b03d1ff9fb30b9da39" name="a48e5bd4af93fd8b03d1ff9fb30b9da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e5bd4af93fd8b03d1ff9fb30b9da39">&#9670;&#160;</a></span>average() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a">xtd::decimal</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga255b88769d29fe91661cacc7720f265a" title="Represents a decimal-precision floating-point number.">xtd::decimal</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a43fcb0557ee8c42fbf6906e481478b73" name="a43fcb0557ee8c42fbf6906e481478b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fcb0557ee8c42fbf6906e481478b73">&#9670;&#160;</a></span>average() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional double values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="ad813a36db751d09ea896190063c987b9" name="ad813a36db751d09ea896190063c987b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad813a36db751d09ea896190063c987b9">&#9670;&#160;</a></span>average() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional float values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional float values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a11950bd1bc11a3e69ca92dd960ccaa83" name="a11950bd1bc11a3e69ca92dd960ccaa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11950bd1bc11a3e69ca92dd960ccaa83">&#9670;&#160;</a></span>average() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="a9df923caaf850458512e70dd985df80d" name="a9df923caaf850458512e70dd985df80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df923caaf850458512e70dd985df80d">&#9670;&#160;</a></span>average() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; double &gt; xtd::linq::enumerable::average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga17559da5e7e089b9cfa775bf7bb40263">xtd::optional</a>&lt; <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4">xtd::int64</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of a sequence of optional <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of optional <a class="el" href="group__types.html#ga2f2888f55e58cac4c07eb490db7868c4" title="Represents a 64-bit signed integer.">xtd::int64</a> values to calculate the average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the sequence of values, or <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a> if the source sequence is empty or contains only values that are <a class="el" href="group__types.html#gaf0620df1fd6c165eaad955c07e15097d" title="Represents a nullopt value. Used to indicate that an std::optional does not contain a value.">xtd::nullopt</a>. </dd></dl>

</div>
</div>
<a id="ab77239b8123b06e5f2d088fb74500995" name="ab77239b8123b06e5f2d088fb74500995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77239b8123b06e5f2d088fb74500995">&#9670;&#160;</a></span>first_or_default() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="acdbe3f710d98adf47db973ae01b0220e" name="acdbe3f710d98adf47db973ae01b0220e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbe3f710d98adf47db973ae01b0220e">&#9670;&#160;</a></span>first_or_default() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="ae6ebabc65a26f263c61c446dbef009b3" name="ae6ebabc65a26f263c61c446dbef009b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ebabc65a26f263c61c446dbef009b3">&#9670;&#160;</a></span>first_or_default() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="ae71c11e30879c9af8531c855b5eb8088" name="ae71c11e30879c9af8531c855b5eb8088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71c11e30879c9af8531c855b5eb8088">&#9670;&#160;</a></span>first_or_default() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const source_t &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if the sequence is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>default_value</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="ab15732619b209ff177c90ad91b1a4bd3" name="ab15732619b209ff177c90ad91b1a4bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15732619b209ff177c90ad91b1a4bd3">&#9670;&#160;</a></span>first_or_default() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a43a3310b7497b5ab2593a9d401a4bf7a" name="a43a3310b7497b5ab2593a9d401a4bf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a3310b7497b5ab2593a9d401a4bf7a">&#9670;&#160;</a></span>first_or_default() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static source_t xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a0e0922997a0fda313f2c308ece6841ac" name="a0e0922997a0fda313f2c308ece6841ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0922997a0fda313f2c308ece6841ac">&#9670;&#160;</a></span>first_or_default() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to return an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a8ef9173ba49b6d1ce79a2aa72d5d781a" name="a8ef9173ba49b6d1ce79a2aa72d5d781a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef9173ba49b6d1ce79a2aa72d5d781a">&#9670;&#160;</a></span>first_or_default() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto xtd::linq::enumerable::first_or_default </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default <code>source_t {}</code> if source is empty or if no element passes the test specified by predicate; otherwise, the first element in source that passes the test specified by predicate. </dd></dl>

</div>
</div>
<a id="a2ad0f9812852378c4ed08a50f39396cd" name="a2ad0f9812852378c4ed08a50f39396cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad0f9812852378c4ed08a50f39396cd">&#9670;&#160;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a> &gt; &amp; xtd::linq::enumerable::range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">xtd::int32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of integral numbers within a specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The value of the first integer in the sequence. </td></tr>
    <tr><td class="paramname">count</td><td>The number of sequential integers to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An xtd::collection::generic::ienumerable &lt;<a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e" title="Represents a 32-bit signed integer.">xtd::int32</a>&gt; that contains a range of sequential integral numbers. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`count` is less than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2ad0f9812852378c4ed08a50f39396cd" title="Generates a sequence of integral numbers within a specified range.">xtd::linq::enumerable::range</a> to generate a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae2df9541f109773859bcaaf42015b8cd" name="ae2df9541f109773859bcaaf42015b8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2df9541f109773859bcaaf42015b8cd">&#9670;&#160;</a></span>select() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a56b515d60afc6b91c90f992d75a8b839" name="a56b515d60afc6b91c90f992d75a8b839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b515d60afc6b91c90f992d75a8b839">&#9670;&#160;</a></span>select() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8cff7768a676655cf4e501cf207ba994" name="a8cff7768a676655cf4e501cf207ba994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cff7768a676655cf4e501cf207ba994">&#9670;&#160;</a></span>select() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2d3159d59161a1a74114d24e228f4bf5" name="a2d3159d59161a1a74114d24e228f4bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3159d59161a1a74114d24e228f4bf5">&#9670;&#160;</a></span>select() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a18f003a07c40e6e294a3f0a7112b928a" name="a18f003a07c40e6e294a3f0a7112b928a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f003a07c40e6e294a3f0a7112b928a">&#9670;&#160;</a></span>select() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a843120789f3e7358378d8890cf3af627" name="a843120789f3e7358378d8890cf3af627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843120789f3e7358378d8890cf3af627">&#9670;&#160;</a></span>select() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a87e0db840e15ea8213f3f3bdf8e4f037" name="a87e0db840e15ea8213f3f3bdf8e4f037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e0db840e15ea8213f3f3bdf8e4f037">&#9670;&#160;</a></span>select() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a67de3d7bedf4a2b37263f3f8c80dd23b" name="a67de3d7bedf4a2b37263f3f8c80dd23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67de3d7bedf4a2b37263f3f8c80dd23b">&#9670;&#160;</a></span>select() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;)&gt;&amp;) to project over a sequence of values. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa225ac00bee37ae20612746f59384344" name="aa225ac00bee37ae20612746f59384344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa225ac00bee37ae20612746f59384344">&#9670;&#160;</a></span>select() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;banana&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">substring</a>(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_a50394c19c9120fecc7228511cd07796b"><div class="ttname"><a href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">xtd::basic_string::substring</a></div><div class="ttdeci">basic_string substring(xtd::size start_index) const</div><div class="ttdoc">Retrieves a substring from this instance. The substring starts at a specified character position and ...</div><div class="ttdef"><b>Definition</b> basic_string.hpp:1872</div></div>
<div class="ttc" id="aclassxtd_1_1console_html"><div class="ttname"><a href="classxtd_1_1console.html">xtd::console</a></div><div class="ttdoc">Represents the standard input, output, and error streams for console applications.</div><div class="ttdef"><b>Definition</b> console.hpp:36</div></div>
<div class="ttc" id="agroup__xtd__core_html_gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb"><div class="ttname"><a href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">xtd::uri_components::query</a></div><div class="ttdeci">@ query</div><div class="ttdoc">The xtd::uri::query data.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a03066643bc764582c7e781399008631f" name="a03066643bc764582c7e781399008631f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03066643bc764582c7e781399008631f">&#9670;&#160;</a></span>select() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;banana&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">substring</a>(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a229157d01b404b5f9586130bae8a2df5" name="a229157d01b404b5f9586130bae8a2df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229157d01b404b5f9586130bae8a2df5">&#9670;&#160;</a></span>select() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;banana&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">substring</a>(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0eab51d38cf021721ab219b4becb3b93" name="a0eab51d38cf021721ab219b4becb3b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eab51d38cf021721ab219b4becb3b93">&#9670;&#160;</a></span>select() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename result_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; result_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; result_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;banana&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">substring</a>(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab9688e81bbe3661c777ca294ace9d477" name="ab9688e81bbe3661c777ca294ace9d477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9688e81bbe3661c777ca294ace9d477">&#9670;&#160;</a></span>select() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;banana&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">substring</a>(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a920f715ad95a5810f4514b2612dcf8a9" name="a920f715ad95a5810f4514b2612dcf8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920f715ad95a5810f4514b2612dcf8a9">&#9670;&#160;</a></span>select() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;banana&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">substring</a>(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1b97fec0f5183fd8fb75c4e8c859a07a" name="a1b97fec0f5183fd8fb75c4e8c859a07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b97fec0f5183fd8fb75c4e8c859a07a">&#9670;&#160;</a></span>select() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;banana&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">substring</a>(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a438cf6d4294b5d07a8a9805b6e0eb3de" name="a438cf6d4294b5d07a8a9805b6e0eb3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438cf6d4294b5d07a8a9805b6e0eb3de">&#9670;&#160;</a></span>select() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::select </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; source_t(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects each element of a sequence into a new form by incorporating the element's index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to invoke a transform function on. </td></tr>
    <tr><td class="paramname">selector</td><td>A transform function to apply to each source element; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are the result of invoking the transform function on each element of source. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae2df9541f109773859bcaaf42015b8cd" title="Projects each element of a sequence into a new form.">xtd::linq::enumerable::select</a> &lt;source_t, result_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function &lt;result_t(const source_t&amp;, size_t)&gt;&amp;) to project over a sequence of values and use the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">auto</span> fruits = <a class="code hl_class" href="classxtd_1_1array.html">array</a> {<span class="stringliteral">&quot;apple&quot;</span>_s, <span class="stringliteral">&quot;banana&quot;</span>_s, <span class="stringliteral">&quot;mango&quot;</span>_s, <span class="stringliteral">&quot;orange&quot;</span>_s, <span class="stringliteral">&quot;passionfruit&quot;</span>_s, <span class="stringliteral">&quot;grape&quot;</span>_s};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.select([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_tuple(index, fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">substring</a>(0, index));</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, str] : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;{{ index = {}, str = {} }}&quot;</span>, index, str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// { index = 0, str =  }</span></div>
<div class="line"><span class="comment">// { index = 1, str = b }</span></div>
<div class="line"><span class="comment">// { index = 2, str = ma }</span></div>
<div class="line"><span class="comment">// { index = 3, str = ora }</span></div>
<div class="line"><span class="comment">// { index = 4, str = pass }</span></div>
<div class="line"><span class="comment">// { index = 5, str = grape }</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae4632879fe4e92c640c0382e32de2967" name="ae4632879fe4e92c640c0382e32de2967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4632879fe4e92c640c0382e32de2967">&#9670;&#160;</a></span>to_list() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a xtd::collection::generic::list &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;size_t&gt;</a> lengths = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2a71193005cec47956095089fd24dca9">select</a>&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).<a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967">to_list</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> length : lengths)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(length);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a2a71193005cec47956095089fd24dca9"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2a71193005cec47956095089fd24dca9">xtd::collections::generic::extensions::enumerable::select</a></div><div class="ttdeci">const xtd::collections::generic::ienumerable&lt; result_t &gt; &amp; select(const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector) const</div><div class="ttdoc">Projects each element of a sequence into a new form.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:189</div></div>
<div class="ttc" id="aclassxtd_1_1linq_1_1enumerable_html_ae4632879fe4e92c640c0382e32de2967"><div class="ttname"><a href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967">xtd::linq::enumerable::to_list</a></div><div class="ttdeci">static const xtd::collections::generic::list&lt; source_t &gt; &amp; to_list(const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp;source) noexcept</div><div class="ttdoc">Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad55daa0b846f9aedeced89d51b29d219" name="ad55daa0b846f9aedeced89d51b29d219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55daa0b846f9aedeced89d51b29d219">&#9670;&#160;</a></span>to_list() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an std::initializer_list &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The std::initializer_list &lt;type_t&gt; to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a xtd::collection::generic::list &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;size_t&gt;</a> lengths = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2a71193005cec47956095089fd24dca9">select</a>&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).<a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967">to_list</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> length : lengths)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(length);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af56d7345bb6c56ad7b55b25518e84ae1" name="af56d7345bb6c56ad7b55b25518e84ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56d7345bb6c56ad7b55b25518e84ae1">&#9670;&#160;</a></span>to_list() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an collection_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The collection_t to create a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a xtd::collection::generic::list &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;size_t&gt;</a> lengths = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2a71193005cec47956095089fd24dca9">select</a>&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).<a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967">to_list</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> length : lengths)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(length);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3c4c298b0cc2654d7b726859f52f4341" name="a3c4c298b0cc2654d7b726859f52f4341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4c298b0cc2654d7b726859f52f4341">&#9670;&#160;</a></span>to_list() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const auto &amp; xtd::linq::enumerable::to_list </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; that contains elements from the input sequence. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967" title="Creates a xtd::collections::generic::list &lt;type_t&gt; from an xtd::collections::generic::ienumerable &lt;ty...">xtd::linq::enumerable::to_list</a> to force immediate query evaluation and return a xtd::collection::generic::list &lt;type_t&gt; that contains the query results. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1list.html">list&lt;size_t&gt;</a> lengths = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2a71193005cec47956095089fd24dca9">select</a>&lt;<span class="keywordtype">size_t</span>&gt;([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.length();}).<a class="code hl_function" href="classxtd_1_1linq_1_1enumerable.html#ae4632879fe4e92c640c0382e32de2967">to_list</a>();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> length : lengths)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(length);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 12</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line"><span class="comment">// 10</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ade645587ccb269b8b05c4325989639be" name="ade645587ccb269b8b05c4325989639be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade645587ccb269b8b05c4325989639be">&#9670;&#160;</a></span>where() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;string&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4db80522d1924c428b39bde2917b805e">where</a>([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable_html_a4db80522d1924c428b39bde2917b805e"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4db80522d1924c428b39bde2917b805e">xtd::collections::generic::extensions::enumerable::where</a></div><div class="ttdeci">const xtd::collections::generic::ienumerable&lt; source_t &gt; &amp; where(const std::function&lt; bool(const source_t &amp;)&gt; &amp;predicate) const</div><div class="ttdoc">Filters a sequence of values based on a predicate.</div><div class="ttdef"><b>Definition</b> enumerable.hpp:237</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1ienumerable_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a></div><div class="ttdoc">Exposes the enumerator, which supports a simple iteration over a collection of a specified type.</div><div class="ttdef"><b>Definition</b> ienumerable.hpp:36</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3dc3f019ba074a6c7a8904919d887222" name="a3dc3f019ba074a6c7a8904919d887222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc3f019ba074a6c7a8904919d887222">&#9670;&#160;</a></span>where() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;string&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4db80522d1924c428b39bde2917b805e">where</a>([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8b767d8dec90302a51169029c37ba82d" name="a8b767d8dec90302a51169029c37ba82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b767d8dec90302a51169029c37ba82d">&#9670;&#160;</a></span>where() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;string&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4db80522d1924c428b39bde2917b805e">where</a>([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0daeaea8dafaa306901966cb1bcfcbc8" name="a0daeaea8dafaa306901966cb1bcfcbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0daeaea8dafaa306901966cb1bcfcbc8">&#9670;&#160;</a></span>where() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each element for a condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;)&gt;&amp;) to filter a sequence. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;string&gt;</a> fruits = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;passionfruit&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;mango&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>, <span class="stringliteral">&quot;blueberry&quot;</span>, <span class="stringliteral">&quot;grape&quot;</span>, <span class="stringliteral">&quot;strawberry&quot;</span>};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;string&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = fruits.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4db80522d1924c428b39bde2917b805e">where</a>([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fruit) {<span class="keywordflow">return</span> fruit.<a class="code hl_function" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>() &lt; 6;});</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; fruit : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(fruit);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// apple</span></div>
<div class="line"><span class="comment">// mango</span></div>
<div class="line"><span class="comment">// grape</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acdcca88e9ad7db7466f0be1b26a2ebdd" name="acdcca88e9ad7db7466f0be1b26a2ebdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdcca88e9ad7db7466f0be1b26a2ebdd">&#9670;&#160;</a></span>where() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, size_t)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;int&gt;</a> numbers = {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;int&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4db80522d1924c428b39bde2917b805e">where</a>([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> &lt;= int(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
<div class="ttc" id="agroup__xtd__core_html_gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df"><div class="ttname"><a href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">xtd::number_styles::number</a></div><div class="ttdeci">@ number</div><div class="ttdoc">Indicates that the allow_leading_white, allow_trailing_white, allow_leading_sign, allow_trailing_sign...</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a11238bde49fa3d58954790a1f3d0028d" name="a11238bde49fa3d58954790a1f3d0028d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11238bde49fa3d58954790a1f3d0028d">&#9670;&#160;</a></span>where() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; source_t &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, size_t)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;int&gt;</a> numbers = {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;int&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4db80522d1924c428b39bde2917b805e">where</a>([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> &lt;= int(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a001fb1729defd31bfc98840b1127f05c" name="a001fb1729defd31bfc98840b1127f05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001fb1729defd31bfc98840b1127f05c">&#9670;&#160;</a></span>where() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A sequence of values to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, size_t)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;int&gt;</a> numbers = {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;int&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4db80522d1924c428b39bde2917b805e">where</a>([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> &lt;= int(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7969a0e7e527596c1a682f9e872114bb" name="a7969a0e7e527596c1a682f9e872114bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7969a0e7e527596c1a682f9e872114bb">&#9670;&#160;</a></span>where() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename source_t , typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; source_t &gt; &amp; xtd::linq::enumerable::where </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator. </td></tr>
    <tr><td class="paramname">predicate</td><td>A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; that contains elements from the input sequence that satisfy the condition. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example demonstrates how to use <a class="el" href="classxtd_1_1linq_1_1enumerable.html#ade645587ccb269b8b05c4325989639be" title="Filters a sequence of values based on a predicate.">xtd::linq::enumerable::where</a> &lt;source_t&gt;(const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;source_t&gt;&amp;, const std::function&lt;bool (const source_t&amp;, size_t)&gt;&amp;) to filter a sequence based on a predicate that involves the index of each element. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1array.html">array&lt;int&gt;</a> numbers = {0, 30, 20, 15, 90, 85, 40, 75};</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable&lt;int&gt;</a>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a> = numbers.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a4db80522d1924c428b39bde2917b805e">where</a>([](<span class="keywordtype">int</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>, <span class="keywordtype">size_t</span> index) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> &lt;= int(index * 10);</div>
<div class="line">  });</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a> : <a class="code hl_enumvalue" href="group__xtd__core.html#gga20b51d7977f3ffaaca44c6075ad021dba1b1cc7f086b3f074da452bc3129981eb">query</a>)</div>
<div class="line">    <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<a class="code hl_enumvalue" href="group__xtd__core.html#gga176c15b86e21b78ec7a3dd6f0a92c686ab1bc248a7ff2b2e95569f56de68615df">number</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 0</span></div>
<div class="line"><span class="comment">// 20</span></div>
<div class="line"><span class="comment">// 15</span></div>
<div class="line"><span class="comment">// 40</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/linq/<a class="el" href="linq_2enumerable_8hpp_source.html">enumerable.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 27 2024 20:43:32 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
