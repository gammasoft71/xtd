<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::basic_string&lt; char_t, traits_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1basic__string-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::basic_string&lt; char_t, traits_t, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__strings.html">strings</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::basic_string&lt; char_t, traits_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1basic__string.png" usemap="#xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::basic_5Fstring_3C_20char_5Ft_2C_20traits_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,56,835,80"/>
<area href="classxtd_1_1icomparable.html" alt="xtd::icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;" shape="rect" coords="845,56,1680,80"/>
<area href="classxtd_1_1iequatable.html" alt="xtd::iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;" shape="rect" coords="2535,56,3370,80"/>
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" alt="xtd::collections::generic::ienumerable&lt; char_t &gt;" shape="rect" coords="4647,56,5482,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="422,0,1257,24"/>
<area href="classxtd_1_1extensions_1_1comparison__operators.html" title="Internal comparable operators definition." alt="xtd::extensions::comparison_operators&lt; type_t, comparable_t &gt;" shape="rect" coords="1267,0,2102,24"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="2112,0,2947,24"/>
<area href="classxtd_1_1extensions_1_1equality__operators.html" title="Internal equality operators definition." alt="xtd::extensions::equality_operators&lt; type_t, equatable_t &gt;" shape="rect" coords="2957,0,3792,24"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="3802,0,4637,24"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html" title="Internal enumarable iterators definition." alt="xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t, iterator_tag_t &gt;" shape="rect" coords="4647,0,5482,24"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html" title="Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;." alt="xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt;" shape="rect" coords="5492,0,6327,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class char_t, class traits_t, class allocator_t&gt;<br />
class xtd::basic_string&lt; char_t, traits_t, allocator_t &gt;</div><p>Represents text as a sequence of character units. </p>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is a sequential collection of char that represent a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is the content of the sequential collection of <code>char_t</code>, and unlike <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char_t&gt;</a> that value is immutable (that is, it is read-only). </dd>
<dd>
If you want the same mutable <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> class, you can use <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char_t&gt; class. </dd>
<dd>
<a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char&gt;</a> and therefore offers the full (immutable) API of std::basic_string. </dd>
<dd>
Several aliases for common character types are provided: </dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;char&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga87efea41d4bd7beb815934226919d4cf" title="Represents text as a sequence of UTF-16 code units.">xtd::u16string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga8e905e9638523f5b5d380d8bcbcc834e" title="Represents text as a sequence of UTF-32 code units.">xtd::u32string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga10e56556495f88e0d68bde21820cdddf" title="Represents text as a sequence of UTF-8 code units.">xtd::u8string</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__strings.html#ga0852e1ddc5f45ee30560e3f95d6915b0" title="Represents text as a sequence of UTF-16 code unit on Windows or UTF-32 code unit on non-Windows syste...">xtd::wstring</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518" title="Represents a wide character.">xtd::wchar</a>&gt;   </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Namespace</dt><dd>xtd </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is a sequential collection of characters that's used to represent text. A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is a sequential collection of char that represent a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object is the content of the sequential collection of <code>char_t</code>, and unlike <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char_t&gt;</a> that value is immutable (that is, it is read-only). </dd>
<dd>
If you want the same mutable <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> class, you can use <a class="el" href="classxtd_1_1text_1_1basic__string__builder.html" title="Represents a mutable string of characters. This class cannot be inherited.">xtd::text::basic_string_builder</a> &lt;char_t&gt; class. </dd>
<dd>
<a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> implements <a href="https://en.cppreference.com/w/cpp/basic_string/basic_string">std::basic_string&lt;char&gt;</a> and therefore offers the full (immutable) API of <a href="https://en.cppreference.com/w/cpp/string/basic_string">std::string</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="event_8cpp-example.html#_a2">event.cpp</a>, <a class="el" href="format_character_8cpp-example.html#_a0">format_character.cpp</a>, <a class="el" href="iasync_result_8cpp-example.html#_a0">iasync_result.cpp</a>, <a class="el" href="split_8cpp-example.html#_a0">split.cpp</a>, <a class="el" href="test_forms_8cpp-example.html#_a27">test_forms.cpp</a>, and <a class="el" href="test_tunit_8cpp-example.html#_a1">test_tunit.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:a023c9110b9e82006d694c297f404e031"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a023c9110b9e82006d694c297f404e031">base_type</a> = std::basic_string&lt; char_t, traits_t, allocator_t &gt;</td></tr>
<tr class="memdesc:a023c9110b9e82006d694c297f404e031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string base type.  <br /></td></tr>
<tr class="separator:a023c9110b9e82006d694c297f404e031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d949b3e7337c9e935ad6f8de390076f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4d949b3e7337c9e935ad6f8de390076f">traits_type</a> = typename base_type::traits_type</td></tr>
<tr class="memdesc:a4d949b3e7337c9e935ad6f8de390076f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string traits type.  <br /></td></tr>
<tr class="separator:a4d949b3e7337c9e935ad6f8de390076f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba30f417a9a6e82bb49c465428af7aa5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> = typename base_type::value_type</td></tr>
<tr class="memdesc:aba30f417a9a6e82bb49c465428af7aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string value type.  <br /></td></tr>
<tr class="separator:aba30f417a9a6e82bb49c465428af7aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ed007365ca191ac40587fe9365f02a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> = typename base_type::allocator_type</td></tr>
<tr class="memdesc:a19ed007365ca191ac40587fe9365f02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string allocator type.  <br /></td></tr>
<tr class="separator:a19ed007365ca191ac40587fe9365f02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c19ff70f8314b59d8e711cadd91302"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> = typename base_type::size_type</td></tr>
<tr class="memdesc:a84c19ff70f8314b59d8e711cadd91302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string size type.  <br /></td></tr>
<tr class="separator:a84c19ff70f8314b59d8e711cadd91302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a0f41842e41c6b6a7e7c3b60eb9473"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae7a0f41842e41c6b6a7e7c3b60eb9473">difference_type</a> = typename base_type::difference_type</td></tr>
<tr class="memdesc:ae7a0f41842e41c6b6a7e7c3b60eb9473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string difference type.  <br /></td></tr>
<tr class="separator:ae7a0f41842e41c6b6a7e7c3b60eb9473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e7e06d00f19b7ec880b4d21e55b5e1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae2e7e06d00f19b7ec880b4d21e55b5e1">reference</a> = typename base_type::reference</td></tr>
<tr class="memdesc:ae2e7e06d00f19b7ec880b4d21e55b5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string referecne type.  <br /></td></tr>
<tr class="separator:ae2e7e06d00f19b7ec880b4d21e55b5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19c12dd03024a0b27ae68115bbfa2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5a19c12dd03024a0b27ae68115bbfa2b">const_reference</a> = typename base_type::const_reference</td></tr>
<tr class="memdesc:a5a19c12dd03024a0b27ae68115bbfa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string const referecne type.  <br /></td></tr>
<tr class="separator:a5a19c12dd03024a0b27ae68115bbfa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5096b493cf6cf40e71b176fcbb2e0624"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5096b493cf6cf40e71b176fcbb2e0624">pointer</a> = typename base_type::pointer</td></tr>
<tr class="memdesc:a5096b493cf6cf40e71b176fcbb2e0624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string pointer type.  <br /></td></tr>
<tr class="separator:a5096b493cf6cf40e71b176fcbb2e0624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4019460efb8119704afcefd0a1703847"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> = typename base_type::const_pointer</td></tr>
<tr class="memdesc:a4019460efb8119704afcefd0a1703847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string const pointer type.  <br /></td></tr>
<tr class="separator:a4019460efb8119704afcefd0a1703847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714fda995fe953db6f1b0f3e5d44943f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a714fda995fe953db6f1b0f3e5d44943f">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; char_t &gt;::iterator</td></tr>
<tr class="memdesc:a714fda995fe953db6f1b0f3e5d44943f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string iterator type.  <br /></td></tr>
<tr class="separator:a714fda995fe953db6f1b0f3e5d44943f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b7bbe92cc0909082b7a1257f9454a6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae6b7bbe92cc0909082b7a1257f9454a6">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; char_t &gt;::const_iterator</td></tr>
<tr class="memdesc:ae6b7bbe92cc0909082b7a1257f9454a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string const iterator type.  <br /></td></tr>
<tr class="separator:ae6b7bbe92cc0909082b7a1257f9454a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8c65e30415746ff874486715febd50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aba8c65e30415746ff874486715febd50">reverse_iterator</a> = typename base_type::reverse_iterator</td></tr>
<tr class="memdesc:aba8c65e30415746ff874486715febd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string reverse iterator type.  <br /></td></tr>
<tr class="separator:aba8c65e30415746ff874486715febd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aff392391a7665d5244311dd7eee46"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a72aff392391a7665d5244311dd7eee46">const_reverse_iterator</a> = typename base_type::const_reverse_iterator</td></tr>
<tr class="memdesc:a72aff392391a7665d5244311dd7eee46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string const reverse iterator type.  <br /></td></tr>
<tr class="separator:a72aff392391a7665d5244311dd7eee46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5493bd9034616dded9fb810d65fd6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2b5493bd9034616dded9fb810d65fd6c">enumerator_type</a> = typename <a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">xtd::collections::generic::enumerator</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt;</td></tr>
<tr class="memdesc:a2b5493bd9034616dded9fb810d65fd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the basic string enumerator type.  <br /></td></tr>
<tr class="separator:a2b5493bd9034616dded9fb810d65fd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Fields</h2></td></tr>
<tr class="memitem:a0ae9e9b0cbe9df3f4fc03f7e4682ef2e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0ae9e9b0cbe9df3f4fc03f7e4682ef2e">empty_string</a></td></tr>
<tr class="memdesc:a0ae9e9b0cbe9df3f4fc03f7e4682ef2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a0ae9e9b0cbe9df3f4fc03f7e4682ef2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9629cc4c296a49e4f99d718e8117689e"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e">npos</a></td></tr>
<tr class="memdesc:a9629cc4c296a49e4f99d718e8117689e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the maximum value representable by the type <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>.  <br /></td></tr>
<tr class="separator:a9629cc4c296a49e4f99d718e8117689e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:af6f4efe678e6742104ad6b0ddb3fc2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a5a19c12dd03024a0b27ae68115bbfa2b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af6f4efe678e6742104ad6b0ddb3fc2db">operator[]</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index) const</td></tr>
<tr class="memdesc:af6f4efe678e6742104ad6b0ddb3fc2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character at specified location index.  <br /></td></tr>
<tr class="separator:af6f4efe678e6742104ad6b0ddb3fc2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6775931e51f45aad56df1c249c578832"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6775931e51f45aad56df1c249c578832">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:a6775931e51f45aad56df1c249c578832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a6775931e51f45aad56df1c249c578832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7fad567430f490e373f26b2d7dce9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8e7fad567430f490e373f26b2d7dce9d">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a8e7fad567430f490e373f26b2d7dce9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:a8e7fad567430f490e373f26b2d7dce9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c813a8edbc5272897079137ac03b1a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9c813a8edbc5272897079137ac03b1a2">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a9c813a8edbc5272897079137ac03b1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:a9c813a8edbc5272897079137ac03b1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab02a07cc26e5c65be216bca381b38f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a1ab02a07cc26e5c65be216bca381b38f">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a1ab02a07cc26e5c65be216bca381b38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:a1ab02a07cc26e5c65be216bca381b38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af878d5d6403d2336b18b4fe35bdd4182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af878d5d6403d2336b18b4fe35bdd4182">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:af878d5d6403d2336b18b4fe35bdd4182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:af878d5d6403d2336b18b4fe35bdd4182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09eea471e56aea42786fa52c8126a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae09eea471e56aea42786fa52c8126a3b">operator=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:ae09eea471e56aea42786fa52c8126a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of str.  <br /></td></tr>
<tr class="separator:ae09eea471e56aea42786fa52c8126a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05124e1ea82616e66fc72599e5ba5914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a05124e1ea82616e66fc72599e5ba5914">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a05124e1ea82616e66fc72599e5ba5914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:a05124e1ea82616e66fc72599e5ba5914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a91c59bacaef916f4aa1e62a4730ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6a91c59bacaef916f4aa1e62a4730ae6">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a6a91c59bacaef916f4aa1e62a4730ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:a6a91c59bacaef916f4aa1e62a4730ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca40ecd701f4cb13da77ee3e1d30587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a1ca40ecd701f4cb13da77ee3e1d30587">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a1ca40ecd701f4cb13da77ee3e1d30587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:a1ca40ecd701f4cb13da77ee3e1d30587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee11528245223380dd77959002077fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aee11528245223380dd77959002077fbe">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:aee11528245223380dd77959002077fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:aee11528245223380dd77959002077fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac411bdfb98de0504a5c126ed67e954a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac411bdfb98de0504a5c126ed67e954a1">operator=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:ac411bdfb98de0504a5c126ed67e954a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards.  <br /></td></tr>
<tr class="separator:ac411bdfb98de0504a5c126ed67e954a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb658b3e0ec4abe277533ac512bc3ae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#abb658b3e0ec4abe277533ac512bc3ae1">operator=</a> (const std::basic_string&lt; char &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:abb658b3e0ec4abe277533ac512bc3ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:abb658b3e0ec4abe277533ac512bc3ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb8217139ce12832231bf9d40b19bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2eb8217139ce12832231bf9d40b19bfd">operator=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a2eb8217139ce12832231bf9d40b19bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a2eb8217139ce12832231bf9d40b19bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9e59b3bf597261e69cb3d3f051aadf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acc9e59b3bf597261e69cb3d3f051aadf">operator=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:acc9e59b3bf597261e69cb3d3f051aadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:acc9e59b3bf597261e69cb3d3f051aadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0786502cf54544309a1abf38184a307"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad0786502cf54544309a1abf38184a307">operator=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:ad0786502cf54544309a1abf38184a307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:ad0786502cf54544309a1abf38184a307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e497c98372f90481ebd0e1bd21f315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab3e497c98372f90481ebd0e1bd21f315">operator=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:ab3e497c98372f90481ebd0e1bd21f315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:ab3e497c98372f90481ebd0e1bd21f315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0ea7a997d8fc99967e72b32c5fdd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5d0ea7a997d8fc99967e72b32c5fdd38">operator=</a> (std::basic_string&lt; char &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a5d0ea7a997d8fc99967e72b32c5fdd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a5d0ea7a997d8fc99967e72b32c5fdd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a9907eb2556368b2c970ef1c55d304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a12a9907eb2556368b2c970ef1c55d304">operator=</a> (std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a12a9907eb2556368b2c970ef1c55d304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a12a9907eb2556368b2c970ef1c55d304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2848f242d67f32fb93125d465593d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a21c2848f242d67f32fb93125d465593d">operator=</a> (std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:a21c2848f242d67f32fb93125d465593d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a21c2848f242d67f32fb93125d465593d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6fd1ff22ea00f8c10049954764abbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aaf6fd1ff22ea00f8c10049954764abbc">operator=</a> (std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:aaf6fd1ff22ea00f8c10049954764abbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:aaf6fd1ff22ea00f8c10049954764abbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9428692f29a5b0aeeaa868ec5be9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#abd9428692f29a5b0aeeaa868ec5be9f1">operator=</a> (std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&amp;str) noexcept</td></tr>
<tr class="memdesc:abd9428692f29a5b0aeeaa868ec5be9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:abd9428692f29a5b0aeeaa868ec5be9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdeadc513f43dc2cf9ee771b5cccf65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#abbdeadc513f43dc2cf9ee771b5cccf65">operator=</a> (const char *str)</td></tr>
<tr class="memdesc:abbdeadc513f43dc2cf9ee771b5cccf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:abbdeadc513f43dc2cf9ee771b5cccf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb13ea20a7630c0c25d59d22c407a25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acb13ea20a7630c0c25d59d22c407a25e">operator=</a> (const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *str)</td></tr>
<tr class="memdesc:acb13ea20a7630c0c25d59d22c407a25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:acb13ea20a7630c0c25d59d22c407a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9180140c3cb5474a4de317d1b81c99a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae9180140c3cb5474a4de317d1b81c99a">operator=</a> (const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *str)</td></tr>
<tr class="memdesc:ae9180140c3cb5474a4de317d1b81c99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:ae9180140c3cb5474a4de317d1b81c99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918e97c3c720478e2b1ff5cb8773de52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a918e97c3c720478e2b1ff5cb8773de52">operator=</a> (const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *str)</td></tr>
<tr class="memdesc:a918e97c3c720478e2b1ff5cb8773de52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:a918e97c3c720478e2b1ff5cb8773de52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa66ed4bee7575c0d6791f9d3c2e0b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aeaa66ed4bee7575c0d6791f9d3c2e0b5">operator=</a> (const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *str)</td></tr>
<tr class="memdesc:aeaa66ed4bee7575c0d6791f9d3c2e0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>.  <br /></td></tr>
<tr class="separator:aeaa66ed4bee7575c0d6791f9d3c2e0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22b7f387671fa95ea8462c297905b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae22b7f387671fa95ea8462c297905b1f">operator=</a> (char character)</td></tr>
<tr class="memdesc:ae22b7f387671fa95ea8462c297905b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:ae22b7f387671fa95ea8462c297905b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbfe5d2566ab0966a19775ea334b5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4bbfe5d2566ab0966a19775ea334b5b7">operator=</a> (<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> character)</td></tr>
<tr class="memdesc:a4bbfe5d2566ab0966a19775ea334b5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:a4bbfe5d2566ab0966a19775ea334b5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20661ac7964f93e1cfbac62cec407934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a20661ac7964f93e1cfbac62cec407934">operator=</a> (<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> character)</td></tr>
<tr class="memdesc:a20661ac7964f93e1cfbac62cec407934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:a20661ac7964f93e1cfbac62cec407934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068c674dbbe9cf949e8f6fe1d25903a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a068c674dbbe9cf949e8f6fe1d25903a6">operator=</a> (<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> character)</td></tr>
<tr class="memdesc:a068c674dbbe9cf949e8f6fe1d25903a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:a068c674dbbe9cf949e8f6fe1d25903a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78a2c22393147a7863d6612ea8ad596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af78a2c22393147a7863d6612ea8ad596">operator=</a> (<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> character)</td></tr>
<tr class="memdesc:af78a2c22393147a7863d6612ea8ad596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with the specified character.  <br /></td></tr>
<tr class="separator:af78a2c22393147a7863d6612ea8ad596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57338bbd9341a8316c97a0cb0b52a0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa57338bbd9341a8316c97a0cb0b52a0b">operator=</a> (const std::initializer_list&lt; char &gt; &amp;il)</td></tr>
<tr class="memdesc:aa57338bbd9341a8316c97a0cb0b52a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:aa57338bbd9341a8316c97a0cb0b52a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ab06b38248888f8efed9bc86a970d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa1ab06b38248888f8efed9bc86a970d6">operator=</a> (const std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:aa1ab06b38248888f8efed9bc86a970d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:aa1ab06b38248888f8efed9bc86a970d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52100794dde1bf6c481e50e94091916a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a52100794dde1bf6c481e50e94091916a">operator=</a> (const std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:a52100794dde1bf6c481e50e94091916a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:a52100794dde1bf6c481e50e94091916a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75927d980766139c7c20de14f1f8d13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa75927d980766139c7c20de14f1f8d13">operator=</a> (const std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:aa75927d980766139c7c20de14f1f8d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:aa75927d980766139c7c20de14f1f8d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed652c5e92066a11e47a0dd6cd647c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aed652c5e92066a11e47a0dd6cd647c90">operator=</a> (const std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:aed652c5e92066a11e47a0dd6cd647c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list.  <br /></td></tr>
<tr class="separator:aed652c5e92066a11e47a0dd6cd647c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f96281407a61fd50345eb7e2b8f7ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab9f96281407a61fd50345eb7e2b8f7ca">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str)</td></tr>
<tr class="memdesc:ab9f96281407a61fd50345eb7e2b8f7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ab9f96281407a61fd50345eb7e2b8f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e5dc85e2d471ae28f9957c4065248f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad1e5dc85e2d471ae28f9957c4065248f">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:ad1e5dc85e2d471ae28f9957c4065248f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ad1e5dc85e2d471ae28f9957c4065248f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58d46ec7ebf00e9bb57d8844bfa684d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab58d46ec7ebf00e9bb57d8844bfa684d">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:ab58d46ec7ebf00e9bb57d8844bfa684d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ab58d46ec7ebf00e9bb57d8844bfa684d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fcc84e7cb9e168ed058dc58a3f4dfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a99fcc84e7cb9e168ed058dc58a3f4dfc">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:a99fcc84e7cb9e168ed058dc58a3f4dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a99fcc84e7cb9e168ed058dc58a3f4dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a84548f6b04aac050a32938bfe5e7c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a1a84548f6b04aac050a32938bfe5e7c6">operator+=</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:a1a84548f6b04aac050a32938bfe5e7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a1a84548f6b04aac050a32938bfe5e7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21d4bbd734b2f65cf373c02a72e1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6f21d4bbd734b2f65cf373c02a72e1ad">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:a6f21d4bbd734b2f65cf373c02a72e1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a6f21d4bbd734b2f65cf373c02a72e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb5b1ef0dcf242170da7be8c770b1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4eb5b1ef0dcf242170da7be8c770b1a9">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:a4eb5b1ef0dcf242170da7be8c770b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a4eb5b1ef0dcf242170da7be8c770b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ad7d6ce3e3cfd9e32b049542eb8418"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad3ad7d6ce3e3cfd9e32b049542eb8418">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:ad3ad7d6ce3e3cfd9e32b049542eb8418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ad3ad7d6ce3e3cfd9e32b049542eb8418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8d99044981bb8b49c438dd552b15c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0e8d99044981bb8b49c438dd552b15c0">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:a0e8d99044981bb8b49c438dd552b15c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a0e8d99044981bb8b49c438dd552b15c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad891204bd0c088717a720bdf92f28212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad891204bd0c088717a720bdf92f28212">operator+=</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:ad891204bd0c088717a720bdf92f28212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:ad891204bd0c088717a720bdf92f28212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb3348705647e01e88be06aa3767894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2fb3348705647e01e88be06aa3767894">operator+=</a> (const std::basic_string&lt; char &gt; &amp;str)</td></tr>
<tr class="memdesc:a2fb3348705647e01e88be06aa3767894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2fb3348705647e01e88be06aa3767894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9bab82c073016f8b31a4f9afdb7ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2b9bab82c073016f8b31a4f9afdb7ce8">operator+=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:a2b9bab82c073016f8b31a4f9afdb7ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2b9bab82c073016f8b31a4f9afdb7ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea45b673c96bbe8fb31b5fcee7164a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9ea45b673c96bbe8fb31b5fcee7164a8">operator+=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:a9ea45b673c96bbe8fb31b5fcee7164a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a9ea45b673c96bbe8fb31b5fcee7164a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf189ea3fea2ff21c6afd2b226a2921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#accf189ea3fea2ff21c6afd2b226a2921">operator+=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:accf189ea3fea2ff21c6afd2b226a2921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:accf189ea3fea2ff21c6afd2b226a2921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba271dd4828ec9c22972ce98ed71543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#afba271dd4828ec9c22972ce98ed71543">operator+=</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str)</td></tr>
<tr class="memdesc:afba271dd4828ec9c22972ce98ed71543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:afba271dd4828ec9c22972ce98ed71543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2769a07751f2040b086f2e532741c682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2769a07751f2040b086f2e532741c682">operator+=</a> (const char *str)</td></tr>
<tr class="memdesc:a2769a07751f2040b086f2e532741c682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2769a07751f2040b086f2e532741c682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af555dcf021c5c3ced7e1a8bfbe5bfa50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af555dcf021c5c3ced7e1a8bfbe5bfa50">operator+=</a> (const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *str)</td></tr>
<tr class="memdesc:af555dcf021c5c3ced7e1a8bfbe5bfa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:af555dcf021c5c3ced7e1a8bfbe5bfa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a78449d887fa5d921f95856cd1487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2c2a78449d887fa5d921f95856cd1487">operator+=</a> (const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *str)</td></tr>
<tr class="memdesc:a2c2a78449d887fa5d921f95856cd1487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2c2a78449d887fa5d921f95856cd1487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9529e5baf23784330b6045f2ef2ec37f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9529e5baf23784330b6045f2ef2ec37f">operator+=</a> (const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *str)</td></tr>
<tr class="memdesc:a9529e5baf23784330b6045f2ef2ec37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a9529e5baf23784330b6045f2ef2ec37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec59e366d520219d67a6ee712e07f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0ec59e366d520219d67a6ee712e07f34">operator+=</a> (const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *str)</td></tr>
<tr class="memdesc:a0ec59e366d520219d67a6ee712e07f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a0ec59e366d520219d67a6ee712e07f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdc9356f22e6ff9139f4a81b93a6175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2bdc9356f22e6ff9139f4a81b93a6175">operator+=</a> (char ch)</td></tr>
<tr class="memdesc:a2bdc9356f22e6ff9139f4a81b93a6175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a2bdc9356f22e6ff9139f4a81b93a6175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda811c544170f9951af6d7bac8ba707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acda811c544170f9951af6d7bac8ba707">operator+=</a> (<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> ch)</td></tr>
<tr class="memdesc:acda811c544170f9951af6d7bac8ba707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:acda811c544170f9951af6d7bac8ba707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493fc8791204b6b8bde403fad729410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7493fc8791204b6b8bde403fad729410">operator+=</a> (<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> ch)</td></tr>
<tr class="memdesc:a7493fc8791204b6b8bde403fad729410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a7493fc8791204b6b8bde403fad729410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfdd130d8ea5f20c20fe15bf794b572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9bfdd130d8ea5f20c20fe15bf794b572">operator+=</a> (<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> ch)</td></tr>
<tr class="memdesc:a9bfdd130d8ea5f20c20fe15bf794b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a9bfdd130d8ea5f20c20fe15bf794b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c75ef362acb78e3f0072b8cbdf3e19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a29c75ef362acb78e3f0072b8cbdf3e19">operator+=</a> (<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> ch)</td></tr>
<tr class="memdesc:a29c75ef362acb78e3f0072b8cbdf3e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. Appends additional characters to the string.  <br /></td></tr>
<tr class="separator:a29c75ef362acb78e3f0072b8cbdf3e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:acb6d598b5155fe5ee9339537f3dae900"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acb6d598b5155fe5ee9339537f3dae900">basic_string</a> ()=default</td></tr>
<tr class="memdesc:acb6d598b5155fe5ee9339537f3dae900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:acb6d598b5155fe5ee9339537f3dae900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3790b669d37b2f581b200a850a78c86a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a3790b669d37b2f581b200a850a78c86a">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a3790b669d37b2f581b200a850a78c86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified allocator.  <br /></td></tr>
<tr class="separator:a3790b669d37b2f581b200a850a78c86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01363cdbad8c2f1a3f0432f39e1104f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa01363cdbad8c2f1a3f0432f39e1104f">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:aa01363cdbad8c2f1a3f0432f39e1104f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:aa01363cdbad8c2f1a3f0432f39e1104f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7fe5fcca0ac2a358b40fa93da6e2f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4a7fe5fcca0ac2a358b40fa93da6e2f6">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a4a7fe5fcca0ac2a358b40fa93da6e2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a4a7fe5fcca0ac2a358b40fa93da6e2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003c0c4a69d9080f0aa43812075f5105"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a003c0c4a69d9080f0aa43812075f5105">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a003c0c4a69d9080f0aa43812075f5105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a003c0c4a69d9080f0aa43812075f5105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa67fdd2798346152a0369deb327928"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2fa67fdd2798346152a0369deb327928">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a2fa67fdd2798346152a0369deb327928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a2fa67fdd2798346152a0369deb327928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba2d784fd4cbc26b1d56b286ce22f40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6ba2d784fd4cbc26b1d56b286ce22f40">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a6ba2d784fd4cbc26b1d56b286ce22f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a6ba2d784fd4cbc26b1d56b286ce22f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af473faad321ab52c4d72ecdff8ce1fcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af473faad321ab52c4d72ecdff8ce1fcf">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:af473faad321ab52c4d72ecdff8ce1fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:af473faad321ab52c4d72ecdff8ce1fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810b107f2ba78d3df123d1c9672fb257"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a810b107f2ba78d3df123d1c9672fb257">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a810b107f2ba78d3df123d1c9672fb257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a810b107f2ba78d3df123d1c9672fb257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbadec7f087b088f299f3b002df41fcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acbadec7f087b088f299f3b002df41fcd">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:acbadec7f087b088f299f3b002df41fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:acbadec7f087b088f299f3b002df41fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f65f90aaa0e7433dfd8c52086bca832"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5f65f90aaa0e7433dfd8c52086bca832">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a5f65f90aaa0e7433dfd8c52086bca832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a5f65f90aaa0e7433dfd8c52086bca832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf6bf013b908aa0d1f0dabb1762d2e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a3bf6bf013b908aa0d1f0dabb1762d2e6">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a3bf6bf013b908aa0d1f0dabb1762d2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a3bf6bf013b908aa0d1f0dabb1762d2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0897dbd3d0da563d013e88f06f0041f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0897dbd3d0da563d013e88f06f0041f2">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index)</td></tr>
<tr class="memdesc:a0897dbd3d0da563d013e88f06f0041f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index.  <br /></td></tr>
<tr class="separator:a0897dbd3d0da563d013e88f06f0041f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790510d7f735bc3e1a7e4ec3a5790b1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a790510d7f735bc3e1a7e4ec3a5790b1d">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index)</td></tr>
<tr class="memdesc:a790510d7f735bc3e1a7e4ec3a5790b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index.  <br /></td></tr>
<tr class="separator:a790510d7f735bc3e1a7e4ec3a5790b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728974ef4e82f756aa1e1f778eacb075"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a728974ef4e82f756aa1e1f778eacb075">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index)</td></tr>
<tr class="memdesc:a728974ef4e82f756aa1e1f778eacb075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index.  <br /></td></tr>
<tr class="separator:a728974ef4e82f756aa1e1f778eacb075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d03d155e3fd35a75d340101cd943e7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0d03d155e3fd35a75d340101cd943e7b">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index)</td></tr>
<tr class="memdesc:a0d03d155e3fd35a75d340101cd943e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index.  <br /></td></tr>
<tr class="separator:a0d03d155e3fd35a75d340101cd943e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdc765c7e94ea3f5a9986855bda0095"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5fdc765c7e94ea3f5a9986855bda0095">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index)</td></tr>
<tr class="memdesc:a5fdc765c7e94ea3f5a9986855bda0095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index.  <br /></td></tr>
<tr class="separator:a5fdc765c7e94ea3f5a9986855bda0095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f86367bc0b1badfafc7b5f8732d5fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7f86367bc0b1badfafc7b5f8732d5fa9">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a7f86367bc0b1badfafc7b5f8732d5fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator.  <br /></td></tr>
<tr class="separator:a7f86367bc0b1badfafc7b5f8732d5fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759adc3fc954c46e9273d04d0832351b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a759adc3fc954c46e9273d04d0832351b">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a759adc3fc954c46e9273d04d0832351b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator.  <br /></td></tr>
<tr class="separator:a759adc3fc954c46e9273d04d0832351b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952b9c5fcf698dcb5d733612f9b1ce50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a952b9c5fcf698dcb5d733612f9b1ce50">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a952b9c5fcf698dcb5d733612f9b1ce50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator.  <br /></td></tr>
<tr class="separator:a952b9c5fcf698dcb5d733612f9b1ce50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93081b9f7ec282a0fce6320f6b1c652c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a93081b9f7ec282a0fce6320f6b1c652c">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a93081b9f7ec282a0fce6320f6b1c652c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator.  <br /></td></tr>
<tr class="separator:a93081b9f7ec282a0fce6320f6b1c652c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892dc8c77844e2065daa665afe86a475"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a892dc8c77844e2065daa665afe86a475">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a892dc8c77844e2065daa665afe86a475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator.  <br /></td></tr>
<tr class="separator:a892dc8c77844e2065daa665afe86a475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83be15f58fcfac4ed4f56ee7af07573"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa83be15f58fcfac4ed4f56ee7af07573">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:aa83be15f58fcfac4ed4f56ee7af07573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters.  <br /></td></tr>
<tr class="separator:aa83be15f58fcfac4ed4f56ee7af07573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73029c72b27fc7c73558a061707aa5ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a73029c72b27fc7c73558a061707aa5ff">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a73029c72b27fc7c73558a061707aa5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters.  <br /></td></tr>
<tr class="separator:a73029c72b27fc7c73558a061707aa5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020400a139bf4be05b019e6adf1fc835"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a020400a139bf4be05b019e6adf1fc835">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a020400a139bf4be05b019e6adf1fc835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters.  <br /></td></tr>
<tr class="separator:a020400a139bf4be05b019e6adf1fc835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c831b74446024bf9237b161d9769ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a35c831b74446024bf9237b161d9769ae">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a35c831b74446024bf9237b161d9769ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters.  <br /></td></tr>
<tr class="separator:a35c831b74446024bf9237b161d9769ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c1c08af3ea741373782607c4c6a8fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a61c1c08af3ea741373782607c4c6a8fd">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a61c1c08af3ea741373782607c4c6a8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters.  <br /></td></tr>
<tr class="separator:a61c1c08af3ea741373782607c4c6a8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee557f9747996e1aa3eb47aa3c05c8d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aee557f9747996e1aa3eb47aa3c05c8d0">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:aee557f9747996e1aa3eb47aa3c05c8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator.  <br /></td></tr>
<tr class="separator:aee557f9747996e1aa3eb47aa3c05c8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcaaeb29123c7c41e4b91a69407d36b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aefcaaeb29123c7c41e4b91a69407d36b">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:aefcaaeb29123c7c41e4b91a69407d36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator.  <br /></td></tr>
<tr class="separator:aefcaaeb29123c7c41e4b91a69407d36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6680b4c84f8ebb9518b1326085d2c004"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6680b4c84f8ebb9518b1326085d2c004">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a6680b4c84f8ebb9518b1326085d2c004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator.  <br /></td></tr>
<tr class="separator:a6680b4c84f8ebb9518b1326085d2c004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad953695b56bad73f18cc2b9e717f7d1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad953695b56bad73f18cc2b9e717f7d1e">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ad953695b56bad73f18cc2b9e717f7d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator.  <br /></td></tr>
<tr class="separator:ad953695b56bad73f18cc2b9e717f7d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bcb0b437ace9e8c27d410e83038c36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad7bcb0b437ace9e8c27d410e83038c36">basic_string</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ad7bcb0b437ace9e8c27d410e83038c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator.  <br /></td></tr>
<tr class="separator:ad7bcb0b437ace9e8c27d410e83038c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9606d876f446e54fc196a6eea79f2480"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9606d876f446e54fc196a6eea79f2480">basic_string</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a9606d876f446e54fc196a6eea79f2480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to move.  <br /></td></tr>
<tr class="separator:a9606d876f446e54fc196a6eea79f2480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b09353f28fcb694c933fa147ca968a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4b09353f28fcb694c933fa147ca968a0">basic_string</a> (<a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;&amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a4b09353f28fcb694c933fa147ca968a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to move and allocator.  <br /></td></tr>
<tr class="separator:a4b09353f28fcb694c933fa147ca968a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad059373b3260d182270ffd503383b379"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad059373b3260d182270ffd503383b379">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, char character)</td></tr>
<tr class="memdesc:ad059373b3260d182270ffd503383b379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:ad059373b3260d182270ffd503383b379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80eb93e04bca76813d159f5090ea2d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab80eb93e04bca76813d159f5090ea2d5">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, char character, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ab80eb93e04bca76813d159f5090ea2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:ab80eb93e04bca76813d159f5090ea2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a14bd54a839fd8f45b7b2b525929b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac2a14bd54a839fd8f45b7b2b525929b9">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> character)</td></tr>
<tr class="memdesc:ac2a14bd54a839fd8f45b7b2b525929b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:ac2a14bd54a839fd8f45b7b2b525929b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8f94c1d63a648958fbd08083487fb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0b8f94c1d63a648958fbd08083487fb4">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> character, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a0b8f94c1d63a648958fbd08083487fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a0b8f94c1d63a648958fbd08083487fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed89c949a38db5641a364798a812617"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aaed89c949a38db5641a364798a812617">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> character)</td></tr>
<tr class="memdesc:aaed89c949a38db5641a364798a812617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:aaed89c949a38db5641a364798a812617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61bd959bf441f2b069d827972a56b56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af61bd959bf441f2b069d827972a56b56">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> character, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:af61bd959bf441f2b069d827972a56b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:af61bd959bf441f2b069d827972a56b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16998e6296fe38ef1b8c0101aa47e856"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a16998e6296fe38ef1b8c0101aa47e856">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> character)</td></tr>
<tr class="memdesc:a16998e6296fe38ef1b8c0101aa47e856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a16998e6296fe38ef1b8c0101aa47e856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f5ea589e05ab7c000d1d5ab9ab6e26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a29f5ea589e05ab7c000d1d5ab9ab6e26">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> character, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a29f5ea589e05ab7c000d1d5ab9ab6e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a29f5ea589e05ab7c000d1d5ab9ab6e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae8694982f8e910461d593c3418fcad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6ae8694982f8e910461d593c3418fcad">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> character)</td></tr>
<tr class="memdesc:a6ae8694982f8e910461d593c3418fcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a6ae8694982f8e910461d593c3418fcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeefa98ba1b5416ab1045d4a6bd1f418"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aaeefa98ba1b5416ab1045d4a6bd1f418">basic_string</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> character, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:aaeefa98ba1b5416ab1045d4a6bd1f418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:aaeefa98ba1b5416ab1045d4a6bd1f418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb71f746f84199f306830719d4d7d3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a1cb71f746f84199f306830719d4d7d3c">basic_string</a> (char character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a1cb71f746f84199f306830719d4d7d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a1cb71f746f84199f306830719d4d7d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522bd864e0cea4a2f089242d7fbad281"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a522bd864e0cea4a2f089242d7fbad281">basic_string</a> (char character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a522bd864e0cea4a2f089242d7fbad281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a522bd864e0cea4a2f089242d7fbad281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cf479389eb5a85efbb1e76936ea9cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa4cf479389eb5a85efbb1e76936ea9cc">basic_string</a> (<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:aa4cf479389eb5a85efbb1e76936ea9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:aa4cf479389eb5a85efbb1e76936ea9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113ef8f12563b8a2b5a06a00f7a15f76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a113ef8f12563b8a2b5a06a00f7a15f76">basic_string</a> (<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a113ef8f12563b8a2b5a06a00f7a15f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a113ef8f12563b8a2b5a06a00f7a15f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91b8ab1b4eb2e07141ec6808fae52ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad91b8ab1b4eb2e07141ec6808fae52ac">basic_string</a> (<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:ad91b8ab1b4eb2e07141ec6808fae52ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:ad91b8ab1b4eb2e07141ec6808fae52ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a82b64d95d02daf4ee9de9192f2cad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7a82b64d95d02daf4ee9de9192f2cad5">basic_string</a> (<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a7a82b64d95d02daf4ee9de9192f2cad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a7a82b64d95d02daf4ee9de9192f2cad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb7b586b719a9681dc6a8517d68bb65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8bb7b586b719a9681dc6a8517d68bb65">basic_string</a> (<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a8bb7b586b719a9681dc6a8517d68bb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a8bb7b586b719a9681dc6a8517d68bb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46db7974b3b8daabb74b39e947a3009b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a46db7974b3b8daabb74b39e947a3009b">basic_string</a> (<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a46db7974b3b8daabb74b39e947a3009b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a46db7974b3b8daabb74b39e947a3009b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291b648455fc7550e53947556d297a83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a291b648455fc7550e53947556d297a83">basic_string</a> (<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a291b648455fc7550e53947556d297a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character.  <br /></td></tr>
<tr class="separator:a291b648455fc7550e53947556d297a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b586d1b47eb0e36112091bdfba11a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a32b586d1b47eb0e36112091bdfba11a3">basic_string</a> (<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> character, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a32b586d1b47eb0e36112091bdfba11a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator.  <br /></td></tr>
<tr class="separator:a32b586d1b47eb0e36112091bdfba11a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7596c4c5b7c698e50b1a371e1859f5e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7596c4c5b7c698e50b1a371e1859f5e3">basic_string</a> (const char *str)</td></tr>
<tr class="memdesc:a7596c4c5b7c698e50b1a371e1859f5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a7596c4c5b7c698e50b1a371e1859f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b55a8a0116a25e314ee7e547e7c15e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab8b55a8a0116a25e314ee7e547e7c15e">basic_string</a> (const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *str)</td></tr>
<tr class="memdesc:ab8b55a8a0116a25e314ee7e547e7c15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ab8b55a8a0116a25e314ee7e547e7c15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ae9ab22760b7055ec0737789a1ca5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a18ae9ab22760b7055ec0737789a1ca5d">basic_string</a> (const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *str)</td></tr>
<tr class="memdesc:a18ae9ab22760b7055ec0737789a1ca5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a18ae9ab22760b7055ec0737789a1ca5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fd429e4a32f0983606f1eb046bd2ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad3fd429e4a32f0983606f1eb046bd2ef">basic_string</a> (const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *str)</td></tr>
<tr class="memdesc:ad3fd429e4a32f0983606f1eb046bd2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ad3fd429e4a32f0983606f1eb046bd2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bba2f3f145a3667ed7aaf3894cb35ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8bba2f3f145a3667ed7aaf3894cb35ca">basic_string</a> (const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *str)</td></tr>
<tr class="memdesc:a8bba2f3f145a3667ed7aaf3894cb35ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a8bba2f3f145a3667ed7aaf3894cb35ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d62d00259aaf8980fe03630f2adbf71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8d62d00259aaf8980fe03630f2adbf71">basic_string</a> (const char *str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a8d62d00259aaf8980fe03630f2adbf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a8d62d00259aaf8980fe03630f2adbf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed5602465ea4a591e81b5638cb58f54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a1ed5602465ea4a591e81b5638cb58f54">basic_string</a> (const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a1ed5602465ea4a591e81b5638cb58f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a1ed5602465ea4a591e81b5638cb58f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4e54bfc2b25ab10fed08cb71b31ffc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0e4e54bfc2b25ab10fed08cb71b31ffc">basic_string</a> (const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a0e4e54bfc2b25ab10fed08cb71b31ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a0e4e54bfc2b25ab10fed08cb71b31ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1894ba32389638586c30bfbe3d089328"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a1894ba32389638586c30bfbe3d089328">basic_string</a> (const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a1894ba32389638586c30bfbe3d089328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:a1894ba32389638586c30bfbe3d089328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52aa99b1076a2ea9ccce90cf0e6283b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae52aa99b1076a2ea9ccce90cf0e6283b">basic_string</a> (const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ae52aa99b1076a2ea9ccce90cf0e6283b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator.  <br /></td></tr>
<tr class="separator:ae52aa99b1076a2ea9ccce90cf0e6283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27340d04ceb0aa363d05385c6fc5981a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a27340d04ceb0aa363d05385c6fc5981a">basic_string</a> (const char *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a27340d04ceb0aa363d05385c6fc5981a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters.  <br /></td></tr>
<tr class="separator:a27340d04ceb0aa363d05385c6fc5981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9e5c8a25e6d253793b0bb148fa455b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#abd9e5c8a25e6d253793b0bb148fa455b">basic_string</a> (const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:abd9e5c8a25e6d253793b0bb148fa455b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters.  <br /></td></tr>
<tr class="separator:abd9e5c8a25e6d253793b0bb148fa455b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec00b682b89233058c3200436838b5df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aec00b682b89233058c3200436838b5df">basic_string</a> (const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:aec00b682b89233058c3200436838b5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters.  <br /></td></tr>
<tr class="separator:aec00b682b89233058c3200436838b5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0111166f70c46c24dfc392d5e9c13b4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0111166f70c46c24dfc392d5e9c13b4d">basic_string</a> (const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a0111166f70c46c24dfc392d5e9c13b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters.  <br /></td></tr>
<tr class="separator:a0111166f70c46c24dfc392d5e9c13b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1aa0e10ee1ed4c77c3b61daad135dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5e1aa0e10ee1ed4c77c3b61daad135dd">basic_string</a> (const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a5e1aa0e10ee1ed4c77c3b61daad135dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters.  <br /></td></tr>
<tr class="separator:a5e1aa0e10ee1ed4c77c3b61daad135dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aaef2824a54111862338756907f438"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab3aaef2824a54111862338756907f438">basic_string</a> (const char *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ab3aaef2824a54111862338756907f438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator.  <br /></td></tr>
<tr class="separator:ab3aaef2824a54111862338756907f438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ee7ec058d2fb8bd1243216e1fb7bb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a11ee7ec058d2fb8bd1243216e1fb7bb7">basic_string</a> (const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a11ee7ec058d2fb8bd1243216e1fb7bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator.  <br /></td></tr>
<tr class="separator:a11ee7ec058d2fb8bd1243216e1fb7bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf177df70d6ed26a58b42c5e152edcb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acf177df70d6ed26a58b42c5e152edcb7">basic_string</a> (const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:acf177df70d6ed26a58b42c5e152edcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator.  <br /></td></tr>
<tr class="separator:acf177df70d6ed26a58b42c5e152edcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b34159223e707f3c9692a103cb0494d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7b34159223e707f3c9692a103cb0494d">basic_string</a> (const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a7b34159223e707f3c9692a103cb0494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator.  <br /></td></tr>
<tr class="separator:a7b34159223e707f3c9692a103cb0494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b81f7fd2173cb19b899804b0e290c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae2b81f7fd2173cb19b899804b0e290c9">basic_string</a> (const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *str, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ae2b81f7fd2173cb19b899804b0e290c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator.  <br /></td></tr>
<tr class="separator:ae2b81f7fd2173cb19b899804b0e290c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d17cc2d9c968474e2db03fae9714852"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4d17cc2d9c968474e2db03fae9714852">basic_string</a> (const std::basic_string&lt; char &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a4d17cc2d9c968474e2db03fae9714852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a4d17cc2d9c968474e2db03fae9714852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd482add7b2c98c24950771aad22791"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5dd482add7b2c98c24950771aad22791">basic_string</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a5dd482add7b2c98c24950771aad22791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:a5dd482add7b2c98c24950771aad22791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea08150d9fb6bbc5bbcb4b6618014df8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aea08150d9fb6bbc5bbcb4b6618014df8">basic_string</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:aea08150d9fb6bbc5bbcb4b6618014df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:aea08150d9fb6bbc5bbcb4b6618014df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1bc8150fc7feeb6eb1dffc81a03e38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aee1bc8150fc7feeb6eb1dffc81a03e38">basic_string</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:aee1bc8150fc7feeb6eb1dffc81a03e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:aee1bc8150fc7feeb6eb1dffc81a03e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3afee2145a54a74b221125616c3acc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae3afee2145a54a74b221125616c3acc2">basic_string</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:ae3afee2145a54a74b221125616c3acc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy.  <br /></td></tr>
<tr class="separator:ae3afee2145a54a74b221125616c3acc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5e30e7cdaf1de13037c954e35c40b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6e5e30e7cdaf1de13037c954e35c40b9">basic_string</a> (const std::basic_string&lt; char &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a6e5e30e7cdaf1de13037c954e35c40b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a6e5e30e7cdaf1de13037c954e35c40b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50082b3f7bfd15a116dc80243d69504d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a50082b3f7bfd15a116dc80243d69504d">basic_string</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a50082b3f7bfd15a116dc80243d69504d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:a50082b3f7bfd15a116dc80243d69504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10922cf294d6b787660a2bb1101975e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab10922cf294d6b787660a2bb1101975e">basic_string</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:ab10922cf294d6b787660a2bb1101975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:ab10922cf294d6b787660a2bb1101975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69cc01d9a89d0f69c8ea9b1cf4732f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae69cc01d9a89d0f69c8ea9b1cf4732f8">basic_string</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:ae69cc01d9a89d0f69c8ea9b1cf4732f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:ae69cc01d9a89d0f69c8ea9b1cf4732f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af197da49cd87da738cbd7a2dd82b7cbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af197da49cd87da738cbd7a2dd82b7cbc">basic_string</a> (const std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;str, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:af197da49cd87da738cbd7a2dd82b7cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator.  <br /></td></tr>
<tr class="separator:af197da49cd87da738cbd7a2dd82b7cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cffd0ccb520bac458db8c1e69e8dee"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a38cffd0ccb520bac458db8c1e69e8dee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a38cffd0ccb520bac458db8c1e69e8dee">basic_string</a> (input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:a38cffd0ccb520bac458db8c1e69e8dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified first and last iterators of substring.  <br /></td></tr>
<tr class="separator:a38cffd0ccb520bac458db8c1e69e8dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294b738b593df2df992600e2720ade75"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a294b738b593df2df992600e2720ade75"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a294b738b593df2df992600e2720ade75">basic_string</a> (input_iterator_t first, input_iterator_t last, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a294b738b593df2df992600e2720ade75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified first and last iterators of substring and allocator.  <br /></td></tr>
<tr class="separator:a294b738b593df2df992600e2720ade75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e917194bb8dd889d36d8fafb29d27ed"><td class="memTemplParams" colspan="2">template&lt;class string_view_like_t &gt; </td></tr>
<tr class="memitem:a0e917194bb8dd889d36d8fafb29d27ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0e917194bb8dd889d36d8fafb29d27ed">basic_string</a> (const string_view_like_t &amp;string_view)</td></tr>
<tr class="memdesc:a0e917194bb8dd889d36d8fafb29d27ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string view of substring and allocator.  <br /></td></tr>
<tr class="separator:a0e917194bb8dd889d36d8fafb29d27ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e6338c49ba8d4c6d70c77ba91463d9"><td class="memTemplParams" colspan="2">template&lt;class string_view_like_t &gt; </td></tr>
<tr class="memitem:ae6e6338c49ba8d4c6d70c77ba91463d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae6e6338c49ba8d4c6d70c77ba91463d9">basic_string</a> (const string_view_like_t &amp;string_view, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ae6e6338c49ba8d4c6d70c77ba91463d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string view of substring and allocator.  <br /></td></tr>
<tr class="separator:ae6e6338c49ba8d4c6d70c77ba91463d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57fd8e7c03abe36192a2ba61c156e63"><td class="memTemplParams" colspan="2">template&lt;class string_view_like_t &gt; </td></tr>
<tr class="memitem:ab57fd8e7c03abe36192a2ba61c156e63"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab57fd8e7c03abe36192a2ba61c156e63">basic_string</a> (const string_view_like_t &amp;string_view, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> index, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:ab57fd8e7c03abe36192a2ba61c156e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string view of substring and allocator.  <br /></td></tr>
<tr class="separator:ab57fd8e7c03abe36192a2ba61c156e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6659f7ba5aafc9db2559b664fa3bc80e"><td class="memTemplParams" colspan="2">template&lt;class string_view_like_t &gt; </td></tr>
<tr class="memitem:a6659f7ba5aafc9db2559b664fa3bc80e"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6659f7ba5aafc9db2559b664fa3bc80e">basic_string</a> (const string_view_like_t &amp;string_view, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> index, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a6659f7ba5aafc9db2559b664fa3bc80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string view of substring and allocator.  <br /></td></tr>
<tr class="separator:a6659f7ba5aafc9db2559b664fa3bc80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdbf759c8d2bbd2256b16666b1d008d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7cdbf759c8d2bbd2256b16666b1d008d">basic_string</a> (std::initializer_list&lt; char &gt; il)</td></tr>
<tr class="memdesc:a7cdbf759c8d2bbd2256b16666b1d008d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a7cdbf759c8d2bbd2256b16666b1d008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac034c2161dcdd4386e6a3b8d410a4586"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac034c2161dcdd4386e6a3b8d410a4586">basic_string</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; il)</td></tr>
<tr class="memdesc:ac034c2161dcdd4386e6a3b8d410a4586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:ac034c2161dcdd4386e6a3b8d410a4586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad58660d076fec72617e2dfb55abdf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5ad58660d076fec72617e2dfb55abdf8">basic_string</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; il)</td></tr>
<tr class="memdesc:a5ad58660d076fec72617e2dfb55abdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a5ad58660d076fec72617e2dfb55abdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c44e9814327dc4e98e28fa74206687"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac4c44e9814327dc4e98e28fa74206687">basic_string</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; il)</td></tr>
<tr class="memdesc:ac4c44e9814327dc4e98e28fa74206687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:ac4c44e9814327dc4e98e28fa74206687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421e7ac13f9d908b2dc1b81827801d2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a421e7ac13f9d908b2dc1b81827801d2a">basic_string</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; il)</td></tr>
<tr class="memdesc:a421e7ac13f9d908b2dc1b81827801d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list.  <br /></td></tr>
<tr class="separator:a421e7ac13f9d908b2dc1b81827801d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a7bc67a43822538bf3b3925f2f89af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a25a7bc67a43822538bf3b3925f2f89af">basic_string</a> (std::initializer_list&lt; char &gt; il, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a25a7bc67a43822538bf3b3925f2f89af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:a25a7bc67a43822538bf3b3925f2f89af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17891ddbf875eaf8128a98260ffdc412"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a17891ddbf875eaf8128a98260ffdc412">basic_string</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; il, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a17891ddbf875eaf8128a98260ffdc412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:a17891ddbf875eaf8128a98260ffdc412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665cb6cefb7df851c7fcda456bfc976d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a665cb6cefb7df851c7fcda456bfc976d">basic_string</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; il, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a665cb6cefb7df851c7fcda456bfc976d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:a665cb6cefb7df851c7fcda456bfc976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46739aa91a301edc507c5846fc7d86a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad46739aa91a301edc507c5846fc7d86a">basic_string</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; il, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ad46739aa91a301edc507c5846fc7d86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:ad46739aa91a301edc507c5846fc7d86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f396ea48e81ac5c0337d83bb961454"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae2f396ea48e81ac5c0337d83bb961454">basic_string</a> (std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; il, const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:ae2f396ea48e81ac5c0337d83bb961454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator.  <br /></td></tr>
<tr class="separator:ae2f396ea48e81ac5c0337d83bb961454"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:afcf4efd4162f8a5d9b3da7c3ba40f3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a5a19c12dd03024a0b27ae68115bbfa2b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#afcf4efd4162f8a5d9b3da7c3ba40f3f0">back</a> () const</td></tr>
<tr class="memdesc:afcf4efd4162f8a5d9b3da7c3ba40f3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the last character in the string.  <br /></td></tr>
<tr class="separator:afcf4efd4162f8a5d9b3da7c3ba40f3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a3ad434a49e497c2827801e37adfdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#ae6b7bbe92cc0909082b7a1257f9454a6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a60a3ad434a49e497c2827801e37adfdc">begin</a> () const override</td></tr>
<tr class="memdesc:a60a3ad434a49e497c2827801e37adfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first character of the string.  <br /></td></tr>
<tr class="separator:a60a3ad434a49e497c2827801e37adfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb32307b8ff07cadb6c0d74de22d08a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#addb32307b8ff07cadb6c0d74de22d08a">c_str</a> () const noexcept</td></tr>
<tr class="memdesc:addb32307b8ff07cadb6c0d74de22d08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a null-terminated character array with data equivalent to those stored in the string.  <br /></td></tr>
<tr class="separator:addb32307b8ff07cadb6c0d74de22d08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb89d9cf553c5a88d4a93d82716cda2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#afb89d9cf553c5a88d4a93d82716cda2c">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:afb89d9cf553c5a88d4a93d82716cda2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters that the string has currently allocated space for.  <br /></td></tr>
<tr class="separator:afb89d9cf553c5a88d4a93d82716cda2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01c1d1476145c027b296d03b41229f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#ae6b7bbe92cc0909082b7a1257f9454a6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad01c1d1476145c027b296d03b41229f3">cbegin</a> () const override</td></tr>
<tr class="memdesc:ad01c1d1476145c027b296d03b41229f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first character of the string.  <br /></td></tr>
<tr class="separator:ad01c1d1476145c027b296d03b41229f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f92b35eb989cf42f65e0a0701b33a4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a72aff392391a7665d5244311dd7eee46">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8f92b35eb989cf42f65e0a0701b33a4d">crbegin</a> () const</td></tr>
<tr class="memdesc:a8f92b35eb989cf42f65e0a0701b33a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first character of the string.  <br /></td></tr>
<tr class="separator:a8f92b35eb989cf42f65e0a0701b33a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd284a790e1c3e7b0b815b54519beb8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1basic__string.html#a023c9110b9e82006d694c297f404e031">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4dd284a790e1c3e7b0b815b54519beb8">chars</a> () const noexcept</td></tr>
<tr class="memdesc:a4dd284a790e1c3e7b0b815b54519beb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a4dd284a790e1c3e7b0b815b54519beb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6992b7ccae6af08474ef89a34573a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#ae6b7bbe92cc0909082b7a1257f9454a6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6a6992b7ccae6af08474ef89a34573a7">cend</a> () const override</td></tr>
<tr class="memdesc:a6a6992b7ccae6af08474ef89a34573a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a6a6992b7ccae6af08474ef89a34573a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b78dd75f8256127726d962064d357fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a72aff392391a7665d5244311dd7eee46">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8b78dd75f8256127726d962064d357fb">crend</a> () const</td></tr>
<tr class="memdesc:a8b78dd75f8256127726d962064d357fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a8b78dd75f8256127726d962064d357fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d4c3712f32d15f308e2a5951298042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a95d4c3712f32d15f308e2a5951298042">data</a> () const noexcept</td></tr>
<tr class="memdesc:a95d4c3712f32d15f308e2a5951298042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the underlying array serving as character storage. The pointer is such that the range [<code><a class="el" href="classxtd_1_1basic__string.html#a95d4c3712f32d15f308e2a5951298042" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a></code>, <code><a class="el" href="classxtd_1_1basic__string.html#a95d4c3712f32d15f308e2a5951298042" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a></code>] is valid and the values in it correspond to the values stored in the string.  <br /></td></tr>
<tr class="separator:a95d4c3712f32d15f308e2a5951298042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2d306e379dd0b505b8c40e37c9439e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#adf2d306e379dd0b505b8c40e37c9439e">empty</a> () const noexcept</td></tr>
<tr class="memdesc:adf2d306e379dd0b505b8c40e37c9439e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the string has no characters, i.e. whether <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959" title="Returns an iterator to the first element of the enumarable.">begin()</a> == <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a" title="Returns an iterator to the element following the last element of the enumarable.">end()</a></code>.  <br /></td></tr>
<tr class="separator:adf2d306e379dd0b505b8c40e37c9439e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6387fcdd54bee21d02cc5d244a3028ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#ae6b7bbe92cc0909082b7a1257f9454a6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6387fcdd54bee21d02cc5d244a3028ff">end</a> () const override</td></tr>
<tr class="memdesc:a6387fcdd54bee21d02cc5d244a3028ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a6387fcdd54bee21d02cc5d244a3028ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82f74f75a637871f055a583780a120c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a5a19c12dd03024a0b27ae68115bbfa2b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac82f74f75a637871f055a583780a120c">front</a> () const</td></tr>
<tr class="memdesc:ac82f74f75a637871f055a583780a120c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the first character in the string. The behavior is undefined if <a class="el" href="classxtd_1_1basic__string.html#adf2d306e379dd0b505b8c40e37c9439e" title="Checks if the string has no characters, i.e. whether begin() == end().">empty()</a> is <code>true</code>.  <br /></td></tr>
<tr class="separator:ac82f74f75a637871f055a583780a120c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfeb876a8fb51c80fa9adaa3663f232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a> () const noexcept</td></tr>
<tr class="memdesc:aabfeb876a8fb51c80fa9adaa3663f232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of characters in the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object.  <br /></td></tr>
<tr class="separator:aabfeb876a8fb51c80fa9adaa3663f232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a674460af1de2943965a320747214d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a75a674460af1de2943965a320747214d">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a75a674460af1de2943965a320747214d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the string is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a" title="Returns an iterator to the element following the last element of the enumarable.">end()</a>)</code> for the largest string.  <br /></td></tr>
<tr class="separator:a75a674460af1de2943965a320747214d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140b818168a60bb3672192795b5ec637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a72aff392391a7665d5244311dd7eee46">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a140b818168a60bb3672192795b5ec637">rbegin</a> () const</td></tr>
<tr class="memdesc:a140b818168a60bb3672192795b5ec637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first character of the string.  <br /></td></tr>
<tr class="separator:a140b818168a60bb3672192795b5ec637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcd80009ae3c9178d9afbdd4f620730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a72aff392391a7665d5244311dd7eee46">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9fcd80009ae3c9178d9afbdd4f620730">rend</a> () const</td></tr>
<tr class="memdesc:a9fcd80009ae3c9178d9afbdd4f620730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a9fcd80009ae3c9178d9afbdd4f620730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e7750375addd424e2684f5f7f88853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853">size</a> () const noexcept</td></tr>
<tr class="memdesc:aa6e7750375addd424e2684f5f7f88853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <code>char_t</code> elements in the string, i.e. <code>std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a" title="Returns an iterator to the element following the last element of the enumarable.">end()</a>)</code>.  <br /></td></tr>
<tr class="separator:aa6e7750375addd424e2684f5f7f88853"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:aa7608d530a9e060c40377f3f6efa1965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a5a19c12dd03024a0b27ae68115bbfa2b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa7608d530a9e060c40377f3f6efa1965">at</a> (<a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:aa7608d530a9e060c40377f3f6efa1965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character at specified location <code>pos</code>.  <br /></td></tr>
<tr class="separator:aa7608d530a9e060c40377f3f6efa1965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6d1ce36c2c1d610948bca326214f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#adc6d1ce36c2c1d610948bca326214f5f">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:adc6d1ce36c2c1d610948bca326214f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:adc6d1ce36c2c1d610948bca326214f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa91fdfcbd6bfb926f6c81d25242203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2aa91fdfcbd6bfb926f6c81d25242203">compare</a> (<a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos1, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> count1, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a2aa91fdfcbd6bfb926f6c81d25242203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a2aa91fdfcbd6bfb926f6c81d25242203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d0c3aa6ba8ade03f28f5528a7cabfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac3d0c3aa6ba8ade03f28f5528a7cabfb">compare</a> (<a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos1, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> count1, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos2) const</td></tr>
<tr class="memdesc:ac3d0c3aa6ba8ade03f28f5528a7cabfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:ac3d0c3aa6ba8ade03f28f5528a7cabfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b565aa564f6888524daf4c978e868ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7b565aa564f6888524daf4c978e868ee">compare</a> (<a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos1, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> count1, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos2, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> count2) const</td></tr>
<tr class="memdesc:a7b565aa564f6888524daf4c978e868ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a7b565aa564f6888524daf4c978e868ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa506b15b46ca02bfb9f5e782ad71b714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa506b15b46ca02bfb9f5e782ad71b714">compare</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:aa506b15b46ca02bfb9f5e782ad71b714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:aa506b15b46ca02bfb9f5e782ad71b714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f4de83225ec7eb81d9e34a6d3fd461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a42f4de83225ec7eb81d9e34a6d3fd461">compare</a> (<a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos1, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> count1, <a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a42f4de83225ec7eb81d9e34a6d3fd461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a42f4de83225ec7eb81d9e34a6d3fd461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd1814acf74f3359393306249030536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4cd1814acf74f3359393306249030536">compare</a> (<a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos1, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> count1, <a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> count2) const</td></tr>
<tr class="memdesc:a4cd1814acf74f3359393306249030536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two character sequences.  <br /></td></tr>
<tr class="separator:a4cd1814acf74f3359393306249030536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785e7ca9244c89a0fd0552a30dca0df6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a785e7ca9244c89a0fd0552a30dca0df6">compare_to</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;value) const</td></tr>
<tr class="memdesc:a785e7ca9244c89a0fd0552a30dca0df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this instance with a specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a>.  <br /></td></tr>
<tr class="separator:a785e7ca9244c89a0fd0552a30dca0df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56991bcdcf3648e12180abbda6d0e4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a56991bcdcf3648e12180abbda6d0e4a2">compare_to</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:a56991bcdcf3648e12180abbda6d0e4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this instance with a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.  <br /></td></tr>
<tr class="separator:a56991bcdcf3648e12180abbda6d0e4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850cd349d2e010f36c975a32b150a981"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a850cd349d2e010f36c975a32b150a981">contains</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a850cd349d2e010f36c975a32b150a981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified char occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a850cd349d2e010f36c975a32b150a981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fea739d2eea162481378cc3563e0e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a46fea739d2eea162481378cc3563e0e7">contains</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a46fea739d2eea162481378cc3563e0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value indicating whether a specified substring occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a46fea739d2eea162481378cc3563e0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa538684c095ac08578828af5eff7d48d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa538684c095ac08578828af5eff7d48d">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept override</td></tr>
<tr class="memdesc:aa538684c095ac08578828af5eff7d48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object, have the same value.  <br /></td></tr>
<tr class="separator:aa538684c095ac08578828af5eff7d48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1e61a72cf0017e83126ebd8d409079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acf1e61a72cf0017e83126ebd8d409079">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept override</td></tr>
<tr class="memdesc:acf1e61a72cf0017e83126ebd8d409079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value.  <br /></td></tr>
<tr class="separator:acf1e61a72cf0017e83126ebd8d409079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe34c3ef80e295d524013594ab98e96f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#abe34c3ef80e295d524013594ab98e96f">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:abe34c3ef80e295d524013594ab98e96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:abe34c3ef80e295d524013594ab98e96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a32b980ce33e6240fad1bdf860be32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a88a32b980ce33e6240fad1bdf860be32">ends_with</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a88a32b980ce33e6240fad1bdf860be32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character.  <br /></td></tr>
<tr class="separator:a88a32b980ce33e6240fad1bdf860be32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235800cab8022150e0242be1f70ccba5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a235800cab8022150e0242be1f70ccba5">ends_with</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:a235800cab8022150e0242be1f70ccba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a235800cab8022150e0242be1f70ccba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac9bb8f1452d6d3f0a504ed482aeff03d">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:ac9bb8f1452d6d3f0a504ed482aeff03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2260a3a56c452a4086de5c75d608f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aad2260a3a56c452a4086de5c75d608f3">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:aad2260a3a56c452a4086de5c75d608f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:aad2260a3a56c452a4086de5c75d608f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d548b663eb6dc7b61394d0a5031a779"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0d548b663eb6dc7b61394d0a5031a779">ends_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) const noexcept</td></tr>
<tr class="memdesc:a0d548b663eb6dc7b61394d0a5031a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option.  <br /></td></tr>
<tr class="separator:a0d548b663eb6dc7b61394d0a5031a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995fc327f844695b7d54bb8c9dcefd64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a995fc327f844695b7d54bb8c9dcefd64">find</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a995fc327f844695b7d54bb8c9dcefd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a995fc327f844695b7d54bb8c9dcefd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ef167753f97393efa4e8a04f645b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae7ef167753f97393efa4e8a04f645b1a">find</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:ae7ef167753f97393efa4e8a04f645b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:ae7ef167753f97393efa4e8a04f645b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa27496a7880e6ec15ed6af9f3ee63a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#afa27496a7880e6ec15ed6af9f3ee63a9">find</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:afa27496a7880e6ec15ed6af9f3ee63a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:afa27496a7880e6ec15ed6af9f3ee63a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b84e810101f5722ea51155b57673c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5b84e810101f5722ea51155b57673c3a">find</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a5b84e810101f5722ea51155b57673c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a5b84e810101f5722ea51155b57673c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe01cbb72aa625955d5f91eaf20b4422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#afe01cbb72aa625955d5f91eaf20b4422">find</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:afe01cbb72aa625955d5f91eaf20b4422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:afe01cbb72aa625955d5f91eaf20b4422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e89be405fda67b0a224b7f5d19dbb74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6e89be405fda67b0a224b7f5d19dbb74">find</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> ch) const</td></tr>
<tr class="memdesc:a6e89be405fda67b0a224b7f5d19dbb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>.  <br /></td></tr>
<tr class="separator:a6e89be405fda67b0a224b7f5d19dbb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada37711b3a6b2d96deb9937458eeed91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ada37711b3a6b2d96deb9937458eeed91">find</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> ch, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:ada37711b3a6b2d96deb9937458eeed91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>.  <br /></td></tr>
<tr class="separator:ada37711b3a6b2d96deb9937458eeed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190df4d0356f13ee707e02bf0ff69670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a190df4d0356f13ee707e02bf0ff69670">find_first_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a190df4d0356f13ee707e02bf0ff69670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a190df4d0356f13ee707e02bf0ff69670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a47ad6cd829e5fb0e5ba7fd173fa52a4c">find_first_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a47ad6cd829e5fb0e5ba7fd173fa52a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92834b04a7c65b7de003f742e78d8309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a92834b04a7c65b7de003f742e78d8309">find_first_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a92834b04a7c65b7de003f742e78d8309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a92834b04a7c65b7de003f742e78d8309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb30d4555ab0d49edac1d1f29748968d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acb30d4555ab0d49edac1d1f29748968d">find_first_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:acb30d4555ab0d49edac1d1f29748968d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:acb30d4555ab0d49edac1d1f29748968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4bf3f78cb8fce98db32d6dea0dacb1fd">find_first_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a4bf3f78cb8fce98db32d6dea0dacb1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63f087262d302ffd91d44441141395f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa63f087262d302ffd91d44441141395f">find_first_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:aa63f087262d302ffd91d44441141395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa63f087262d302ffd91d44441141395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0742e91a1bc6cc31486581993106d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aebf0742e91a1bc6cc31486581993106d">find_first_of</a> (char_t ch, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:aebf0742e91a1bc6cc31486581993106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aebf0742e91a1bc6cc31486581993106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44655a7fb2b16b0ac355f98efbe7f60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a44655a7fb2b16b0ac355f98efbe7f60a">find_first_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a44655a7fb2b16b0ac355f98efbe7f60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a44655a7fb2b16b0ac355f98efbe7f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865854c0f1fc517a76019ef74357471c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a865854c0f1fc517a76019ef74357471c">find_first_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:a865854c0f1fc517a76019ef74357471c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a865854c0f1fc517a76019ef74357471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ee3d277929b2e2822347bbef0799ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa7ee3d277929b2e2822347bbef0799ec">find_first_not_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:aa7ee3d277929b2e2822347bbef0799ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa7ee3d277929b2e2822347bbef0799ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa68c7409e9483b7fb2ecb4119a1a49c3">find_first_not_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa68c7409e9483b7fb2ecb4119a1a49c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394185c5018c818ca6e8c3cbf9048da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a394185c5018c818ca6e8c3cbf9048da1">find_first_not_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:a394185c5018c818ca6e8c3cbf9048da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a394185c5018c818ca6e8c3cbf9048da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525f7ed777b11690436a4e545cbd4c52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a525f7ed777b11690436a4e545cbd4c52">find_first_not_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:a525f7ed777b11690436a4e545cbd4c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a525f7ed777b11690436a4e545cbd4c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa337f7f098dc744c16c768824cdbf5de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa337f7f098dc744c16c768824cdbf5de">find_first_not_of</a> (char_t ch, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:aa337f7f098dc744c16c768824cdbf5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:aa337f7f098dc744c16c768824cdbf5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4b8376a5af873f844aa5de5a7f36f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ada4b8376a5af873f844aa5de5a7f36f1">find_last_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:ada4b8376a5af873f844aa5de5a7f36f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:ada4b8376a5af873f844aa5de5a7f36f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8812d25aeb365b83a6e13b22d3ea15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#abe8812d25aeb365b83a6e13b22d3ea15">find_last_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:abe8812d25aeb365b83a6e13b22d3ea15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:abe8812d25aeb365b83a6e13b22d3ea15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae683ad85d132dc61069a39ab5ecfc892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae683ad85d132dc61069a39ab5ecfc892">find_last_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:ae683ad85d132dc61069a39ab5ecfc892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ae683ad85d132dc61069a39ab5ecfc892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9f9c97ebc85319e7bb0890747f95f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a3b9f9c97ebc85319e7bb0890747f95f0">find_last_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a3b9f9c97ebc85319e7bb0890747f95f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a3b9f9c97ebc85319e7bb0890747f95f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43971d40fb8f9c14c8f2a8973fda5241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a43971d40fb8f9c14c8f2a8973fda5241">find_last_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:a43971d40fb8f9c14c8f2a8973fda5241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a43971d40fb8f9c14c8f2a8973fda5241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f1e765d3c800b53ad278aeea40cbbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad3f1e765d3c800b53ad278aeea40cbbb">find_last_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:ad3f1e765d3c800b53ad278aeea40cbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ad3f1e765d3c800b53ad278aeea40cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2276b8461430eec909f87352134d92d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2276b8461430eec909f87352134d92d8">find_last_of</a> (char_t ch, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:a2276b8461430eec909f87352134d92d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a2276b8461430eec909f87352134d92d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a0529754f7c547dd26d0e3df7d4d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a85a0529754f7c547dd26d0e3df7d4d57">find_last_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a85a0529754f7c547dd26d0e3df7d4d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for.  <br /></td></tr>
<tr class="separator:a85a0529754f7c547dd26d0e3df7d4d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7be46eecca48686b7893fdcc22f1064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae7be46eecca48686b7893fdcc22f1064">find_last_not_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:ae7be46eecca48686b7893fdcc22f1064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ae7be46eecca48686b7893fdcc22f1064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db0de794b93c1d3daec32ee93ebb840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0db0de794b93c1d3daec32ee93ebb840">find_last_not_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a0db0de794b93c1d3daec32ee93ebb840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a0db0de794b93c1d3daec32ee93ebb840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66">find_last_not_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867ec6c6bbe8ded000aab89983f5b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad867ec6c6bbe8ded000aab89983f5b37">find_last_not_of</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:ad867ec6c6bbe8ded000aab89983f5b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:ad867ec6c6bbe8ded000aab89983f5b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622aba17212244261f0a1dee4cf2a76c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a622aba17212244261f0a1dee4cf2a76c">find_last_not_of</a> (char_t ch) const</td></tr>
<tr class="memdesc:a622aba17212244261f0a1dee4cf2a76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a622aba17212244261f0a1dee4cf2a76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb1e50a316279a814fbf6caa9a52512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2bb1e50a316279a814fbf6caa9a52512">find_last_not_of</a> (char_t ch, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:a2bb1e50a316279a814fbf6caa9a52512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned.  <br /></td></tr>
<tr class="separator:a2bb1e50a316279a814fbf6caa9a52512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fea87ee51c2cc221b5018ff83de9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0f3fea87ee51c2cc221b5018ff83de9b">get_allocator</a> () const</td></tr>
<tr class="memdesc:a0f3fea87ee51c2cc221b5018ff83de9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the string.  <br /></td></tr>
<tr class="separator:a0f3fea87ee51c2cc221b5018ff83de9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f45ba04d07446618d604b99c22fbb3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classxtd_1_1basic__string.html#a023c9110b9e82006d694c297f404e031">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a38f45ba04d07446618d604b99c22fbb3">get_base_type</a> () const noexcept</td></tr>
<tr class="memdesc:a38f45ba04d07446618d604b99c22fbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type.  <br /></td></tr>
<tr class="separator:a38f45ba04d07446618d604b99c22fbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8204b499a2a327ac2193814c5ba59be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8204b499a2a327ac2193814c5ba59be4">get_hash_code</a> () const noexcept override</td></tr>
<tr class="memdesc:a8204b499a2a327ac2193814c5ba59be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash code for this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a8204b499a2a327ac2193814c5ba59be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273eee6b3d879fdab255817b5406ff1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a2b5493bd9034616dded9fb810d65fd6c">enumerator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a273eee6b3d879fdab255817b5406ff1b">get_enumerator</a> () const noexcept override</td></tr>
<tr class="memdesc:a273eee6b3d879fdab255817b5406ff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that iterates through a collection.  <br /></td></tr>
<tr class="separator:a273eee6b3d879fdab255817b5406ff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e2b0b18ffae65666bfe665f10c8eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa2e2b0b18ffae65666bfe665f10c8eee">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:aa2e2b0b18ffae65666bfe665f10c8eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:aa2e2b0b18ffae65666bfe665f10c8eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae8cdbff9d2baf8ca5354e0361db8b8f1">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ae8cdbff9d2baf8ca5354e0361db8b8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9376bff15d7276c49c0ce4ea3bd744b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9376bff15d7276c49c0ce4ea3bd744b0">index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a9376bff15d7276c49c0ce4ea3bd744b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a9376bff15d7276c49c0ce4ea3bd744b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a03cc9bdb3ebf738766cf0b8357d9f28d">index_of</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a03cc9bdb3ebf738766cf0b8357d9f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1241d527912da0524fe79c1885104986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a1241d527912da0524fe79c1885104986">index_of</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a1241d527912da0524fe79c1885104986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a1241d527912da0524fe79c1885104986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101dd613f8711c38c17443fbc8c29799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a101dd613f8711c38c17443fbc8c29799">index_of</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a101dd613f8711c38c17443fbc8c29799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a101dd613f8711c38c17443fbc8c29799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c38c1845d60e7d08f8750bb181aa4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a50c38c1845d60e7d08f8750bb181aa4d">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a50c38c1845d60e7d08f8750bb181aa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a50c38c1845d60e7d08f8750bb181aa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a19d7c6fb6ca5e05c6a464e8cb25c2e76">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a19d7c6fb6ca5e05c6a464e8cb25c2e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac27b133bb5f4567decb3a19ff63a883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aac27b133bb5f4567decb3a19ff63a883">index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:aac27b133bb5f4567decb3a19ff63a883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:aac27b133bb5f4567decb3a19ff63a883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ce826afc61742ea2b759feb0987d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a48ce826afc61742ea2b759feb0987d9c">insert</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const</td></tr>
<tr class="memdesc:a48ce826afc61742ea2b759feb0987d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a specified instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> at a specified index position in this instance.  <br /></td></tr>
<tr class="separator:a48ce826afc61742ea2b759feb0987d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9caea8081698b588cb6af9b6da8542"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6c9caea8081698b588cb6af9b6da8542">is_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a6c9caea8081698b588cb6af9b6da8542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> ("").  <br /></td></tr>
<tr class="separator:a6c9caea8081698b588cb6af9b6da8542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc799a8cc31af232470d65cd88a1ca6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acc799a8cc31af232470d65cd88a1ca6a">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:acc799a8cc31af232470d65cd88a1ca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:acc799a8cc31af232470d65cd88a1ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a6db704899bd1263a714bf8363f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a3b7a6db704899bd1263a714bf8363f6b">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a3b7a6db704899bd1263a714bf8363f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:a3b7a6db704899bd1263a714bf8363f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb55029c7dfebcfb60989e102943e70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4fb55029c7dfebcfb60989e102943e70">last_index_of</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a4fb55029c7dfebcfb60989e102943e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a4fb55029c7dfebcfb60989e102943e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a1c153b902e5edf0b877652add0e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a68a1c153b902e5edf0b877652add0e43">last_index_of</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:a68a1c153b902e5edf0b877652add0e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this tring.  <br /></td></tr>
<tr class="separator:a68a1c153b902e5edf0b877652add0e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bdcec1f21421c38a7a80d8142ff7d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af8bdcec1f21421c38a7a80d8142ff7d5">last_index_of</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:af8bdcec1f21421c38a7a80d8142ff7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:af8bdcec1f21421c38a7a80d8142ff7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8c63d72cfa3f91e2cf9f23881f68d9a6">last_index_of</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions.  <br /></td></tr>
<tr class="separator:a8c63d72cfa3f91e2cf9f23881f68d9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cef9de4c87f758793ab52f372999b98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9cef9de4c87f758793ab52f372999b98">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;values) const noexcept</td></tr>
<tr class="memdesc:a9cef9de4c87f758793ab52f372999b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters.  <br /></td></tr>
<tr class="separator:a9cef9de4c87f758793ab52f372999b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eee5a0186b0272dde1487fa3a76e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad9eee5a0186b0272dde1487fa3a76e31">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:ad9eee5a0186b0272dde1487fa3a76e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ad9eee5a0186b0272dde1487fa3a76e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c41879b43a215e17a3b3f1d940352b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac4c41879b43a215e17a3b3f1d940352b">last_index_of_any</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;values, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:ac4c41879b43a215e17a3b3f1d940352b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position.  <br /></td></tr>
<tr class="separator:ac4c41879b43a215e17a3b3f1d940352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0841b4ac447cc426dfc86857696a59d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0841b4ac447cc426dfc86857696a59d3">pad_left</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> total_width) const noexcept</td></tr>
<tr class="memdesc:a0841b4ac447cc426dfc86857696a59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:a0841b4ac447cc426dfc86857696a59d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8d49dec1f34267194ae3d6023e5bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acd8d49dec1f34267194ae3d6023e5bca">pad_left</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> total_width, <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> padding_char) const noexcept</td></tr>
<tr class="memdesc:acd8d49dec1f34267194ae3d6023e5bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length.  <br /></td></tr>
<tr class="separator:acd8d49dec1f34267194ae3d6023e5bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37d71513cd7f2585290402bd45afb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#abe37d71513cd7f2585290402bd45afb2">pad_right</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> total_width) const noexcept</td></tr>
<tr class="memdesc:abe37d71513cd7f2585290402bd45afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:abe37d71513cd7f2585290402bd45afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948b86a1e0b7a58d6813048a74c4106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7948b86a1e0b7a58d6813048a74c4106">pad_right</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> total_width, <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a> padding_char) const noexcept</td></tr>
<tr class="memdesc:a7948b86a1e0b7a58d6813048a74c4106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length.  <br /></td></tr>
<tr class="separator:a7948b86a1e0b7a58d6813048a74c4106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856547e0780ad2ada0c0f614dc063df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5856547e0780ad2ada0c0f614dc063df">quoted</a> () const</td></tr>
<tr class="memdesc:a5856547e0780ad2ada0c0f614dc063df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>.  <br /></td></tr>
<tr class="separator:a5856547e0780ad2ada0c0f614dc063df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773214921b5ced5e4a8d4c25dd88891c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a773214921b5ced5e4a8d4c25dd88891c">quoted</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> delimiter) const</td></tr>
<tr class="memdesc:a773214921b5ced5e4a8d4c25dd88891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter.  <br /></td></tr>
<tr class="separator:a773214921b5ced5e4a8d4c25dd88891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19de7bf5a27c141a306859535be853a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af19de7bf5a27c141a306859535be853a">quoted</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> delimiter, <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae0ebc3c409070d07f1df0f2f4132509e">escape</a>) const</td></tr>
<tr class="memdesc:af19de7bf5a27c141a306859535be853a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape.  <br /></td></tr>
<tr class="separator:af19de7bf5a27c141a306859535be853a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb28698bda96ef32e834d79377523c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5fb28698bda96ef32e834d79377523c7">remove</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a5fb28698bda96ef32e834d79377523c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a5fb28698bda96ef32e834d79377523c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f92a6d19c47147afc8eacf6f9c6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a678f92a6d19c47147afc8eacf6f9c6b3">remove</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a678f92a6d19c47147afc8eacf6f9c6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position.  <br /></td></tr>
<tr class="separator:a678f92a6d19c47147afc8eacf6f9c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aab8e9d4ff2110bf9f24035babdc2a1ef">replace</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> old_char, <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> new_char) const noexcept</td></tr>
<tr class="memdesc:aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified char_t in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified char_t.  <br /></td></tr>
<tr class="separator:aab8e9d4ff2110bf9f24035babdc2a1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dba25995a5713a69ad528fc0dcf889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a80dba25995a5713a69ad528fc0dcf889">replace</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;old_string, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;new_string) const noexcept</td></tr>
<tr class="memdesc:a80dba25995a5713a69ad528fc0dcf889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a80dba25995a5713a69ad528fc0dcf889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4f156b7f8196bcf93d922f5a0936d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2e4f156b7f8196bcf93d922f5a0936d3">rfind</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str) const</td></tr>
<tr class="memdesc:a2e4f156b7f8196bcf93d922f5a0936d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>, the whole string will be searched. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. @remarks Finds the first substring equal to</code>str`.  <br /></td></tr>
<tr class="separator:a2e4f156b7f8196bcf93d922f5a0936d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58fe89ac239e9c5c32ed70df7c7c883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad58fe89ac239e9c5c32ed70df7c7c883">rfind</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:ad58fe89ac239e9c5c32ed70df7c7c883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:ad58fe89ac239e9c5c32ed70df7c7c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b86f1367a8a62bd5c9ec81730c6ff03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2b86f1367a8a62bd5c9ec81730c6ff03">rfind</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a2b86f1367a8a62bd5c9ec81730c6ff03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a2b86f1367a8a62bd5c9ec81730c6ff03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5e3a4d7133856d265119fea8ec612f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2c5e3a4d7133856d265119fea8ec612f">rfind</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>) const</td></tr>
<tr class="memdesc:a2c5e3a4d7133856d265119fea8ec612f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>, the whole string will be searched. @param s The pointer to a character string to search for. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. @remarks Finds the first substring equal to the character string pointed to by</code>s<code>. The length of the string is determined by the first null character using</code>traits_t::length(s)<code>. @remarks If [</code>s<code>,</code>s + traits_t::length(s)`) is not a valid range, the behavior is undefined.  <br /></td></tr>
<tr class="separator:a2c5e3a4d7133856d265119fea8ec612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7dc0272a38daae9fe92213bf3743f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#afff7dc0272a38daae9fe92213bf3743f">rfind</a> (<a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:afff7dc0272a38daae9fe92213bf3743f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:afff7dc0272a38daae9fe92213bf3743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89758e3790f9444b86efcdb7b0ecbee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a89758e3790f9444b86efcdb7b0ecbee2">rfind</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> ch) const</td></tr>
<tr class="memdesc:a89758e3790f9444b86efcdb7b0ecbee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>, the whole string will be searched. @param ch The character to search for. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. @remarks Finds the first character</code>ch` (treated as a single-character substring by the formal rules below).  <br /></td></tr>
<tr class="separator:a89758e3790f9444b86efcdb7b0ecbee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2a1c61ed2fd70d04090ff9e4ce3374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6f2a1c61ed2fd70d04090ff9e4ce3374">rfind</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> ch, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:a6f2a1c61ed2fd70d04090ff9e4ce3374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched.  <br /></td></tr>
<tr class="separator:a6f2a1c61ed2fd70d04090ff9e4ce3374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1344c6559dbf009f5ab4bebe64b6bb69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a1344c6559dbf009f5ab4bebe64b6bb69">split</a> () const noexcept</td></tr>
<tr class="memdesc:a1344c6559dbf009f5ab4bebe64b6bb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the default white-space characters. White-space characters are defined by the c++ standard and return <code>true</code> if they are passed to the xtd::char_object::isspace() or std::iswspace() method.  <br /></td></tr>
<tr class="separator:a1344c6559dbf009f5ab4bebe64b6bb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5dd5044af32ac25bb0baf9b6413342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5f5dd5044af32ac25bb0baf9b6413342">split</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>) const noexcept</td></tr>
<tr class="memdesc:a5f5dd5044af32ac25bb0baf9b6413342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the characters in an array.  <br /></td></tr>
<tr class="separator:a5f5dd5044af32ac25bb0baf9b6413342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edaf9bbe18d8453a1a4efbf54e74870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8edaf9bbe18d8453a1a4efbf54e74870">split</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a8edaf9bbe18d8453a1a4efbf54e74870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.  <br /></td></tr>
<tr class="separator:a8edaf9bbe18d8453a1a4efbf54e74870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2382e0600fa5915622f8eafd4c72bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#afd2382e0600fa5915622f8eafd4c72bb">split</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const noexcept</td></tr>
<tr class="memdesc:afd2382e0600fa5915622f8eafd4c72bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return.  <br /></td></tr>
<tr class="separator:afd2382e0600fa5915622f8eafd4c72bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbf084f9d5a9dcd94e199f33e18da31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2cbf084f9d5a9dcd94e199f33e18da31">split</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a2cbf084f9d5a9dcd94e199f33e18da31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array.  <br /></td></tr>
<tr class="separator:a2cbf084f9d5a9dcd94e199f33e18da31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26322b05a341263f70f5dbb8559e1e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a26322b05a341263f70f5dbb8559e1e49">split</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;separators) const noexcept</td></tr>
<tr class="memdesc:a26322b05a341263f70f5dbb8559e1e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the characters in an array.  <br /></td></tr>
<tr class="separator:a26322b05a341263f70f5dbb8559e1e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5de967d299899ed013ff09081289601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af5de967d299899ed013ff09081289601">split</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;separators, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:af5de967d299899ed013ff09081289601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.  <br /></td></tr>
<tr class="separator:af5de967d299899ed013ff09081289601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24f8ff6be34a9febe468cae4e98de8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af24f8ff6be34a9febe468cae4e98de8d">split</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;separators, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const noexcept</td></tr>
<tr class="memdesc:af24f8ff6be34a9febe468cae4e98de8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return.  <br /></td></tr>
<tr class="separator:af24f8ff6be34a9febe468cae4e98de8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f0ee8ec40989e2f2b12c148174e73a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a77f0ee8ec40989e2f2b12c148174e73a">split</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;separators, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>, <a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a> options) const noexcept</td></tr>
<tr class="memdesc:a77f0ee8ec40989e2f2b12c148174e73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array.  <br /></td></tr>
<tr class="separator:a77f0ee8ec40989e2f2b12c148174e73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49e5676d2d8bc36ac6f9294626a433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acf49e5676d2d8bc36ac6f9294626a433">starts_with</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value) const noexcept</td></tr>
<tr class="memdesc:acf49e5676d2d8bc36ac6f9294626a433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:acf49e5676d2d8bc36ac6f9294626a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844fc4d1f8f6465bb42b33c83ef11d38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a844fc4d1f8f6465bb42b33c83ef11d38">starts_with</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:a844fc4d1f8f6465bb42b33c83ef11d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a844fc4d1f8f6465bb42b33c83ef11d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ab7003170f911983442950687fd66e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a46ab7003170f911983442950687fd66e">starts_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value) const noexcept</td></tr>
<tr class="memdesc:a46ab7003170f911983442950687fd66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a46ab7003170f911983442950687fd66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc64225a0c82e51d464a248a98263d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aefc64225a0c82e51d464a248a98263d2">starts_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, bool ignore_case) const noexcept</td></tr>
<tr class="memdesc:aefc64225a0c82e51d464a248a98263d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:aefc64225a0c82e51d464a248a98263d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa21b380225ae8dd5786e7d27b8a30fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#afa21b380225ae8dd5786e7d27b8a30fc">starts_with</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;value, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) const noexcept</td></tr>
<tr class="memdesc:afa21b380225ae8dd5786e7d27b8a30fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option.  <br /></td></tr>
<tr class="separator:afa21b380225ae8dd5786e7d27b8a30fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae796b1c2de68ac5b3c39e09361682bd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ae796b1c2de68ac5b3c39e09361682bd2">substr</a> () const</td></tr>
<tr class="memdesc:ae796b1c2de68ac5b3c39e09361682bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:ae796b1c2de68ac5b3c39e09361682bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ea0f77673ecfbd266dc085d516e34a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aa8ea0f77673ecfbd266dc085d516e34a">substr</a> (<a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos) const</td></tr>
<tr class="memdesc:aa8ea0f77673ecfbd266dc085d516e34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:aa8ea0f77673ecfbd266dc085d516e34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544b0e8a83055ed6041d1c8f32afb5ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a544b0e8a83055ed6041d1c8f32afb5ed">substr</a> (<a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> pos, <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>) const</td></tr>
<tr class="memdesc:a544b0e8a83055ed6041d1c8f32afb5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).  <br /></td></tr>
<tr class="separator:a544b0e8a83055ed6041d1c8f32afb5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50394c19c9120fecc7228511cd07796b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a50394c19c9120fecc7228511cd07796b">substring</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a50394c19c9120fecc7228511cd07796b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.  <br /></td></tr>
<tr class="separator:a50394c19c9120fecc7228511cd07796b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c075ac57baaa69e5cae23fa37a750de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a1c075ac57baaa69e5cae23fa37a750de">substring</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>) const</td></tr>
<tr class="memdesc:a1c075ac57baaa69e5cae23fa37a750de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.  <br /></td></tr>
<tr class="separator:a1c075ac57baaa69e5cae23fa37a750de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65a379a9653c9aa95d4cdd67793ac53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af65a379a9653c9aa95d4cdd67793ac53">to_array</a> () const noexcept</td></tr>
<tr class="memdesc:af65a379a9653c9aa95d4cdd67793ac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array.  <br /></td></tr>
<tr class="separator:af65a379a9653c9aa95d4cdd67793ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef5e889d2eec057dbb70531d7431ba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4ef5e889d2eec057dbb70531d7431ba1">to_array</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index) const</td></tr>
<tr class="memdesc:a4ef5e889d2eec057dbb70531d7431ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index.  <br /></td></tr>
<tr class="separator:a4ef5e889d2eec057dbb70531d7431ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7c2c19ac001d245d0b6aacc6b893e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aab7c2c19ac001d245d0b6aacc6b893e9">to_array</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>) const</td></tr>
<tr class="memdesc:aab7c2c19ac001d245d0b6aacc6b893e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index with specified length.  <br /></td></tr>
<tr class="separator:aab7c2c19ac001d245d0b6aacc6b893e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57271b1de1ecc20c7f6eaaf9e1947a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a57271b1de1ecc20c7f6eaaf9e1947a8d">to_char_array</a> () const noexcept</td></tr>
<tr class="memdesc:a57271b1de1ecc20c7f6eaaf9e1947a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array.  <br /></td></tr>
<tr class="separator:a57271b1de1ecc20c7f6eaaf9e1947a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad26f801b726bf0e9f8e55ccfbb76bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7ad26f801b726bf0e9f8e55ccfbb76bc">to_char_array</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> start_index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>) const</td></tr>
<tr class="memdesc:a7ad26f801b726bf0e9f8e55ccfbb76bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters in this instance to a Unicode character array starting at specified index with specified length.  <br /></td></tr>
<tr class="separator:a7ad26f801b726bf0e9f8e55ccfbb76bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0612d8c3d9feb6b741e2a0d0a07f2121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0612d8c3d9feb6b741e2a0d0a07f2121">to_lower</a> () const noexcept</td></tr>
<tr class="memdesc:a0612d8c3d9feb6b741e2a0d0a07f2121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> converted to lowercase.  <br /></td></tr>
<tr class="separator:a0612d8c3d9feb6b741e2a0d0a07f2121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dbb00bd5ca3a95303ece7973c23be8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a58dbb00bd5ca3a95303ece7973c23be8">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:a58dbb00bd5ca3a95303ece7973c23be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;char&gt;.  <br /></td></tr>
<tr class="separator:a58dbb00bd5ca3a95303ece7973c23be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab652a0332d481e6ff0e234f6c8c629c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#aab652a0332d481e6ff0e234f6c8c629c">to_title_case</a> () const noexcept</td></tr>
<tr class="memdesc:aab652a0332d481e6ff0e234f6c8c629c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to title case (except for words that are entirely in uppercase, which are considered to be acronyms).  <br /></td></tr>
<tr class="separator:aab652a0332d481e6ff0e234f6c8c629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5381c036c5cf11a5fff2b228dce8441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af5381c036c5cf11a5fff2b228dce8441">to_u16string</a> () const noexcept</td></tr>
<tr class="memdesc:af5381c036c5cf11a5fff2b228dce8441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;.  <br /></td></tr>
<tr class="separator:af5381c036c5cf11a5fff2b228dce8441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de628a8933be7f9e8d1ec19b93b643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#af6de628a8933be7f9e8d1ec19b93b643">to_u32string</a> () const noexcept</td></tr>
<tr class="memdesc:af6de628a8933be7f9e8d1ec19b93b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;.  <br /></td></tr>
<tr class="separator:af6de628a8933be7f9e8d1ec19b93b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c7f70f3570876064475705884708c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad8c7f70f3570876064475705884708c6">to_u8string</a> () const noexcept</td></tr>
<tr class="memdesc:ad8c7f70f3570876064475705884708c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;.  <br /></td></tr>
<tr class="separator:ad8c7f70f3570876064475705884708c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc6be7fa93346c34256fb76e6dc4b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4cc6be7fa93346c34256fb76e6dc4b3a">to_upper</a> () const noexcept</td></tr>
<tr class="memdesc:a4cc6be7fa93346c34256fb76e6dc4b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> converted to uppercase.  <br /></td></tr>
<tr class="separator:a4cc6be7fa93346c34256fb76e6dc4b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce3a3f2c42d41896f43593d3e853edf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5ce3a3f2c42d41896f43593d3e853edf">to_wstring</a> () const noexcept</td></tr>
<tr class="memdesc:a5ce3a3f2c42d41896f43593d3e853edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518" title="Represents a wide character.">xtd::wchar</a>&gt;.  <br /></td></tr>
<tr class="separator:a5ce3a3f2c42d41896f43593d3e853edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12abc4b92c5666dbe597aebe733796e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a12abc4b92c5666dbe597aebe733796e1">trim</a> () const noexcept</td></tr>
<tr class="memdesc:a12abc4b92c5666dbe597aebe733796e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a12abc4b92c5666dbe597aebe733796e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008a2167029ed114ad95a3911d717b81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a008a2167029ed114ad95a3911d717b81">trim</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> trim_char) const noexcept</td></tr>
<tr class="memdesc:a008a2167029ed114ad95a3911d717b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> .  <br /></td></tr>
<tr class="separator:a008a2167029ed114ad95a3911d717b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8146db206c16a41c826fe5cc5d62926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad8146db206c16a41c826fe5cc5d62926">trim</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:ad8146db206c16a41c826fe5cc5d62926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading and trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:ad8146db206c16a41c826fe5cc5d62926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0a8e47fafff38f414e0a2fdae990bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9c0a8e47fafff38f414e0a2fdae990bc">trim_end</a> () const noexcept</td></tr>
<tr class="memdesc:a9c0a8e47fafff38f414e0a2fdae990bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a9c0a8e47fafff38f414e0a2fdae990bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cd7da5dcdbb9e48b57b074d45c4086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac0cd7da5dcdbb9e48b57b074d45c4086">trim_end</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> trim_char) const noexcept</td></tr>
<tr class="memdesc:ac0cd7da5dcdbb9e48b57b074d45c4086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> .  <br /></td></tr>
<tr class="separator:ac0cd7da5dcdbb9e48b57b074d45c4086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040906f5d3bac8da047872886e0ec723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a040906f5d3bac8da047872886e0ec723">trim_end</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:a040906f5d3bac8da047872886e0ec723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a040906f5d3bac8da047872886e0ec723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86342c41edcf3e05ef56d2a170d1389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac86342c41edcf3e05ef56d2a170d1389">trim_start</a> () const noexcept</td></tr>
<tr class="memdesc:ac86342c41edcf3e05ef56d2a170d1389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:ac86342c41edcf3e05ef56d2a170d1389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f441a6805a2fe3cfa6467eeecab5d3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a4f441a6805a2fe3cfa6467eeecab5d3e">trim_start</a> (<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> trim_char) const noexcept</td></tr>
<tr class="memdesc:a4f441a6805a2fe3cfa6467eeecab5d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> .  <br /></td></tr>
<tr class="separator:a4f441a6805a2fe3cfa6467eeecab5d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b36d97086675150ce441a1da48d3da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6b36d97086675150ce441a1da48d3da3">trim_start</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;trim_chars) const noexcept</td></tr>
<tr class="memdesc:a6b36d97086675150ce441a1da48d3da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all leading occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>.  <br /></td></tr>
<tr class="separator:a6b36d97086675150ce441a1da48d3da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Static Methods</h2></td></tr>
<tr class="memitem:a69a97f1b420e640208ecd970b0d17f09"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:a69a97f1b420e640208ecd970b0d17f09"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a69a97f1b420e640208ecd970b0d17f09">class_name</a> ()</td></tr>
<tr class="memdesc:a69a97f1b420e640208ecd970b0d17f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the object_t.  <br /></td></tr>
<tr class="separator:a69a97f1b420e640208ecd970b0d17f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0da452ea8889d3c99e3ef0437d12b3a2">class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a0da452ea8889d3c99e3ef0437d12b3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0695f721a034545f3ce21d8ac16944"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6a0695f721a034545f3ce21d8ac16944">class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:a6a0695f721a034545f3ce21d8ac16944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the class name of the specified object.  <br /></td></tr>
<tr class="separator:a6a0695f721a034545f3ce21d8ac16944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb70bd0d2a63dbd30c7256fc22563ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6fb70bd0d2a63dbd30c7256fc22563ed">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b) noexcept</td></tr>
<tr class="memdesc:a6fb70bd0d2a63dbd30c7256fc22563ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a6fb70bd0d2a63dbd30c7256fc22563ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f962d883014226a68c6a4d654ddb1b3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6f962d883014226a68c6a4d654ddb1b3">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:a6f962d883014226a68c6a4d654ddb1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a6f962d883014226a68c6a4d654ddb1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f90cbdcb6cc485cf796ba6105f0ed3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a03f90cbdcb6cc485cf796ba6105f0ed3">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type) noexcept</td></tr>
<tr class="memdesc:a03f90cbdcb6cc485cf796ba6105f0ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a03f90cbdcb6cc485cf796ba6105f0ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc411e57525bdd57f6de7607b8f6542"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9fc411e57525bdd57f6de7607b8f6542">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index_b, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>)</td></tr>
<tr class="memdesc:a9fc411e57525bdd57f6de7607b8f6542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a9fc411e57525bdd57f6de7607b8f6542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad607d694b591590cfb8a179a012a9641"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ad607d694b591590cfb8a179a012a9641">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index_b, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>, bool ignore_case)</td></tr>
<tr class="memdesc:ad607d694b591590cfb8a179a012a9641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:ad607d694b591590cfb8a179a012a9641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a8880cff5658a0b1a23d8ee576328a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a58a8880cff5658a0b1a23d8ee576328a">compare</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index_b, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232">length</a>, <a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a> comparison_type)</td></tr>
<tr class="memdesc:a58a8880cff5658a0b1a23d8ee576328a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.  <br /></td></tr>
<tr class="separator:a58a8880cff5658a0b1a23d8ee576328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897d161d82900b9f756cb79b479c5351"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a897d161d82900b9f756cb79b479c5351">concat</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_c, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_d) noexcept</td></tr>
<tr class="memdesc:a897d161d82900b9f756cb79b479c5351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates four specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a897d161d82900b9f756cb79b479c5351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45af237c4737e733b0ca2ced78e4fa95"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t , class object_c_t , class object_d_t &gt; </td></tr>
<tr class="memitem:a45af237c4737e733b0ca2ced78e4fa95"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a45af237c4737e733b0ca2ced78e4fa95">concat</a> (object_a_t obj_a, object_b_t obj_b, object_c_t obj_c, object_d_t obj_d) noexcept</td></tr>
<tr class="memdesc:a45af237c4737e733b0ca2ced78e4fa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates four specified instances of object.  <br /></td></tr>
<tr class="separator:a45af237c4737e733b0ca2ced78e4fa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e3085a92a360bc1f6085145673dc64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a72e3085a92a360bc1f6085145673dc64">concat</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_c) noexcept</td></tr>
<tr class="memdesc:a72e3085a92a360bc1f6085145673dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates three specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a72e3085a92a360bc1f6085145673dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e213408c3f1ed719e9df3f798ef2c2d"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t , class object_c_t &gt; </td></tr>
<tr class="memitem:a7e213408c3f1ed719e9df3f798ef2c2d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7e213408c3f1ed719e9df3f798ef2c2d">concat</a> (object_a_t obj_a, object_b_t obj_b, object_c_t obj_c) noexcept</td></tr>
<tr class="memdesc:a7e213408c3f1ed719e9df3f798ef2c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates three specified instances of object.  <br /></td></tr>
<tr class="separator:a7e213408c3f1ed719e9df3f798ef2c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9717df63b6c2f2372c428c637869da8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9717df63b6c2f2372c428c637869da8a">concat</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_a, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str_b) noexcept</td></tr>
<tr class="memdesc:a9717df63b6c2f2372c428c637869da8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a9717df63b6c2f2372c428c637869da8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03788833b277a559456d8adfc727218c"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t &gt; </td></tr>
<tr class="memitem:a03788833b277a559456d8adfc727218c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a03788833b277a559456d8adfc727218c">concat</a> (object_a_t obj_a, object_b_t obj_b) noexcept</td></tr>
<tr class="memdesc:a03788833b277a559456d8adfc727218c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two specified instances of object.  <br /></td></tr>
<tr class="separator:a03788833b277a559456d8adfc727218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81226baa5f8d9ba7538c7d8b4a3449b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac81226baa5f8d9ba7538c7d8b4a3449b">concat</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; &amp;values) noexcept</td></tr>
<tr class="memdesc:ac81226baa5f8d9ba7538c7d8b4a3449b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the elements of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> array.  <br /></td></tr>
<tr class="separator:ac81226baa5f8d9ba7538c7d8b4a3449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2df32b25b6236f532243869d9bc5541"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:ab2df32b25b6236f532243869d9bc5541"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab2df32b25b6236f532243869d9bc5541">concat</a> (const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; object_t &gt; &amp;args) noexcept</td></tr>
<tr class="memdesc:ab2df32b25b6236f532243869d9bc5541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representations of the elements in a specified object array.  <br /></td></tr>
<tr class="separator:ab2df32b25b6236f532243869d9bc5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4994f61a96b71e100492512d0a8e9b5"><td class="memTemplParams" colspan="2">template&lt;class value_t &gt; </td></tr>
<tr class="memitem:ac4994f61a96b71e100492512d0a8e9b5"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac4994f61a96b71e100492512d0a8e9b5">concat</a> (value_t value) noexcept</td></tr>
<tr class="memdesc:ac4994f61a96b71e100492512d0a8e9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representation of a specified object.  <br /></td></tr>
<tr class="separator:ac4994f61a96b71e100492512d0a8e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2778ed4d8fd85400ff448179da68a592"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a2778ed4d8fd85400ff448179da68a592">demangle</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;name)</td></tr>
<tr class="memdesc:a2778ed4d8fd85400ff448179da68a592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets demangled <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> of name,.  <br /></td></tr>
<tr class="separator:a2778ed4d8fd85400ff448179da68a592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9573cce5da4b27808874ef0c1aae00"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a6c9573cce5da4b27808874ef0c1aae00">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a>, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a92eb5ffee6ae2fec3ad71c777531578f">b</a>) noexcept</td></tr>
<tr class="memdesc:a6c9573cce5da4b27808874ef0c1aae00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value.  <br /></td></tr>
<tr class="separator:a6c9573cce5da4b27808874ef0c1aae00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7ee87a503480f443dcefa417db2fe6"><td class="memTemplParams" colspan="2">template&lt;class char_a_t , class char_b_t &gt; </td></tr>
<tr class="memitem:a9d7ee87a503480f443dcefa417db2fe6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a9d7ee87a503480f443dcefa417db2fe6">equals</a> (const char_a_t *<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a>, const char_b_t *<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a92eb5ffee6ae2fec3ad71c777531578f">b</a>) noexcept</td></tr>
<tr class="memdesc:a9d7ee87a503480f443dcefa417db2fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value.  <br /></td></tr>
<tr class="separator:a9d7ee87a503480f443dcefa417db2fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e41bbb8db6a246cf7965a565446ac8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a47e41bbb8db6a246cf7965a565446ac8">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a>, const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a92eb5ffee6ae2fec3ad71c777531578f">b</a>, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:a47e41bbb8db6a246cf7965a565446ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a47e41bbb8db6a246cf7965a565446ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d99f1ae4294e002f20661d66567150f"><td class="memTemplParams" colspan="2">template&lt;class char_a_t , class char_b_t &gt; </td></tr>
<tr class="memitem:a7d99f1ae4294e002f20661d66567150f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a7d99f1ae4294e002f20661d66567150f">equals</a> (const char_a_t *<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a>, const char_b_t *<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a92eb5ffee6ae2fec3ad71c777531578f">b</a>, bool ignore_case) noexcept</td></tr>
<tr class="memdesc:a7d99f1ae4294e002f20661d66567150f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value, ignoring or honoring their case.  <br /></td></tr>
<tr class="separator:a7d99f1ae4294e002f20661d66567150f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591487f7c52877614fd80f43a332d455"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:ga591487f7c52877614fd80f43a332d455"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__format__parse.html#ga591487f7c52877614fd80f43a332d455">format</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;fmt, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga591487f7c52877614fd80f43a332d455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the text representation of the specified arguments list, to string using the specified format information.  <br /></td></tr>
<tr class="separator:ga591487f7c52877614fd80f43a332d455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac003a2b39a8e6160043f9d3a8681a178"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:ac003a2b39a8e6160043f9d3a8681a178"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ac003a2b39a8e6160043f9d3a8681a178">full_class_name</a> ()</td></tr>
<tr class="memdesc:ac003a2b39a8e6160043f9d3a8681a178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the objec_t, including the namespace of the objec_t.  <br /></td></tr>
<tr class="separator:ac003a2b39a8e6160043f9d3a8681a178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2dad45219c94eda3bd54742cc0a82a"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:acc2dad45219c94eda3bd54742cc0a82a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#acc2dad45219c94eda3bd54742cc0a82a">full_class_name</a> (const object_t &amp;<a class="el" href="classxtd_1_1object.html">object</a>)</td></tr>
<tr class="memdesc:acc2dad45219c94eda3bd54742cc0a82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:acc2dad45219c94eda3bd54742cc0a82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f42e3b00b7c27ffa63cc8e48dde6aa4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a3f42e3b00b7c27ffa63cc8e48dde6aa4">full_class_name</a> (const std::type_info &amp;info)</td></tr>
<tr class="memdesc:a3f42e3b00b7c27ffa63cc8e48dde6aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fully qualified class name of the specified object, including the namespace of the specified object.  <br /></td></tr>
<tr class="separator:a3f42e3b00b7c27ffa63cc8e48dde6aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bdd160233334a9b7d36af486906d4b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#ab4bdd160233334a9b7d36af486906d4b">is_empty</a> (const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>, <a class="el" href="classxtd_1_1basic__string.html#a4d949b3e7337c9e935ad6f8de390076f">traits_type</a>, <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &gt; &amp;<a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">string</a>) noexcept</td></tr>
<tr class="memdesc:ab4bdd160233334a9b7d36af486906d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specifeid <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> ("").  <br /></td></tr>
<tr class="separator:ab4bdd160233334a9b7d36af486906d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7a51d0792107dd537730634b8fff12"><td class="memTemplParams" colspan="2">template&lt;class collection_t &gt; </td></tr>
<tr class="memitem:a8a7a51d0792107dd537730634b8fff12"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a8a7a51d0792107dd537730634b8fff12">join</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values) noexcept</td></tr>
<tr class="memdesc:a8a7a51d0792107dd537730634b8fff12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a8a7a51d0792107dd537730634b8fff12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aece978830816e4b33a685b27cc31e3"><td class="memTemplParams" colspan="2">template&lt;class collection_t &gt; </td></tr>
<tr class="memitem:a5aece978830816e4b33a685b27cc31e3"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5aece978830816e4b33a685b27cc31e3">join</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index)</td></tr>
<tr class="memdesc:a5aece978830816e4b33a685b27cc31e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a5aece978830816e4b33a685b27cc31e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5012723424590a079c236dfdc8f8968e"><td class="memTemplParams" colspan="2">template&lt;class collection_t &gt; </td></tr>
<tr class="memitem:a5012723424590a079c236dfdc8f8968e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a5012723424590a079c236dfdc8f8968e">join</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2aa0f0bc95016c862498bbad29d1f4d9d4">separator</a>, const collection_t &amp;values, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> index, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a>)</td></tr>
<tr class="memdesc:a5012723424590a079c236dfdc8f8968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified Object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.  <br /></td></tr>
<tr class="separator:a5012723424590a079c236dfdc8f8968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0616ee2fd16ff911dafe84b19522ec75"><td class="memTemplParams" colspan="2">template&lt;class value_t &gt; </td></tr>
<tr class="memitem:a0616ee2fd16ff911dafe84b19522ec75"><td class="memTemplItemLeft" align="right" valign="top">static value_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a0616ee2fd16ff911dafe84b19522ec75">parse</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str)</td></tr>
<tr class="memdesc:a0616ee2fd16ff911dafe84b19522ec75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a value_t type.  <br /></td></tr>
<tr class="separator:a0616ee2fd16ff911dafe84b19522ec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d4b243f60f84e512a0fb001f40f066"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:ga06d4b243f60f84e512a0fb001f40f066"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__format__parse.html#ga06d4b243f60f84e512a0fb001f40f066">sprintf</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;fmt, args_t &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:ga06d4b243f60f84e512a0fb001f40f066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the text representation of the specified arguments list, to <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> using the specified format information.  <br /></td></tr>
<tr class="separator:ga06d4b243f60f84e512a0fb001f40f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389cf357f98d28ecb33f535462289251"><td class="memTemplParams" colspan="2">template&lt;class value_t &gt; </td></tr>
<tr class="memitem:a389cf357f98d28ecb33f535462289251"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1basic__string.html#a389cf357f98d28ecb33f535462289251">try_parse</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp;str, value_t &amp;value) noexcept</td></tr>
<tr class="memdesc:a389cf357f98d28ecb33f535462289251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to convert a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a value_t type.  <br /></td></tr>
<tr class="separator:a389cf357f98d28ecb33f535462289251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable&lt; char_t &gt;</a></td></tr>
<tr class="memitem:a1b6f4bbb7a3c18056332b28dae525927 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> = char_t</td></tr>
<tr class="memdesc:a1b6f4bbb7a3c18056332b28dae525927 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a1b6f4bbb7a3c18056332b28dae525927 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287e9c3dff72a406f2cf715de19afb11 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a287e9c3dff72a406f2cf715de19afb11">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators</a>&lt; char_t, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; char_t &gt; &gt;::iterator</td></tr>
<tr class="memdesc:a287e9c3dff72a406f2cf715de19afb11 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a287e9c3dff72a406f2cf715de19afb11 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a5659ab1d2d261e2a5d390685f6765 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#ac4a5659ab1d2d261e2a5d390685f6765">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators</a>&lt; char_t, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; char_t &gt; &gt;::const_iterator</td></tr>
<tr class="memdesc:ac4a5659ab1d2d261e2a5d390685f6765 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:ac4a5659ab1d2d261e2a5d390685f6765 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t, iterator_tag_t &gt;</a></td></tr>
<tr class="memitem:a887f291bffea0f450760702ed2682590 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a887f291bffea0f450760702ed2682590">iterator</a> = enumerable_iterator</td></tr>
<tr class="memdesc:a887f291bffea0f450760702ed2682590 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of enumarable value type.  <br /></td></tr>
<tr class="separator:a887f291bffea0f450760702ed2682590 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75470cb0387e1459f1a87c300f097560 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a75470cb0387e1459f1a87c300f097560">const_iterator</a> = const enumerable_iterator</td></tr>
<tr class="memdesc:a75470cb0387e1459f1a87c300f097560 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of enumarable value type.  <br /></td></tr>
<tr class="separator:a75470cb0387e1459f1a87c300f097560 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt;</a></td></tr>
<tr class="memitem:afa0428a5d439bb7fd6a75f0ca54751c5 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afa0428a5d439bb7fd6a75f0ca54751c5">enumerable_type</a> = enumerable_t</td></tr>
<tr class="memdesc:afa0428a5d439bb7fd6a75f0ca54751c5 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable enumerable type.  <br /></td></tr>
<tr class="separator:afa0428a5d439bb7fd6a75f0ca54751c5 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723aac49b8d3459b2caaff26c2ab90e0 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a723aac49b8d3459b2caaff26c2ab90e0">source_type</a> = source_t</td></tr>
<tr class="memdesc:a723aac49b8d3459b2caaff26c2ab90e0 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable source type.  <br /></td></tr>
<tr class="separator:a723aac49b8d3459b2caaff26c2ab90e0 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;class type_t &gt; </td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a> = typename <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">xtd::linq::enumerable::ienumerable</a>&lt; type_t &gt;</td></tr>
<tr class="memdesc:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;class type_t &gt; </td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a> = typename <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">xtd::linq::enumerable::list</a>&lt; type_t &gt;</td></tr>
<tr class="memdesc:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga4ac188feb2d52b21e188417441519bb2">xtd::uptr</a>&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#abb9700deaba669584080178e391d97c4">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1icomparable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1icomparable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1icomparable.html">xtd::icomparable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;</a></td></tr>
<tr class="memitem:a8e5ad6ed9d798584e8b9be5749d6faa5 inherit pub_methods_classxtd_1_1icomparable"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1icomparable.html#a8e5ad6ed9d798584e8b9be5749d6faa5">compare_to</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;obj) const noexcept=0</td></tr>
<tr class="memdesc:a8e5ad6ed9d798584e8b9be5749d6faa5 inherit pub_methods_classxtd_1_1icomparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current instance with another object of the same type.  <br /></td></tr>
<tr class="separator:a8e5ad6ed9d798584e8b9be5749d6faa5 inherit pub_methods_classxtd_1_1icomparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1iequatable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1iequatable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1iequatable.html">xtd::iequatable&lt; basic_string&lt; char_t, traits_t, allocator_t &gt; &gt;</a></td></tr>
<tr class="memitem:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1iequatable.html#a1f8bbde943d2e5ecf565734c60e23903">equals</a> (const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;) const noexcept=0</td></tr>
<tr class="memdesc:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current object is equal to another object of the same type.  <br /></td></tr>
<tr class="separator:a1f8bbde943d2e5ecf565734c60e23903 inherit pub_methods_classxtd_1_1iequatable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1ienumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1ienumerable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable&lt; char_t &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t, iterator_tag_t &gt;</a></td></tr>
<tr class="memitem:ad1e3a53b1e5c0e7769075bd28132d959 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a887f291bffea0f450760702ed2682590">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959">begin</a> ()</td></tr>
<tr class="memdesc:ad1e3a53b1e5c0e7769075bd28132d959 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:ad1e3a53b1e5c0e7769075bd28132d959 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc1239887628ed8028bdd1339af135a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a887f291bffea0f450760702ed2682590">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a">end</a> ()</td></tr>
<tr class="memdesc:a1cc1239887628ed8028bdd1339af135a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a1cc1239887628ed8028bdd1339af135a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt;</a></td></tr>
<tr class="memitem:a22f3540f62b3b6140ecf188faf509842 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a> (const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>) const</td></tr>
<tr class="memdesc:a22f3540f62b3b6140ecf188faf509842 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a22f3540f62b3b6140ecf188faf509842 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bbfa7cff2e26dcf33e973a97d42316 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#af8bbfa7cff2e26dcf33e973a97d42316">aggregate</a> (const source_t &amp;seed, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>) const</td></tr>
<tr class="memdesc:af8bbfa7cff2e26dcf33e973a97d42316 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:af8bbfa7cff2e26dcf33e973a97d42316 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;class accumulate_t &gt; </td></tr>
<tr class="memitem:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2705732af439af4da98a7a28f0a02f5a">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>) const</td></tr>
<tr class="memdesc:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487db86dcfc03a261804db9288b917df inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a487db86dcfc03a261804db9288b917df">aggregate</a> (const source_t &amp;seed, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a487db86dcfc03a261804db9288b917df inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a487db86dcfc03a261804db9288b917df inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;class result_t , class accumulate_t &gt; </td></tr>
<tr class="memitem:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0b91578ce3ebc8da03751dfca700bf7d">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c344a4319826da54bae2611d78f7e41 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a8c344a4319826da54bae2611d78f7e41 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a8c344a4319826da54bae2611d78f7e41 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e647f592add925edc5682334fa2b29 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">any</a> () const noexcept</td></tr>
<tr class="memdesc:a25e647f592add925edc5682334fa2b29 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a25e647f592add925edc5682334fa2b29 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddaea79f05f3a1d7c83bdc64883ec44 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a7ddaea79f05f3a1d7c83bdc64883ec44">any</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a7ddaea79f05f3a1d7c83bdc64883ec44 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a7ddaea79f05f3a1d7c83bdc64883ec44 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227fd05d7acfc24fe8805534fd706309 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a227fd05d7acfc24fe8805534fd706309">append</a> (const source_t &amp;element) const noexcept</td></tr>
<tr class="memdesc:a227fd05d7acfc24fe8805534fd706309 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a227fd05d7acfc24fe8805534fd706309 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184c35f6e8a0058a196b533394dbccd7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a184c35f6e8a0058a196b533394dbccd7">as_enumerable</a> () const noexcept</td></tr>
<tr class="memdesc:a184c35f6e8a0058a196b533394dbccd7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a184c35f6e8a0058a196b533394dbccd7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5669f1a9bf9da6303aa9ff29197b4799 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5669f1a9bf9da6303aa9ff29197b4799">average</a> () const noexcept</td></tr>
<tr class="memdesc:a5669f1a9bf9da6303aa9ff29197b4799 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of source_t values.  <br /></td></tr>
<tr class="separator:a5669f1a9bf9da6303aa9ff29197b4799 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;class result_t &gt; </td></tr>
<tr class="memitem:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ac8353f4d5daa13e1810b8aad661eb938">cast</a> () const noexcept</td></tr>
<tr class="memdesc:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> to the specified type.  <br /></td></tr>
<tr class="separator:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e97c665374affe07c6240f55db92a63 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; source_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8e97c665374affe07c6240f55db92a63">chunk</a> (size_t <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">size</a>) const</td></tr>
<tr class="memdesc:a8e97c665374affe07c6240f55db92a63 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the elements of a sequence into chunks of size at most size.  <br /></td></tr>
<tr class="separator:a8e97c665374affe07c6240f55db92a63 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28746d3222dc23090a710dd8548e77e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ad28746d3222dc23090a710dd8548e77e">concat</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;second) const noexcept</td></tr>
<tr class="memdesc:ad28746d3222dc23090a710dd8548e77e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two sequences.  <br /></td></tr>
<tr class="separator:ad28746d3222dc23090a710dd8548e77e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e29837254bb373971404eb103ba26 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ad77e29837254bb373971404eb103ba26">contains</a> (const source_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:ad77e29837254bb373971404eb103ba26 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using the default equality comparer.  <br /></td></tr>
<tr class="separator:ad77e29837254bb373971404eb103ba26 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4be2e1cde9d4316519230b03e0496 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a87d4be2e1cde9d4316519230b03e0496">contains</a> (const source_t &amp;value, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept</td></tr>
<tr class="memdesc:a87d4be2e1cde9d4316519230b03e0496 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using a specified equality comparer.  <br /></td></tr>
<tr class="separator:a87d4be2e1cde9d4316519230b03e0496 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0560a5c54fcf0e9786018f00e136c7fb inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a> () const noexcept</td></tr>
<tr class="memdesc:a0560a5c54fcf0e9786018f00e136c7fb inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in current sequence.  <br /></td></tr>
<tr class="separator:a0560a5c54fcf0e9786018f00e136c7fb inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef0abd344f629aef3c96e49d272b50c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aeef0abd344f629aef3c96e49d272b50c">count</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:aeef0abd344f629aef3c96e49d272b50c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number that represents how many elements in the specified sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aeef0abd344f629aef3c96e49d272b50c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;class key_t &gt; </td></tr>
<tr class="memitem:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; key_t, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0dba2660f845875cd5908be53e52bbc7">count_by</a> (const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector) const noexcept</td></tr>
<tr class="memdesc:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;class key_t &gt; </td></tr>
<tr class="memitem:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; key_t, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#acd274fa4579c9e02119888c7135d6c8e">count_by</a> (const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;key_comparer) const noexcept</td></tr>
<tr class="memdesc:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb41413e817b71a549e3f99aaf743e1 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a3fb41413e817b71a549e3f99aaf743e1">default_if_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3fb41413e817b71a549e3f99aaf743e1 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a3fb41413e817b71a549e3f99aaf743e1 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5954e34075473c77cc41c979ed506fa3 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5954e34075473c77cc41c979ed506fa3">default_if_empty</a> (const source_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:a5954e34075473c77cc41c979ed506fa3 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the specified value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a5954e34075473c77cc41c979ed506fa3 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcddc251cf8f945686a5f77807e62dcd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afcddc251cf8f945686a5f77807e62dcd">first_or_default</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>, const source_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:afcddc251cf8f945686a5f77807e62dcd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:afcddc251cf8f945686a5f77807e62dcd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52658d4876a5f7642288ef7cfd0be8 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2e52658d4876a5f7642288ef7cfd0be8">first_or_default</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:a2e52658d4876a5f7642288ef7cfd0be8 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2e52658d4876a5f7642288ef7cfd0be8 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0a757b76c036ef644cec12662f887 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2ba0a757b76c036ef644cec12662f887">first_or_default</a> (const source_t default_value) const noexcept</td></tr>
<tr class="memdesc:a2ba0a757b76c036ef644cec12662f887 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2ba0a757b76c036ef644cec12662f887 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964948d137047014d18a7cc5db15f46f inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a964948d137047014d18a7cc5db15f46f">first_or_default</a> () const noexcept</td></tr>
<tr class="memdesc:a964948d137047014d18a7cc5db15f46f inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a964948d137047014d18a7cc5db15f46f inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;class result_t &gt; </td></tr>
<tr class="memitem:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a69ca739f420b3ddd4df01845ce9bd979">select</a> (const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58637f7cae0e9518f0b728d47f2dc8f9 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a58637f7cae0e9518f0b728d47f2dc8f9">select</a> (const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a58637f7cae0e9518f0b728d47f2dc8f9 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a58637f7cae0e9518f0b728d47f2dc8f9 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;class result_t &gt; </td></tr>
<tr class="memitem:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a74a6585ba5b3ff487437db47ade70486">select</a> (const std::function&lt; result_t(const source_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009c5250029162433b826be3a1a93efd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a009c5250029162433b826be3a1a93efd">select</a> (const std::function&lt; source_t(const source_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a009c5250029162433b826be3a1a93efd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a009c5250029162433b826be3a1a93efd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a910fbeb2bb448c779d761dd865063c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a6a910fbeb2bb448c779d761dd865063c">to_list</a> () const noexcept</td></tr>
<tr class="memdesc:a6a910fbeb2bb448c779d761dd865063c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a6a910fbeb2bb448c779d761dd865063c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669773bec96bcfe7a5b4f43068892620 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a669773bec96bcfe7a5b4f43068892620 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a669773bec96bcfe7a5b4f43068892620 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c236ea62904000f45e720b7a7dbf17 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a46c236ea62904000f45e720b7a7dbf17">where</a> (const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a46c236ea62904000f45e720b7a7dbf17 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a46c236ea62904000f45e720b7a7dbf17 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t &gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t &gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t, iterator_tag_t &gt;</a></td></tr>
<tr class="memitem:a448a5456acc01f4fba47c60de3e131fb inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memTemplParams" colspan="2">template&lt;class source_collection_t , class target_collection_t &gt; </td></tr>
<tr class="memitem:a448a5456acc01f4fba47c60de3e131fb inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memTemplItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a448a5456acc01f4fba47c60de3e131fb">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a448a5456acc01f4fba47c60de3e131fb inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a448a5456acc01f4fba47c60de3e131fb inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4290d992ac1a1c103d8da2b51e0a5b3 inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memTemplParams" colspan="2">template&lt;class source_collection_t , class target_collection_t &gt; </td></tr>
<tr class="memitem:ae4290d992ac1a1c103d8da2b51e0a5b3 inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memTemplItemLeft" align="right" valign="top">static target_collection_t::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ae4290d992ac1a1c103d8da2b51e0a5b3">to_iterator</a> (typename source_collection_t::iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:ae4290d992ac1a1c103d8da2b51e0a5b3 inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:ae4290d992ac1a1c103d8da2b51e0a5b3 inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa952a17cd36abced37d4ff35733790cc inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memTemplParams" colspan="2">template&lt;class source_collection_t , class target_collection_t &gt; </td></tr>
<tr class="memitem:aa952a17cd36abced37d4ff35733790cc inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memTemplItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#aa952a17cd36abced37d4ff35733790cc">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:aa952a17cd36abced37d4ff35733790cc inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:aa952a17cd36abced37d4ff35733790cc inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f03a39012c080e229c4c3c5d1ad6df inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memTemplParams" colspan="2">template&lt;class source_collection_t , class target_collection_t &gt; </td></tr>
<tr class="memitem:a42f03a39012c080e229c4c3c5d1ad6df inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memTemplItemLeft" align="right" valign="top">static target_collection_t::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a42f03a39012c080e229c4c3c5d1ad6df">to_iterator</a> (typename source_collection_t::iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a42f03a39012c080e229c4c3c5d1ad6df inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a42f03a39012c080e229c4c3c5d1ad6df inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a023c9110b9e82006d694c297f404e031" name="a023c9110b9e82006d694c297f404e031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023c9110b9e82006d694c297f404e031">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::base_type =  std::basic_string&lt;char_t, traits_t, allocator_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string base type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Is equal to <code>std::basic_string&lt;char_t, traits_t, allocator_t&gt;</code>.` </dd></dl>

</div>
</div>
<a id="a4d949b3e7337c9e935ad6f8de390076f" name="a4d949b3e7337c9e935ad6f8de390076f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d949b3e7337c9e935ad6f8de390076f">&#9670;&#160;</a></span>traits_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::traits_type =  typename base_type::traits_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string traits type. </p>

</div>
</div>
<a id="aba30f417a9a6e82bb49c465428af7aa5" name="aba30f417a9a6e82bb49c465428af7aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba30f417a9a6e82bb49c465428af7aa5">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::value_type =  typename base_type::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string value type. </p>

</div>
</div>
<a id="a19ed007365ca191ac40587fe9365f02a" name="a19ed007365ca191ac40587fe9365f02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ed007365ca191ac40587fe9365f02a">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::allocator_type =  typename base_type::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string allocator type. </p>

</div>
</div>
<a id="a84c19ff70f8314b59d8e711cadd91302" name="a84c19ff70f8314b59d8e711cadd91302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c19ff70f8314b59d8e711cadd91302">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::size_type =  typename base_type::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string size type. </p>

</div>
</div>
<a id="ae7a0f41842e41c6b6a7e7c3b60eb9473" name="ae7a0f41842e41c6b6a7e7c3b60eb9473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a0f41842e41c6b6a7e7c3b60eb9473">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::difference_type =  typename base_type::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string difference type. </p>

</div>
</div>
<a id="ae2e7e06d00f19b7ec880b4d21e55b5e1" name="ae2e7e06d00f19b7ec880b4d21e55b5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e7e06d00f19b7ec880b4d21e55b5e1">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::reference =  typename base_type::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string referecne type. </p>

</div>
</div>
<a id="a5a19c12dd03024a0b27ae68115bbfa2b" name="a5a19c12dd03024a0b27ae68115bbfa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a19c12dd03024a0b27ae68115bbfa2b">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::const_reference =  typename base_type::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string const referecne type. </p>

</div>
</div>
<a id="a5096b493cf6cf40e71b176fcbb2e0624" name="a5096b493cf6cf40e71b176fcbb2e0624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5096b493cf6cf40e71b176fcbb2e0624">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pointer =  typename base_type::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string pointer type. </p>

</div>
</div>
<a id="a4019460efb8119704afcefd0a1703847" name="a4019460efb8119704afcefd0a1703847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4019460efb8119704afcefd0a1703847">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::const_pointer =  typename base_type::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string const pointer type. </p>

</div>
</div>
<a id="a714fda995fe953db6f1b0f3e5d44943f" name="a714fda995fe953db6f1b0f3e5d44943f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714fda995fe953db6f1b0f3e5d44943f">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::iterator =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt;char_t&gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string iterator type. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>replace xtd::ienumerable::iterator </dd></dl>

</div>
</div>
<a id="ae6b7bbe92cc0909082b7a1257f9454a6" name="ae6b7bbe92cc0909082b7a1257f9454a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b7bbe92cc0909082b7a1257f9454a6">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::const_iterator =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt;char_t&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string const iterator type. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>replace xtd::ienumerable::const_iterator </dd></dl>

</div>
</div>
<a id="aba8c65e30415746ff874486715febd50" name="aba8c65e30415746ff874486715febd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8c65e30415746ff874486715febd50">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::reverse_iterator =  typename base_type::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string reverse iterator type. </p>

</div>
</div>
<a id="a72aff392391a7665d5244311dd7eee46" name="a72aff392391a7665d5244311dd7eee46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aff392391a7665d5244311dd7eee46">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::const_reverse_iterator =  typename base_type::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string const reverse iterator type. </p>

</div>
</div>
<a id="a2b5493bd9034616dded9fb810d65fd6c" name="a2b5493bd9034616dded9fb810d65fd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5493bd9034616dded9fb810d65fd6c">&#9670;&#160;</a></span>enumerator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::enumerator_type =  typename <a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">xtd::collections::generic::enumerator</a>&lt;<a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the basic string enumerator type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acb6d598b5155fe5ee9339537f3dae900" name="acb6d598b5155fe5ee9339537f3dae900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6d598b5155fe5ee9339537f3dae900">&#9670;&#160;</a></span>basic_string() <span class="overload">[1/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>

</div>
</div>
<a id="a3790b669d37b2f581b200a850a78c86a" name="a3790b669d37b2f581b200a850a78c86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3790b669d37b2f581b200a850a78c86a">&#9670;&#160;</a></span>basic_string() <span class="overload">[2/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa01363cdbad8c2f1a3f0432f39e1104f" name="aa01363cdbad8c2f1a3f0432f39e1104f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01363cdbad8c2f1a3f0432f39e1104f">&#9670;&#160;</a></span>basic_string() <span class="overload">[3/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a7fe5fcca0ac2a358b40fa93da6e2f6" name="a4a7fe5fcca0ac2a358b40fa93da6e2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7fe5fcca0ac2a358b40fa93da6e2f6">&#9670;&#160;</a></span>basic_string() <span class="overload">[4/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a003c0c4a69d9080f0aa43812075f5105" name="a003c0c4a69d9080f0aa43812075f5105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003c0c4a69d9080f0aa43812075f5105">&#9670;&#160;</a></span>basic_string() <span class="overload">[5/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fa67fdd2798346152a0369deb327928" name="a2fa67fdd2798346152a0369deb327928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa67fdd2798346152a0369deb327928">&#9670;&#160;</a></span>basic_string() <span class="overload">[6/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ba2d784fd4cbc26b1d56b286ce22f40" name="a6ba2d784fd4cbc26b1d56b286ce22f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba2d784fd4cbc26b1d56b286ce22f40">&#9670;&#160;</a></span>basic_string() <span class="overload">[7/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af473faad321ab52c4d72ecdff8ce1fcf" name="af473faad321ab52c4d72ecdff8ce1fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af473faad321ab52c4d72ecdff8ce1fcf">&#9670;&#160;</a></span>basic_string() <span class="overload">[8/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a810b107f2ba78d3df123d1c9672fb257" name="a810b107f2ba78d3df123d1c9672fb257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810b107f2ba78d3df123d1c9672fb257">&#9670;&#160;</a></span>basic_string() <span class="overload">[9/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbadec7f087b088f299f3b002df41fcd" name="acbadec7f087b088f299f3b002df41fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbadec7f087b088f299f3b002df41fcd">&#9670;&#160;</a></span>basic_string() <span class="overload">[10/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f65f90aaa0e7433dfd8c52086bca832" name="a5f65f90aaa0e7433dfd8c52086bca832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f65f90aaa0e7433dfd8c52086bca832">&#9670;&#160;</a></span>basic_string() <span class="overload">[11/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bf6bf013b908aa0d1f0dabb1762d2e6" name="a3bf6bf013b908aa0d1f0dabb1762d2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf6bf013b908aa0d1f0dabb1762d2e6">&#9670;&#160;</a></span>basic_string() <span class="overload">[12/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0897dbd3d0da563d013e88f06f0041f2" name="a0897dbd3d0da563d013e88f06f0041f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0897dbd3d0da563d013e88f06f0041f2">&#9670;&#160;</a></span>basic_string() <span class="overload">[13/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a790510d7f735bc3e1a7e4ec3a5790b1d" name="a790510d7f735bc3e1a7e4ec3a5790b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790510d7f735bc3e1a7e4ec3a5790b1d">&#9670;&#160;</a></span>basic_string() <span class="overload">[14/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a728974ef4e82f756aa1e1f778eacb075" name="a728974ef4e82f756aa1e1f778eacb075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728974ef4e82f756aa1e1f778eacb075">&#9670;&#160;</a></span>basic_string() <span class="overload">[15/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d03d155e3fd35a75d340101cd943e7b" name="a0d03d155e3fd35a75d340101cd943e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d03d155e3fd35a75d340101cd943e7b">&#9670;&#160;</a></span>basic_string() <span class="overload">[16/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fdc765c7e94ea3f5a9986855bda0095" name="a5fdc765c7e94ea3f5a9986855bda0095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdc765c7e94ea3f5a9986855bda0095">&#9670;&#160;</a></span>basic_string() <span class="overload">[17/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f86367bc0b1badfafc7b5f8732d5fa9" name="a7f86367bc0b1badfafc7b5f8732d5fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f86367bc0b1badfafc7b5f8732d5fa9">&#9670;&#160;</a></span>basic_string() <span class="overload">[18/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a759adc3fc954c46e9273d04d0832351b" name="a759adc3fc954c46e9273d04d0832351b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759adc3fc954c46e9273d04d0832351b">&#9670;&#160;</a></span>basic_string() <span class="overload">[19/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a952b9c5fcf698dcb5d733612f9b1ce50" name="a952b9c5fcf698dcb5d733612f9b1ce50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952b9c5fcf698dcb5d733612f9b1ce50">&#9670;&#160;</a></span>basic_string() <span class="overload">[20/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93081b9f7ec282a0fce6320f6b1c652c" name="a93081b9f7ec282a0fce6320f6b1c652c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93081b9f7ec282a0fce6320f6b1c652c">&#9670;&#160;</a></span>basic_string() <span class="overload">[21/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a892dc8c77844e2065daa665afe86a475" name="a892dc8c77844e2065daa665afe86a475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892dc8c77844e2065daa665afe86a475">&#9670;&#160;</a></span>basic_string() <span class="overload">[22/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa83be15f58fcfac4ed4f56ee7af07573" name="aa83be15f58fcfac4ed4f56ee7af07573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83be15f58fcfac4ed4f56ee7af07573">&#9670;&#160;</a></span>basic_string() <span class="overload">[23/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73029c72b27fc7c73558a061707aa5ff" name="a73029c72b27fc7c73558a061707aa5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73029c72b27fc7c73558a061707aa5ff">&#9670;&#160;</a></span>basic_string() <span class="overload">[24/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a020400a139bf4be05b019e6adf1fc835" name="a020400a139bf4be05b019e6adf1fc835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020400a139bf4be05b019e6adf1fc835">&#9670;&#160;</a></span>basic_string() <span class="overload">[25/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35c831b74446024bf9237b161d9769ae" name="a35c831b74446024bf9237b161d9769ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c831b74446024bf9237b161d9769ae">&#9670;&#160;</a></span>basic_string() <span class="overload">[26/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61c1c08af3ea741373782607c4c6a8fd" name="a61c1c08af3ea741373782607c4c6a8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c1c08af3ea741373782607c4c6a8fd">&#9670;&#160;</a></span>basic_string() <span class="overload">[27/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee557f9747996e1aa3eb47aa3c05c8d0" name="aee557f9747996e1aa3eb47aa3c05c8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee557f9747996e1aa3eb47aa3c05c8d0">&#9670;&#160;</a></span>basic_string() <span class="overload">[28/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefcaaeb29123c7c41e4b91a69407d36b" name="aefcaaeb29123c7c41e4b91a69407d36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcaaeb29123c7c41e4b91a69407d36b">&#9670;&#160;</a></span>basic_string() <span class="overload">[29/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6680b4c84f8ebb9518b1326085d2c004" name="a6680b4c84f8ebb9518b1326085d2c004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6680b4c84f8ebb9518b1326085d2c004">&#9670;&#160;</a></span>basic_string() <span class="overload">[30/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad953695b56bad73f18cc2b9e717f7d1e" name="ad953695b56bad73f18cc2b9e717f7d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad953695b56bad73f18cc2b9e717f7d1e">&#9670;&#160;</a></span>basic_string() <span class="overload">[31/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7bcb0b437ace9e8c27d410e83038c36" name="ad7bcb0b437ace9e8c27d410e83038c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bcb0b437ace9e8c27d410e83038c36">&#9670;&#160;</a></span>basic_string() <span class="overload">[32/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring at index, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`index` + `count`is greater or equal than `str` size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9606d876f446e54fc196a6eea79f2480" name="a9606d876f446e54fc196a6eea79f2480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9606d876f446e54fc196a6eea79f2480">&#9670;&#160;</a></span>basic_string() <span class="overload">[33/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b09353f28fcb694c933fa147ca968a0" name="a4b09353f28fcb694c933fa147ca968a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b09353f28fcb694c933fa147ca968a0">&#9670;&#160;</a></span>basic_string() <span class="overload">[34/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to move and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to move. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad059373b3260d182270ffd503383b379" name="ad059373b3260d182270ffd503383b379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad059373b3260d182270ffd503383b379">&#9670;&#160;</a></span>basic_string() <span class="overload">[35/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab80eb93e04bca76813d159f5090ea2d5" name="ab80eb93e04bca76813d159f5090ea2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80eb93e04bca76813d159f5090ea2d5">&#9670;&#160;</a></span>basic_string() <span class="overload">[36/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2a14bd54a839fd8f45b7b2b525929b9" name="ac2a14bd54a839fd8f45b7b2b525929b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a14bd54a839fd8f45b7b2b525929b9">&#9670;&#160;</a></span>basic_string() <span class="overload">[37/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b8f94c1d63a648958fbd08083487fb4" name="a0b8f94c1d63a648958fbd08083487fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8f94c1d63a648958fbd08083487fb4">&#9670;&#160;</a></span>basic_string() <span class="overload">[38/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaed89c949a38db5641a364798a812617" name="aaed89c949a38db5641a364798a812617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed89c949a38db5641a364798a812617">&#9670;&#160;</a></span>basic_string() <span class="overload">[39/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af61bd959bf441f2b069d827972a56b56" name="af61bd959bf441f2b069d827972a56b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61bd959bf441f2b069d827972a56b56">&#9670;&#160;</a></span>basic_string() <span class="overload">[40/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16998e6296fe38ef1b8c0101aa47e856" name="a16998e6296fe38ef1b8c0101aa47e856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16998e6296fe38ef1b8c0101aa47e856">&#9670;&#160;</a></span>basic_string() <span class="overload">[41/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29f5ea589e05ab7c000d1d5ab9ab6e26" name="a29f5ea589e05ab7c000d1d5ab9ab6e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f5ea589e05ab7c000d1d5ab9ab6e26">&#9670;&#160;</a></span>basic_string() <span class="overload">[42/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ae8694982f8e910461d593c3418fcad" name="a6ae8694982f8e910461d593c3418fcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae8694982f8e910461d593c3418fcad">&#9670;&#160;</a></span>basic_string() <span class="overload">[43/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeefa98ba1b5416ab1045d4a6bd1f418" name="aaeefa98ba1b5416ab1045d4a6bd1f418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeefa98ba1b5416ab1045d4a6bd1f418">&#9670;&#160;</a></span>basic_string() <span class="overload">[44/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cb71f746f84199f306830719d4d7d3c" name="a1cb71f746f84199f306830719d4d7d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb71f746f84199f306830719d4d7d3c">&#9670;&#160;</a></span>basic_string() <span class="overload">[45/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a522bd864e0cea4a2f089242d7fbad281" name="a522bd864e0cea4a2f089242d7fbad281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522bd864e0cea4a2f089242d7fbad281">&#9670;&#160;</a></span>basic_string() <span class="overload">[46/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4cf479389eb5a85efbb1e76936ea9cc" name="aa4cf479389eb5a85efbb1e76936ea9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cf479389eb5a85efbb1e76936ea9cc">&#9670;&#160;</a></span>basic_string() <span class="overload">[47/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a113ef8f12563b8a2b5a06a00f7a15f76" name="a113ef8f12563b8a2b5a06a00f7a15f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113ef8f12563b8a2b5a06a00f7a15f76">&#9670;&#160;</a></span>basic_string() <span class="overload">[48/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad91b8ab1b4eb2e07141ec6808fae52ac" name="ad91b8ab1b4eb2e07141ec6808fae52ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91b8ab1b4eb2e07141ec6808fae52ac">&#9670;&#160;</a></span>basic_string() <span class="overload">[49/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a82b64d95d02daf4ee9de9192f2cad5" name="a7a82b64d95d02daf4ee9de9192f2cad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a82b64d95d02daf4ee9de9192f2cad5">&#9670;&#160;</a></span>basic_string() <span class="overload">[50/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bb7b586b719a9681dc6a8517d68bb65" name="a8bb7b586b719a9681dc6a8517d68bb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb7b586b719a9681dc6a8517d68bb65">&#9670;&#160;</a></span>basic_string() <span class="overload">[51/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46db7974b3b8daabb74b39e947a3009b" name="a46db7974b3b8daabb74b39e947a3009b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46db7974b3b8daabb74b39e947a3009b">&#9670;&#160;</a></span>basic_string() <span class="overload">[52/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a291b648455fc7550e53947556d297a83" name="a291b648455fc7550e53947556d297a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291b648455fc7550e53947556d297a83">&#9670;&#160;</a></span>basic_string() <span class="overload">[53/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32b586d1b47eb0e36112091bdfba11a3" name="a32b586d1b47eb0e36112091bdfba11a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b586d1b47eb0e36112091bdfba11a3">&#9670;&#160;</a></span>basic_string() <span class="overload">[54/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a>&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified count copies of character and specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character copied. </td></tr>
    <tr><td class="paramname">count</td><td>The number of copies of character. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7596c4c5b7c698e50b1a371e1859f5e3" name="a7596c4c5b7c698e50b1a371e1859f5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7596c4c5b7c698e50b1a371e1859f5e3">&#9670;&#160;</a></span>basic_string() <span class="overload">[55/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8b55a8a0116a25e314ee7e547e7c15e" name="ab8b55a8a0116a25e314ee7e547e7c15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b55a8a0116a25e314ee7e547e7c15e">&#9670;&#160;</a></span>basic_string() <span class="overload">[56/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18ae9ab22760b7055ec0737789a1ca5d" name="a18ae9ab22760b7055ec0737789a1ca5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ae9ab22760b7055ec0737789a1ca5d">&#9670;&#160;</a></span>basic_string() <span class="overload">[57/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3fd429e4a32f0983606f1eb046bd2ef" name="ad3fd429e4a32f0983606f1eb046bd2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fd429e4a32f0983606f1eb046bd2ef">&#9670;&#160;</a></span>basic_string() <span class="overload">[58/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bba2f3f145a3667ed7aaf3894cb35ca" name="a8bba2f3f145a3667ed7aaf3894cb35ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bba2f3f145a3667ed7aaf3894cb35ca">&#9670;&#160;</a></span>basic_string() <span class="overload">[59/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d62d00259aaf8980fe03630f2adbf71" name="a8d62d00259aaf8980fe03630f2adbf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d62d00259aaf8980fe03630f2adbf71">&#9670;&#160;</a></span>basic_string() <span class="overload">[60/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ed5602465ea4a591e81b5638cb58f54" name="a1ed5602465ea4a591e81b5638cb58f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed5602465ea4a591e81b5638cb58f54">&#9670;&#160;</a></span>basic_string() <span class="overload">[61/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e4e54bfc2b25ab10fed08cb71b31ffc" name="a0e4e54bfc2b25ab10fed08cb71b31ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4e54bfc2b25ab10fed08cb71b31ffc">&#9670;&#160;</a></span>basic_string() <span class="overload">[62/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1894ba32389638586c30bfbe3d089328" name="a1894ba32389638586c30bfbe3d089328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1894ba32389638586c30bfbe3d089328">&#9670;&#160;</a></span>basic_string() <span class="overload">[63/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae52aa99b1076a2ea9ccce90cf0e6283b" name="ae52aa99b1076a2ea9ccce90cf0e6283b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52aa99b1076a2ea9ccce90cf0e6283b">&#9670;&#160;</a></span>basic_string() <span class="overload">[64/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy, and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27340d04ceb0aa363d05385c6fc5981a" name="a27340d04ceb0aa363d05385c6fc5981a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27340d04ceb0aa363d05385c6fc5981a">&#9670;&#160;</a></span>basic_string() <span class="overload">[65/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd9e5c8a25e6d253793b0bb148fa455b" name="abd9e5c8a25e6d253793b0bb148fa455b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9e5c8a25e6d253793b0bb148fa455b">&#9670;&#160;</a></span>basic_string() <span class="overload">[66/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec00b682b89233058c3200436838b5df" name="aec00b682b89233058c3200436838b5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec00b682b89233058c3200436838b5df">&#9670;&#160;</a></span>basic_string() <span class="overload">[67/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0111166f70c46c24dfc392d5e9c13b4d" name="a0111166f70c46c24dfc392d5e9c13b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0111166f70c46c24dfc392d5e9c13b4d">&#9670;&#160;</a></span>basic_string() <span class="overload">[68/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e1aa0e10ee1ed4c77c3b61daad135dd" name="a5e1aa0e10ee1ed4c77c3b61daad135dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1aa0e10ee1ed4c77c3b61daad135dd">&#9670;&#160;</a></span>basic_string() <span class="overload">[69/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring and count characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3aaef2824a54111862338756907f438" name="ab3aaef2824a54111862338756907f438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aaef2824a54111862338756907f438">&#9670;&#160;</a></span>basic_string() <span class="overload">[70/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11ee7ec058d2fb8bd1243216e1fb7bb7" name="a11ee7ec058d2fb8bd1243216e1fb7bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ee7ec058d2fb8bd1243216e1fb7bb7">&#9670;&#160;</a></span>basic_string() <span class="overload">[71/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf177df70d6ed26a58b42c5e152edcb7" name="acf177df70d6ed26a58b42c5e152edcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf177df70d6ed26a58b42c5e152edcb7">&#9670;&#160;</a></span>basic_string() <span class="overload">[72/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b34159223e707f3c9692a103cb0494d" name="a7b34159223e707f3c9692a103cb0494d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b34159223e707f3c9692a103cb0494d">&#9670;&#160;</a></span>basic_string() <span class="overload">[73/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2b81f7fd2173cb19b899804b0e290c9" name="ae2b81f7fd2173cb19b899804b0e290c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b81f7fd2173cb19b899804b0e290c9">&#9670;&#160;</a></span>basic_string() <span class="overload">[74/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified substring, count characters and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d17cc2d9c968474e2db03fae9714852" name="a4d17cc2d9c968474e2db03fae9714852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d17cc2d9c968474e2db03fae9714852">&#9670;&#160;</a></span>basic_string() <span class="overload">[75/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dd482add7b2c98c24950771aad22791" name="a5dd482add7b2c98c24950771aad22791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd482add7b2c98c24950771aad22791">&#9670;&#160;</a></span>basic_string() <span class="overload">[76/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea08150d9fb6bbc5bbcb4b6618014df8" name="aea08150d9fb6bbc5bbcb4b6618014df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea08150d9fb6bbc5bbcb4b6618014df8">&#9670;&#160;</a></span>basic_string() <span class="overload">[77/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee1bc8150fc7feeb6eb1dffc81a03e38" name="aee1bc8150fc7feeb6eb1dffc81a03e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1bc8150fc7feeb6eb1dffc81a03e38">&#9670;&#160;</a></span>basic_string() <span class="overload">[78/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3afee2145a54a74b221125616c3acc2" name="ae3afee2145a54a74b221125616c3acc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3afee2145a54a74b221125616c3acc2">&#9670;&#160;</a></span>basic_string() <span class="overload">[79/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e5e30e7cdaf1de13037c954e35c40b9" name="a6e5e30e7cdaf1de13037c954e35c40b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5e30e7cdaf1de13037c954e35c40b9">&#9670;&#160;</a></span>basic_string() <span class="overload">[80/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50082b3f7bfd15a116dc80243d69504d" name="a50082b3f7bfd15a116dc80243d69504d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50082b3f7bfd15a116dc80243d69504d">&#9670;&#160;</a></span>basic_string() <span class="overload">[81/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab10922cf294d6b787660a2bb1101975e" name="ab10922cf294d6b787660a2bb1101975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10922cf294d6b787660a2bb1101975e">&#9670;&#160;</a></span>basic_string() <span class="overload">[82/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae69cc01d9a89d0f69c8ea9b1cf4732f8" name="ae69cc01d9a89d0f69c8ea9b1cf4732f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69cc01d9a89d0f69c8ea9b1cf4732f8">&#9670;&#160;</a></span>basic_string() <span class="overload">[83/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af197da49cd87da738cbd7a2dd82b7cbc" name="af197da49cd87da738cbd7a2dd82b7cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af197da49cd87da738cbd7a2dd82b7cbc">&#9670;&#160;</a></span>basic_string() <span class="overload">[84/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string to copy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38cffd0ccb520bac458db8c1e69e8dee" name="a38cffd0ccb520bac458db8c1e69e8dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cffd0ccb520bac458db8c1e69e8dee">&#9670;&#160;</a></span>basic_string() <span class="overload">[85/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified first and last iterators of substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">last</td><td>The first iterator of substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a294b738b593df2df992600e2720ade75" name="a294b738b593df2df992600e2720ade75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294b738b593df2df992600e2720ade75">&#9670;&#160;</a></span>basic_string() <span class="overload">[86/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified first and last iterators of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">last</td><td>The first iterator of substring. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e917194bb8dd889d36d8fafb29d27ed" name="a0e917194bb8dd889d36d8fafb29d27ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e917194bb8dd889d36d8fafb29d27ed">&#9670;&#160;</a></span>basic_string() <span class="overload">[87/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class string_view_like_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const string_view_like_t &amp;&#160;</td>
          <td class="paramname"><em>string_view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string view of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_view</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> view. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6e6338c49ba8d4c6d70c77ba91463d9" name="ae6e6338c49ba8d4c6d70c77ba91463d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e6338c49ba8d4c6d70c77ba91463d9">&#9670;&#160;</a></span>basic_string() <span class="overload">[88/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class string_view_like_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const string_view_like_t &amp;&#160;</td>
          <td class="paramname"><em>string_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string view of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_view</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> view. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab57fd8e7c03abe36192a2ba61c156e63" name="ab57fd8e7c03abe36192a2ba61c156e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57fd8e7c03abe36192a2ba61c156e63">&#9670;&#160;</a></span>basic_string() <span class="overload">[89/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class string_view_like_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const string_view_like_t &amp;&#160;</td>
          <td class="paramname"><em>string_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string view of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_view</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> view. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6659f7ba5aafc9db2559b664fa3bc80e" name="a6659f7ba5aafc9db2559b664fa3bc80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6659f7ba5aafc9db2559b664fa3bc80e">&#9670;&#160;</a></span>basic_string() <span class="overload">[90/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class string_view_like_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const string_view_like_t &amp;&#160;</td>
          <td class="paramname"><em>string_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified string view of substring and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_view</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> view. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first substring character where start copy. </td></tr>
    <tr><td class="paramname">count</td><td>The number of substring characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cdbf759c8d2bbd2256b16666b1d008d" name="a7cdbf759c8d2bbd2256b16666b1d008d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdbf759c8d2bbd2256b16666b1d008d">&#9670;&#160;</a></span>basic_string() <span class="overload">[91/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; char &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac034c2161dcdd4386e6a3b8d410a4586" name="ac034c2161dcdd4386e6a3b8d410a4586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac034c2161dcdd4386e6a3b8d410a4586">&#9670;&#160;</a></span>basic_string() <span class="overload">[92/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ad58660d076fec72617e2dfb55abdf8" name="a5ad58660d076fec72617e2dfb55abdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad58660d076fec72617e2dfb55abdf8">&#9670;&#160;</a></span>basic_string() <span class="overload">[93/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4c44e9814327dc4e98e28fa74206687" name="ac4c44e9814327dc4e98e28fa74206687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c44e9814327dc4e98e28fa74206687">&#9670;&#160;</a></span>basic_string() <span class="overload">[94/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a421e7ac13f9d908b2dc1b81827801d2a" name="a421e7ac13f9d908b2dc1b81827801d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421e7ac13f9d908b2dc1b81827801d2a">&#9670;&#160;</a></span>basic_string() <span class="overload">[95/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25a7bc67a43822538bf3b3925f2f89af" name="a25a7bc67a43822538bf3b3925f2f89af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a7bc67a43822538bf3b3925f2f89af">&#9670;&#160;</a></span>basic_string() <span class="overload">[96/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; char &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17891ddbf875eaf8128a98260ffdc412" name="a17891ddbf875eaf8128a98260ffdc412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17891ddbf875eaf8128a98260ffdc412">&#9670;&#160;</a></span>basic_string() <span class="overload">[97/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a665cb6cefb7df851c7fcda456bfc976d" name="a665cb6cefb7df851c7fcda456bfc976d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665cb6cefb7df851c7fcda456bfc976d">&#9670;&#160;</a></span>basic_string() <span class="overload">[98/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad46739aa91a301edc507c5846fc7d86a" name="ad46739aa91a301edc507c5846fc7d86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46739aa91a301edc507c5846fc7d86a">&#9670;&#160;</a></span>basic_string() <span class="overload">[99/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2f396ea48e81ac5c0337d83bb961454" name="ae2f396ea48e81ac5c0337d83bb961454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f396ea48e81ac5c0337d83bb961454">&#9670;&#160;</a></span>basic_string() <span class="overload">[100/100]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> with specified initializer list and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to fill. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for all memory allocations of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afcf4efd4162f8a5d9b3da7c3ba40f3f0" name="afcf4efd4162f8a5d9b3da7c3ba40f3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf4efd4162f8a5d9b3da7c3ba40f3f0">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a5a19c12dd03024a0b27ae68115bbfa2b">const_reference</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to the last character in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last character, equivalent to <code>operator[](<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - 1)</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60a3ad434a49e497c2827801e37adfdc" name="a60a3ad434a49e497c2827801e37adfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a3ad434a49e497c2827801e37adfdc">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#ae6b7bbe92cc0909082b7a1257f9454a6">const_iterator</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first character of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first character. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a7b9f8c15358cc78f7265ffe8f6480579">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t, iterator_tag_t &gt;</a>.</p>

</div>
</div>
<a id="addb32307b8ff07cadb6c0d74de22d08a" name="addb32307b8ff07cadb6c0d74de22d08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb32307b8ff07cadb6c0d74de22d08a">&#9670;&#160;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to a null-terminated character array with data equivalent to those stored in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying character storage. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer is such that the range [<code><a class="el" href="classxtd_1_1basic__string.html#addb32307b8ff07cadb6c0d74de22d08a" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a></code>, <code><a class="el" href="classxtd_1_1basic__string.html#addb32307b8ff07cadb6c0d74de22d08a" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a></code>] is valid and the values in it correspond to the values stored in the string with an additional null character after the last position. </dd>
<dd>
The pointer obtained from <a class="el" href="classxtd_1_1basic__string.html#addb32307b8ff07cadb6c0d74de22d08a" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a> may be invalidated by:<ul>
<li>Passing a non-const reference to the string to any standard library function, or</li>
<li>Calling non-const member functions on the string, excluding operator[], <a class="el" href="classxtd_1_1basic__string.html#aa7608d530a9e060c40377f3f6efa1965" title="Returns a reference to the character at specified location pos.">at()</a>, <a class="el" href="classxtd_1_1basic__string.html#ac82f74f75a637871f055a583780a120c" title="Returns reference to the first character in the string. The behavior is undefined if empty() is true.">front()</a>, <a class="el" href="classxtd_1_1basic__string.html#afcf4efd4162f8a5d9b3da7c3ba40f3f0" title="Returns reference to the last character in the string.">back()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1basic__string.html#a140b818168a60bb3672192795b5ec637" title="Returns a reverse iterator to the first character of the string.">rbegin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a" title="Returns an iterator to the element following the last element of the enumarable.">end()</a> and <a class="el" href="classxtd_1_1basic__string.html#a9fcd80009ae3c9178d9afbdd4f620730" title="Returns a reverse iterator to the character following the last character of the string....">rend()</a>. </li>
</ul>
</dd>
<dd>
Writing to the character array accessed through <a class="el" href="classxtd_1_1basic__string.html#addb32307b8ff07cadb6c0d74de22d08a" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a> is undefined behavior. </dd>
<dd>
<a class="el" href="classxtd_1_1basic__string.html#addb32307b8ff07cadb6c0d74de22d08a" title="Returns a pointer to a null-terminated character array with data equivalent to those stored in the st...">c_str()</a> and <a class="el" href="classxtd_1_1basic__string.html#a95d4c3712f32d15f308e2a5951298042" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> perform the same function. </dd></dl>

</div>
</div>
<a id="afb89d9cf553c5a88d4a93d82716cda2c" name="afb89d9cf553c5a88d4a93d82716cda2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb89d9cf553c5a88d4a93d82716cda2c">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of characters that the string has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the currently allocated storage, i.e. the storage available for storing elements. </dd></dl>

</div>
</div>
<a id="ad01c1d1476145c027b296d03b41229f3" name="ad01c1d1476145c027b296d03b41229f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01c1d1476145c027b296d03b41229f3">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#ae6b7bbe92cc0909082b7a1257f9454a6">const_iterator</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first character of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first character. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a9c64ad67e8894d51bd1ee7da6f397e14">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t, iterator_tag_t &gt;</a>.</p>

</div>
</div>
<a id="a8f92b35eb989cf42f65e0a0701b33a4d" name="a8f92b35eb989cf42f65e0a0701b33a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f92b35eb989cf42f65e0a0701b33a4d">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a72aff392391a7665d5244311dd7eee46">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first character of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first character. </dd></dl>

</div>
</div>
<a id="a4dd284a790e1c3e7b0b815b54519beb8" name="a4dd284a790e1c3e7b0b815b54519beb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd284a790e1c3e7b0b815b54519beb8">&#9670;&#160;</a></span>chars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1basic__string.html#a023c9110b9e82006d694c297f404e031">base_type</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::chars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a6a6992b7ccae6af08474ef89a34573a7" name="a6a6992b7ccae6af08474ef89a34573a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6992b7ccae6af08474ef89a34573a7">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#ae6b7bbe92cc0909082b7a1257f9454a6">const_iterator</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the character following the last character. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ab461dd402e7464666ba6657864ea5f40">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t, iterator_tag_t &gt;</a>.</p>

</div>
</div>
<a id="a8b78dd75f8256127726d962064d357fb" name="a8b78dd75f8256127726d962064d357fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b78dd75f8256127726d962064d357fb">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a72aff392391a7665d5244311dd7eee46">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Return iterator to the character following the last character. </dd></dl>

</div>
</div>
<a id="a95d4c3712f32d15f308e2a5951298042" name="a95d4c3712f32d15f308e2a5951298042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d4c3712f32d15f308e2a5951298042">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the underlying array serving as character storage. The pointer is such that the range [<code><a class="el" href="classxtd_1_1basic__string.html#a95d4c3712f32d15f308e2a5951298042" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a></code>, <code><a class="el" href="classxtd_1_1basic__string.html#a95d4c3712f32d15f308e2a5951298042" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a></code>] is valid and the values in it correspond to the values stored in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the underlying character storage. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The pointer obtained from <code><a class="el" href="classxtd_1_1basic__string.html#a95d4c3712f32d15f308e2a5951298042" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a></code> may be invalidated by:<ul>
<li>Passing a non-const reference to the string to any standard library function, or</li>
<li>Calling non-const member functions on the string, excluding <a class="el" href="classxtd_1_1basic__string.html#af6f4efe678e6742104ad6b0ddb3fc2db" title="Returns a reference to the character at specified location index.">operator[]()</a>, <a class="el" href="classxtd_1_1basic__string.html#aa7608d530a9e060c40377f3f6efa1965" title="Returns a reference to the character at specified location pos.">at()</a>, <a class="el" href="classxtd_1_1basic__string.html#ac82f74f75a637871f055a583780a120c" title="Returns reference to the first character in the string. The behavior is undefined if empty() is true.">front()</a>, <a class="el" href="classxtd_1_1basic__string.html#afcf4efd4162f8a5d9b3da7c3ba40f3f0" title="Returns reference to the last character in the string.">back()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a" title="Returns an iterator to the element following the last element of the enumarable.">end()</a>, <a class="el" href="classxtd_1_1basic__string.html#a140b818168a60bb3672192795b5ec637" title="Returns a reverse iterator to the first character of the string.">rbegin()</a>, <a class="el" href="classxtd_1_1basic__string.html#a9fcd80009ae3c9178d9afbdd4f620730" title="Returns a reverse iterator to the character following the last character of the string....">rend()</a>.<ol type="1">
<li>Modifying the character array accessed through the const overload of data has undefined behavior.</li>
<li>Modifying the past-the-end null terminator stored at <a class="el" href="classxtd_1_1basic__string.html#a95d4c3712f32d15f308e2a5951298042" title="Returns a pointer to the underlying array serving as character storage. The pointer is such that the ...">data()</a> + <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> to any value other than char_t() has undefined behavior. </li>
</ol>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="adf2d306e379dd0b505b8c40e37c9439e" name="adf2d306e379dd0b505b8c40e37c9439e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2d306e379dd0b505b8c40e37c9439e">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the string has no characters, i.e. whether <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959" title="Returns an iterator to the first element of the enumarable.">begin()</a> == <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a" title="Returns an iterator to the element following the last element of the enumarable.">end()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string is empty; otherwise <code>false</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="test_forms_8cpp-example.html#a41">test_forms.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6387fcdd54bee21d02cc5d244a3028ff" name="a6387fcdd54bee21d02cc5d244a3028ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6387fcdd54bee21d02cc5d244a3028ff">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#ae6b7bbe92cc0909082b7a1257f9454a6">const_iterator</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the character following the last character. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a5f943e5420e93551f9d764a055a8e50a">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t, iterator_tag_t &gt;</a>.</p>

</div>
</div>
<a id="ac82f74f75a637871f055a583780a120c" name="ac82f74f75a637871f055a583780a120c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82f74f75a637871f055a583780a120c">&#9670;&#160;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a5a19c12dd03024a0b27ae68115bbfa2b">const_reference</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to the first character in the string. The behavior is undefined if <a class="el" href="classxtd_1_1basic__string.html#adf2d306e379dd0b505b8c40e37c9439e" title="Checks if the string has no characters, i.e. whether begin() == end().">empty()</a> is <code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first character, equivalent to <code>operator[](0)</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabfeb876a8fb51c80fa9adaa3663f232" name="aabfeb876a8fb51c80fa9adaa3663f232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfeb876a8fb51c80fa9adaa3663f232">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of characters in the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of characters in the current string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232" title="Gets the number of characters in the current xtd::basic_string object.">xtd::basic_string::length</a> property returns the number of <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5" title="Represents the basic string value type.">xtd::basic_string::value_type</a> objects in this instance, not the number of Unicode characters. The reason is that a Unicode character might be represented by more than one <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5" title="Represents the basic string value type.">xtd::basic_string::value_type</a>. </dd></dl>

</div>
</div>
<a id="a75a674460af1de2943965a320747214d" name="a75a674460af1de2943965a320747214d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a674460af1de2943965a320747214d">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the string is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a" title="Returns an iterator to the element following the last element of the enumarable.">end()</a>)</code> for the largest string. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of characters. </dd></dl>

</div>
</div>
<a id="a140b818168a60bb3672192795b5ec637" name="a140b818168a60bb3672192795b5ec637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140b818168a60bb3672192795b5ec637">&#9670;&#160;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a72aff392391a7665d5244311dd7eee46">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first character of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first character. </dd></dl>

</div>
</div>
<a id="a9fcd80009ae3c9178d9afbdd4f620730" name="a9fcd80009ae3c9178d9afbdd4f620730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcd80009ae3c9178d9afbdd4f620730">&#9670;&#160;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a72aff392391a7665d5244311dd7eee46">const_reverse_iterator</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Return iterator to the character following the last character. </dd></dl>

</div>
</div>
<a id="aa6e7750375addd424e2684f5f7f88853" name="aa6e7750375addd424e2684f5f7f88853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e7750375addd424e2684f5f7f88853">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <code>char_t</code> elements in the string, i.e. <code>std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a" title="Returns an iterator to the element following the last element of the enumarable.">end()</a>)</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of <code>char_t</code> elements in the string. </dd></dl>

</div>
</div>
<a id="aa7608d530a9e060c40377f3f6efa1965" name="aa7608d530a9e060c40377f3f6efa1965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7608d530a9e060c40377f3f6efa1965">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a5a19c12dd03024a0b27ae68115bbfa2b">const_reference</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the character at specified location <code>pos</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc6d1ce36c2c1d610948bca326214f5f" name="adc6d1ce36c2c1d610948bca326214f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6d1ce36c2c1d610948bca326214f5f">&#9670;&#160;</a></span>compare() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The other string to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to str. </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a2aa91fdfcbd6bfb926f6c81d25242203" name="a2aa91fdfcbd6bfb926f6c81d25242203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa91fdfcbd6bfb926f6c81d25242203">&#9670;&#160;</a></span>compare() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to <code>str</code>.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ac3d0c3aa6ba8ade03f28f5528a7cabfb" name="ac3d0c3aa6ba8ade03f28f5528a7cabfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d0c3aa6ba8ade03f28f5528a7cabfb">&#9670;&#160;</a></span>compare() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. </td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).</li>
<li>If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a7b565aa564f6888524daf4c978e868ee" name="a7b565aa564f6888524daf4c978e868ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b565aa564f6888524daf4c978e868ee">&#9670;&#160;</a></span>compare() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">str</td><td>The other string to compare to. </td></tr>
    <tr><td class="paramname">pos2</td><td>The position of the first character of the given string to compare. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter:<ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to a substring [<code>pos2</code>, <code>pos2 + count2</code>) of <code>str</code>.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the first substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>).</li>
<li>If <code>count2 &gt; str.size() - pos2</code>, the second substring is [<code>pos2</code>, <code>str.size()</code>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="aa506b15b46ca02bfb9f5e782ad71b714" name="aa506b15b46ca02bfb9f5e782ad71b714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa506b15b46ca02bfb9f5e782ad71b714">&#9670;&#160;</a></span>compare() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>. </dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a42f4de83225ec7eb81d9e34a6d3fd461" name="a42f4de83225ec7eb81d9e34a6d3fd461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f4de83225ec7eb81d9e34a6d3fd461">&#9670;&#160;</a></span>compare() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the null-terminated character sequence beginning at the character pointed to by <code>s</code> with length <code>traits_t::length(s)</code>.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1$ , <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). @remarks A character sequence consisting of</code>count1<code>characters starting at</code>data1<code>is compared to a character sequence consisting of</code>count2<code>characters starting at</code>data2<code>as follows:</code></li>
<li><code>First, calculate the number of characters to compare, as if by</code>size_type rlen = std::min(count1, count2)<code>.</code></li>
<li><code>Then compare the sequences by calling</code>traits_t::compare(data1, data2, rlen)`. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a4cd1814acf74f3359393306249030536" name="a4cd1814acf74f3359393306249030536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd1814acf74f3359393306249030536">&#9670;&#160;</a></span>compare() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two character sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The position of the first character in this string to compare. </td></tr>
    <tr><td class="paramname">count1</td><td>The number of characters of this string to compare. </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the character string to compare to. </td></tr>
    <tr><td class="paramname">count2</td><td>The number of characters of the given string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if <code>*this</code> appears before the character sequence specified by the arguments, in lexicographical order.</li>
<li>Zero if both character sequences compare equivalent.</li>
<li>Positive value if <code>*this</code> appears after the character sequence specified by the arguments, in lexicographical order. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Compares a [<code>pos1</code>, <code>pos1 + count1</code>) substring of this string to the characters in the range [<code>s</code>, <code>s + count2</code>). The characters in [<code>s</code>, <code>s + count2</code>) may include null characters.<ul>
<li>If <code>count1 &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos1</code>, the substring is [<code>pos1</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </li>
</ul>
</dd>
<dd>
A character sequence consisting of <code>count1</code> characters starting at <code>data1</code> is compared to a character sequence consisting of <code>count2</code> characters starting at <code>data2</code> as follows:<ul>
<li>First, calculate the number of characters to compare, as if by <code>size_type rlen = std::min(count1, count2)</code>.</li>
<li>Then compare the sequences by calling <code>traits_t::compare(data1, data2, rlen)</code>. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows: </li>
</ul>
</dd>
<dd>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Condition   </th><th class="markdownTableHeadNone">Result   </th><th class="markdownTableHeadNone">Return value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &lt; 0   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &lt; size2   </td><td class="markdownTableBodyNone">data1 is <b>less than</b> data2   </td><td class="markdownTableBodyNone">&lt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 == size2   </td><td class="markdownTableBodyNone">data1 is <b>equal to</b> data2   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Â traits_t::compare(data1, data2, rlen) == 0 and size1 &gt; size2   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traits_t::compare(data1, data2, rlen) &gt; 0   </td><td class="markdownTableBodyNone">data1 is <b>greater than</b> data2   </td><td class="markdownTableBodyNone">&gt; 0   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a785e7ca9244c89a0fd0552a30dca0df6" name="a785e7ca9244c89a0fd0552a30dca0df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785e7ca9244c89a0fd0552a30dca0df6">&#9670;&#160;</a></span>compare_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this instance with a specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <a class="el" href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....">xtd::object</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An object that evaluates to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the value parameter. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">This instance precedes <code>value</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">This instance has the same position in the sort order as <code>value</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">This instance follows <code>value</code>.   </td></tr>
</table>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`value` is not a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56991bcdcf3648e12180abbda6d0e4a2" name="a56991bcdcf3648e12180abbda6d0e4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56991bcdcf3648e12180abbda6d0e4a2">&#9670;&#160;</a></span>compare_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this instance with a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare with this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <code>value</code> parameter. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">This instance precedes <code>value</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">This instance has the same position in the sort order as <code>value</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">This instance follows <code>value</code>.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a850cd349d2e010f36c975a32b150a981" name="a850cd349d2e010f36c975a32b150a981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850cd349d2e010f36c975a32b150a981">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified char occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a46fea739d2eea162481378cc3563e0e7" name="a46fea739d2eea162481378cc3563e0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fea739d2eea162481378cc3563e0e7">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value indicating whether a specified substring occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to seek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter occurs within this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, or if value is the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="aa538684c095ac08578828af5eff7d48d" name="aa538684c095ac08578828af5eff7d48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa538684c095ac08578828af5eff7d48d">&#9670;&#160;</a></span>equals() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1object.html">object</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and a specified object, which must also be a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object, have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>obj</code> is a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> and its value is the same as this instance; otherwise, <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">xtd::object</a>.</p>

</div>
</div>
<a id="acf1e61a72cf0017e83126ebd8d409079" name="acf1e61a72cf0017e83126ebd8d409079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1e61a72cf0017e83126ebd8d409079">&#9670;&#160;</a></span>equals() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

</div>
</div>
<a id="abe34c3ef80e295d524013594ab98e96f" name="abe34c3ef80e295d524013594ab98e96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe34c3ef80e295d524013594ab98e96f">&#9670;&#160;</a></span>equals() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this instance and another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> object have the same value, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing this instance and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>value</code> of the value parameter is the same as the value of this instance; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal comparison. </dd></dl>

</div>
</div>
<a id="a88a32b980ce33e6240fad1bdf860be32" name="a88a32b980ce33e6240fad1bdf860be32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a32b980ce33e6240fad1bdf860be32">&#9670;&#160;</a></span>ends_with() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a235800cab8022150e0242be1f70ccba5" name="a235800cab8022150e0242be1f70ccba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235800cab8022150e0242be1f70ccba5">&#9670;&#160;</a></span>ends_with() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified character, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char_t to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac9bb8f1452d6d3f0a504ed482aeff03d" name="ac9bb8f1452d6d3f0a504ed482aeff03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bb8f1452d6d3f0a504ed482aeff03d">&#9670;&#160;</a></span>ends_with() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare to the substring at the end of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value matches the end of this instance; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="aad2260a3a56c452a4086de5c75d608f3" name="aad2260a3a56c452a4086de5c75d608f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2260a3a56c452a4086de5c75d608f3">&#9670;&#160;</a></span>ends_with() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a0d548b663eb6dc7b61394d0a5031a779" name="a0d548b663eb6dc7b61394d0a5031a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d548b663eb6dc7b61394d0a5031a779">&#9670;&#160;</a></span>ends_with() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that determines how this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a995fc327f844695b7d54bb8c9dcefd64" name="a995fc327f844695b7d54bb8c9dcefd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995fc327f844695b7d54bb8c9dcefd64">&#9670;&#160;</a></span>find() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae7ef167753f97393efa4e8a04f645b1a" name="ae7ef167753f97393efa4e8a04f645b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef167753f97393efa4e8a04f645b1a">&#9670;&#160;</a></span>find() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="afa27496a7880e6ec15ed6af9f3ee63a9" name="afa27496a7880e6ec15ed6af9f3ee63a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa27496a7880e6ec15ed6af9f3ee63a9">&#9670;&#160;</a></span>find() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a5b84e810101f5722ea51155b57673c3a" name="a5b84e810101f5722ea51155b57673c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b84e810101f5722ea51155b57673c3a">&#9670;&#160;</a></span>find() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="afe01cbb72aa625955d5f91eaf20b4422" name="afe01cbb72aa625955d5f91eaf20b4422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe01cbb72aa625955d5f91eaf20b4422">&#9670;&#160;</a></span>find() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6e89be405fda67b0a224b7f5d19dbb74" name="a6e89be405fda67b0a224b7f5d19dbb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e89be405fda67b0a224b7f5d19dbb74">&#9670;&#160;</a></span>find() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>0</code>, i.e. the found substring must not begin in a position preceding <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="ada37711b3a6b2d96deb9937458eeed91" name="ada37711b3a6b2d96deb9937458eeed91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada37711b3a6b2d96deb9937458eeed91">&#9670;&#160;</a></span>find() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first substring equal to the given character sequence. Search begins at <code>pos</code>, i.e. the found substring must not begin in a position preceding <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a190df4d0356f13ee707e02bf0ff69670" name="a190df4d0356f13ee707e02bf0ff69670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190df4d0356f13ee707e02bf0ff69670">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a47ad6cd829e5fb0e5ba7fd173fa52a4c" name="a47ad6cd829e5fb0e5ba7fd173fa52a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad6cd829e5fb0e5ba7fd173fa52a4c">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a92834b04a7c65b7de003f742e78d8309" name="a92834b04a7c65b7de003f742e78d8309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92834b04a7c65b7de003f742e78d8309">&#9670;&#160;</a></span>find_first_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="acb30d4555ab0d49edac1d1f29748968d" name="acb30d4555ab0d49edac1d1f29748968d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb30d4555ab0d49edac1d1f29748968d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a4bf3f78cb8fce98db32d6dea0dacb1fd" name="a4bf3f78cb8fce98db32d6dea0dacb1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf3f78cb8fce98db32d6dea0dacb1fd">&#9670;&#160;</a></span>find_first_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa63f087262d302ffd91d44441141395f" name="aa63f087262d302ffd91d44441141395f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63f087262d302ffd91d44441141395f">&#9670;&#160;</a></span>find_first_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char_t&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="aebf0742e91a1bc6cc31486581993106d" name="aebf0742e91a1bc6cc31486581993106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf0742e91a1bc6cc31486581993106d">&#9670;&#160;</a></span>find_first_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char_t&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to one of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a44655a7fb2b16b0ac355f98efbe7f60a" name="a44655a7fb2b16b0ac355f98efbe7f60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44655a7fb2b16b0ac355f98efbe7f60a">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a865854c0f1fc517a76019ef74357471c" name="a865854c0f1fc517a76019ef74357471c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865854c0f1fc517a76019ef74357471c">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="aa7ee3d277929b2e2822347bbef0799ec" name="aa7ee3d277929b2e2822347bbef0799ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ee3d277929b2e2822347bbef0799ec">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="aa68c7409e9483b7fb2ecb4119a1a49c3" name="aa68c7409e9483b7fb2ecb4119a1a49c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68c7409e9483b7fb2ecb4119a1a49c3">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a394185c5018c818ca6e8c3cbf9048da1" name="a394185c5018c818ca6e8c3cbf9048da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394185c5018c818ca6e8c3cbf9048da1">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a525f7ed777b11690436a4e545cbd4c52" name="a525f7ed777b11690436a4e545cbd4c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525f7ed777b11690436a4e545cbd4c52">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="aa337f7f098dc744c16c768824cdbf5de" name="aa337f7f098dc744c16c768824cdbf5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa337f7f098dc744c16c768824cdbf5de">&#9670;&#160;</a></span>find_first_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character equal to none of the characters in the given character sequence. The search considers only the range [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). If all characters in the range can be found in the given character sequence, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="ada4b8376a5af873f844aa5de5a7f36f1" name="ada4b8376a5af873f844aa5de5a7f36f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4b8376a5af873f844aa5de5a7f36f1">&#9670;&#160;</a></span>find_last_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="abe8812d25aeb365b83a6e13b22d3ea15" name="abe8812d25aeb365b83a6e13b22d3ea15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8812d25aeb365b83a6e13b22d3ea15">&#9670;&#160;</a></span>find_last_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae683ad85d132dc61069a39ab5ecfc892" name="ae683ad85d132dc61069a39ab5ecfc892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae683ad85d132dc61069a39ab5ecfc892">&#9670;&#160;</a></span>find_last_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a3b9f9c97ebc85319e7bb0890747f95f0" name="a3b9f9c97ebc85319e7bb0890747f95f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9f9c97ebc85319e7bb0890747f95f0">&#9670;&#160;</a></span>find_last_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a43971d40fb8f9c14c8f2a8973fda5241" name="a43971d40fb8f9c14c8f2a8973fda5241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43971d40fb8f9c14c8f2a8973fda5241">&#9670;&#160;</a></span>find_last_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="ad3f1e765d3c800b53ad278aeea40cbbb" name="ad3f1e765d3c800b53ad278aeea40cbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f1e765d3c800b53ad278aeea40cbbb">&#9670;&#160;</a></span>find_last_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char_t&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a2276b8461430eec909f87352134d92d8" name="a2276b8461430eec909f87352134d92d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2276b8461430eec909f87352134d92d8">&#9670;&#160;</a></span>find_last_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char_t&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If none of the characters in the given character sequence is present in the range, <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a85a0529754f7c547dd26d0e3df7d4d57" name="a85a0529754f7c547dd26d0e3df7d4d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a0529754f7c547dd26d0e3df7d4d57">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. @parzm str The string identifying characters to search for. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="ae7be46eecca48686b7893fdcc22f1064" name="ae7be46eecca48686b7893fdcc22f1064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7be46eecca48686b7893fdcc22f1064">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in <code>str</code>. </dd></dl>

</div>
</div>
<a id="a0db0de794b93c1d3daec32ee93ebb840" name="a0db0de794b93c1d3daec32ee93ebb840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db0de794b93c1d3daec32ee93ebb840">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
    <tr><td class="paramname">count</td><td>The length of character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in the range [<code>s</code>, <code>s + count</code>). This range can include null characters. </dd>
<dd>
If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66" name="a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2cbf6ea9e0b8e5cbea0ccd43e0ab66">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="ad867ec6c6bbe8ded000aab89983f5b37" name="ad867ec6c6bbe8ded000aab89983f5b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867ec6c6bbe8ded000aab89983f5b37">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string identifying characters to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to one of the characters in character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a622aba17212244261f0a1dee4cf2a76c" name="a622aba17212244261f0a1dee4cf2a76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622aba17212244261f0a1dee4cf2a76c">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a2bb1e50a316279a814fbf6caa9a52512" name="a2bb1e50a316279a814fbf6caa9a52512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb1e50a316279a814fbf6caa9a52512">&#9670;&#160;</a></span>find_last_not_of() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char_t&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last character equal to none of the characters in the given character sequence. The search considers only the range [â<code>0</code>â, <code>pos</code>]. If all characters in the range can be found in the given character sequence,<a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the found character or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such character is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character equal to <code>ch</code>. </dd></dl>

</div>
</div>
<a id="a0f3fea87ee51c2cc221b5018ff83de9b" name="a0f3fea87ee51c2cc221b5018ff83de9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3fea87ee51c2cc221b5018ff83de9b">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="a38f45ba04d07446618d604b99c22fbb3" name="a38f45ba04d07446618d604b99c22fbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f45ba04d07446618d604b99c22fbb3">&#9670;&#160;</a></span>get_base_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classxtd_1_1basic__string.html#a023c9110b9e82006d694c297f404e031">base_type</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_base_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type. </dd></dl>

</div>
</div>
<a id="a8204b499a2a327ac2193814c5ba59be4" name="a8204b499a2a327ac2193814c5ba59be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8204b499a2a327ac2193814c5ba59be4">&#9670;&#160;</a></span>get_hash_code()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_hash_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash code for this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">xtd::object</a>.</p>

</div>
</div>
<a id="a273eee6b3d879fdab255817b5406ff1b" name="a273eee6b3d879fdab255817b5406ff1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273eee6b3d879fdab255817b5406ff1b">&#9670;&#160;</a></span>get_enumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a2b5493bd9034616dded9fb810d65fd6c">enumerator_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::get_enumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerator that iterates through a collection. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html" title="Supports a simple iteration over a generic collection.">xtd::collections::generic::enumerator</a> object that can be used to iterate through the collection. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#aaa7f31bc15aecee93e381b36c71c3058">xtd::collections::generic::ienumerable&lt; char_t &gt;</a>.</p>

</div>
</div>
<a id="aa2e2b0b18ffae65666bfe665f10c8eee" name="aa2e2b0b18ffae65666bfe665f10c8eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e2b0b18ffae65666bfe665f10c8eee">&#9670;&#160;</a></span>index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="time_span_from_hours_8cpp-example.html#a2">time_span_from_hours.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae8cdbff9d2baf8ca5354e0361db8b8f1" name="ae8cdbff9d2baf8ca5354e0361db8b8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cdbff9d2baf8ca5354e0361db8b8f1">&#9670;&#160;</a></span>index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a9376bff15d7276c49c0ce4ea3bd744b0" name="a9376bff15d7276c49c0ce4ea3bd744b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9376bff15d7276c49c0ce4ea3bd744b0">&#9670;&#160;</a></span>index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03cc9bdb3ebf738766cf0b8357d9f28d" name="a03cc9bdb3ebf738766cf0b8357d9f28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cc9bdb3ebf738766cf0b8357d9f28d">&#9670;&#160;</a></span>index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a1241d527912da0524fe79c1885104986" name="a1241d527912da0524fe79c1885104986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1241d527912da0524fe79c1885104986">&#9670;&#160;</a></span>index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="a101dd613f8711c38c17443fbc8c29799" name="a101dd613f8711c38c17443fbc8c29799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101dd613f8711c38c17443fbc8c29799">&#9670;&#160;</a></span>index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50c38c1845d60e7d08f8750bb181aa4d" name="a50c38c1845d60e7d08f8750bb181aa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c38c1845d60e7d08f8750bb181aa4d">&#9670;&#160;</a></span>index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a19d7c6fb6ca5e05c6a464e8cb25c2e76" name="a19d7c6fb6ca5e05c6a464e8cb25c2e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d7c6fb6ca5e05c6a464e8cb25c2e76">&#9670;&#160;</a></span>index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac27b133bb5f4567decb3a19ff63a883" name="aac27b133bb5f4567decb3a19ff63a883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac27b133bb5f4567decb3a19ff63a883">&#9670;&#160;</a></span>index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the first occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48ce826afc61742ea2b759feb0987d9c" name="a48ce826afc61742ea2b759feb0987d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ce826afc61742ea2b759feb0987d9c">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a specified instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> at a specified index position in this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The index position of the insertion. </td></tr>
    <tr><td class="paramname">value</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to this instance but with value inserted at position start_index. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If start_index is equal to the length of this instance, value is appended to the end of this instance. </dd>
<dd>
For example, the return value of "abc".Insert(2, "XYZ") is "abXYZc". </dd></dl>

</div>
</div>
<a id="a6c9caea8081698b588cb6af9b6da8542" name="a6c9caea8081698b588cb6af9b6da8542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9caea8081698b588cb6af9b6da8542">&#9670;&#160;</a></span>is_empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter is null or an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Replaced by xtd::basic_string::is_empty(const xtd::basic_string&amp;) - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="acc799a8cc31af232470d65cd88a1ca6a" name="acc799a8cc31af232470d65cd88a1ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc799a8cc31af232470d65cd88a1ca6a">&#9670;&#160;</a></span>last_index_of() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="test_forms_8cpp-example.html#a28">test_forms.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3b7a6db704899bd1263a714bf8363f6b" name="a3b7a6db704899bd1263a714bf8363f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a6db704899bd1263a714bf8363f6b">&#9670;&#160;</a></span>last_index_of() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fb55029c7dfebcfb60989e102943e70" name="a4fb55029c7dfebcfb60989e102943e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb55029c7dfebcfb60989e102943e70">&#9670;&#160;</a></span>last_index_of() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68a1c153b902e5edf0b877652add0e43" name="a68a1c153b902e5edf0b877652add0e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a1c153b902e5edf0b877652add0e43">&#9670;&#160;</a></span>last_index_of() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this tring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>

</div>
</div>
<a id="af8bdcec1f21421c38a7a80d8142ff7d5" name="af8bdcec1f21421c38a7a80d8142ff7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bdcec1f21421c38a7a80d8142ff7d5">&#9670;&#160;</a></span>last_index_of() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c63d72cfa3f91e2cf9f23881f68d9a6" name="a8c63d72cfa3f91e2cf9f23881f68d9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c63d72cfa3f91e2cf9f23881f68d9a6">&#9670;&#160;</a></span>last_index_of() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence of the specified character in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. The search starts at a specified character position and examines a specified number of character positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to find last index of. </td></tr>
    <tr><td class="paramname">value</td><td>An unicode character to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of value if that character is found, or std::basic_string&lt;char_t&gt;::npos if it is not. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>start_index + count are greater than the length of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cef9de4c87f758793ab52f372999b98" name="a9cef9de4c87f758793ab52f372999b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cef9de4c87f758793ab52f372999b98">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ad9eee5a0186b0272dde1487fa3a76e31" name="ad9eee5a0186b0272dde1487fa3a76e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eee5a0186b0272dde1487fa3a76e31">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="ac4c41879b43a215e17a3b3f1d940352b" name="ac4c41879b43a215e17a3b3f1d940352b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c41879b43a215e17a3b3f1d940352b">&#9670;&#160;</a></span>last_index_of_any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::last_index_of_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the index of the last occurrence in this instance of any character in a specified array of characters. The search starts at a specified character position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An unicode character array containing one or more characters to seek </td></tr>
    <tr><td class="paramname">start_index</td><td>The search starting position </td></tr>
    <tr><td class="paramname">count</td><td>The number of character positions to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index position of the first occurrence in this instance where any character in values was found; otherwise, std::basic_string&lt;char_t&gt;::npos if no character in values was found. </dd></dl>

</div>
</div>
<a id="a0841b4ac447cc426dfc86857696a59d3" name="a0841b4ac447cc426dfc86857696a59d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0841b4ac447cc426dfc86857696a59d3">&#9670;&#160;</a></span>pad_left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>total_width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the right portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="acd8d49dec1f34267194ae3d6023e5bca" name="acd8d49dec1f34267194ae3d6023e5bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8d49dec1f34267194ae3d6023e5bca">&#9670;&#160;</a></span>pad_left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>total_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a>&#160;</td>
          <td class="paramname"><em>padding_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the left for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_width</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but right-aligned and padded on the left with as many spaces as needed to create a length of total_width. Or, if total_width is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The pad_left(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the beginning of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the right portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="abe37d71513cd7f2585290402bd45afb2" name="abe37d71513cd7f2585290402bd45afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe37d71513cd7f2585290402bd45afb2">&#9670;&#160;</a></span>pad_right() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>total_width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but left-aligned and padded on the right with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The PadRight(const std::basic_string&lt;char_t&gt;&amp;, int) method pads the end of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the left portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="format_boolean_8cpp-example.html#a0">format_boolean.cpp</a>, <a class="el" href="format_character_8cpp-example.html#a1">format_character.cpp</a>, <a class="el" href="format_class_with_specified_formating_8cpp-example.html#a2">format_class_with_specified_formating.cpp</a>, <a class="el" href="format_class_with_specified_formating_with_to_string_8cpp-example.html#a2">format_class_with_specified_formating_with_to_string.cpp</a>, <a class="el" href="format_date_time_8cpp-example.html#a1">format_date_time.cpp</a>, <a class="el" href="format_duration_8cpp-example.html#a0">format_duration.cpp</a>, <a class="el" href="format_enum_8cpp-example.html#a1">format_enum.cpp</a>, <a class="el" href="format_enum_class_8cpp-example.html#a1">format_enum_class.cpp</a>, <a class="el" href="format_enum_class_flags_8cpp-example.html#a2">format_enum_class_flags.cpp</a>, <a class="el" href="format_enum_class_flags_without_helper_8cpp-example.html#a3">format_enum_class_flags_without_helper.cpp</a>, and <a class="el" href="format_floating_point_8cpp-example.html#a0">format_floating_point.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7948b86a1e0b7a58d6813048a74c4106" name="a7948b86a1e0b7a58d6813048a74c4106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7948b86a1e0b7a58d6813048a74c4106">&#9670;&#160;</a></span>pad_right() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::pad_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>total_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">char32</a>&#160;</td>
          <td class="paramname"><em>padding_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-aligns the characters in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, padding with spaces on the right for a specified total length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totalWidth</td><td>The number of characters in the resulting <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, equal to the number of original characters plus any additional padding characters. </td></tr>
    <tr><td class="paramname">paddingChar</td><td>An unicode padding character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, but left-aligned and padded on the tight with as many spaces as needed to create a length of totalWidth. Or, if totalWidth is less than the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, a new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is identical to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unicode space is defined as hexadecimal 0x20. </dd>
<dd>
The <a class="el" href="classxtd_1_1basic__string.html#abe37d71513cd7f2585290402bd45afb2" title="Left-aligns the characters in this basic_string, padding with spaces on the right for a specified tot...">xtd::basic_string::pad_right</a> method pads the end of the returned <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. This means that, when used with right-to-left languages, it pads the left portion of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>.. </dd></dl>

</div>
</div>
<a id="a5856547e0780ad2ada0c0f614dc063df" name="a5856547e0780ad2ada0c0f614dc063df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5856547e0780ad2ada0c0f614dc063df">&#9670;&#160;</a></span>quoted() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A new quoted <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>the delimiter is set to <pre class="fragment">" </pre> by default and the escape is set to <code>\</code> by default. </dd>
<dd>
for more information see <a href="https://en.cppreference.com/w/cpp/io/manip/quoted">std::quoted</a>. </dd></dl>

</div>
</div>
<a id="a773214921b5ced5e4a8d4c25dd88891c" name="a773214921b5ced5e4a8d4c25dd88891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773214921b5ced5e4a8d4c25dd88891c">&#9670;&#160;</a></span>quoted() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>delimiter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>The character to use as the delimiter, defaults to <code>"&lt;/tt&gt;.
@return A new quoted basic_string.
@remarks for more information see &lt;a href="<a href="https://en.cppreference.com/w/cpp/io/manip/quoted">https://en.cppreference.com/w/cpp/io/manip/quoted</a>" &gt;std::quoted. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19de7bf5a27c141a306859535be853a" name="af19de7bf5a27c141a306859535be853a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19de7bf5a27c141a306859535be853a">&#9670;&#160;</a></span>quoted() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>escape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows insertion and extraction of quoted strings, such as the ones found in <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a href="https://en.wikipedia.org/wiki/XML">XML</a> ith specified delimiter and escape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>The character to use as the delimiter, defaults to <code>"&lt;/tt&gt;.
@param escape The character to use as the escape character, defaults to &lt;tt&gt;\\&lt;/tt&gt;.
@return A new quoted basic_string.
@remarks for more information see &lt;a href="<a href="https://en.cppreference.com/w/cpp/io/manip/quoted">https://en.cppreference.com/w/cpp/io/manip/quoted</a>" &gt;std::quoted. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb28698bda96ef32e834d79377523c7" name="a5fb28698bda96ef32e834d79377523c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb28698bda96ef32e834d79377523c7">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is equivalent to this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> less the removed characters. </dd></dl>

</div>
</div>
<a id="a678f92a6d19c47147afc8eacf6f9c6b3" name="a678f92a6d19c47147afc8eacf6f9c6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f92a6d19c47147afc8eacf6f9c6b3">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all the characters from this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> beginning at a specified position and continuing through the last position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The position to begin deleting characters. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> object that is equivalent to this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> less the removed characters. </dd></dl>

</div>
</div>
<a id="aab8e9d4ff2110bf9f24035babdc2a1ef" name="aab8e9d4ff2110bf9f24035babdc2a1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8e9d4ff2110bf9f24035babdc2a1ef">&#9670;&#160;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>old_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>new_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified char_t in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified char_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_char</td><td>A char_t to be replaced. </td></tr>
    <tr><td class="paramname">new_char</td><td>A char_t to replace all occurrences of old_char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> but with all instances of old_char replaced with new_char. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="file_info_replace_8cpp-example.html#a2">file_info_replace.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a80dba25995a5713a69ad528fc0dcf889" name="a80dba25995a5713a69ad528fc0dcf889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dba25995a5713a69ad528fc0dcf889">&#9670;&#160;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> with another specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_string</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to be replaced. </td></tr>
    <tr><td class="paramname">new_string</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to replace all occurrences of old_string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> but with all instances of old_string replaced with new_string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If new_string is empty, all occurrences of old_string are removed </dd></dl>

</div>
</div>
<a id="a2e4f156b7f8196bcf93d922f5a0936d3" name="a2e4f156b7f8196bcf93d922f5a0936d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4f156b7f8196bcf93d922f5a0936d3">&#9670;&#160;</a></span>rfind() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>, the whole string will be searched. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. @remarks Finds the first substring equal to</code>str`. </p>

</div>
</div>
<a id="ad58fe89ac239e9c5c32ed70df7c7c883" name="ad58fe89ac239e9c5c32ed70df7c7c883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58fe89ac239e9c5c32ed70df7c7c883">&#9670;&#160;</a></span>rfind() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to <code>str</code>. </dd></dl>

</div>
</div>
<a id="a2b86f1367a8a62bd5c9ec81730c6ff03" name="a2b86f1367a8a62bd5c9ec81730c6ff03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b86f1367a8a62bd5c9ec81730c6ff03">&#9670;&#160;</a></span>rfind() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
    <tr><td class="paramname">count</td><td>The length of substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the range [s, s + count). </dd>
<dd>
This range may contain null characters. If [<code>s</code>, <code>s + count</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a2c5e3a4d7133856d265119fea8ec612f" name="a2c5e3a4d7133856d265119fea8ec612f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5e3a4d7133856d265119fea8ec612f">&#9670;&#160;</a></span>rfind() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>, the whole string will be searched. @param s The pointer to a character string to search for. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. @remarks Finds the first substring equal to the character string pointed to by</code>s<code>. The length of the string is determined by the first null character using</code>traits_t::length(s)<code>. @remarks If [</code>s<code>,</code>s + traits_t::length(s)`) is not a valid range, the behavior is undefined. </p>

</div>
</div>
<a id="afff7dc0272a38daae9fe92213bf3743f" name="afff7dc0272a38daae9fe92213bf3743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff7dc0272a38daae9fe92213bf3743f">&#9670;&#160;</a></span>rfind() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a4019460efb8119704afcefd0a1703847">const_pointer</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to a character string to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first substring equal to the character string pointed to by <code>s</code>. The length of the string is determined by the first null character using <code>traits_t::length(s)</code>. </dd>
<dd>
If [<code>s</code>, <code>s + traits_t::length(s)</code>) is not a valid range, the behavior is undefined. </dd></dl>

</div>
</div>
<a id="a89758e3790f9444b86efcdb7b0ecbee2" name="a89758e3790f9444b86efcdb7b0ecbee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89758e3790f9444b86efcdb7b0ecbee2">&#9670;&#160;</a></span>rfind() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a><code>and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>, the whole string will be searched. @param ch The character to search for. @return Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. @remarks Finds the first character</code>ch` (treated as a single-character substring by the formal rules below). </p>

</div>
</div>
<a id="a6f2a1c61ed2fd70d04090ff9e4ce3374" name="a6f2a1c61ed2fd70d04090ff9e4ce3374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2a1c61ed2fd70d04090ff9e4ce3374">&#9670;&#160;</a></span>rfind() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last substring that is equal to the given character sequence. The search begins at <code>pos</code> and proceeds from right to left (thus, the found substring, if any, cannot begin in a position following <code>pos</code>). If <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> or any value not smaller than <a class="el" href="classxtd_1_1basic__string.html#aa6e7750375addd424e2684f5f7f88853" title="Returns the number of char_t elements in the string, i.e. std::distance(begin(), end()).">xtd::basic_string::size()</a> - 1 is passed as <code>pos</code>, the whole string will be searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to start the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first character of the found substring or <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a> if no such substring is found. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds the first character <code>ch</code> (treated as a single-character substring by the formal rules below). </dd></dl>

</div>
</div>
<a id="a1344c6559dbf009f5ab4bebe64b6bb69" name="a1344c6559dbf009f5ab4bebe64b6bb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1344c6559dbf009f5ab4bebe64b6bb69">&#9670;&#160;</a></span>split() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the default white-space characters. White-space characters are defined by the c++ standard and return <code>true</code> if they are passed to the xtd::char_object::isspace() or std::iswspace() method. </p>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in white-space separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="split_8cpp-example.html#a1">split.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5f5dd5044af32ac25bb0baf9b6413342" name="a5f5dd5044af32ac25bb0baf9b6413342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5dd5044af32ac25bb0baf9b6413342">&#9670;&#160;</a></span>split() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A character that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="a8edaf9bbe18d8453a1a4efbf54e74870" name="a8edaf9bbe18d8453a1a4efbf54e74870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edaf9bbe18d8453a1a4efbf54e74870">&#9670;&#160;</a></span>split() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings based on the characters in an array. You can specify whether the substrings include empty array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A character that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the options parameter is remove_empty_entries and the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is zero, the method returns an empty array. </dd>
<dd>
Each element of separator defines a separate delimiter that consists of a single character. If the options argument is none, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. For example, if separator includes two elements, "-" and "_", the value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance is "-_aa-_", and the value of the options argument is None, the method returns a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> array with the following five elements:<ol type="1">
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that precedes the "-" character at index 0.</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between the "-" character at index 0 and the "_" character at index 1.</li>
<li>"aa",</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that follows the "_" character at index 4.</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that follows the "-" character at index 5. </li>
</ol>
</dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the c++ standard and return <code>true</code> if they are passed to the xtd::char_object::isspace() or std::iswspace() method. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="afd2382e0600fa5915622f8eafd4c72bb" name="afd2382e0600fa5915622f8eafd4c72bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2382e0600fa5915622f8eafd4c72bb">&#9670;&#160;</a></span>split() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return <code>true</code> if they are passed to the char_t.IsWhiteSpace method. </dd>
<dd>
Each element of separator defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If there are more than count substrings in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> are returned in the last element of the return value. </dd></dl>

</div>
</div>
<a id="a2cbf084f9d5a9dcd94e199f33e18da31" name="a2cbf084f9d5a9dcd94e199f33e18da31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbf084f9d5a9dcd94e199f33e18da31">&#9670;&#160;</a></span>split() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the count parameter is zero, or the options parameter is remove_empty_entries and the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is zero, an empty array is returned. </dd>
<dd>
Each element of separator defines a separate delimiter character. If the options parameter is None, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If there are more than count substrings in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> are returned in the last element of the return value. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="a26322b05a341263f70f5dbb8559e1e49" name="a26322b05a341263f70f5dbb8559e1e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26322b05a341263f70f5dbb8559e1e49">&#9670;&#160;</a></span>split() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings that are based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="af5de967d299899ed013ff09081289601" name="af5de967d299899ed013ff09081289601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5de967d299899ed013ff09081289601">&#9670;&#160;</a></span>split() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into substrings based on the characters in an array. You can specify whether the substrings include empty array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the options parameter is remove_empty_entries and the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is zero, the method returns an empty array. </dd>
<dd>
Each element of separator defines a separate delimiter that consists of a single character. If the options argument is none, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. For example, if separator includes two elements, "-" and "_", the value of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instance is "-_aa-_", and the value of the options argument is None, the method returns a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> array with the following five elements:<ol type="1">
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that precedes the "-" character at index 0.</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between the "-" character at index 0 and the "_" character at index 1.</li>
<li>"aa",</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that follows the "_" character at index 4.</li>
<li>empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, which represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that follows the "-" character at index 5. </li>
</ol>
</dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the c++ standard and return <code>true</code> if they are passed to the xtd::char_object::isspace() or std::iswspace() method. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="af24f8ff6be34a9febe468cae4e98de8d" name="af24f8ff6be34a9febe468cae4e98de8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24f8ff6be34a9febe468cae4e98de8d">&#9670;&#160;</a></span>split() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the separator parameter contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return <code>true</code> if they are passed to the char_t.IsWhiteSpace method. </dd>
<dd>
Each element of separator defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If there are more than count substrings in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> are returned in the last element of the return value. </dd></dl>

</div>
</div>
<a id="a77f0ee8ec40989e2f2b12c148174e73a" name="a77f0ee8ec40989e2f2b12c148174e73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f0ee8ec40989e2f2b12c148174e73a">&#9670;&#160;</a></span>split() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga1856f4f531626dc585fd1c8ccc6d596c">xtd::string_split_options</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a maximum number of substrings based on the characters in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separators</td><td>A character array that delimits the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, an empty array that contains no delimiters. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of substrings to return. </td></tr>
    <tr><td class="paramname">options</td><td><a class="el" href="group__xtd__core.html#gga1856f4f531626dc585fd1c8ccc6d596ca554bc886886f880e29b898519e657f9a" title="The return value does not include array elements that contain an empty string.">xtd::string_split_options::remove_empty_entries</a> to omit empty array elements from the array returned; or None to include empty array elements in the array returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array whose elements contain the substrings in this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that are delimited by one or more characters in separators. For more information, see the Remarks section. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Delimiter characters are not included in the elements of the returned array. </dd>
<dd>
If the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> does not contain any of the characters in separator, or the count parameter is 1, the returned array consists of a single element that contains the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If the count parameter is zero, or the options parameter is remove_empty_entries and the length of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is zero, an empty array is returned. </dd>
<dd>
Each element of separator defines a separate delimiter character. If the options parameter is None, and two delimiters are adjacent or a delimiter is found at the beginning or end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the corresponding array element contains an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd>
<dd>
If there are more than count substrings in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, the first count minus 1 substrings are returned in the first count minus 1 elements of the return value, and the remaining characters in the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> are returned in the last element of the return value. </dd>
<dd>
If count is greater than the number of substrings, the available substrings are returned. </dd></dl>

</div>
</div>
<a id="acf49e5676d2d8bc36ac6f9294626a433" name="acf49e5676d2d8bc36ac6f9294626a433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf49e5676d2d8bc36ac6f9294626a433">&#9670;&#160;</a></span>starts_with() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="a844fc4d1f8f6465bb42b33c83ef11d38" name="a844fc4d1f8f6465bb42b33c83ef11d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844fc4d1f8f6465bb42b33c83ef11d38">&#9670;&#160;</a></span>starts_with() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to compare to. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="a46ab7003170f911983442950687fd66e" name="a46ab7003170f911983442950687fd66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ab7003170f911983442950687fd66e">&#9670;&#160;</a></span>starts_with() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="aefc64225a0c82e51d464a248a98263d2" name="aefc64225a0c82e51d464a248a98263d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc64225a0c82e51d464a248a98263d2">&#9670;&#160;</a></span>starts_with() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the beginning of this instance of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> matches a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to compare to. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method compares value to the substring at the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> that is the same length as value, and returns an indication whether they are equal. To be equal, value must be a reference to this same instance, or match the beginning of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>

</div>
</div>
<a id="afa21b380225ae8dd5786e7d27b8a30fc" name="afa21b380225ae8dd5786e7d27b8a30fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa21b380225ae8dd5786e7d27b8a30fc">&#9670;&#160;</a></span>starts_with() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the end of this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> matches the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> when compared using the specified comparison option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to compare to the substring at the end of this instance. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that determines how this <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> and value are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <code>true</code> if value matches the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae796b1c2de68ac5b3c39e09361682bd2" name="ae796b1c2de68ac5b3c39e09361682bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae796b1c2de68ac5b3c39e09361682bd2">&#9670;&#160;</a></span>substr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="aa8ea0f77673ecfbd266dc085d516e34a" name="aa8ea0f77673ecfbd266dc085d516e34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ea0f77673ecfbd266dc085d516e34a">&#9670;&#160;</a></span>substr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="a544b0e8a83055ed6041d1c8f32afb5ed" name="a544b0e8a83055ed6041d1c8f32afb5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544b0e8a83055ed6041d1c8f32afb5ed">&#9670;&#160;</a></span>substr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring [<code>pos</code>, <code>pos + count</code>). If the requested substring extends past the end of the string, i.e. the <code>count</code> is greater than <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> - pos (e.g. if <code>count</code> == <a class="el" href="classxtd_1_1basic__string.html#a9629cc4c296a49e4f99d718e8117689e" title="This is a special value equal to the maximum value representable by the type xtd::size.">xtd::basic_string::npos</a>), the returned substring is [<code>pos</code>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the first character to include. </td></tr>
    <tr><td class="paramname">count</td><td>The length of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the substring [<code>pos</code>, <code>pos + count</code>) or [pos, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`std::out_of_range`</td><td>if `pos &gt; <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a>`. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Equivalent to return <code>basic_string(*this, pos, count);</code>. </dd></dl>

</div>
</div>
<a id="a50394c19c9120fecc7228511cd07796b" name="a50394c19c9120fecc7228511cd07796b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50394c19c9120fecc7228511cd07796b">&#9670;&#160;</a></span>substring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to substring. </td></tr>
    <tr><td class="paramname">start_index</td><td>The zero-based starting character position of a substring in this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the substring of length length that begins at start_index in this instance, or Empty if start_index is equal to the length of this instance and length is zero. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`start_index` is greater than the <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232" title="Gets the number of characters in the current xtd::basic_string object.">length()</a> of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="test_forms_8cpp-example.html#a30">test_forms.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1c075ac57baaa69e5cae23fa37a750de" name="a1c075ac57baaa69e5cae23fa37a750de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c075ac57baaa69e5cae23fa37a750de">&#9670;&#160;</a></span>substring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::substring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The zero-based starting character position of a substring in this instance. </td></tr>
    <tr><td class="paramname">length</td><td>The number of characters in the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> equivalent to the substring of length length that begins at start_index in this instance, or Empty if start_index is equal to the length of this instance and length is zero. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`start_index` plus `length` is greater than the <a class="el" href="classxtd_1_1basic__string.html#aabfeb876a8fb51c80fa9adaa3663f232" title="Gets the number of characters in the current xtd::basic_string object.">length()</a> of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af65a379a9653c9aa95d4cdd67793ac53" name="af65a379a9653c9aa95d4cdd67793ac53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65a379a9653c9aa95d4cdd67793ac53">&#9670;&#160;</a></span>to_array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array. </p>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a4ef5e889d2eec057dbb70531d7431ba1" name="a4ef5e889d2eec057dbb70531d7431ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef5e889d2eec057dbb70531d7431ba1">&#9670;&#160;</a></span>to_array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="aab7c2c19ac001d245d0b6aacc6b893e9" name="aab7c2c19ac001d245d0b6aacc6b893e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7c2c19ac001d245d0b6aacc6b893e9">&#9670;&#160;</a></span>to_array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index with specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a57271b1de1ecc20c7f6eaaf9e1947a8d" name="a57271b1de1ecc20c7f6eaaf9e1947a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57271b1de1ecc20c7f6eaaf9e1947a8d">&#9670;&#160;</a></span>to_char_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_char_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array. </p>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a7ad26f801b726bf0e9f8e55ccfbb76bc" name="a7ad26f801b726bf0e9f8e55ccfbb76bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad26f801b726bf0e9f8e55ccfbb76bc">&#9670;&#160;</a></span>to_char_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_char_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the characters in this instance to a Unicode character array starting at specified index with specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>The starting position of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character array whose elements are the individual characters of this instance. If this instance is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>, the returned array is empty and has a zero length. </dd></dl>

</div>
</div>
<a id="a0612d8c3d9feb6b741e2a0d0a07f2121" name="a0612d8c3d9feb6b741e2a0d0a07f2121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0612d8c3d9feb6b741e2a0d0a07f2121">&#9670;&#160;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_lower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> converted to lowercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A string in lowercase. </dd></dl>

</div>
</div>
<a id="a58dbb00bd5ca3a95303ece7973c23be8" name="a58dbb00bd5ca3a95303ece7973c23be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58dbb00bd5ca3a95303ece7973c23be8">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;char&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Uncomment the folllowing line and remove the next.. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">xtd::object</a>.</p>

</div>
</div>
<a id="aab652a0332d481e6ff0e234f6c8c629c" name="aab652a0332d481e6ff0e234f6c8c629c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab652a0332d481e6ff0e234f6c8c629c">&#9670;&#160;</a></span>to_title_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_title_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to title case (except for words that are entirely in uppercase, which are considered to be acronyms). </p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> in title case. </dd></dl>

</div>
</div>
<a id="af5381c036c5cf11a5fff2b228dce8441" name="af5381c036c5cf11a5fff2b228dce8441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5381c036c5cf11a5fff2b228dce8441">&#9670;&#160;</a></span>to_u16string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_u16string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570" title="Represents a 16-bit unicode character.">xtd::char16</a>&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>

</div>
</div>
<a id="af6de628a8933be7f9e8d1ec19b93b643" name="af6de628a8933be7f9e8d1ec19b93b643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6de628a8933be7f9e8d1ec19b93b643">&#9670;&#160;</a></span>to_u32string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_u32string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92" title="Represents a 32-bit unicode character.">xtd::char32</a>&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>

</div>
</div>
<a id="ad8c7f70f3570876064475705884708c6" name="ad8c7f70f3570876064475705884708c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c7f70f3570876064475705884708c6">&#9670;&#160;</a></span>to_u8string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_u8string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a" title="Represents a 8-bit unicode character.">xtd::char8</a>&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>

</div>
</div>
<a id="a4cc6be7fa93346c34256fb76e6dc4b3a" name="a4cc6be7fa93346c34256fb76e6dc4b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc6be7fa93346c34256fb76e6dc4b3a">&#9670;&#160;</a></span>to_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_upper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the current <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> converted to uppercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A string in uppercase. </dd></dl>

</div>
</div>
<a id="a5ce3a3f2c42d41896f43593d3e853edf" name="a5ce3a3f2c42d41896f43593d3e853edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce3a3f2c42d41896f43593d3e853edf">&#9670;&#160;</a></span>to_wstring()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::to_wstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the value of this instance to a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> &lt;<a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518" title="Represents a wide character.">xtd::wchar</a>&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>The current string. </dd></dl>

</div>
</div>
<a id="a12abc4b92c5666dbe597aebe733796e1" name="a12abc4b92c5666dbe597aebe733796e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12abc4b92c5666dbe597aebe733796e1">&#9670;&#160;</a></span>trim() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start and te and of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a008a2167029ed114ad95a3911d717b81" name="a008a2167029ed114ad95a3911d717b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008a2167029ed114ad95a3911d717b81">&#9670;&#160;</a></span>trim() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>trim_char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start and the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="ad8146db206c16a41c826fe5cc5d62926" name="ad8146db206c16a41c826fe5cc5d62926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8146db206c16a41c826fe5cc5d62926">&#9670;&#160;</a></span>trim() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trim_chars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading and trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the characters in the trim_chars parameter are removed from the start and the edn of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a9c0a8e47fafff38f414e0a2fdae990bc" name="a9c0a8e47fafff38f414e0a2fdae990bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0a8e47fafff38f414e0a2fdae990bc">&#9670;&#160;</a></span>trim_end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="ac0cd7da5dcdbb9e48b57b074d45c4086" name="ac0cd7da5dcdbb9e48b57b074d45c4086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cd7da5dcdbb9e48b57b074d45c4086">&#9670;&#160;</a></span>trim_end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>trim_char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a040906f5d3bac8da047872886e0ec723" name="a040906f5d3bac8da047872886e0ec723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040906f5d3bac8da047872886e0ec723">&#9670;&#160;</a></span>trim_end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trim_chars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all trailing occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim end. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the characters in the trim_chars parameter are removed from the end of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="ac86342c41edcf3e05ef56d2a170d1389" name="ac86342c41edcf3e05ef56d2a170d1389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86342c41edcf3e05ef56d2a170d1389">&#9670;&#160;</a></span>trim_start() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of white-space characters from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a4f441a6805a2fe3cfa6467eeecab5d3e" name="a4f441a6805a2fe3cfa6467eeecab5d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f441a6805a2fe3cfa6467eeecab5d3e">&#9670;&#160;</a></span>trim_start() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>&#160;</td>
          <td class="paramname"><em>trim_char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of a character specified from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_char</td><td>A character to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the character in the trim_char parameter are removed from the start of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a6b36d97086675150ce441a1da48d3da3" name="a6b36d97086675150ce441a1da48d3da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b36d97086675150ce441a1da48d3da3">&#9670;&#160;</a></span>trim_start() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::trim_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trim_chars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all leading occurrences of a set of characters specified in an array from the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to trim start. </td></tr>
    <tr><td class="paramname">trim_chars</td><td>An array of characters to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> that remains after all occurrences of the characters in the trim_chars parameter are removed from the start of the specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>

</div>
</div>
<a id="a69a97f1b420e640208ecd970b0d17f09" name="a69a97f1b420e640208ecd970b0d17f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a97f1b420e640208ecd970b0d17f09">&#9670;&#160;</a></span>class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::class_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the object_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the object_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_&lt;object_t&gt;()</a>.name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a0da452ea8889d3c99e3ef0437d12b3a2" name="a0da452ea8889d3c99e3ef0437d12b3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da452ea8889d3c99e3ef0437d12b3a2">&#9670;&#160;</a></span>class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(object)</a>.name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a6a0695f721a034545f3ce21d8ac16944" name="a6a0695f721a034545f3ce21d8ac16944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0695f721a034545f3ce21d8ac16944">&#9670;&#160;</a></span>class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the class name of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The class name of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(info)</a>.name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a6fb70bd0d2a63dbd30c7256fc22563ed" name="a6fb70bd0d2a63dbd30c7256fc22563ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb70bd0d2a63dbd30c7256fc22563ed">&#9670;&#160;</a></span>compare() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a6f962d883014226a68c6a4d654ddb1b3" name="a6f962d883014226a68c6a4d654ddb1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f962d883014226a68c6a4d654ddb1b3">&#9670;&#160;</a></span>compare() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a03f90cbdcb6cc485cf796ba6105f0ed3" name="a03f90cbdcb6cc485cf796ba6105f0ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f90cbdcb6cc485cf796ba6105f0ed3">&#9670;&#160;</a></span>compare() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects using the specified rules, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that specifies the rules to use in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a9fc411e57525bdd57f6de7607b8f6542" name="a9fc411e57525bdd57f6de7607b8f6542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc411e57525bdd57f6de7607b8f6542">&#9670;&#160;</a></span>compare() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ad607d694b591590cfb8a179a012a9641" name="ad607d694b591590cfb8a179a012a9641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad607d694b591590cfb8a179a012a9641">&#9670;&#160;</a></span>compare() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case during the comparison; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a58a8880cff5658a0b1a23d8ee576328a" name="a58a8880cff5658a0b1a23d8ee576328a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a8880cff5658a0b1a23d8ee576328a">&#9670;&#160;</a></span>compare() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__types.html#ga205462e259a4eca1545511085c2c350e">int32</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xtd__core.html#ga04dd6c532656e286dfbf2f9aea3d8ccd">xtd::string_comparison</a>&#160;</td>
          <td class="paramname"><em>comparison_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares substrings of two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> objects using the specified rules, and returns an integer that indicates their relative position in the sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_a</td><td>The position of the substring within str_a. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to use in the comparison. </td></tr>
    <tr><td class="paramname">index_b</td><td>The position of the substring within str_b. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of characters in the substrings to compare </td></tr>
    <tr><td class="paramname">comparison_type</td><td>One of the enumeration values that specifies the rules to use in the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit signed integer that indicates the lexical relationship between the two compares. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Condition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Less than zero   </td><td class="markdownTableBodyNone">str_a precedes str_b in the sort order.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">str_a occurs in the same position as str_b in the sort order.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Greater than zero   </td><td class="markdownTableBodyNone">str_a follows str_b in the sort order.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a897d161d82900b9f756cb79b479c5351" name="a897d161d82900b9f756cb79b479c5351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897d161d82900b9f756cb79b479c5351">&#9670;&#160;</a></span>concat() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates four specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_c</td><td>The third <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_d</td><td>The fourth <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of str_a, str_b, str_c and str_d. </dd></dl>

</div>
</div>
<a id="a45af237c4737e733b0ca2ced78e4fa95" name="a45af237c4737e733b0ca2ced78e4fa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45af237c4737e733b0ca2ced78e4fa95">&#9670;&#160;</a></span>concat() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class object_a_t , class object_b_t , class object_c_t , class object_d_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t&#160;</td>
          <td class="paramname"><em>obj_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t&#160;</td>
          <td class="paramname"><em>obj_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_c_t&#160;</td>
          <td class="paramname"><em>obj_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_d_t&#160;</td>
          <td class="paramname"><em>obj_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates four specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
    <tr><td class="paramname">obj_c</td><td>The third object to concatenate. </td></tr>
    <tr><td class="paramname">obj_d</td><td>The fourth object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a, obj_b, obj_c and obj_d. </dd></dl>

</div>
</div>
<a id="a72e3085a92a360bc1f6085145673dc64" name="a72e3085a92a360bc1f6085145673dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e3085a92a360bc1f6085145673dc64">&#9670;&#160;</a></span>concat() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates three specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_c</td><td>The third <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> The concatenation of str_a, str_b and str_c. </dd></dl>

</div>
</div>
<a id="a7e213408c3f1ed719e9df3f798ef2c2d" name="a7e213408c3f1ed719e9df3f798ef2c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e213408c3f1ed719e9df3f798ef2c2d">&#9670;&#160;</a></span>concat() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class object_a_t , class object_b_t , class object_c_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t&#160;</td>
          <td class="paramname"><em>obj_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t&#160;</td>
          <td class="paramname"><em>obj_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_c_t&#160;</td>
          <td class="paramname"><em>obj_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates three specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
    <tr><td class="paramname">obj_c</td><td>The third object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a, obj_b and obj_c. </dd></dl>

</div>
</div>
<a id="a9717df63b6c2f2372c428c637869da8a" name="a9717df63b6c2f2372c428c637869da8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9717df63b6c2f2372c428c637869da8a">&#9670;&#160;</a></span>concat() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two specified instances of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str_a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
    <tr><td class="paramname">str_b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> The concatenation of str_a and str_b. </dd></dl>

</div>
</div>
<a id="a03788833b277a559456d8adfc727218c" name="a03788833b277a559456d8adfc727218c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03788833b277a559456d8adfc727218c">&#9670;&#160;</a></span>concat() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class object_a_t , class object_b_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">object_a_t&#160;</td>
          <td class="paramname"><em>obj_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object_b_t&#160;</td>
          <td class="paramname"><em>obj_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two specified instances of object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>The first object to concatenate. </td></tr>
    <tr><td class="paramname">obj_b</td><td>The second object to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of obj_a and obj_b. </dd></dl>

</div>
</div>
<a id="ac81226baa5f8d9ba7538c7d8b4a3449b" name="ac81226baa5f8d9ba7538c7d8b4a3449b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81226baa5f8d9ba7538c7d8b4a3449b">&#9670;&#160;</a></span>concat() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the elements of a specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>An array of <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated elements of values. </dd></dl>

</div>
</div>
<a id="ab2df32b25b6236f532243869d9bc5541" name="ab2df32b25b6236f532243869d9bc5541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2df32b25b6236f532243869d9bc5541">&#9670;&#160;</a></span>concat() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; object_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representations of the elements in a specified object array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>An object array that contains the elements to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representations of the values of the elements in args. </dd></dl>

</div>
</div>
<a id="ac4994f61a96b71e100492512d0a8e9b5" name="ac4994f61a96b71e100492512d0a8e9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4994f61a96b71e100492512d0a8e9b5">&#9670;&#160;</a></span>concat() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">value_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representation of a specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to represent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> representation of the value of arg. </dd></dl>

</div>
</div>
<a id="a2778ed4d8fd85400ff448179da68a592" name="a2778ed4d8fd85400ff448179da68a592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2778ed4d8fd85400ff448179da68a592">&#9670;&#160;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::demangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets demangled <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> of name,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to demangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The demangled <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> of name. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example shows how to use <a class="el" href="classxtd_1_1basic__string.html#a2778ed4d8fd85400ff448179da68a592" title="Gets demangled basic_string of name,.">xtd::basic_string::demangle</a>. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;name = {}&quot;</span>, <span class="keyword">typeid</span>(<a class="code hl_class" href="classxtd_1_1date__time.html">xtd::date_time</a>).name());</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;demangled name = {}&quot;</span>, <a class="code hl_function" href="classxtd_1_1basic__string.html#a2778ed4d8fd85400ff448179da68a592">basic_string::demangle</a>(<span class="keyword">typeid</span>(<a class="code hl_class" href="classxtd_1_1date__time.html">xtd::date_time</a>).name()));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output on macOS :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// name = N3xtd9date_timeE</span></div>
<div class="line"><span class="comment">// demangled name = xtd::date_time</span></div>
<div class="ttc" id="aclassxtd_1_1basic__string_html_a2778ed4d8fd85400ff448179da68a592"><div class="ttname"><a href="classxtd_1_1basic__string.html#a2778ed4d8fd85400ff448179da68a592">xtd::basic_string::demangle</a></div><div class="ttdeci">static basic_string demangle(const basic_string &amp;name)</div><div class="ttdoc">Gets demangled basic_string of name,.</div><div class="ttdef"><b>Definition</b> basic_string.hpp:2211</div></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
<div class="ttc" id="aclassxtd_1_1date__time_html"><div class="ttname"><a href="classxtd_1_1date__time.html">xtd::date_time</a></div><div class="ttdoc">Represents an instant in time, typically expressed as a date and time of day.</div><div class="ttdef"><b>Definition</b> date_time.hpp:85</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.hpp:10</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6c9573cce5da4b27808874ef0c1aae00" name="a6c9573cce5da4b27808874ef0c1aae00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9573cce5da4b27808874ef0c1aae00">&#9670;&#160;</a></span>equals() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

</div>
</div>
<a id="a9d7ee87a503480f443dcefa417db2fe6" name="a9d7ee87a503480f443dcefa417db2fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7ee87a503480f443dcefa417db2fe6">&#9670;&#160;</a></span>equals() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class char_a_t , class char_b_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const char_a_t *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char_b_t *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal (case-sensitive) comparison. </dd></dl>

</div>
</div>
<a id="a47e41bbb8db6a246cf7965a565446ac8" name="a47e41bbb8db6a246cf7965a565446ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e41bbb8db6a246cf7965a565446ac8">&#9670;&#160;</a></span>equals() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing this instance and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal comparison. </dd></dl>

</div>
</div>
<a id="a7d99f1ae4294e002f20661d66567150f" name="a7d99f1ae4294e002f20661d66567150f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d99f1ae4294e002f20661d66567150f">&#9670;&#160;</a></span>equals() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class char_a_t , class char_b_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const char_a_t *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char_b_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two specified <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> objects have the same value, ignoring or honoring their case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> to compare. </td></tr>
    <tr><td class="paramname">ignore_case</td><td><code>true</code> to ignore case when comparing this instance and value; otherwise, <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs an ordinal comparison. </dd></dl>

</div>
</div>
<a id="ac003a2b39a8e6160043f9d3a8681a178" name="ac003a2b39a8e6160043f9d3a8681a178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac003a2b39a8e6160043f9d3a8681a178">&#9670;&#160;</a></span>full_class_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::full_class_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the objec_t, including the namespace of the objec_t. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the objec_t. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_&lt;object_t&gt;()</a>.full_name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="acc2dad45219c94eda3bd54742cc0a82a" name="acc2dad45219c94eda3bd54742cc0a82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2dad45219c94eda3bd54742cc0a82a">&#9670;&#160;</a></span>full_class_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(object)</a>.full_name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="a3f42e3b00b7c27ffa63cc8e48dde6aa4" name="a3f42e3b00b7c27ffa63cc8e48dde6aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f42e3b00b7c27ffa63cc8e48dde6aa4">&#9670;&#160;</a></span>full_class_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::full_class_name </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the fully qualified class name of the specified object, including the namespace of the specified object. </p>
<dl class="section return"><dt>Returns</dt><dd>The fully qualified class name of the objec_t, including the namespace of the specified object. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, the fully qualified name of the <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> type is <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group__keywords.html#gafa2ffd9b4a6568b57ab2731bec095d99" title="Used to obtain the type object of a specified type or object.">typeof_(info)</a>.full_name() - Will be removed in version 0.4.0. </dd></dl>

</div>
</div>
<a id="ab4bdd160233334a9b7d36af486906d4b" name="ab4bdd160233334a9b7d36af486906d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bdd160233334a9b7d36af486906d4b">&#9670;&#160;</a></span>is_empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; <a class="el" href="classxtd_1_1basic__string.html#aba30f417a9a6e82bb49c465428af7aa5">value_type</a>, <a class="el" href="classxtd_1_1basic__string.html#a4d949b3e7337c9e935ad6f8de390076f">traits_type</a>, <a class="el" href="classxtd_1_1basic__string.html#a19ed007365ca191ac40587fe9365f02a">allocator_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the specifeid <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> is an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to check if empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value parameter is null or an empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> (""); otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a8a7a51d0792107dd537730634b8fff12" name="a8a7a51d0792107dd537730634b8fff12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7a51d0792107dd537730634b8fff12">&#9670;&#160;</a></span>join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> consisting of the elements of value interspersed with the separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="test_forms_8cpp-example.html#a34">test_forms.cpp</a>, and <a class="el" href="uri_8cpp-example.html#a2">uri.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5aece978830816e4b33a685b27cc31e3" name="a5aece978830816e4b33a685b27cc31e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aece978830816e4b33a685b27cc31e3">&#9670;&#160;</a></span>join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first array element in value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> consisting of the elements of value interspersed with the separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a5012723424590a079c236dfdc8f8968e" name="a5012723424590a079c236dfdc8f8968e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5012723424590a079c236dfdc8f8968e">&#9670;&#160;</a></span>join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class collection_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const collection_t &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates a specified separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> between each element of a specified Object array, yielding a single concatenated <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> separator. </td></tr>
    <tr><td class="paramname">values</td><td>An array of Object. </td></tr>
    <tr><td class="paramname">start_index</td><td>The first array element in value to use. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements of value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> consisting of the elements of value interspersed with the separator <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example if separator is ", " and the elements of value are "red", "blue", "green", and "yellow", Join(separator, value) returns "red, blue, green, yellow". </dd>
<dd>
stream &lt;&lt; operator is called on each object to generate the content. </dd></dl>

</div>
</div>
<a id="a0616ee2fd16ff911dafe84b19522ec75" name="a0616ee2fd16ff911dafe84b19522ec75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0616ee2fd16ff911dafe84b19522ec75">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static value_t <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a value_t type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Ax <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to convert to value_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value_t object parsed. </dd></dl>

</div>
</div>
<a id="a389cf357f98d28ecb33f535462289251" name="a389cf357f98d28ecb33f535462289251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389cf357f98d28ecb33f535462289251">&#9670;&#160;</a></span>try_parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<div class="memtemplate">
template&lt;class value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::try_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char_t, traits_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to convert a <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a> into a value_t type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a> to convert to value_t </td></tr>
    <tr><td class="paramname">value</td><td>The value that will contain the parsed <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">xtd::basic_string</a>:=:try_parse succed; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="af6f4efe678e6742104ad6b0ddb3fc2db" name="af6f4efe678e6742104ad6b0ddb3fc2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f4efe678e6742104ad6b0ddb3fc2db">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html#a5a19c12dd03024a0b27ae68115bbfa2b">const_reference</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the character at specified location index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the character to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1index__out__of__range__exception.html" title="The exception that is thrown when an attempt is made to access an element of an array with an index t...">xtd::index_out_of_range_exception</a></td><td>If `index` is not within the range of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6775931e51f45aad56df1c249c578832" name="a6775931e51f45aad56df1c249c578832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6775931e51f45aad56df1c249c578832">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator const <a class="el" href="classxtd_1_1basic__string.html#a023c9110b9e82006d694c297f404e031">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a8e7fad567430f490e373f26b2d7dce9d" name="a8e7fad567430f490e373f26b2d7dce9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7fad567430f490e373f26b2d7dce9d">&#9670;&#160;</a></span>operator=() <span class="overload">[1/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a9c813a8edbc5272897079137ac03b1a2" name="a9c813a8edbc5272897079137ac03b1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c813a8edbc5272897079137ac03b1a2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a1ab02a07cc26e5c65be216bca381b38f" name="a1ab02a07cc26e5c65be216bca381b38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab02a07cc26e5c65be216bca381b38f">&#9670;&#160;</a></span>operator=() <span class="overload">[3/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="af878d5d6403d2336b18b4fe35bdd4182" name="af878d5d6403d2336b18b4fe35bdd4182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af878d5d6403d2336b18b4fe35bdd4182">&#9670;&#160;</a></span>operator=() <span class="overload">[4/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ae09eea471e56aea42786fa52c8126a3b" name="ae09eea471e56aea42786fa52c8126a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09eea471e56aea42786fa52c8126a3b">&#9670;&#160;</a></span>operator=() <span class="overload">[5/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a05124e1ea82616e66fc72599e5ba5914" name="a05124e1ea82616e66fc72599e5ba5914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05124e1ea82616e66fc72599e5ba5914">&#9670;&#160;</a></span>operator=() <span class="overload">[6/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a6a91c59bacaef916f4aa1e62a4730ae6" name="a6a91c59bacaef916f4aa1e62a4730ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a91c59bacaef916f4aa1e62a4730ae6">&#9670;&#160;</a></span>operator=() <span class="overload">[7/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a1ca40ecd701f4cb13da77ee3e1d30587" name="a1ca40ecd701f4cb13da77ee3e1d30587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca40ecd701f4cb13da77ee3e1d30587">&#9670;&#160;</a></span>operator=() <span class="overload">[8/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aee11528245223380dd77959002077fbe" name="aee11528245223380dd77959002077fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee11528245223380dd77959002077fbe">&#9670;&#160;</a></span>operator=() <span class="overload">[9/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ac411bdfb98de0504a5c126ed67e954a1" name="ac411bdfb98de0504a5c126ed67e954a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac411bdfb98de0504a5c126ed67e954a1">&#9670;&#160;</a></span>operator=() <span class="overload">[10/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in <code>str</code> is moved from <code>str</code> into this string). <code>str</code> is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="abb658b3e0ec4abe277533ac512bc3ae1" name="abb658b3e0ec4abe277533ac512bc3ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb658b3e0ec4abe277533ac512bc3ae1">&#9670;&#160;</a></span>operator=() <span class="overload">[11/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a2eb8217139ce12832231bf9d40b19bfd" name="a2eb8217139ce12832231bf9d40b19bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb8217139ce12832231bf9d40b19bfd">&#9670;&#160;</a></span>operator=() <span class="overload">[12/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="acc9e59b3bf597261e69cb3d3f051aadf" name="acc9e59b3bf597261e69cb3d3f051aadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9e59b3bf597261e69cb3d3f051aadf">&#9670;&#160;</a></span>operator=() <span class="overload">[13/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ad0786502cf54544309a1abf38184a307" name="ad0786502cf54544309a1abf38184a307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0786502cf54544309a1abf38184a307">&#9670;&#160;</a></span>operator=() <span class="overload">[14/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ab3e497c98372f90481ebd0e1bd21f315" name="ab3e497c98372f90481ebd0e1bd21f315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e497c98372f90481ebd0e1bd21f315">&#9670;&#160;</a></span>operator=() <span class="overload">[15/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a5d0ea7a997d8fc99967e72b32c5fdd38" name="a5d0ea7a997d8fc99967e72b32c5fdd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0ea7a997d8fc99967e72b32c5fdd38">&#9670;&#160;</a></span>operator=() <span class="overload">[16/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; char &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a12a9907eb2556368b2c970ef1c55d304" name="a12a9907eb2556368b2c970ef1c55d304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a9907eb2556368b2c970ef1c55d304">&#9670;&#160;</a></span>operator=() <span class="overload">[17/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a21c2848f242d67f32fb93125d465593d" name="a21c2848f242d67f32fb93125d465593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c2848f242d67f32fb93125d465593d">&#9670;&#160;</a></span>operator=() <span class="overload">[18/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aaf6fd1ff22ea00f8c10049954764abbc" name="aaf6fd1ff22ea00f8c10049954764abbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6fd1ff22ea00f8c10049954764abbc">&#9670;&#160;</a></span>operator=() <span class="overload">[19/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="abd9428692f29a5b0aeeaa868ec5be9f1" name="abd9428692f29a5b0aeeaa868ec5be9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9428692f29a5b0aeeaa868ec5be9f1">&#9670;&#160;</a></span>operator=() <span class="overload">[20/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="abbdeadc513f43dc2cf9ee771b5cccf65" name="abbdeadc513f43dc2cf9ee771b5cccf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdeadc513f43dc2cf9ee771b5cccf65">&#9670;&#160;</a></span>operator=() <span class="overload">[21/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="acb13ea20a7630c0c25d59d22c407a25e" name="acb13ea20a7630c0c25d59d22c407a25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb13ea20a7630c0c25d59d22c407a25e">&#9670;&#160;</a></span>operator=() <span class="overload">[22/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ae9180140c3cb5474a4de317d1b81c99a" name="ae9180140c3cb5474a4de317d1b81c99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9180140c3cb5474a4de317d1b81c99a">&#9670;&#160;</a></span>operator=() <span class="overload">[23/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a918e97c3c720478e2b1ff5cb8773de52" name="a918e97c3c720478e2b1ff5cb8773de52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918e97c3c720478e2b1ff5cb8773de52">&#9670;&#160;</a></span>operator=() <span class="overload">[24/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aeaa66ed4bee7575c0d6791f9d3c2e0b5" name="aeaa66ed4bee7575c0d6791f9d3c2e0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa66ed4bee7575c0d6791f9d3c2e0b5">&#9670;&#160;</a></span>operator=() <span class="overload">[25/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String litteral pointer to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">xtd::tring_null_pointer_exception</td><td>The `str` is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ae22b7f387671fa95ea8462c297905b1f" name="ae22b7f387671fa95ea8462c297905b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22b7f387671fa95ea8462c297905b1f">&#9670;&#160;</a></span>operator=() <span class="overload">[26/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a4bbfe5d2566ab0966a19775ea334b5b7" name="a4bbfe5d2566ab0966a19775ea334b5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbfe5d2566ab0966a19775ea334b5b7">&#9670;&#160;</a></span>operator=() <span class="overload">[27/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a>&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a20661ac7964f93e1cfbac62cec407934" name="a20661ac7964f93e1cfbac62cec407934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20661ac7964f93e1cfbac62cec407934">&#9670;&#160;</a></span>operator=() <span class="overload">[28/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a>&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a068c674dbbe9cf949e8f6fe1d25903a6" name="a068c674dbbe9cf949e8f6fe1d25903a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068c674dbbe9cf949e8f6fe1d25903a6">&#9670;&#160;</a></span>operator=() <span class="overload">[29/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a>&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="af78a2c22393147a7863d6612ea8ad596" name="af78a2c22393147a7863d6612ea8ad596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78a2c22393147a7863d6612ea8ad596">&#9670;&#160;</a></span>operator=() <span class="overload">[30/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a>&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with the specified character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa57338bbd9341a8316c97a0cb0b52a0b" name="aa57338bbd9341a8316c97a0cb0b52a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57338bbd9341a8316c97a0cb0b52a0b">&#9670;&#160;</a></span>operator=() <span class="overload">[31/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa1ab06b38248888f8efed9bc86a970d6" name="aa1ab06b38248888f8efed9bc86a970d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ab06b38248888f8efed9bc86a970d6">&#9670;&#160;</a></span>operator=() <span class="overload">[32/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a52100794dde1bf6c481e50e94091916a" name="a52100794dde1bf6c481e50e94091916a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52100794dde1bf6c481e50e94091916a">&#9670;&#160;</a></span>operator=() <span class="overload">[33/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa75927d980766139c7c20de14f1f8d13" name="aa75927d980766139c7c20de14f1f8d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75927d980766139c7c20de14f1f8d13">&#9670;&#160;</a></span>operator=() <span class="overload">[34/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aed652c5e92066a11e47a0dd6cd647c90" name="aed652c5e92066a11e47a0dd6cd647c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed652c5e92066a11e47a0dd6cd647c90">&#9670;&#160;</a></span>operator=() <span class="overload">[35/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of the specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initialiazer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="ab9f96281407a61fd50345eb7e2b8f7ca" name="ab9f96281407a61fd50345eb7e2b8f7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f96281407a61fd50345eb7e2b8f7ca">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="ad1e5dc85e2d471ae28f9957c4065248f" name="ad1e5dc85e2d471ae28f9957c4065248f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e5dc85e2d471ae28f9957c4065248f">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="ab58d46ec7ebf00e9bb57d8844bfa684d" name="ab58d46ec7ebf00e9bb57d8844bfa684d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58d46ec7ebf00e9bb57d8844bfa684d">&#9670;&#160;</a></span>operator+=() <span class="overload">[3/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a99fcc84e7cb9e168ed058dc58a3f4dfc" name="a99fcc84e7cb9e168ed058dc58a3f4dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fcc84e7cb9e168ed058dc58a3f4dfc">&#9670;&#160;</a></span>operator+=() <span class="overload">[4/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a1a84548f6b04aac050a32938bfe5e7c6" name="a1a84548f6b04aac050a32938bfe5e7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a84548f6b04aac050a32938bfe5e7c6">&#9670;&#160;</a></span>operator+=() <span class="overload">[5/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a6f21d4bbd734b2f65cf373c02a72e1ad" name="a6f21d4bbd734b2f65cf373c02a72e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f21d4bbd734b2f65cf373c02a72e1ad">&#9670;&#160;</a></span>operator+=() <span class="overload">[6/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; char &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a4eb5b1ef0dcf242170da7be8c770b1a9" name="a4eb5b1ef0dcf242170da7be8c770b1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb5b1ef0dcf242170da7be8c770b1a9">&#9670;&#160;</a></span>operator+=() <span class="overload">[7/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="ad3ad7d6ce3e3cfd9e32b049542eb8418" name="ad3ad7d6ce3e3cfd9e32b049542eb8418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ad7d6ce3e3cfd9e32b049542eb8418">&#9670;&#160;</a></span>operator+=() <span class="overload">[8/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a0e8d99044981bb8b49c438dd552b15c0" name="a0e8d99044981bb8b49c438dd552b15c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8d99044981bb8b49c438dd552b15c0">&#9670;&#160;</a></span>operator+=() <span class="overload">[9/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="ad891204bd0c088717a720bdf92f28212" name="ad891204bd0c088717a720bdf92f28212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad891204bd0c088717a720bdf92f28212">&#9670;&#160;</a></span>operator+=() <span class="overload">[10/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a>&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2fb3348705647e01e88be06aa3767894" name="a2fb3348705647e01e88be06aa3767894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb3348705647e01e88be06aa3767894">&#9670;&#160;</a></span>operator+=() <span class="overload">[11/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2b9bab82c073016f8b31a4f9afdb7ce8" name="a2b9bab82c073016f8b31a4f9afdb7ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9bab82c073016f8b31a4f9afdb7ce8">&#9670;&#160;</a></span>operator+=() <span class="overload">[12/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a9ea45b673c96bbe8fb31b5fcee7164a8" name="a9ea45b673c96bbe8fb31b5fcee7164a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea45b673c96bbe8fb31b5fcee7164a8">&#9670;&#160;</a></span>operator+=() <span class="overload">[13/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="accf189ea3fea2ff21c6afd2b226a2921" name="accf189ea3fea2ff21c6afd2b226a2921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf189ea3fea2ff21c6afd2b226a2921">&#9670;&#160;</a></span>operator+=() <span class="overload">[14/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="afba271dd4828ec9c22972ce98ed71543" name="afba271dd4828ec9c22972ce98ed71543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba271dd4828ec9c22972ce98ed71543">&#9670;&#160;</a></span>operator+=() <span class="overload">[15/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2769a07751f2040b086f2e532741c682" name="a2769a07751f2040b086f2e532741c682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2769a07751f2040b086f2e532741c682">&#9670;&#160;</a></span>operator+=() <span class="overload">[16/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="af555dcf021c5c3ced7e1a8bfbe5bfa50" name="af555dcf021c5c3ced7e1a8bfbe5bfa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af555dcf021c5c3ced7e1a8bfbe5bfa50">&#9670;&#160;</a></span>operator+=() <span class="overload">[17/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2c2a78449d887fa5d921f95856cd1487" name="a2c2a78449d887fa5d921f95856cd1487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2a78449d887fa5d921f95856cd1487">&#9670;&#160;</a></span>operator+=() <span class="overload">[18/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a9529e5baf23784330b6045f2ef2ec37f" name="a9529e5baf23784330b6045f2ef2ec37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9529e5baf23784330b6045f2ef2ec37f">&#9670;&#160;</a></span>operator+=() <span class="overload">[19/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a0ec59e366d520219d67a6ee712e07f34" name="a0ec59e366d520219d67a6ee712e07f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec59e366d520219d67a6ee712e07f34">&#9670;&#160;</a></span>operator+=() <span class="overload">[20/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a2bdc9356f22e6ff9139f4a81b93a6175" name="a2bdc9356f22e6ff9139f4a81b93a6175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdc9356f22e6ff9139f4a81b93a6175">&#9670;&#160;</a></span>operator+=() <span class="overload">[21/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="acda811c544170f9951af6d7bac8ba707" name="acda811c544170f9951af6d7bac8ba707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda811c544170f9951af6d7bac8ba707">&#9670;&#160;</a></span>operator+=() <span class="overload">[22/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga39d5c4947c807e5f78b8a9abe3692570">xtd::char16</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a7493fc8791204b6b8bde403fad729410" name="a7493fc8791204b6b8bde403fad729410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7493fc8791204b6b8bde403fad729410">&#9670;&#160;</a></span>operator+=() <span class="overload">[23/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga989a1148b6ff15567dca430966b17c92">xtd::char32</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a9bfdd130d8ea5f20c20fe15bf794b572" name="a9bfdd130d8ea5f20c20fe15bf794b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfdd130d8ea5f20c20fe15bf794b572">&#9670;&#160;</a></span>operator+=() <span class="overload">[24/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga1259090c8918e75847a8cb2a64b8912a">xtd::char8</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<a id="a29c75ef362acb78e3f0072b8cbdf3e19" name="a29c75ef362acb78e3f0072b8cbdf3e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c75ef362acb78e3f0072b8cbdf3e19">&#9670;&#160;</a></span>operator+=() <span class="overload">[25/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga155357d92cf162b71b396e46accee518">xtd::wchar</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. Appends additional characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character value to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance with characters added. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0ae9e9b0cbe9df3f4fc03f7e4682ef2e" name="a0ae9e9b0cbe9df3f4fc03f7e4682ef2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae9e9b0cbe9df3f4fc03f7e4682ef2e">&#9670;&#160;</a></span>empty_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1basic__string.html">basic_string</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::empty_string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the empty <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The value of this method is the zero-length <a class="el" href="classxtd_1_1basic__string.html" title="Represents text as a sequence of character units.">basic_string</a>, "". </dd></dl>

</div>
</div>
<a id="a9629cc4c296a49e4f99d718e8117689e" name="a9629cc4c296a49e4f99d718e8117689e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9629cc4c296a49e4f99d718e8117689e">&#9670;&#160;</a></span>npos</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class char_t , class traits_t , class allocator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classxtd_1_1basic__string.html#a84c19ff70f8314b59d8e711cadd91302">size_type</a> <a class="el" href="classxtd_1_1basic__string.html">xtd::basic_string</a>&lt; char_t, traits_t, allocator_t &gt;::npos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a special value equal to the maximum value representable by the type <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">xtd::size</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="test_forms_8cpp-example.html#a29">test_forms.cpp</a>.</dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/<a class="el" href="basic__string_8hpp_source.html">basic_string.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 9 2025 23:56:11 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
