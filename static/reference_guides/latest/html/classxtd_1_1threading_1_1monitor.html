<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::monitor Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1monitor.html">monitor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classxtd_1_1threading_1_1monitor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::monitor Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::monitor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1monitor.png" usemap="#xtd::threading::monitor_map" alt=""/>
  <map id="xtd::threading::monitor_map" name="xtd::threading::monitor_map">
<area href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted)." alt="xtd::static_object" shape="rect" coords="0,0,134,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a mechanism that synchronizes access to objects. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_class" href="classxtd_1_1threading_1_1monitor.html">monitor</a> <a class="code hl_define" href="group__keywords.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1monitor_html"><div class="ttname"><a href="classxtd_1_1threading_1_1monitor.html">xtd::threading::monitor</a></div><div class="ttdoc">Provides a mechanism that synchronizes access to objects.</div><div class="ttdef"><b>Definition</b> monitor.h:43</div></div>
<div class="ttc" id="agroup__keywords_html_ga28796443ec37b938df7072c79595e3f6"><div class="ttname"><a href="group__keywords.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div><div class="ttdeci">#define static_</div><div class="ttdoc">This keyword is use to represent a static object. A static object can't be instantiated (constructors...</div><div class="ttdef"><b>Definition</b> static.h:38</div></div>
<div class="ttc" id="agroup__keywords_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.h:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted).">xtd::static_object</a> â†’ <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/monitor&gt;</span> </div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example uses the <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a> class to synchronize access to a single instance of a random number generator represented by the <a class="el" href="classxtd_1_1random.html" title="Represents a pseudo-random number generator, a device that produces a sequence of numbers that meet c...">xtd::random</a> class. The example creates ten threads, each of which executes asynchronously on a thread pool thread. Each thread generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum. After all threads have executed, these two values are then used to calculate the overall mean. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/interlocked&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/monitor&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/literals&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/random&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/startup&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1threading.html">xtd::threading</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>monitor_example {</div>
<div class="line">  <span class="keyword">class </span>program {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">      <span class="keyword">auto</span> threads = std::vector&lt;thread&gt; {};</div>
<div class="line">      <span class="keyword">auto</span> rnd = <a class="code hl_class" href="classxtd_1_1random.html">xtd::random</a> {};</div>
<div class="line">      <span class="keyword">auto</span> total = 0_s64;</div>
<div class="line">      <span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a> = 0;</div>
<div class="line">      </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> thread_ctr = 0; thread_ctr &lt; 10; ++thread_ctr)</div>
<div class="line">        threads.push_back(thread::start_new(<a class="code hl_typedef" href="group__xtd__core.html#ga629e09da122fad73508fa0fb6286fd0a">thread_start</a> {[&amp;] {</div>
<div class="line">          auto values = std::array&lt;int, 10000&gt; {};</div>
<div class="line">          auto thread_total = 0;</div>
<div class="line">          auto thread_n = 0;</div>
<div class="line">          auto ctr = 0;</div>
<div class="line">          monitor::enter(rnd);</div>
<div class="line">          <span class="comment">// Generate 10,000 random integers</span></div>
<div class="line">          for (ctr = 0; ctr &lt; 10000; ++ctr)</div>
<div class="line">            values[ctr] = rnd.next(0, 1001);</div>
<div class="line">          monitor::exit(rnd);</div>
<div class="line">          thread_n = ctr;</div>
<div class="line">          for (auto value : values)</div>
<div class="line">            thread_total += value;</div>
<div class="line">          </div>
<div class="line">          console::write_line(<span class="stringliteral">&quot;Mean for task {0,2}: {1:N2} (N={2:N0})&quot;</span>,</div>
<div class="line">                              thread::current_thread().managed_thread_id(),</div>
<div class="line">                              (thread_total * 1.0) / thread_n, thread_n);</div>
<div class="line">          interlocked::add(n, thread_n);</div>
<div class="line">          interlocked::add(total, thread_total);</div>
<div class="line">        }}));</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a> : threads)</div>
<div class="line">          <a class="code hl_class" href="classxtd_1_1threading_1_1thread.html">thread</a>.join();</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;\nMean for all tasks: {0:N2} (N={1:N0})&quot;</span>,</div>
<div class="line">                            (total * 1.0)/n, n);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1system__exception.html">system_exception</a>&amp; e) {</div>
<div class="line">        console::write_line(<span class="stringliteral">&quot;{0}: {1}&quot;</span>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.get_type().name(), <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">e</a>.message());</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(monitor_example::program::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example produces output similar to the following:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Mean for task  4: 498.90 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  2: 499.92 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  7: 503.12 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  5: 499.41 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  3: 498.58 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  8: 496.71 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task 10: 501.49 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  6: 498.84 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task  9: 502.72 (N=10000)</span></div>
<div class="line"><span class="comment">// Mean for task 11: 498.69 (N=10000)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Mean for all tasks: 499.84 (N=100000)</span></div>
<div class="ttc" id="aclassxtd_1_1random_html"><div class="ttname"><a href="classxtd_1_1random.html">xtd::random</a></div><div class="ttdoc">Represents a pseudo-random number generator, a device that produces a sequence of numbers that meet c...</div><div class="ttdef"><b>Definition</b> random.h:37</div></div>
<div class="ttc" id="aclassxtd_1_1system__exception_html"><div class="ttname"><a href="classxtd_1_1system__exception.html">xtd::system_exception</a></div><div class="ttdoc">Defines the base class for predefined exceptions in the xtd namespace.</div><div class="ttdef"><b>Definition</b> system_exception.h:24</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread_html"><div class="ttname"><a href="classxtd_1_1threading_1_1thread.html">xtd::threading::thread</a></div><div class="ttdoc">Creates and controls a thread, sets its priority, and gets its status.</div><div class="ttdef"><b>Definition</b> thread.h:42</div></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.h:162</div></div>
<div class="ttc" id="agroup__xtd__core_html_ga629e09da122fad73508fa0fb6286fd0a"><div class="ttname"><a href="group__xtd__core.html#ga629e09da122fad73508fa0fb6286fd0a">xtd::threading::thread_start</a></div><div class="ttdeci">action&lt;&gt; thread_start</div><div class="ttdoc">Represents the method that executes on a xtd::threading::thread.</div><div class="ttdef"><b>Definition</b> thread_start.h:19</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">xtd::console_key::n</a></div><div class="ttdeci">@ n</div><div class="ttdoc">The N key.</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2ae1671797c52e15f763380b45e841ec32">xtd::console_key::e</a></div><div class="ttdeci">@ e</div><div class="ttdoc">The E key.</div></div>
<div class="ttc" id="anamespacextd_1_1threading_html"><div class="ttname"><a href="namespacextd_1_1threading.html">xtd::threading</a></div><div class="ttdoc">The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....</div><div class="ttdef"><b>Definition</b> abandoned_mutex_exception.h:10</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> system_report.h:17</div></div>
</div><!-- fragment --> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods</h2></td></tr>
<tr class="memitem:afabaf5361f6d4dd04701dd1973d0a0f9"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:afabaf5361f6d4dd04701dd1973d0a0f9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#afabaf5361f6d4dd04701dd1973d0a0f9">enter</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:afabaf5361f6d4dd04701dd1973d0a0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires an exclusive lock on the specified obj.  <br /></td></tr>
<tr class="separator:afabaf5361f6d4dd04701dd1973d0a0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad2ab8bb155091207b7d5ad4ff1280c"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:afad2ab8bb155091207b7d5ad4ff1280c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#afad2ab8bb155091207b7d5ad4ff1280c">enter</a> (const object_t &amp;obj, bool &amp;lock_taken)</td></tr>
<tr class="memdesc:afad2ab8bb155091207b7d5ad4ff1280c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires an exclusive lock on the specified obj.  <br /></td></tr>
<tr class="separator:afad2ab8bb155091207b7d5ad4ff1280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bbf98eb3c316c3ca6db252d41ff57e"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a53bbf98eb3c316c3ca6db252d41ff57e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#a53bbf98eb3c316c3ca6db252d41ff57e">is_entered</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:a53bbf98eb3c316c3ca6db252d41ff57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires an exclusive lock on the specified obj.  <br /></td></tr>
<tr class="separator:a53bbf98eb3c316c3ca6db252d41ff57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02075512c6dc3fb73840910466cca815"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a02075512c6dc3fb73840910466cca815"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#a02075512c6dc3fb73840910466cca815">pulse</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:a02075512c6dc3fb73840910466cca815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a thread in the waiting queue of a change in the locked object's state.  <br /></td></tr>
<tr class="separator:a02075512c6dc3fb73840910466cca815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362df17ae1c2d6e99ae2d272805c2dcb"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a362df17ae1c2d6e99ae2d272805c2dcb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#a362df17ae1c2d6e99ae2d272805c2dcb">pulse_all</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:a362df17ae1c2d6e99ae2d272805c2dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies all waiting threads of a change in the object's state.  <br /></td></tr>
<tr class="separator:a362df17ae1c2d6e99ae2d272805c2dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511fd1ffb8c451222fe4071f7a19f243"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a511fd1ffb8c451222fe4071f7a19f243"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#a511fd1ffb8c451222fe4071f7a19f243">exit</a> (const object_t &amp;obj)</td></tr>
<tr class="memdesc:a511fd1ffb8c451222fe4071f7a19f243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an exclusive lock on the specified obj.  <br /></td></tr>
<tr class="separator:a511fd1ffb8c451222fe4071f7a19f243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6c3abf3a67c1ea400c2c63002ffd1d"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a2d6c3abf3a67c1ea400c2c63002ffd1d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#a2d6c3abf3a67c1ea400c2c63002ffd1d">try_enter</a> (const object_t &amp;obj) noexcept</td></tr>
<tr class="memdesc:a2d6c3abf3a67c1ea400c2c63002ffd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a2d6c3abf3a67c1ea400c2c63002ffd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3e78c724e33a7573d95e7c262961e"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:afbb3e78c724e33a7573d95e7c262961e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#afbb3e78c724e33a7573d95e7c262961e">try_enter</a> (const object_t &amp;obj, bool &amp;lock_taken) noexcept</td></tr>
<tr class="memdesc:afbb3e78c724e33a7573d95e7c262961e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:afbb3e78c724e33a7573d95e7c262961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e596d515e48f52e357ee7b87b258048"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a7e596d515e48f52e357ee7b87b258048"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#a7e596d515e48f52e357ee7b87b258048">try_enter</a> (const object_t &amp;obj, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout) noexcept</td></tr>
<tr class="memdesc:a7e596d515e48f52e357ee7b87b258048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a7e596d515e48f52e357ee7b87b258048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebb588113749b4905385f1c40b8b383"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a3ebb588113749b4905385f1c40b8b383"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#a3ebb588113749b4905385f1c40b8b383">try_enter</a> (const object_t &amp;obj, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout, bool &amp;lock_taken) noexcept</td></tr>
<tr class="memdesc:a3ebb588113749b4905385f1c40b8b383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a3ebb588113749b4905385f1c40b8b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6f9c0d2fb7cd11d4fad2c1750a1bb7"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:afd6f9c0d2fb7cd11d4fad2c1750a1bb7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#afd6f9c0d2fb7cd11d4fad2c1750a1bb7">try_enter</a> (const object_t &amp;obj, <a class="el" href="group__types.html#ga7ab879ebcae19d6021222f00537cfdce">int64</a> milliseconds_timeout) noexcept</td></tr>
<tr class="memdesc:afd6f9c0d2fb7cd11d4fad2c1750a1bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:afd6f9c0d2fb7cd11d4fad2c1750a1bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbf60d0c81756e2c34d1dc5336dc31c"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a2bbf60d0c81756e2c34d1dc5336dc31c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#a2bbf60d0c81756e2c34d1dc5336dc31c">try_enter</a> (const object_t &amp;obj, <a class="el" href="group__types.html#ga7ab879ebcae19d6021222f00537cfdce">int64</a> milliseconds_timeout, bool &amp;lock_taken) noexcept</td></tr>
<tr class="memdesc:a2bbf60d0c81756e2c34d1dc5336dc31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a2bbf60d0c81756e2c34d1dc5336dc31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9c4422ca36bc1af1de59aa68c5e795"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:a2f9c4422ca36bc1af1de59aa68c5e795"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#a2f9c4422ca36bc1af1de59aa68c5e795">try_enter</a> (const object_t &amp;obj, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>) noexcept</td></tr>
<tr class="memdesc:a2f9c4422ca36bc1af1de59aa68c5e795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:a2f9c4422ca36bc1af1de59aa68c5e795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02a91612d5aff072456943c35716549"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:aa02a91612d5aff072456943c35716549"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1monitor.html#aa02a91612d5aff072456943c35716549">try_enter</a> (const object_t &amp;obj, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>, bool &amp;lock_taken) noexcept</td></tr>
<tr class="memdesc:aa02a91612d5aff072456943c35716549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.  <br /></td></tr>
<tr class="separator:aa02a91612d5aff072456943c35716549"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afabaf5361f6d4dd04701dd1973d0a0f9" name="afabaf5361f6d4dd04701dd1973d0a0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabaf5361f6d4dd04701dd1973d0a0f9">&#9670;&#160;</a></span>enter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires an exclusive lock on the specified obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the monitor lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use Enter to acquire the Monitor on the object passed as the parameter. If another thread has executed an Enter on the object, but has not yet executed the corresponding Exit, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke Enter more than once without it blocking; however, an equal number of Exit calls must be invoked before other threads waiting on the object will unblock. </dd>
<dd>
Usex Monitor to lock objects (that is, reference types), not value types. When you pass a value type variable to Enter, it is boxed as an object. If you pass the same variable to Enter again, the thread is block. The code that Monitor is supposedly protecting is not protected. Furthermore, when you pass the variable to Exit, still another separate object is created. Because the object passed to Exit is different from the object passed to Enter, Monitor throws SynchronizationLockException. For details, see the conceptual topic Monitors. </dd></dl>

</div>
</div>
<a id="afad2ab8bb155091207b7d5ad4ff1280c" name="afad2ab8bb155091207b7d5ad4ff1280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad2ab8bb155091207b7d5ad4ff1280c">&#9670;&#160;</a></span>enter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires an exclusive lock on the specified obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the monitor lock. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be false. The output is true if the lock is acquired; otherwise, the output is false. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always true. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use Enter to acquire the Monitor on the object passed as the parameter. If another thread has executed an Enter on the object, but has not yet executed the corresponding Exit, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke Enter more than once without it blocking; however, an equal number of Exit calls must be invoked before other threads waiting on the object will unblock. </dd>
<dd>
Use Monitor to lock objects (that is, reference types), not value types. When you pass a value type variable to Enter, it is boxed as an object. If you pass the same variable to Enter again, the thread is block. The code that Monitor is supposedly protecting is not protected. Furthermore, when you pass the variable to Exit, still another separate object is created. Because the object passed to Exit is different from the object passed to Enter, Monitor throws SynchronizationLockException. For details, see the conceptual topic Monitors. </dd></dl>

</div>
</div>
<a id="a511fd1ffb8c451222fe4071f7a19f243" name="a511fd1ffb8c451222fe4071f7a19f243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511fd1ffb8c451222fe4071f7a19f243">&#9670;&#160;</a></span>exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::exit </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases an exclusive lock on the specified obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to release the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The calling thread must own the lock on the obj parameter. If the calling thread owns the lock on the specified object, and has made an equal number of Exit and Enter calls for the object, then the lock is released. If the calling thread has not invoked Exit as many times as Enter, the lock is not released. </dd>
<dd>
If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock. If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls Exit. To move one or more waiting threads into the ready queue, call Pulse or PulseAll before invoking Exit. </dd></dl>

</div>
</div>
<a id="a53bbf98eb3c316c3ca6db252d41ff57e" name="a53bbf98eb3c316c3ca6db252d41ff57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bbf98eb3c316c3ca6db252d41ff57e">&#9670;&#160;</a></span>is_entered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::is_entered </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires an exclusive lock on the specified obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the monitor lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use Enter to acquire the Monitor on the object passed as the parameter. If another thread has executed an Enter on the object, but has not yet executed the corresponding Exit, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke Enter more than once without it blocking; however, an equal number of Exit calls must be invoked before other threads waiting on the object will unblock. </dd>
<dd>
Usex Monitor to lock objects (that is, reference types), not value types. When you pass a value type variable to Enter, it is boxed as an object. If you pass the same variable to Enter again, the thread is block. The code that Monitor is supposedly protecting is not protected. Furthermore, when you pass the variable to Exit, still another separate object is created. Because the object passed to Exit is different from the object passed to Enter, Monitor throws SynchronizationLockException. For details, see the conceptual topic Monitors. </dd></dl>

</div>
</div>
<a id="a02075512c6dc3fb73840910466cca815" name="a02075512c6dc3fb73840910466cca815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02075512c6dc3fb73840910466cca815">&#9670;&#160;</a></span>pulse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::pulse </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a thread in the waiting queue of a change in the locked object's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object a thread is waiting for. Only the current owner of the lock can signal a waiting object using Pulse. The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock. Upon receiving the pulse, the waiting thread is moved to the ready queue. When the thread that invoked Pulse releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a362df17ae1c2d6e99ae2d272805c2dcb" name="a362df17ae1c2d6e99ae2d272805c2dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362df17ae1c2d6e99ae2d272805c2dcb">&#9670;&#160;</a></span>pulse_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::monitor::pulse_all </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies all waiting threads of a change in the object's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object a thread is waiting for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object. After the signal is sent, the waiting threads are moved to the ready queue. When the thread that invoked PulseAll releases the lock, the next thread in the ready queue acquires the lock. </dd>
<dd>
Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </dd>
<dd>
The Pulse, PulseAll, and Wait methods must be invoked from within a synchronized block of code. </dd>
<dd>
The remarks for the Pulse method explain what happens if Pulse is called when no threads are waiting. </dd>
<dd>
To signal a single thread, use the Pulse method. </dd></dl>

</div>
</div>
<a id="a2d6c3abf3a67c1ea400c2c63002ffd1d" name="a2d6c3abf3a67c1ea400c2c63002ffd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6c3abf3a67c1ea400c2c63002ffd1d">&#9670;&#160;</a></span>try_enter() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the current thread acquires the lock; otherwise, false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If successful, this method acquires an exclusive lock on the obj parameter. This method returns immediately, whether or not the lock is available. </dd>
<dd>
This method is similar to Enter, but it will never block. If the thread cannot enter without blocking, the method returns false, and the thread does not enter the critical section. </dd></dl>

</div>
</div>
<a id="afbb3e78c724e33a7573d95e7c262961e" name="afbb3e78c724e33a7573d95e7c262961e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb3e78c724e33a7573d95e7c262961e">&#9670;&#160;</a></span>try_enter() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be false. The output is true if the lock is acquired; otherwise, the output is false. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always true. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the current thread acquires the lock; otherwise, false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If successful, this method acquires an exclusive lock on the obj parameter. This method returns immediately, whether or not the lock is available. </dd>
<dd>
This method is similar to Enter, but it will never block. If the thread cannot enter without blocking, the method returns false, and the thread does not enter the critical section. </dd></dl>

</div>
</div>
<a id="a2f9c4422ca36bc1af1de59aa68c5e795" name="a2f9c4422ca36bc1af1de59aa68c5e795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9c4422ca36bc1af1de59aa68c5e795">&#9670;&#160;</a></span>try_enter() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">time_span</a> representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the current thread acquires the lock; otherwise, false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the value of the timeout parameter converted to milliseconds equals -1, this method is equivalent to Enter. If the value of timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="aa02a91612d5aff072456943c35716549" name="aa02a91612d5aff072456943c35716549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02a91612d5aff072456943c35716549">&#9670;&#160;</a></span>try_enter() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">time_span</a> representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be false. The output is true if the lock is acquired; otherwise, the output is false. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always true. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the current thread acquires the lock; otherwise, false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the value of the timeout parameter converted to milliseconds equals -1, this method is equivalent to Enter. If the value of timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="a7e596d515e48f52e357ee7b87b258048" name="a7e596d515e48f52e357ee7b87b258048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e596d515e48f52e357ee7b87b258048">&#9670;&#160;</a></span>try_enter() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the current thread acquires the lock; otherwise, false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the milliseconds_timeout parameter equals Timeout::Infinite, this method is equivalent to Enter. If milliseconds_timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="a3ebb588113749b4905385f1c40b8b383" name="a3ebb588113749b4905385f1c40b8b383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebb588113749b4905385f1c40b8b383">&#9670;&#160;</a></span>try_enter() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the lock. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be false. The output is true if the lock is acquired; otherwise, the output is false. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always true. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the current thread acquires the lock; otherwise, false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the milliseconds_timeout parameter equals Timeout::Infinite, this method is equivalent to Enter. If milliseconds_timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="afd6f9c0d2fb7cd11d4fad2c1750a1bb7" name="afd6f9c0d2fb7cd11d4fad2c1750a1bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6f9c0d2fb7cd11d4fad2c1750a1bb7">&#9670;&#160;</a></span>try_enter() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga7ab879ebcae19d6021222f00537cfdce">int64</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the current thread acquires the lock; otherwise, false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the milliseconds_timeout parameter equals Timeout::Infinite, this method is equivalent to Enter. If milliseconds_timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<a id="a2bbf60d0c81756e2c34d1dc5336dc31c" name="a2bbf60d0c81756e2c34d1dc5336dc31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbf60d0c81756e2c34d1dc5336dc31c">&#9670;&#160;</a></span>try_enter() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename object_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::monitor::try_enter </td>
          <td>(</td>
          <td class="paramtype">const object_t &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga7ab879ebcae19d6021222f00537cfdce">int64</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object on which to acquire the lock. </td></tr>
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for the lock. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>The result of the attempt to acquire the lock, passed by reference. The input must be false. The output is true if the lock is acquired; otherwise, the output is false. The output is set even if an exception occurs during the attempt to acquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If no exception occurs, the output of this method is always true. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the current thread acquires the lock; otherwise, false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the milliseconds_timeout parameter equals Timeout::Infinite, this method is equivalent to Enter. If milliseconds_timeout equals 0, this method is equivalent to try_enter. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="monitor_8h_source.html">monitor.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 5 2023 22:25:23 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
