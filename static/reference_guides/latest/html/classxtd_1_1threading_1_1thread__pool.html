<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::thread_pool Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html">thread_pool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classxtd_1_1threading_1_1thread__pool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::thread_pool Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::thread_pool:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1thread__pool.png" usemap="#xtd::threading::thread_5Fpool_map" alt=""/>
  <map id="xtd::threading::thread_5Fpool_map" name="xtd::threading::thread_5Fpool_map">
<area href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted)." alt="xtd::static_object" shape="rect" coords="0,0,160,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_define" href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a> <a class="code hl_class" href="classxtd_1_1threading_1_1thread__pool.html">thread_pool</a> <a class="code hl_define" href="group__keywords.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1thread__pool_html"><div class="ttname"><a href="classxtd_1_1threading_1_1thread__pool.html">xtd::threading::thread_pool</a></div><div class="ttdoc">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...</div><div class="ttdef"><b>Definition</b> thread_pool.h:50</div></div>
<div class="ttc" id="agroup__keywords_html_ga28796443ec37b938df7072c79595e3f6"><div class="ttname"><a href="group__keywords.html#ga28796443ec37b938df7072c79595e3f6">static_</a></div><div class="ttdeci">#define static_</div><div class="ttdoc">This keyword is use to represent a static object. A static object can't be instantiated (constructors...</div><div class="ttdef"><b>Definition</b> static.h:37</div></div>
<div class="ttc" id="agroup__keywords_html_gabc8f9c2aa36f6cee610a37f0e8227fd1"><div class="ttname"><a href="group__keywords.html#gabc8f9c2aa36f6cee610a37f0e8227fd1">core_export_</a></div><div class="ttdeci">#define core_export_</div><div class="ttdoc">Define shared library export.</div><div class="ttdef"><b>Definition</b> core_export.h:13</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Inheritance</dt><dd><a class="el" href="classxtd_1_1static__object.html" title="Represent a static object. A static class can&#39;t be instantiated (constructors are deleted).">xtd::static_object</a> â†’ <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread_pool&gt;</span> </div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>In the following example, the main application thread queues a method named ThreadProc to execute on a thread pool thread, sleeps for one second, and then exits. The ThreadProc method simply displays a message. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/auto_reset_event&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/threading/thread_pool&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/console&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/date_time&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/random&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xtd/startup&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1threading.html">xtd::threading</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>wait_handle_example {</div>
<div class="line">  <span class="keyword">class </span>program {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> main() {</div>
<div class="line">      <span class="comment">// Queue the task.</span></div>
<div class="line">      thread_pool::queue_user_work_item({thread_proc});</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;Main thread does some work, then sleeps.&quot;</span>);</div>
<div class="line">      thread::sleep(1000);</div>
<div class="line">      </div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;Main thread exits.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// This thread procedure performs the task.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> thread_proc(std::any state_info) {</div>
<div class="line">      <span class="comment">// No state object was passed to queue_user_work_item, so state_info has no value.</span></div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;Hello from the thread pool.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(wait_handle_example::program::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example produces output similar to the following:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Main thread does some work, then sleeps.</span></div>
<div class="line"><span class="comment">// Hello from the thread pool.</span></div>
<div class="line"><span class="comment">// Main thread exits.</span></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.h:162</div></div>
<div class="ttc" id="anamespacextd_1_1threading_html"><div class="ttname"><a href="namespacextd_1_1threading.html">xtd::threading</a></div><div class="ttdoc">The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....</div><div class="ttdef"><b>Definition</b> abandoned_mutex_exception.h:10</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> xtd_about_box.h:10</div></div>
</div><!-- fragment --> If you comment out the call to the <a class="el" href="classxtd_1_1threading_1_1thread.html#a42bc6e2bb805f928e50ae73d243b95f2" title="Suspends the current thread for a specified time.">xtd::threading::thread::sleep</a> method, the main thread exits before method runs on the thread pool thread. The thread pool uses background threads, which do not keep the application running if all foreground threads have terminated. (This is a simple example of a race condition.) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur. Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information. The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system. Examples of operations that use thread pool threads include the following:<ul>
<li>When you create a xtd::threading::task::task or xtd::threading::task::task &lt; result_t &gt; object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</li>
<li>Asynchronous timers use the thread pool. Thread pool threads execute callbacks from the <a class="el" href="classxtd_1_1threading_1_1timer.html" title="Provides a mechanism for executing a method on a thread pool thread at specified intervals....">xtd::threading::timer</a> class and raise events from the <a class="el" href="classxtd_1_1timers_1_1timer.html" title="Generates an event after a set interval, with an option to generate recurring events.">xtd::timers::timer</a> class.</li>
<li>When you use registered wait handles, a system thread monitors the status of the wait handles. When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</li>
<li>When you call the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a6e1d511cd1dbe0a07b98128042118f3c" title="Queues a method for execution. The method executes when a thread pool thread becomes available.">xtd::threading::thread_pool::queue_user_work_item</a> method to queue a method for execution on a thread pool thread. You do this by passing the method a <a class="el" href="group__xtd__core.html#ga8e591282c14ed5ae0c0038b503b1373d" title="Represents a callback method to be executed by a thread pool thread.">xtd::threading::wait_callback</a> delegate. The delegate has the signature @verbatom using wait_callback = <a class="el" href="group__xtd__core.html#ga53c721aac682a7ccf19ee17d92280e31" title="Represents a xtd::delegate that has variable parameters and does not return a value.">action&lt;std::any&gt;</a>  where state is an object that contains data to be used by the delegate. The actual data can be passed to the delegate by calling the xtd::threading::thread_pool::queue_user_work_item(xtd::threading::wait_callback, std::any) method. </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The threads in the managed thread pool are background threads. That is, their <a class="el" href="classxtd_1_1threading_1_1thread.html#a11f3c0ca7be2108803058899a895193e" title="Gets a value indicating whether or not a thread is a background thread.">xtd::threading::thread::is_background</a> properties are true. This means that a <a class="el" href="classxtd_1_1threading_1_1thread__pool.html" title="Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I...">xtd::threading::thread_pool</a> thread will not keep an application running after all foreground threads have exited. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>You can also queue work items that are not related to a wait operation to the thread pool. To request that a work item be handled by a thread in the thread pool, call the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a6e1d511cd1dbe0a07b98128042118f3c" title="Queues a method for execution. The method executes when a thread pool thread becomes available.">xtd::threading::thread_pool::queue_user_work_item</a> method. This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool. There is no way to cancel a work item after it has been queued. </dd>
<dd>
Timer-queue timers and registered wait operations also use the thread pool. Their callback functions are queued to the thread pool. </dd>
<dd>
There is one thread pool per process.The default size of the thread pool for a process depends on several factors, such as the size of the virtual address space. A process can call the xtd::threading::thread_pool::gt_max_threads method to determine the number of threads. The number of threads in the thread pool can be changed by using the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a35f26921fd206db30d10595147869ac5" title="Sets the number of requests to the thread pool that can be active concurrently. All requests above th...">xtd::threading::thread_pool::set_max_threads</a> method. Each thread uses the default stack size and runs at the default priority. </dd>
<dd>
The thread pool provides new worker threads or I/O completion threads on demand until it reaches the maximum for each category. When a maximum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. The thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When demand is low, the actual number of thread pool threads can fall below the minimum values. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>You can use the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a9d286fb4b631f16224678853d0f86669" title="Retrieves the number of idle threads the thread pool maintains in anticipation of new requests....">xtd::threading::thread_pool::get_min_threads</a> method to obtain these minimum values. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You can use the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a5c3b43e653cf43209dcc846c4f2070f9" title="Sets the number of idle threads the thread pool maintains in anticipation of new requests.">xtd::threading::thread_pool::set_min_threads</a> method to increase the minimum number of threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods</h2></td></tr>
<tr class="memitem:a67c0921c9e154215c14cf459b9d0f3ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a67c0921c9e154215c14cf459b9d0f3ed">close</a> ()</td></tr>
<tr class="memdesc:a67c0921c9e154215c14cf459b9d0f3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all resources and worker threads.  <br /></td></tr>
<tr class="separator:a67c0921c9e154215c14cf459b9d0f3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac881c038fd40c50b3e05f885dceb4a22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#ac881c038fd40c50b3e05f885dceb4a22">get_available_threads</a> (size_t &amp;worker_threads, size_t &amp;completion_port_threads)</td></tr>
<tr class="memdesc:ac881c038fd40c50b3e05f885dceb4a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the difference between the maximum number of thread pool threads returned by the GetMaxThreads method, and the number currently active.  <br /></td></tr>
<tr class="separator:ac881c038fd40c50b3e05f885dceb4a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69068aac907ee0c13a7e4cd699c09c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#af69068aac907ee0c13a7e4cd699c09c7">get_max_threads</a> (size_t &amp;worker_threads, size_t &amp;completion_port_threads)</td></tr>
<tr class="memdesc:af69068aac907ee0c13a7e4cd699c09c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.  <br /></td></tr>
<tr class="separator:af69068aac907ee0c13a7e4cd699c09c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d286fb4b631f16224678853d0f86669"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a9d286fb4b631f16224678853d0f86669">get_min_threads</a> (size_t &amp;worker_threads, size_t &amp;completion_port_threads)</td></tr>
<tr class="memdesc:a9d286fb4b631f16224678853d0f86669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of idle threads the thread pool maintains in anticipation of new requests. Always 0 for both.  <br /></td></tr>
<tr class="separator:a9d286fb4b631f16224678853d0f86669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448cec08735d8f22c79b2acb832130f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a448cec08735d8f22c79b2acb832130f9">join_all</a> ()</td></tr>
<tr class="memdesc:a448cec08735d8f22c79b2acb832130f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join all resources and worker threads.  <br /></td></tr>
<tr class="separator:a448cec08735d8f22c79b2acb832130f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46511ae8bfea10f66ee96fb3b9cf3374"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a46511ae8bfea10f66ee96fb3b9cf3374">join_all</a> (<a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout)</td></tr>
<tr class="memdesc:a46511ae8bfea10f66ee96fb3b9cf3374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join all resources and worker threads.  <br /></td></tr>
<tr class="separator:a46511ae8bfea10f66ee96fb3b9cf3374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da6db77a7e9173bd1db7c1e8122c10d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a5da6db77a7e9173bd1db7c1e8122c10d">join_all</a> (const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>)</td></tr>
<tr class="memdesc:a5da6db77a7e9173bd1db7c1e8122c10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join all resources and worker threads.  <br /></td></tr>
<tr class="separator:a5da6db77a7e9173bd1db7c1e8122c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1d511cd1dbe0a07b98128042118f3c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a6e1d511cd1dbe0a07b98128042118f3c">queue_user_work_item</a> (const <a class="el" href="group__xtd__core.html#ga8e591282c14ed5ae0c0038b503b1373d">wait_callback</a> &amp;callback)</td></tr>
<tr class="memdesc:a6e1d511cd1dbe0a07b98128042118f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a method for execution. The method executes when a thread pool thread becomes available.  <br /></td></tr>
<tr class="separator:a6e1d511cd1dbe0a07b98128042118f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495589d2c33d3b82fa4e8478a2082088"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a495589d2c33d3b82fa4e8478a2082088">queue_user_work_item</a> (const <a class="el" href="group__xtd__core.html#ga8e591282c14ed5ae0c0038b503b1373d">wait_callback</a> &amp;callback, std::any state)</td></tr>
<tr class="memdesc:a495589d2c33d3b82fa4e8478a2082088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a method for execution. The method executes when a thread pool thread becomes available.  <br /></td></tr>
<tr class="separator:a495589d2c33d3b82fa4e8478a2082088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cce31828de40647b89320b2ace3a5e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a21cce31828de40647b89320b2ace3a5e">register_wait_for_single_object</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;wait_object, const <a class="el" href="group__xtd__core.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;callback, std::any state, <a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a> milliseconds_timeout_interval, bool execute_only_once)</td></tr>
<tr class="memdesc:a21cce31828de40647b89320b2ace3a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.  <br /></td></tr>
<tr class="separator:a21cce31828de40647b89320b2ace3a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a112c7bc6718335fd075cccd2dd1af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#ac3a112c7bc6718335fd075cccd2dd1af">register_wait_for_single_object</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;wait_object, const <a class="el" href="group__xtd__core.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;callback, std::any state, <a class="el" href="group__types.html#ga7ab879ebcae19d6021222f00537cfdce">int64</a> milliseconds_timeout_interval, bool execute_only_once)</td></tr>
<tr class="memdesc:ac3a112c7bc6718335fd075cccd2dd1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.  <br /></td></tr>
<tr class="separator:ac3a112c7bc6718335fd075cccd2dd1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923290b27e20898255ee9d38b4bfd2ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a923290b27e20898255ee9d38b4bfd2ed">register_wait_for_single_object</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;wait_object, const <a class="el" href="group__xtd__core.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;callback, std::any state, const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>, bool execute_only_once)</td></tr>
<tr class="memdesc:a923290b27e20898255ee9d38b4bfd2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.  <br /></td></tr>
<tr class="separator:a923290b27e20898255ee9d38b4bfd2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4005a0a841c8b79f8a687c881b9baaeb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a4005a0a841c8b79f8a687c881b9baaeb">register_wait_for_single_object</a> (<a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;wait_object, const <a class="el" href="group__xtd__core.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;callback, std::any state, <a class="el" href="group__types.html#gae7af83eab478757e17f0eb7af57571df">uint32</a> milliseconds_timeout_interval, bool execute_only_once)</td></tr>
<tr class="memdesc:a4005a0a841c8b79f8a687c881b9baaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.  <br /></td></tr>
<tr class="separator:a4005a0a841c8b79f8a687c881b9baaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f26921fd206db30d10595147869ac5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a35f26921fd206db30d10595147869ac5">set_max_threads</a> (size_t worker_threads, size_t completion_port_threads)</td></tr>
<tr class="memdesc:a35f26921fd206db30d10595147869ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.  <br /></td></tr>
<tr class="separator:a35f26921fd206db30d10595147869ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3b43e653cf43209dcc846c4f2070f9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a5c3b43e653cf43209dcc846c4f2070f9">set_min_threads</a> (size_t worker_threads, size_t completion_port_threads)</td></tr>
<tr class="memdesc:a5c3b43e653cf43209dcc846c4f2070f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of idle threads the thread pool maintains in anticipation of new requests.  <br /></td></tr>
<tr class="separator:a5c3b43e653cf43209dcc846c4f2070f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a67c0921c9e154215c14cf459b9d0f3ed" name="a67c0921c9e154215c14cf459b9d0f3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c0921c9e154215c14cf459b9d0f3ed">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread_pool::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close all resources and worker threads. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The close method waits for the end of running worker threads, but will not wait for unstarted worker threads. </dd>
<dd>
You can use this method to ensure that all pending threads are closed, and that resources are also closed. </dd>
<dd>
#startup_calls xtd::thread_pool::close method. </dd>
<dd>
<a class="el" href="classxtd_1_1threading_1_1thread.html#a6998fa3ca4218452ae93143d120174ba" title="Blocks the calling thread until all joinable threads terminate.">xtd::threading::thread::join_all</a>, <a class="el" href="classxtd_1_1threading_1_1thread.html#af862f9b072e29e78324d76af04ed5ed1" title="Blocks the calling thread until all joinable threads terminate or the specified time elapses,...">xtd::threading::thread::join_all(int32)</a>, <a class="el" href="classxtd_1_1threading_1_1thread.html#aa78f49e122e15aba2a9ca013e12e0bee" title="Blocks the calling thread until all joinable threads terminate or the specified time elapses,...">xtd::threading::thread::join_all(const xtd::time_span&amp;)</a> methods call <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a67c0921c9e154215c14cf459b9d0f3ed" title="Close all resources and worker threads.">xtd::threading::thread_pool::close</a> method too. </dd></dl>

</div>
</div>
<a id="ac881c038fd40c50b3e05f885dceb4a22" name="ac881c038fd40c50b3e05f885dceb4a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac881c038fd40c50b3e05f885dceb4a22">&#9670;&#160;</a></span>get_available_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread_pool::get_available_threads </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>worker_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>completion_port_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the difference between the maximum number of thread pool threads returned by the GetMaxThreads method, and the number currently active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker_threads</td><td>The number of available worker threads </td></tr>
    <tr><td class="paramname">completion_port_threads</td><td>The number of available asynchronous I/O threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#ac881c038fd40c50b3e05f885dceb4a22" title="Retrieves the difference between the maximum number of thread pool threads returned by the GetMaxThre...">xtd::threading::thread_pool::get_available_threads</a> returns, the variable specified by worker_threads contains the number of additional worker threads that can be started, and the variable specified by completion_port_threads contains the number of additional asynchronous I/O threads that can be started. </dd></dl>

</div>
</div>
<a id="af69068aac907ee0c13a7e4cd699c09c7" name="af69068aac907ee0c13a7e4cd699c09c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69068aac907ee0c13a7e4cd699c09c7">&#9670;&#160;</a></span>get_max_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread_pool::get_max_threads </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>worker_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>completion_port_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker_threads</td><td>The maximum number of worker threads in the thread pool. </td></tr>
    <tr><td class="paramname">completion_port_threads</td><td>The maximum number of asynchronous I/O threads in the thread pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When GetMaxThreads returns, the variable specified by worker_threads contains the maximum number of worker threads allowed in the thread pool, and the variable specified by completion_port_threads contains the maximum number of asynchronous I/O threads allowed in the thread pool. </dd>
<dd>
You can use the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#ac881c038fd40c50b3e05f885dceb4a22" title="Retrieves the difference between the maximum number of thread pool threads returned by the GetMaxThre...">xtd::threading::thread_pool::get_available_threads</a> method to determine the actual number of threads in the thread pool at any given time. </dd>
<dd>
You can use the <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a35f26921fd206db30d10595147869ac5" title="Sets the number of requests to the thread pool that can be active concurrently. All requests above th...">xtd::threading::thread_pool::set_max_threads</a> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool. </dd></dl>

</div>
</div>
<a id="a9d286fb4b631f16224678853d0f86669" name="a9d286fb4b631f16224678853d0f86669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d286fb4b631f16224678853d0f86669">&#9670;&#160;</a></span>get_min_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread_pool::get_min_threads </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>worker_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>completion_port_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of idle threads the thread pool maintains in anticipation of new requests. Always 0 for both. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker_threads</td><td>The maximum number of worker threads in the thread pool. </td></tr>
    <tr><td class="paramname">completion_port_threads</td><td>The maximum number of asynchronous I/O threads in the thread pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a448cec08735d8f22c79b2acb832130f9" name="a448cec08735d8f22c79b2acb832130f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448cec08735d8f22c79b2acb832130f9">&#9670;&#160;</a></span>join_all() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xtd::threading::thread_pool::join_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join all resources and worker threads. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The join_all method waits for the end of running worker threads, but will not wait for unstarted worker threads. </dd>
<dd>
You can use this method to ensure that all pending threads are closed, and that resources are also closed. </dd>
<dd>
#startup_calls xtd::thread_pool::close method. </dd>
<dd>
<a class="el" href="classxtd_1_1threading_1_1thread.html#a6998fa3ca4218452ae93143d120174ba" title="Blocks the calling thread until all joinable threads terminate.">xtd::threading::thread::join_all</a>, <a class="el" href="classxtd_1_1threading_1_1thread.html#af862f9b072e29e78324d76af04ed5ed1" title="Blocks the calling thread until all joinable threads terminate or the specified time elapses,...">xtd::threading::thread::join_all(int32)</a>, <a class="el" href="classxtd_1_1threading_1_1thread.html#aa78f49e122e15aba2a9ca013e12e0bee" title="Blocks the calling thread until all joinable threads terminate or the specified time elapses,...">xtd::threading::thread::join_all(const xtd::time_span&amp;)</a> methods call <a class="el" href="classxtd_1_1threading_1_1thread__pool.html#a67c0921c9e154215c14cf459b9d0f3ed" title="Close all resources and worker threads.">xtd::threading::thread_pool::close</a> method too. </dd></dl>

</div>
</div>
<a id="a5da6db77a7e9173bd1db7c1e8122c10d" name="a5da6db77a7e9173bd1db7c1e8122c10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da6db77a7e9173bd1db7c1e8122c10d">&#9670;&#160;</a></span>join_all() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread_pool::join_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join all resources and worker threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="structxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> set to the amount of time to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all threads have terminated; false if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd>
<dd>
You can use this method to ensure that all pending threads are closed, and that resources are also closed. </dd></dl>

</div>
</div>
<a id="a46511ae8bfea10f66ee96fb3b9cf3374" name="a46511ae8bfea10f66ee96fb3b9cf3374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46511ae8bfea10f66ee96fb3b9cf3374">&#9670;&#160;</a></span>join_all() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread_pool::join_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join all resources and worker threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait for all threads to terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all threads have terminated; false if all threads have not terminated after the amount of time specified by the timeout parameter has elapsed. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If one or more threads are not joinable, they will be skipped. </dd>
<dd>
You can use this method to ensure that all pending threads are closed, and that resources are also closed. </dd></dl>

</div>
</div>
<a id="a6e1d511cd1dbe0a07b98128042118f3c" name="a6e1d511cd1dbe0a07b98128042118f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1d511cd1dbe0a07b98128042118f3c">&#9670;&#160;</a></span>queue_user_work_item() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread_pool::queue_user_work_item </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#ga8e591282c14ed5ae0c0038b503b1373d">wait_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a method for execution. The method executes when a thread pool thread becomes available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A pointer function that represents the method to be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the method is successfully queued; NotSupportException is thrown if the work item could not be queued </dd></dl>

</div>
</div>
<a id="a495589d2c33d3b82fa4e8478a2082088" name="a495589d2c33d3b82fa4e8478a2082088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495589d2c33d3b82fa4e8478a2082088">&#9670;&#160;</a></span>queue_user_work_item() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread_pool::queue_user_work_item </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#ga8e591282c14ed5ae0c0038b503b1373d">wait_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::any&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a method for execution. The method executes when a thread pool thread becomes available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A pointer function that represents the method to be executed. </td></tr>
    <tr><td class="paramname">state</td><td>An object containing data to be used by the method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the method is successfully queued; NotSupportedException is thrown if the work item could not be queued </dd></dl>

</div>
</div>
<a id="a923290b27e20898255ee9d38b4bfd2ed" name="a923290b27e20898255ee9d38b4bfd2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923290b27e20898255ee9d38b4bfd2ed">&#9670;&#160;</a></span>register_wait_for_single_object() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a> xtd::threading::thread_pool::register_wait_for_single_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::any&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>execute_only_once</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_object</td><td>The <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> to register. Use a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> other than Mutex </td></tr>
    <tr><td class="paramname">callback</td><td>A pointer function to call when the wait_object parameter is signaled. </td></tr>
    <tr><td class="paramname">state</td><td>The object that is passed to the callback. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time-out represented by a time_span.If timeout is 0 (zero), the function tests the object's state and returns immediately.If timeout is -1, the function's time-out interval never elapses. </td></tr>
    <tr><td class="paramname">execute_only_once</td><td>true to indicate that the thread will no longer wait on the wait_object parameter after the callback has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html" title="A synchronization primitive that can also be used for interprocess synchronization.">registered_wait_handle</a> The <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::registered_wait_handle</a> that encapsulates the native handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>The milliseconds_timeout_interval parameter is less than -1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21cce31828de40647b89320b2ace3a5e" name="a21cce31828de40647b89320b2ace3a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cce31828de40647b89320b2ace3a5e">&#9670;&#160;</a></span>register_wait_for_single_object() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a> xtd::threading::thread_pool::register_wait_for_single_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::any&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92bf6d527cbcada4a30faa2efd0d6a91">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>execute_only_once</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_object</td><td>The <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> to register. Use a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> other than Mutex </td></tr>
    <tr><td class="paramname">callback</td><td>A pointer function to call when the wait_object parameter is signaled. </td></tr>
    <tr><td class="paramname">state</td><td>The object that is passed to the callback. </td></tr>
    <tr><td class="paramname">milliseconds_timeout_interval</td><td>The time-out in milliseconds. If the milliseconds_timeout_interval parameter is 0 (zero), the function tests the object's state and returns immediately. If milliseconds_timeout_interval is -1, the function's time-out interval never elapses. </td></tr>
    <tr><td class="paramname">execute_only_once</td><td>true to indicate that the thread will no longer wait on the wait_object parameter after the callback has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html" title="A synchronization primitive that can also be used for interprocess synchronization.">registered_wait_handle</a> The <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::registered_wait_handle</a> that encapsulates the native handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>The milliseconds_timeout_interval parameter is less than -1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3a112c7bc6718335fd075cccd2dd1af" name="ac3a112c7bc6718335fd075cccd2dd1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a112c7bc6718335fd075cccd2dd1af">&#9670;&#160;</a></span>register_wait_for_single_object() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a> xtd::threading::thread_pool::register_wait_for_single_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::any&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga7ab879ebcae19d6021222f00537cfdce">int64</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>execute_only_once</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_object</td><td>The <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> to register. Use a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> other than Mutex </td></tr>
    <tr><td class="paramname">callback</td><td>A pointer function to call when the wait_object parameter is signaled. </td></tr>
    <tr><td class="paramname">state</td><td>The object that is passed to the callback. </td></tr>
    <tr><td class="paramname">milliseconds_timeout_interval</td><td>The time-out in milliseconds. If the milliseconds_timeout_interval parameter is 0 (zero), the function tests the object's state and returns immediately. If milliseconds_timeout_interval is -1, the function's time-out interval never elapses. </td></tr>
    <tr><td class="paramname">execute_only_once</td><td>true to indicate that the thread will no longer wait on the wait_object parameter after the callback has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html" title="A synchronization primitive that can also be used for interprocess synchronization.">registered_wait_handle</a> The <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::registered_wait_handle</a> that encapsulates the native handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>The milliseconds_timeout_interval parameter is less than -1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4005a0a841c8b79f8a687c881b9baaeb" name="a4005a0a841c8b79f8a687c881b9baaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4005a0a841c8b79f8a687c881b9baaeb">&#9670;&#160;</a></span>register_wait_for_single_object() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html">registered_wait_handle</a> xtd::threading::thread_pool::register_wait_for_single_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1threading_1_1wait__handle.html">wait_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__xtd__core.html#gae8743c04a110382ce68fbd35eef2f782">wait_or_timer_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::any&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gae7af83eab478757e17f0eb7af57571df">uint32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>execute_only_once</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a delegate to wait for a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a>, specifying a 32-bit signed integer for the time-out in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_object</td><td>The <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> to register. Use a <a class="el" href="classxtd_1_1threading_1_1wait__handle.html" title="Encapsulates operating system specific objects that wait for exclusive access to shared resources.">xtd::threading::wait_handle</a> other than Mutex </td></tr>
    <tr><td class="paramname">callback</td><td>A pointer function to call when the wait_object parameter is signaled. </td></tr>
    <tr><td class="paramname">state</td><td>The object that is passed to the callback. </td></tr>
    <tr><td class="paramname">milliseconds_timeout_interval</td><td>The time-out in milliseconds. If the milliseconds_timeout_interval parameter is 0 (zero), the function tests the object's state and returns immediately. If milliseconds_timeout_interval is -1, the function's time-out interval never elapses. </td></tr>
    <tr><td class="paramname">execute_only_once</td><td>true to indicate that the thread will no longer wait on the wait_object parameter after the callback has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html" title="A synchronization primitive that can also be used for interprocess synchronization.">registered_wait_handle</a> The <a class="el" href="classxtd_1_1threading_1_1registered__wait__handle.html" title="A synchronization primitive that can also be used for interprocess synchronization.">xtd::threading::registered_wait_handle</a> that encapsulates the native handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>The milliseconds_timeout_interval parameter is less than -1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35f26921fd206db30d10595147869ac5" name="a35f26921fd206db30d10595147869ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f26921fd206db30d10595147869ac5">&#9670;&#160;</a></span>set_max_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread_pool::set_max_threads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>worker_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>completion_port_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker_threads</td><td>The maximum number of worker threads in the thread pool. </td></tr>
    <tr><td class="paramname">completion_port_threads</td><td>The maximum number of asynchronous I/O threads in the thread pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the change is successful; otherwise, false. </dd></dl>

</div>
</div>
<a id="a5c3b43e653cf43209dcc846c4f2070f9" name="a5c3b43e653cf43209dcc846c4f2070f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3b43e653cf43209dcc846c4f2070f9">&#9670;&#160;</a></span>set_min_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xtd::threading::thread_pool::set_min_threads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>worker_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>completion_port_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of idle threads the thread pool maintains in anticipation of new requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker_threads</td><td>The new minimum number of idle worker threads to be maintained by the thread pool. </td></tr>
    <tr><td class="paramname">completion_port_threads</td><td>The new minimum number of idle asynchronous I/O threads to be maintained by the thread pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the change is successful; otherwise, false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="thread__pool_8h_source.html">thread_pool.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 1 2024 07:55:39 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
