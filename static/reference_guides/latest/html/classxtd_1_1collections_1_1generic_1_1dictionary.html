<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections.html">collections</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections_1_1generic.html">generic</a></li><li class="navelem"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classxtd_1_1collections_1_1generic_1_1dictionary-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__collections.html">collections</a> &raquo; <a class="el" href="group__generic__collections.html">generic</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1collections_1_1generic_1_1dictionary.png" usemap="#xtd::collections::generic::dictionary_3C_20key_5Ft_2C_20value_5Ft_2C_20hasher_5Ft_2C_20equator_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::collections::generic::dictionary_3C_20key_5Ft_2C_20value_5Ft_2C_20hasher_5Ft_2C_20equator_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::collections::generic::dictionary_3C_20key_5Ft_2C_20value_5Ft_2C_20hasher_5Ft_2C_20equator_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,168,1099,192"/>
<area href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs." alt="xtd::collections::generic::idictionary&lt; key_t, value_t &gt;" shape="rect" coords="1663,168,2762,192"/>
<area href="classxtd_1_1collections_1_1generic_1_1icollection.html" alt="xtd::collections::generic::icollection&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;" shape="rect" coords="1663,112,2762,136"/>
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type." alt="xtd::collections::generic::ienumerable&lt; type_t &gt;" shape="rect" coords="1109,56,2208,80"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators.html" title="Internal collection operators definition." alt="xtd::collections::generic::extensions::collection_operators&lt; type_t, collection_t &gt;" shape="rect" coords="2218,56,3317,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="0,0,1099,24"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html" alt="xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;" shape="rect" coords="1109,0,2208,24"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html" alt="xtd::collections::generic::extensions::enumerable&lt; ienumerable&lt; type_t &gt;, type_t &gt;" shape="rect" coords="2218,0,3317,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class key_t, class value_t, class hasher_t = helpers::hasher&lt;key_t&gt;, class equator_t = helpers::equator&lt;key_t&gt;, class allocator_t = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt;<br />
class xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;</div><p>Represents a collection of keys and values. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> key_t, <span class="keyword">class</span> value_t, <span class="keyword">class</span> hasher_t = xtd::collections::<span class="keyword">generic</span>::helpers::hasher&lt;key_t&gt;, <span class="keyword">class </span>equator_t = <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1helpers_1_1equator.html">xtd::collections::generic::helpers::equator&lt;key_t&gt;</a>, <span class="keyword">class </span>allocator_t = <a class="code hl_typedef" href="group__helpers__generic__collections.html#gac7dc24539787a344466014161f2d39af">xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;</a>&gt;&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a>, <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;key_t, value_t&gt;;</div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a></div><div class="ttdoc">Represents a collection of keys and values.</div><div class="ttdef"><b>Definition</b> dictionary.hpp:67</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1idictionary_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a></div><div class="ttdoc">Represents a generic collection of key/value pairs.</div><div class="ttdef"><b>Definition</b> idictionary.hpp:44</div></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
<div class="ttc" id="agroup__helpers__generic__collections_html_gac7dc24539787a344466014161f2d39af"><div class="ttname"><a href="group__helpers__generic__collections.html#gac7dc24539787a344466014161f2d39af">xtd::collections::generic::helpers::allocator</a></div><div class="ttdeci">std::allocator&lt; type_t &gt; allocator</div><div class="ttdoc">Represent an allocator alias.</div><div class="ttdef"><b>Definition</b> allocator.hpp:38</div></div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1helpers_1_1equator_html"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1helpers_1_1equator.html">xtd::collections::generic::helpers::equator</a></div><div class="ttdoc">Implements a function object for performing comparisons. Unless specialised, invokes operator== on ty...</div><div class="ttdef"><b>Definition</b> equator.hpp:38</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/generic/dictionary&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1collections_1_1generic.html" title="The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...">xtd::collections::generic</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example creates an empty <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; of strings with string keys and uses the Add method to add some elements. The example demonstrates that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method throws an <a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a> when attempting to add a duplicate key.</dd></dl>
<p>The example uses the xtd::collections::generic::dictionary::operator [] to retrieve values, demonstrating that a <a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a> is thrown when a requested key is not present, and showing that the value associated with a key can be replaced.</p>
<p>The example shows how to use the xtd::collections::generic::dictionary::try_get_vValue method as a more efficient way to retrieve values if a program often must try key values that are not in the dictionary, and it shows how to use the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#acf27b6ece343e1dd7450de296277f892" title="Determines whether the xtd::collections::generic::dictionary &lt;key_t, value_t&gt; contains the specified ...">xtd::collections::generic::dictionary::contains_key</a> method to test whether a key exists before calling the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method.</p>
<p>The example shows how to enumerate the keys and values in the dictionary and how to enumerate the keys and values alone using the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac2a9b4d312798abd41548c6c97ee3312" title="Gets a collection containing the keys in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::keys</a> property and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa5519d6518ce9849e89b90fd573839f2" title="Gets a collection containing the values in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::values</a> property.</p>
<p>Finally, the example demonstrates the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a73cb9a204619fd297fb77f09b86b4b29" title="Removes the value with the specified key from the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::remove</a> method. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>example {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="comment">// Create a new dictionary of strings, with string keys.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keyword">auto</span> open_with = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary&lt;string, string&gt;</a> {};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add some elements to the dictionary. There are no</span></div>
<div class="line">    <span class="comment">// duplicate keys, but some of the values are duplicates.</span></div>
<div class="line">    open_with.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522">add</a>(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;notepad.exe&quot;</span>);</div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;bmp&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;dib&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;rtf&quot;</span>, <span class="stringliteral">&quot;wordpad.exe&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The Add method throws an exception if the new key is</span></div>
<div class="line">    <span class="comment">// already in the dictionary.</span></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      open_with.add(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;winword.exe&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1argument__exception.html">argument_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;An element with key = \&quot;txt\&quot; already exists.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The operator [] is another name for the indexer, so you</span></div>
<div class="line">    <span class="comment">// can omit its name when accessing elements.</span></div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;For key = \&quot;rtf\&quot;, value = {0}.&quot;</span>, <a class="code hl_function" href="namespacextd.html#aacbd2f5780a3a0e2aa51480648286bc2">xtd::as_const</a>(open_with)[<span class="stringliteral">&quot;rtf&quot;</span>]);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The indexer can be used to change the value associated with a key.</span></div>
<div class="line">    open_with[<span class="stringliteral">&quot;rtf&quot;</span>] = <span class="stringliteral">&quot;winword.exe&quot;</span>;</div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;For key = \&quot;rtf\&quot;, value = {0}.&quot;</span>, <a class="code hl_function" href="namespacextd.html#aacbd2f5780a3a0e2aa51480648286bc2">xtd::as_const</a>(open_with)[<span class="stringliteral">&quot;rtf&quot;</span>]);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// If a key does not exist, setting the indexer for that key</span></div>
<div class="line">    <span class="comment">// adds a new key/value pair.</span></div>
<div class="line">    open_with[<span class="stringliteral">&quot;doc&quot;</span>] = <span class="stringliteral">&quot;winword.exe&quot;</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The indexer throws an exception if the requested key is not in the dictionary.</span></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;For key = \&quot;tif\&quot;, value = {0}.&quot;</span>, <a class="code hl_function" href="namespacextd.html#aacbd2f5780a3a0e2aa51480648286bc2">xtd::as_const</a>(open_with)[<span class="stringliteral">&quot;tif&quot;</span>]);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html">key_not_found_exception</a>&amp;) {</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;key = \&quot;tif\&quot; is not found.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// When a program often has to try keys that turn out not to</span></div>
<div class="line">    <span class="comment">// be in the dictionary, try_get_value can be a more efficient</span></div>
<div class="line">    <span class="comment">// way to retrieve values.</span></div>
<div class="line">    <span class="keyword">auto</span> value = <span class="stringliteral">&quot;&quot;</span>_s;</div>
<div class="line">    <span class="keywordflow">if</span> (open_with.try_get_value(<span class="stringliteral">&quot;tif&quot;</span>, value))</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;For key = \&quot;tif\&quot;, value = {0}.&quot;</span>, value);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;key = \&quot;tif\&quot; is not found.&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// contains_key can be used to test keys before inserting them.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!open_with.contains_key(<span class="stringliteral">&quot;ht&quot;</span>)) {</div>
<div class="line">      open_with.add(<span class="stringliteral">&quot;ht&quot;</span>, <span class="stringliteral">&quot;hypertrm.exe&quot;</span>);</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;value added for key = \&quot;ht\&quot;: {0}&quot;</span>, <a class="code hl_function" href="namespacextd.html#aacbd2f5780a3a0e2aa51480648286bc2">xtd::as_const</a>(open_with)[<span class="stringliteral">&quot;ht&quot;</span>]);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// When you use for each to enumerate dictionary elements,</span></div>
<div class="line">    <span class="comment">// the elements are retrieved as key_value_pair objects.</span></div>
<div class="line">    console::write_line();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair&lt;string, string&gt;</a>&amp; kvp : open_with)</div>
<div class="line">      <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;key = {0}, value = {1}&quot;</span>, kvp.key(), kvp.value());</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// To get the values alone, use the values property.</span></div>
<div class="line">    <a class="code hl_typedef" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52">dictionary&lt;string, string&gt;::value_collection</a> values = open_with.values();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The elements of the value_collection are strongly typed</span></div>
<div class="line">    <span class="comment">// with the type that was specified for dictionary values.</span></div>
<div class="line">    console::write_line();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : values)</div>
<div class="line">      <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;value = {0}&quot;</span>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// To get the keys alone, use the keys property.</span></div>
<div class="line">    <a class="code hl_typedef" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388">dictionary&lt;string, string&gt;::key_collection</a> <a class="code hl_enumeration" href="group__xtd__forms.html#ga2f00c1ad108efaddc951106e768970de">keys</a> = open_with.keys();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The elements of the key_collection are strongly typed</span></div>
<div class="line">    <span class="comment">// with the type that was specified for dictionary keys.</span></div>
<div class="line">    console::write_line();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; s : <a class="code hl_enumeration" href="group__xtd__forms.html#ga2f00c1ad108efaddc951106e768970de">keys</a>)</div>
<div class="line">      <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;key = {0}&quot;</span>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">s</a>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Use the remove method to remove a key/value pair.</span></div>
<div class="line">    console::write_line(<span class="stringliteral">&quot;\nRemove(\&quot;doc\&quot;)&quot;</span>);</div>
<div class="line">    open_with.remove(<span class="stringliteral">&quot;doc&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (!open_with.contains_key(<span class="stringliteral">&quot;doc&quot;</span>))</div>
<div class="line">      console::write_line(<span class="stringliteral">&quot;key \&quot;doc\&quot; is not found.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(example::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// An element with key = &quot;txt&quot; already exists.</span></div>
<div class="line"><span class="comment">// For key = &quot;rtf&quot;, value = wordpad.exe.</span></div>
<div class="line"><span class="comment">// For key = &quot;rtf&quot;, value = winword.exe.</span></div>
<div class="line"><span class="comment">// key = &quot;tif&quot; is not found.</span></div>
<div class="line"><span class="comment">// key = &quot;tif&quot; is not found.</span></div>
<div class="line"><span class="comment">// value added for key = &quot;ht&quot;: hypertrm.exe</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// key = doc, value = winword.exe</span></div>
<div class="line"><span class="comment">// key = rtf, value = winword.exe</span></div>
<div class="line"><span class="comment">// key = bmp, value = paint.exe</span></div>
<div class="line"><span class="comment">// key = ht, value = hypertrm.exe</span></div>
<div class="line"><span class="comment">// key = dib, value = paint.exe</span></div>
<div class="line"><span class="comment">// key = txt, value = notepad.exe</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// value = winword.exe</span></div>
<div class="line"><span class="comment">// value = winword.exe</span></div>
<div class="line"><span class="comment">// value = paint.exe</span></div>
<div class="line"><span class="comment">// value = hypertrm.exe</span></div>
<div class="line"><span class="comment">// value = paint.exe</span></div>
<div class="line"><span class="comment">// value = notepad.exe</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// key = doc</span></div>
<div class="line"><span class="comment">// key = rtf</span></div>
<div class="line"><span class="comment">// key = bmp</span></div>
<div class="line"><span class="comment">// key = ht</span></div>
<div class="line"><span class="comment">// key = dib</span></div>
<div class="line"><span class="comment">// key = txt</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Remove(&quot;doc&quot;)</span></div>
<div class="line"><span class="comment">// key &quot;doc&quot; is not found.</span></div>
<div class="ttc" id="aclassxtd_1_1argument__exception_html"><div class="ttname"><a href="classxtd_1_1argument__exception.html">xtd::argument_exception</a></div><div class="ttdoc">The exception that is thrown when one of the arguments provided to a method is not valid.</div><div class="ttdef"><b>Definition</b> argument_exception.hpp:23</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html_a4b86fcba0283b6ed1cb596b086e7d388"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388">xtd::collections::generic::dictionary::key_collection</a></div><div class="ttdeci">typename xtd::collections::generic::idictionary&lt; key_type, mapped_type &gt;::key_collection key_collection</div><div class="ttdoc">Represents the idictionary key collection type.</div><div class="ttdef"><b>Definition</b> dictionary.hpp:181</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html_a5837e916ed3ecf5ad27d9c1287033f52"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52">xtd::collections::generic::dictionary::value_collection</a></div><div class="ttdeci">typename xtd::collections::generic::idictionary&lt; key_type, mapped_type &gt;::value_collection value_collection</div><div class="ttdoc">Represents the idictionary value collection type.</div><div class="ttdef"><b>Definition</b> dictionary.hpp:183</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html_a8e4b572d70b69d4b688a2835a3258522"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522">xtd::collections::generic::dictionary::add</a></div><div class="ttdeci">void add(const key_t &amp;key, const value_t value) override</div><div class="ttdoc">Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...</div><div class="ttdef"><b>Definition</b> dictionary.hpp:710</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1key__not__found__exception_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html">xtd::collections::generic::key_not_found_exception</a></div><div class="ttdoc">The exception that is thrown when the key specified for accessing an element in a collection does not...</div><div class="ttdef"><b>Definition</b> key_not_found_exception.hpp:31</div></div>
<div class="ttc" id="aclassxtd_1_1console_html"><div class="ttname"><a href="classxtd_1_1console.html">xtd::console</a></div><div class="ttdoc">Represents the standard input, output, and error streams for console applications.</div><div class="ttdef"><b>Definition</b> console.hpp:36</div></div>
<div class="ttc" id="agroup__keywords_html_ga44bd440a34d147923e428eacd1c8eedd"><div class="ttname"><a href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a></div><div class="ttdeci">#define startup_(main_method)</div><div class="ttdoc">Defines the entry point to be called when the application loads. Generally this is set either to the ...</div><div class="ttdef"><b>Definition</b> startup.hpp:167</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a03c7c0ace395d80182db07ae2c30f034">xtd::console_key::s</a></div><div class="ttdeci">@ s</div><div class="ttdoc">The S key.</div></div>
<div class="ttc" id="agroup__xtd__forms_html_ga2f00c1ad108efaddc951106e768970de"><div class="ttname"><a href="group__xtd__forms.html#ga2f00c1ad108efaddc951106e768970de">xtd::forms::keys</a></div><div class="ttdeci">keys</div><div class="ttdoc">Specifies key codes and modifiers.</div><div class="ttdef"><b>Definition</b> keys.hpp:77</div></div>
<div class="ttc" id="anamespacextd_1_1collections_1_1generic_html"><div class="ttname"><a href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a></div><div class="ttdoc">The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...</div><div class="ttdef"><b>Definition</b> comparer.hpp:16</div></div>
<div class="ttc" id="anamespacextd_html"><div class="ttname"><a href="namespacextd.html">xtd</a></div><div class="ttdoc">The xtd namespace contains all fundamental classes to access Hardware, Os, System,...</div><div class="ttdef"><b>Definition</b> abstract.hpp:8</div></div>
<div class="ttc" id="anamespacextd_html_aacbd2f5780a3a0e2aa51480648286bc2"><div class="ttname"><a href="namespacextd.html#aacbd2f5780a3a0e2aa51480648286bc2">xtd::as_const</a></div><div class="ttdeci">constexpr std::add_const_t&lt; type_t &gt; &amp; as_const(type_t &amp;type) noexcept</div><div class="ttdoc">Obtains a reference to const to its argument.</div><div class="ttdef"><b>Definition</b> as_const.hpp:13</div></div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1key__value__pair_html"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a></div><div class="ttdoc">Defines a key/value pair that can be set or retrieved.</div><div class="ttdef"><b>Definition</b> key_value_pair.hpp:37</div></div>
</div><!-- fragment --> <dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; generic class provides a mapping from a set of keys to a set of values. Each addition to the dictionary consists of a value and its associated key. Retrieving a value by using its key is very fast, close to O(1), because the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class is implemented as a hash table. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The speed of retrieval depends on the quality of the hashing algorithm of the type specified for <code>key_t</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>As long as an object is used as a key in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, it must not change in any way that affects its hash value. Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the dictionary's equality comparer. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. You can specify an implementation of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; generic interface by using a constructor that accepts a comparer parameter; if you do not specify an implementation, the default generic equality comparer <a class="el" href="classxtd_1_1collections_1_1generic_1_1equality__comparer.html#a5849423379f7c39750a1713ba8c44e35" title="Gets the default equality comparer for the type specified by the generic argument.">xtd::collections::generic::equality_comparer&lt;type_t&gt;::default_equality_comparer</a> is used. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For example, you can use the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga088b87511ab0bc2c8d8d37b0582f0c5f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class to create dictionaries with case-insensitive string keys. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can hold. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
For purposes of enumeration, each item in the dictionary is treated as a <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> &lt;key_t, value_t&gt; structure representing a value and its key. The order in which the items are returned is undefined. </dd>
<dd>
The for each statement returns an object of the type of the elements in the collection. Since the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is a collection of keys and values, the element type is not the type of the key or the type of the value. Instead, the element type is a <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> &lt;key_t, value_t&gt; of the key type and the value type. For example: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair&lt;string, string&gt;</a>&amp; kvp : my_dictionary)</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;key = {}, value = {}&quot;</span>, kvp.key(), kvp.value());</div>
</div><!-- fragment --> </dd>
<dd>
Or with <code>auto</code> key type and the value type. For example: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [key, value] : my_dictionary)</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;key = {}, value = {}&quot;</span>, key, value);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="hashtable_8cpp-example.html#_a0">hashtable.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1equator.html">equator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary equator type.  <a href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1equator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html">hasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary hasher type.  <a href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:ac46665df3307e2ef72937349cbe9a043"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; key_t, value_t &gt;::key_type</td></tr>
<tr class="memdesc:ac46665df3307e2ef72937349cbe9a043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary key type.  <br /></td></tr>
<tr class="separator:ac46665df3307e2ef72937349cbe9a043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62f8fa8a47c2a7f0f4371ec0483086d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; key_t, value_t &gt;::mapped_type</td></tr>
<tr class="memdesc:ab62f8fa8a47c2a7f0f4371ec0483086d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary mapped type.  <br /></td></tr>
<tr class="separator:ab62f8fa8a47c2a7f0f4371ec0483086d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f951179b33766491339c34e62fcc98f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::value_type</td></tr>
<tr class="memdesc:a1f951179b33766491339c34e62fcc98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary value type.  <br /></td></tr>
<tr class="separator:a1f951179b33766491339c34e62fcc98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af564e40d9fd72f4ad84f8e5ae62f4610"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> = <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a></td></tr>
<tr class="memdesc:af564e40d9fd72f4ad84f8e5ae62f4610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary size type.  <br /></td></tr>
<tr class="separator:af564e40d9fd72f4ad84f8e5ae62f4610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad6f561b6c8f20e4e5f9c8cf73dfbbcc5">difference_type</a> = <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca">xtd::ptrdiff</a></td></tr>
<tr class="memdesc:ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary difference type.  <br /></td></tr>
<tr class="separator:ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6112bd0a235323e439c6a230e3fb76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1d6112bd0a235323e439c6a230e3fb76">key_equal</a> = <a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1equator.html">equator</a></td></tr>
<tr class="memdesc:a1d6112bd0a235323e439c6a230e3fb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary key_equal type.  <br /></td></tr>
<tr class="separator:a1d6112bd0a235323e439c6a230e3fb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d7f951247c504df41d30e51f987394"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> = allocator_t</td></tr>
<tr class="memdesc:ad1d7f951247c504df41d30e51f987394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary allocator type.  <br /></td></tr>
<tr class="separator:ad1d7f951247c504df41d30e51f987394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69009b6f6be690dbfa2591d29b28c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> = std::pair&lt; const key_t, value_t &gt;</td></tr>
<tr class="memdesc:a6a69009b6f6be690dbfa2591d29b28c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary base value type.  <br /></td></tr>
<tr class="separator:a6a69009b6f6be690dbfa2591d29b28c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eda53efea9ddfea79ad6f47b9f1eb8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> = std::unordered_map&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>, <a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html">hasher</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1d6112bd0a235323e439c6a230e3fb76">key_equal</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &gt;</td></tr>
<tr class="memdesc:a48eda53efea9ddfea79ad6f47b9f1eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary base type.  <br /></td></tr>
<tr class="separator:a48eda53efea9ddfea79ad6f47b9f1eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f55af09de680f0014615c3d4c4a2915"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f55af09de680f0014615c3d4c4a2915">reference</a> = <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;</td></tr>
<tr class="memdesc:a1f55af09de680f0014615c3d4c4a2915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary reference type.  <br /></td></tr>
<tr class="separator:a1f55af09de680f0014615c3d4c4a2915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b6e59722145f09a8b59f06d94c9601"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad8b6e59722145f09a8b59f06d94c9601">const_reference</a> = const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;</td></tr>
<tr class="memdesc:ad8b6e59722145f09a8b59f06d94c9601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary const reference type.  <br /></td></tr>
<tr class="separator:ad8b6e59722145f09a8b59f06d94c9601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853042cc781b451b7e8c0522526c48e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a853042cc781b451b7e8c0522526c48e9">pointer</a> = typename std::allocator_traits&lt; allocator_t &gt;::pointer</td></tr>
<tr class="memdesc:a853042cc781b451b7e8c0522526c48e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary pointer type.  <br /></td></tr>
<tr class="separator:a853042cc781b451b7e8c0522526c48e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84e5f837cd6080080b886aa3378288b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af84e5f837cd6080080b886aa3378288b">const_pointer</a> = typename std::allocator_traits&lt; allocator_t &gt;::const_pointer</td></tr>
<tr class="memdesc:af84e5f837cd6080080b886aa3378288b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary const pointer type.  <br /></td></tr>
<tr class="separator:af84e5f837cd6080080b886aa3378288b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec072eea57e68e1c6fad6aaee1a5a22e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::iterator</td></tr>
<tr class="memdesc:aec072eea57e68e1c6fad6aaee1a5a22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:aec072eea57e68e1c6fad6aaee1a5a22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cadb73d74ba5ee36bafe1bc66810cb0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::const_iterator</td></tr>
<tr class="memdesc:a7cadb73d74ba5ee36bafe1bc66810cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:a7cadb73d74ba5ee36bafe1bc66810cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc966a9b4269ce145604c61eace7f57c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#adc966a9b4269ce145604c61eace7f57c">local_iterator</a> = typename base_type::local_iterator</td></tr>
<tr class="memdesc:adc966a9b4269ce145604c61eace7f57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the local iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:adc966a9b4269ce145604c61eace7f57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259c368e0dff747a4e4687d94d0ca8e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> = typename base_type::const_local_iterator</td></tr>
<tr class="memdesc:a259c368e0dff747a4e4687d94d0ca8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const local iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:a259c368e0dff747a4e4687d94d0ca8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ebfcd509b5c4d473ec9ab61bed6e85"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> = typename base_type::node_type</td></tr>
<tr class="memdesc:a09ebfcd509b5c4d473ec9ab61bed6e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary node type.  <br /></td></tr>
<tr class="separator:a09ebfcd509b5c4d473ec9ab61bed6e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e88bf6f5031a8e127a56adb37ec848d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7e88bf6f5031a8e127a56adb37ec848d">insert_return_type</a> = typename base_type::insert_return_type</td></tr>
<tr class="memdesc:a7e88bf6f5031a8e127a56adb37ec848d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary insert return type.  <br /></td></tr>
<tr class="separator:a7e88bf6f5031a8e127a56adb37ec848d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b86fcba0283b6ed1cb596b086e7d388"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388">key_collection</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::key_collection</td></tr>
<tr class="memdesc:a4b86fcba0283b6ed1cb596b086e7d388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary key collection type.  <br /></td></tr>
<tr class="separator:a4b86fcba0283b6ed1cb596b086e7d388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5837e916ed3ecf5ad27d9c1287033f52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52">value_collection</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::value_collection</td></tr>
<tr class="memdesc:a5837e916ed3ecf5ad27d9c1287033f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary value collection type.  <br /></td></tr>
<tr class="separator:a5837e916ed3ecf5ad27d9c1287033f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:a50b15016f1b91a266a8beec12ab89584"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a> () noexcept=default</td></tr>
<tr class="memdesc:a50b15016f1b91a266a8beec12ab89584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the default equality comparer for the key type.  <br /></td></tr>
<tr class="separator:a50b15016f1b91a266a8beec12ab89584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd88350f974f41a0c131db83cbf72290"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#afd88350f974f41a0c131db83cbf72290">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">idictionary</a>&lt; key_t, value_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>)</td></tr>
<tr class="memdesc:afd88350f974f41a0c131db83cbf72290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs.">xtd::collections::generic::idictionary</a> &lt;key_t, value_t&gt; and uses the default equality comparer for the key type.  <br /></td></tr>
<tr class="separator:afd88350f974f41a0c131db83cbf72290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ddf7990763fbea30e0c6e38b5ae659"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae7ddf7990763fbea30e0c6e38b5ae659">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt; &amp;collection)</td></tr>
<tr class="memdesc:ae7ddf7990763fbea30e0c6e38b5ae659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ae7ddf7990763fbea30e0c6e38b5ae659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1d7beda0f8576d701cd22e9e3a12d8"><td class="memTemplParams" colspan="2">template&lt;class equality_comparer_t &gt; </td></tr>
<tr class="memitem:acd1d7beda0f8576d701cd22e9e3a12d8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#acd1d7beda0f8576d701cd22e9e3a12d8">dictionary</a> (const equality_comparer_t &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>)</td></tr>
<tr class="memdesc:acd1d7beda0f8576d701cd22e9e3a12d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the specified xtd::collections::generic::iequality_comparer&lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:acd1d7beda0f8576d701cd22e9e3a12d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43f677d6205a77520b4601206429243"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae43f677d6205a77520b4601206429243">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash=hasher_t {}, const equator_t &amp;equal=equator_t {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {}) noexcept</td></tr>
<tr class="memdesc:ae43f677d6205a77520b4601206429243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:ae43f677d6205a77520b4601206429243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933f2c0b545c0485ecf052ec431db7a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a933f2c0b545c0485ecf052ec431db7a4">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a933f2c0b545c0485ecf052ec431db7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a933f2c0b545c0485ecf052ec431db7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab609bca970bff889772b49d51f204487"><td class="memTemplParams" colspan="2">template&lt;class equality_comparer_t &gt; </td></tr>
<tr class="memitem:ab609bca970bff889772b49d51f204487"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab609bca970bff889772b49d51f204487">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">idictionary</a>&lt; key_t, value_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>, const equality_comparer_t &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>)</td></tr>
<tr class="memdesc:ab609bca970bff889772b49d51f204487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:ab609bca970bff889772b49d51f204487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e18164c1d61bd817872588bd77c6789"><td class="memTemplParams" colspan="2">template&lt;class equality_comparer_t &gt; </td></tr>
<tr class="memitem:a2e18164c1d61bd817872588bd77c6789"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2e18164c1d61bd817872588bd77c6789">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt; &amp;collection, const equality_comparer_t &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>)</td></tr>
<tr class="memdesc:a2e18164c1d61bd817872588bd77c6789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a2e18164c1d61bd817872588bd77c6789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349de516d0b938124c175ce956b3ac28"><td class="memTemplParams" colspan="2">template&lt;class equality_comparer_t &gt; </td></tr>
<tr class="memitem:a349de516d0b938124c175ce956b3ac28"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a349de516d0b938124c175ce956b3ac28">dictionary</a> (size_t <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3">capacity</a>, const equality_comparer_t &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>)</td></tr>
<tr class="memdesc:a349de516d0b938124c175ce956b3ac28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the specified initial capacity, and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a349de516d0b938124c175ce956b3ac28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fb45416d0a2a0b1d27082b7912878b"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a78fb45416d0a2a0b1d27082b7912878b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a78fb45416d0a2a0b1d27082b7912878b">dictionary</a> (input_iterator_t first, input_iterator_t last, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>=0, const hasher_t &amp;hash=hasher_t {}, const equator_t &amp;equal=equator_t {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {})</td></tr>
<tr class="memdesc:a78fb45416d0a2a0b1d27082b7912878b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a78fb45416d0a2a0b1d27082b7912878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a1e3057a72c385fc731c20b21e9606"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a85a1e3057a72c385fc731c20b21e9606"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a85a1e3057a72c385fc731c20b21e9606">dictionary</a> (input_iterator_t first, input_iterator_t last, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a85a1e3057a72c385fc731c20b21e9606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a85a1e3057a72c385fc731c20b21e9606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d7fe8271b0f7dd1776a8a99de3b1d0"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a45d7fe8271b0f7dd1776a8a99de3b1d0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a45d7fe8271b0f7dd1776a8a99de3b1d0">dictionary</a> (input_iterator_t first, input_iterator_t last, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a45d7fe8271b0f7dd1776a8a99de3b1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a45d7fe8271b0f7dd1776a8a99de3b1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa953d39916161c5551072ee7685d48dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa953d39916161c5551072ee7685d48dc">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aa953d39916161c5551072ee7685d48dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:aa953d39916161c5551072ee7685d48dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cea1264d53956ff616c99322bd744a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a27cea1264d53956ff616c99322bd744a">dictionary</a> (const std::unordered_map&lt; key_t, value_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a27cea1264d53956ff616c99322bd744a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a27cea1264d53956ff616c99322bd744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5202127b516af4f37f86d4a3f472ddc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5202127b516af4f37f86d4a3f472ddc6">dictionary</a> (const std::unordered_map&lt; key_t, value_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a5202127b516af4f37f86d4a3f472ddc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a5202127b516af4f37f86d4a3f472ddc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b758a73f04808f26eee3fa8ce363ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a07b758a73f04808f26eee3fa8ce363ef">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:a07b758a73f04808f26eee3fa8ce363ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a07b758a73f04808f26eee3fa8ce363ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c24d7c8b5165f2e3814e21c8ad0231"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab1c24d7c8b5165f2e3814e21c8ad0231">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:ab1c24d7c8b5165f2e3814e21c8ad0231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:ab1c24d7c8b5165f2e3814e21c8ad0231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153be4b6329ddb7d86bfedd03db85ca8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a153be4b6329ddb7d86bfedd03db85ca8">dictionary</a> (std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a153be4b6329ddb7d86bfedd03db85ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a153be4b6329ddb7d86bfedd03db85ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260ac3aa16033a8c92bbb9a71c7ede0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6260ac3aa16033a8c92bbb9a71c7ede0">dictionary</a> (std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a6260ac3aa16033a8c92bbb9a71c7ede0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a6260ac3aa16033a8c92bbb9a71c7ede0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457a42aa23639faa8590bdb23f2d346a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a457a42aa23639faa8590bdb23f2d346a">dictionary</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>=0, const hasher_t &amp;hash=hasher_t {}, const equator_t &amp;equal=equator_t {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {})</td></tr>
<tr class="memdesc:a457a42aa23639faa8590bdb23f2d346a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a457a42aa23639faa8590bdb23f2d346a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1e2bddbc888c451b97e6cd2f760250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#acd1e2bddbc888c451b97e6cd2f760250">dictionary</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:acd1e2bddbc888c451b97e6cd2f760250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:acd1e2bddbc888c451b97e6cd2f760250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db2868740c4f2c5e70bb845654d31cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0db2868740c4f2c5e70bb845654d31cf">dictionary</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a0db2868740c4f2c5e70bb845654d31cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a0db2868740c4f2c5e70bb845654d31cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f5f06c57ba2d50fffe837ff8dde852"><td class="memTemplParams" colspan="2">template&lt;class init_key_t , class init_value_t &gt; </td></tr>
<tr class="memitem:af8f5f06c57ba2d50fffe837ff8dde852"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af8f5f06c57ba2d50fffe837ff8dde852">dictionary</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>=0, const hasher_t &amp;hash=hasher_t {}, const equator_t &amp;equal=equator_t {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {})</td></tr>
<tr class="memdesc:af8f5f06c57ba2d50fffe837ff8dde852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:af8f5f06c57ba2d50fffe837ff8dde852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b272479748bbf823035dc716d9dad1d"><td class="memTemplParams" colspan="2">template&lt;class init_key_t , class init_value_t &gt; </td></tr>
<tr class="memitem:a8b272479748bbf823035dc716d9dad1d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8b272479748bbf823035dc716d9dad1d">dictionary</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a8b272479748bbf823035dc716d9dad1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a8b272479748bbf823035dc716d9dad1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ad7bfb943fd88490c08ae70251968"><td class="memTemplParams" colspan="2">template&lt;class init_key_t , class init_value_t &gt; </td></tr>
<tr class="memitem:a144ad7bfb943fd88490c08ae70251968"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a144ad7bfb943fd88490c08ae70251968">dictionary</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const hasher_t &amp;hash, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a144ad7bfb943fd88490c08ae70251968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a144ad7bfb943fd88490c08ae70251968"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:a5fb05a4d36ada3a05639760bbef1866f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5fb05a4d36ada3a05639760bbef1866f">begin</a> () const noexcept override</td></tr>
<tr class="memdesc:a5fb05a4d36ada3a05639760bbef1866f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:a5fb05a4d36ada3a05639760bbef1866f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43461af42f40fafcba6c351b8915909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909">begin</a> () noexcept override</td></tr>
<tr class="memdesc:ad43461af42f40fafcba6c351b8915909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:ad43461af42f40fafcba6c351b8915909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51c920c156b8cc6863e143972f5c11b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:ad51c920c156b8cc6863e143972f5c11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of buckets in the container.  <br /></td></tr>
<tr class="separator:ad51c920c156b8cc6863e143972f5c11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ebcb226f6bc8869c35bf9e1d634ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a24ebcb226f6bc8869c35bf9e1d634ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total numbers of elements the internal data structure can hold without resizing.  <br /></td></tr>
<tr class="separator:a24ebcb226f6bc8869c35bf9e1d634ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375db294d333e09891584e2a0956e1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac375db294d333e09891584e2a0956e1d">cbegin</a> () const noexcept override</td></tr>
<tr class="memdesc:ac375db294d333e09891584e2a0956e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:ac375db294d333e09891584e2a0956e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63291ea36f70c7ded93799d6890847e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad63291ea36f70c7ded93799d6890847e">cend</a> () const noexcept override</td></tr>
<tr class="memdesc:ad63291ea36f70c7ded93799d6890847e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:ad63291ea36f70c7ded93799d6890847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2826f22b8d56568081a760c9f6d594da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2826f22b8d56568081a760c9f6d594da">comparer</a> () const noexcept</td></tr>
<tr class="memdesc:a2826f22b8d56568081a760c9f6d594da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the td::collections::generic::iequality_comparer &lt;type_t&gt; that is used to determine equality of keys for the dictionary.  <br /></td></tr>
<tr class="separator:a2826f22b8d56568081a760c9f6d594da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92f9b1f02bf864a69a46230f9b53c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62">count</a> () const noexcept override</td></tr>
<tr class="memdesc:af92f9b1f02bf864a69a46230f9b53c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:af92f9b1f02bf864a69a46230f9b53c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55611e5c2304788bf7a281fc5b75e1cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55611e5c2304788bf7a281fc5b75e1cb">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a55611e5c2304788bf7a281fc5b75e1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumarable.">begin()</a> == <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">end()</a></code>.  <br /></td></tr>
<tr class="separator:a55611e5c2304788bf7a281fc5b75e1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bcbef97b1acb696d8b444988530830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830">end</a> () const noexcept override</td></tr>
<tr class="memdesc:a84bcbef97b1acb696d8b444988530830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a84bcbef97b1acb696d8b444988530830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e062f26b355616dce3110a815645e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d">end</a> () noexcept override</td></tr>
<tr class="memdesc:a8e062f26b355616dce3110a815645e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a8e062f26b355616dce3110a815645e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2181745ec5b125827735336ea9ada43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af2181745ec5b125827735336ea9ada43">is_read_only</a> () const noexcept override</td></tr>
<tr class="memdesc:af2181745ec5b125827735336ea9ada43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is read-only.  <br /></td></tr>
<tr class="separator:af2181745ec5b125827735336ea9ada43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9798bb3a3f89e6dd45d5783d42957550"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a9798bb3a3f89e6dd45d5783d42957550">is_synchronized</a> () const noexcept override</td></tr>
<tr class="memdesc:a9798bb3a3f89e6dd45d5783d42957550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether access to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is synchronized (thread safe).  <br /></td></tr>
<tr class="separator:a9798bb3a3f89e6dd45d5783d42957550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f9fa62ba008a290c60f795e768d74f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac5f9fa62ba008a290c60f795e768d74f">items</a> () const noexcept</td></tr>
<tr class="memdesc:ac5f9fa62ba008a290c60f795e768d74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:ac5f9fa62ba008a290c60f795e768d74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb58202461ac49407519756acca9ed12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aeb58202461ac49407519756acca9ed12">items</a> () noexcept</td></tr>
<tr class="memdesc:aeb58202461ac49407519756acca9ed12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:aeb58202461ac49407519756acca9ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a9b4d312798abd41548c6c97ee3312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388">key_collection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac2a9b4d312798abd41548c6c97ee3312">keys</a> () const noexcept override</td></tr>
<tr class="memdesc:ac2a9b4d312798abd41548c6c97ee3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a collection containing the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:ac2a9b4d312798abd41548c6c97ee3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fed9d70080e18e58e5f678ff8fce0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad12fed9d70080e18e58e5f678ff8fce0">load_factor</a> () const</td></tr>
<tr class="memdesc:ad12fed9d70080e18e58e5f678ff8fce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the average number of elements per bucket, that is, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a9b8a36cd363866ea458b74960e5d68eb" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::size</a> divided by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a>.  <br /></td></tr>
<tr class="separator:ad12fed9d70080e18e58e5f678ff8fce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4c1821576c7fba7fdd4dea0f2c512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad9e4c1821576c7fba7fdd4dea0f2c512">max_bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:ad9e4c1821576c7fba7fdd4dea0f2c512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of buckets the container is able to hold due to system or library implementation limitations.  <br /></td></tr>
<tr class="separator:ad9e4c1821576c7fba7fdd4dea0f2c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ebdfacb702aad8221aa1b77817cdbd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd">max_load_factor</a> () const</td></tr>
<tr class="memdesc:af4ebdfacb702aad8221aa1b77817cdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.  <br /></td></tr>
<tr class="separator:af4ebdfacb702aad8221aa1b77817cdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f7acfa0c36a187bd76efe62d87581c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad7f7acfa0c36a187bd76efe62d87581c">max_load_factor</a> (float value) const</td></tr>
<tr class="memdesc:ad7f7acfa0c36a187bd76efe62d87581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.  <br /></td></tr>
<tr class="separator:ad7f7acfa0c36a187bd76efe62d87581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070747ad0686a9136f66dfc5e3b19aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a070747ad0686a9136f66dfc5e3b19aa9">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a070747ad0686a9136f66dfc5e3b19aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">end()</a>)</code> for the largest container.  <br /></td></tr>
<tr class="separator:a070747ad0686a9136f66dfc5e3b19aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8a36cd363866ea458b74960e5d68eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a9b8a36cd363866ea458b74960e5d68eb">size</a> () const noexcept</td></tr>
<tr class="memdesc:a9b8a36cd363866ea458b74960e5d68eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a9b8a36cd363866ea458b74960e5d68eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0784fa1eee73f0061df828986a5ae52d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1object.html">xtd::object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0784fa1eee73f0061df828986a5ae52d">sync_root</a> () const noexcept override</td></tr>
<tr class="memdesc:a0784fa1eee73f0061df828986a5ae52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an object that can be used to synchronize access to the the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a0784fa1eee73f0061df828986a5ae52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5519d6518ce9849e89b90fd573839f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52">value_collection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa5519d6518ce9849e89b90fd573839f2">values</a> () const noexcept override</td></tr>
<tr class="memdesc:aa5519d6518ce9849e89b90fd573839f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a collection containing the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:aa5519d6518ce9849e89b90fd573839f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a8e4b572d70b69d4b688a2835a3258522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522">add</a> (const key_t &amp;key, const value_t value) override</td></tr>
<tr class="memdesc:a8e4b572d70b69d4b688a2835a3258522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element with the provided key and value to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a8e4b572d70b69d4b688a2835a3258522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f323cd7289784e6380117b8bfadf8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a22f323cd7289784e6380117b8bfadf8b">add</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;item) override</td></tr>
<tr class="memdesc:a22f323cd7289784e6380117b8bfadf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a22f323cd7289784e6380117b8bfadf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56664bbd826ba01e34ff35477064db2d"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a56664bbd826ba01e34ff35477064db2d">at</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a56664bbd826ba01e34ff35477064db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element with the specified key.  <br /></td></tr>
<tr class="separator:a56664bbd826ba01e34ff35477064db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32980a15b7ef803c1ba5c8d69f1dbb84"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a32980a15b7ef803c1ba5c8d69f1dbb84">at</a> (const key_t &amp;key)</td></tr>
<tr class="memdesc:a32980a15b7ef803c1ba5c8d69f1dbb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element with the specified key.  <br /></td></tr>
<tr class="separator:a32980a15b7ef803c1ba5c8d69f1dbb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3e8fd61595d88e72199205dbf976b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#adc966a9b4269ce145604c61eace7f57c">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8d3e8fd61595d88e72199205dbf976b5">begin</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>)</td></tr>
<tr class="memdesc:a8d3e8fd61595d88e72199205dbf976b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the specified bucket.  <br /></td></tr>
<tr class="separator:a8d3e8fd61595d88e72199205dbf976b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772b3aff980ea2b05d5bf8ce5cbdd9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a772b3aff980ea2b05d5bf8ce5cbdd9f1">begin</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const</td></tr>
<tr class="memdesc:a772b3aff980ea2b05d5bf8ce5cbdd9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the specified bucket.  <br /></td></tr>
<tr class="separator:a772b3aff980ea2b05d5bf8ce5cbdd9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b83cb5cb0fa23c7b4ff7c2c447419aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3b83cb5cb0fa23c7b4ff7c2c447419aa">bucket</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a3b83cb5cb0fa23c7b4ff7c2c447419aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket.  <br /></td></tr>
<tr class="separator:a3b83cb5cb0fa23c7b4ff7c2c447419aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce1e7684c03c73e9980372eceb779a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8ce1e7684c03c73e9980372eceb779a2">bucket_size</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const noexcept</td></tr>
<tr class="memdesc:a8ce1e7684c03c73e9980372eceb779a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the bucket with index <code>n</code>.  <br /></td></tr>
<tr class="separator:a8ce1e7684c03c73e9980372eceb779a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d0ef8dbeb149776a600386b13a9c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a325d0ef8dbeb149776a600386b13a9c6">cbegin</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const</td></tr>
<tr class="memdesc:a325d0ef8dbeb149776a600386b13a9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the specified bucket.  <br /></td></tr>
<tr class="separator:a325d0ef8dbeb149776a600386b13a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38876c6b918c241ca74f597089606c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab38876c6b918c241ca74f597089606c1">cend</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const</td></tr>
<tr class="memdesc:ab38876c6b918c241ca74f597089606c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the specified bucket.  <br /></td></tr>
<tr class="separator:ab38876c6b918c241ca74f597089606c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50385c2da2442292164bc4f65c84ee76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50385c2da2442292164bc4f65c84ee76">clear</a> () noexcept override</td></tr>
<tr class="memdesc:a50385c2da2442292164bc4f65c84ee76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all keys and values from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a50385c2da2442292164bc4f65c84ee76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db129cddf553ee484a09e6d39bb87a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7db129cddf553ee484a09e6d39bb87a0">contains</a> (const key_t &amp;key) const noexcept</td></tr>
<tr class="memdesc:a7db129cddf553ee484a09e6d39bb87a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container contains element with specific key.  <br /></td></tr>
<tr class="separator:a7db129cddf553ee484a09e6d39bb87a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19c1aca5cdab0045940d70246b37093"><td class="memTemplParams" colspan="2">template&lt;class contains_key_t &gt; </td></tr>
<tr class="memitem:ac19c1aca5cdab0045940d70246b37093"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac19c1aca5cdab0045940d70246b37093">contains</a> (const contains_key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) const</td></tr>
<tr class="memdesc:ac19c1aca5cdab0045940d70246b37093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container contains element with specific key.  <br /></td></tr>
<tr class="separator:ac19c1aca5cdab0045940d70246b37093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b87fe3db85b2c9f55ac59544070e20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a90b87fe3db85b2c9f55ac59544070e20">contains</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;item) const noexcept override</td></tr>
<tr class="memdesc:a90b87fe3db85b2c9f55ac59544070e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an element is in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a90b87fe3db85b2c9f55ac59544070e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf27b6ece343e1dd7450de296277f892"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#acf27b6ece343e1dd7450de296277f892">contains_key</a> (const key_t &amp;key) const noexcept override</td></tr>
<tr class="memdesc:acf27b6ece343e1dd7450de296277f892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains the specified key.  <br /></td></tr>
<tr class="separator:acf27b6ece343e1dd7450de296277f892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135b9e8d0789a85bd120b3c25af1102e"><td class="memItemLeft" align="right" valign="top"><a id="a135b9e8d0789a85bd120b3c25af1102e" name="a135b9e8d0789a85bd120b3c25af1102e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains_value</b> (const value_t &amp;value) const noexcept</td></tr>
<tr class="separator:a135b9e8d0789a85bd120b3c25af1102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d231addcc65486d9ad0abee23ada3ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3d231addcc65486d9ad0abee23ada3ac">copy_to</a> (<a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt; &amp;<a class="el" href="classxtd_1_1array.html">array</a>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> array_index) const override</td></tr>
<tr class="memdesc:a3d231addcc65486d9ad0abee23ada3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; to an <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a>, starting at a particular <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> index.  <br /></td></tr>
<tr class="separator:a3d231addcc65486d9ad0abee23ada3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62388a5a93af71eb55d9f509420d1acb"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:a62388a5a93af71eb55d9f509420d1acb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a62388a5a93af71eb55d9f509420d1acb">emplace</a> (args_t &amp;&amp;...args)</td></tr>
<tr class="memdesc:a62388a5a93af71eb55d9f509420d1acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs element in-place.  <br /></td></tr>
<tr class="separator:a62388a5a93af71eb55d9f509420d1acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fad4302a8e0c5a82892df5bef0504"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:a657fad4302a8e0c5a82892df5bef0504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a657fad4302a8e0c5a82892df5bef0504">emplace_hint</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> hint, args_t &amp;&amp;...args)</td></tr>
<tr class="memdesc:a657fad4302a8e0c5a82892df5bef0504"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs elements in-place using a hint  <br /></td></tr>
<tr class="separator:a657fad4302a8e0c5a82892df5bef0504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cefc1b2c8027b4257647fccda518f71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#adc966a9b4269ce145604c61eace7f57c">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0cefc1b2c8027b4257647fccda518f71">end</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>)</td></tr>
<tr class="memdesc:a0cefc1b2c8027b4257647fccda518f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the specified bucket.  <br /></td></tr>
<tr class="separator:a0cefc1b2c8027b4257647fccda518f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26ad005233fb7741a285d791e56db19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa26ad005233fb7741a285d791e56db19">end</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const</td></tr>
<tr class="memdesc:aa26ad005233fb7741a285d791e56db19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the specified bucket.  <br /></td></tr>
<tr class="separator:aa26ad005233fb7741a285d791e56db19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460da2f9004cddf41f14d23d1fa09a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a460da2f9004cddf41f14d23d1fa09a25">ensure_capacity</a> (<a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3">capacity</a>) noexcept</td></tr>
<tr class="memdesc:a460da2f9004cddf41f14d23d1fa09a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the dictionary can hold up to a specified number of entries without any further expansion of its backing storage.  <br /></td></tr>
<tr class="separator:a460da2f9004cddf41f14d23d1fa09a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7192082480f0412da88dfa004dca3c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7192082480f0412da88dfa004dca3c3b">equal_range</a> (const key_t &amp;key)</td></tr>
<tr class="memdesc:a7192082480f0412da88dfa004dca3c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range of elements matching a specific key.  <br /></td></tr>
<tr class="separator:a7192082480f0412da88dfa004dca3c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e8a1a164d50122468d84a0d31c0724"><td class="memTemplParams" colspan="2">template&lt;class equal_range_key_t &gt; </td></tr>
<tr class="memitem:a85e8a1a164d50122468d84a0d31c0724"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a85e8a1a164d50122468d84a0d31c0724">equal_range</a> (const equal_range_key_t &amp;key) const</td></tr>
<tr class="memdesc:a85e8a1a164d50122468d84a0d31c0724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range of elements matching a specific key.  <br /></td></tr>
<tr class="separator:a85e8a1a164d50122468d84a0d31c0724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94931223079f91ec84fd48de20d2c3e8"><td class="memTemplParams" colspan="2">template&lt;class equal_range_key_t &gt; </td></tr>
<tr class="memitem:a94931223079f91ec84fd48de20d2c3e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a94931223079f91ec84fd48de20d2c3e8">equal_range</a> (const equal_range_key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>)</td></tr>
<tr class="memdesc:a94931223079f91ec84fd48de20d2c3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range of elements matching a specific key.  <br /></td></tr>
<tr class="separator:a94931223079f91ec84fd48de20d2c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a7786db2622f4e3c0cab7f64b6ff58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a60a7786db2622f4e3c0cab7f64b6ff58">equal_range</a> (const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) const</td></tr>
<tr class="memdesc:a60a7786db2622f4e3c0cab7f64b6ff58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range of elements matching a specific key.  <br /></td></tr>
<tr class="separator:a60a7786db2622f4e3c0cab7f64b6ff58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eab79e42511efe5dd18c64f470a6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a05eab79e42511efe5dd18c64f470a6bd">erase</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a05eab79e42511efe5dd18c64f470a6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases elements.  <br /></td></tr>
<tr class="separator:a05eab79e42511efe5dd18c64f470a6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e499b3634ee1402b59a6742fc817e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a51e499b3634ee1402b59a6742fc817e1">erase</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> first, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> last)</td></tr>
<tr class="memdesc:a51e499b3634ee1402b59a6742fc817e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases elements.  <br /></td></tr>
<tr class="separator:a51e499b3634ee1402b59a6742fc817e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a6184442c9b335e7984d655f722e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa7a6184442c9b335e7984d655f722e0d">erase</a> (const key_t &amp;key)</td></tr>
<tr class="memdesc:aa7a6184442c9b335e7984d655f722e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases elements.  <br /></td></tr>
<tr class="separator:aa7a6184442c9b335e7984d655f722e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7934e22726ecf3f3e3ddbe7ae6dbe4b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7934e22726ecf3f3e3ddbe7ae6dbe4b5">extract</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> position) noexcept</td></tr>
<tr class="memdesc:a7934e22726ecf3f3e3ddbe7ae6dbe4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts nodes from the container.  <br /></td></tr>
<tr class="separator:a7934e22726ecf3f3e3ddbe7ae6dbe4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248ff4fbc36fb649ca0ef6a682b37c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a248ff4fbc36fb649ca0ef6a682b37c6c">extract</a> (const key_t <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>)</td></tr>
<tr class="memdesc:a248ff4fbc36fb649ca0ef6a682b37c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts nodes from the container.  <br /></td></tr>
<tr class="separator:a248ff4fbc36fb649ca0ef6a682b37c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b99ac9d6af11fda53cb838f611a0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a15b99ac9d6af11fda53cb838f611a0ec">find</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a15b99ac9d6af11fda53cb838f611a0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds element with specific key.  <br /></td></tr>
<tr class="separator:a15b99ac9d6af11fda53cb838f611a0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a5892c788e1c794aa49766438b79c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3a5892c788e1c794aa49766438b79c1">find</a> (const key_t &amp;key)</td></tr>
<tr class="memdesc:ae3a5892c788e1c794aa49766438b79c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds element with specific key.  <br /></td></tr>
<tr class="separator:ae3a5892c788e1c794aa49766438b79c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e712574f32c4ee5baf17502c9d89991"><td class="memTemplParams" colspan="2">template&lt;class find_key_t &gt; </td></tr>
<tr class="memitem:a4e712574f32c4ee5baf17502c9d89991"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4e712574f32c4ee5baf17502c9d89991">find</a> (const find_key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>) const</td></tr>
<tr class="memdesc:a4e712574f32c4ee5baf17502c9d89991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds element with specific key.  <br /></td></tr>
<tr class="separator:a4e712574f32c4ee5baf17502c9d89991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba5c1ca5b7f05e3035ba70ca10c1ae0"><td class="memTemplParams" colspan="2">template&lt;class find_key_t &gt; </td></tr>
<tr class="memitem:a6ba5c1ca5b7f05e3035ba70ca10c1ae0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6ba5c1ca5b7f05e3035ba70ca10c1ae0">find</a> (const find_key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a9dd4e461268c8034f5c8564e155c67a6">x</a>)</td></tr>
<tr class="memdesc:a6ba5c1ca5b7f05e3035ba70ca10c1ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds element with specific key.  <br /></td></tr>
<tr class="separator:a6ba5c1ca5b7f05e3035ba70ca10c1ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f30a82dc96ded7a4145c3d0533e3a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:ae3f30a82dc96ded7a4145c3d0533e3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <br /></td></tr>
<tr class="separator:ae3f30a82dc96ded7a4145c3d0533e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab937a31d8ae4cb896ab25baf67330225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">enumerator</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab937a31d8ae4cb896ab25baf67330225">get_enumerator</a> () const noexcept override</td></tr>
<tr class="memdesc:ab937a31d8ae4cb896ab25baf67330225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that iterates through the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:ab937a31d8ae4cb896ab25baf67330225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c1f0dd1e8ac7f753d0f56e05fa5a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a14c1f0dd1e8ac7f753d0f56e05fa5a8c">hash_function</a> () const</td></tr>
<tr class="memdesc:a14c1f0dd1e8ac7f753d0f56e05fa5a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns function used to hash the keys.  <br /></td></tr>
<tr class="separator:a14c1f0dd1e8ac7f753d0f56e05fa5a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2536af020316364a5f3e053dbc02feb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7">insert</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a2536af020316364a5f3e053dbc02feb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a2536af020316364a5f3e053dbc02feb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbab4055f21c2b4f292408e2fe681e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4bbab4055f21c2b4f292408e2fe681e8">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a4bbab4055f21c2b4f292408e2fe681e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a4bbab4055f21c2b4f292408e2fe681e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ad0f3139526c64cf06412b65feae9e"><td class="memTemplParams" colspan="2">template&lt;class type_t &gt; </td></tr>
<tr class="memitem:a18ad0f3139526c64cf06412b65feae9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a18ad0f3139526c64cf06412b65feae9e">insert</a> (type_t &amp;&amp;value)</td></tr>
<tr class="memdesc:a18ad0f3139526c64cf06412b65feae9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a18ad0f3139526c64cf06412b65feae9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380d38c18d0aa2a9d14309adfc143b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a380d38c18d0aa2a9d14309adfc143b53">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a380d38c18d0aa2a9d14309adfc143b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a380d38c18d0aa2a9d14309adfc143b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18df0c230fef405f5748b1bc0e499128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a18df0c230fef405f5748b1bc0e499128">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a18df0c230fef405f5748b1bc0e499128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a18df0c230fef405f5748b1bc0e499128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7128e65ca299ec54ac3141117d0a6215"><td class="memTemplParams" colspan="2">template&lt;class type_t &gt; </td></tr>
<tr class="memitem:a7128e65ca299ec54ac3141117d0a6215"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7128e65ca299ec54ac3141117d0a6215">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, type_t &amp;&amp;value)</td></tr>
<tr class="memdesc:a7128e65ca299ec54ac3141117d0a6215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a7128e65ca299ec54ac3141117d0a6215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85007cea09c65235fd258adcc3a5a28d"><td class="memTemplParams" colspan="2">template&lt;class input_iterator_t &gt; </td></tr>
<tr class="memitem:a85007cea09c65235fd258adcc3a5a28d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a85007cea09c65235fd258adcc3a5a28d">insert</a> (input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:a85007cea09c65235fd258adcc3a5a28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a85007cea09c65235fd258adcc3a5a28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f13f08d0a8068edeec540cd55b2656e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2f13f08d0a8068edeec540cd55b2656e">insert</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">ilist</a>)</td></tr>
<tr class="memdesc:a2f13f08d0a8068edeec540cd55b2656e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a2f13f08d0a8068edeec540cd55b2656e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03539711e3e6f86380a893e725b95d3"><td class="memTemplParams" colspan="2">template&lt;class init_key_t , class init_value_t &gt; </td></tr>
<tr class="memitem:ab03539711e3e6f86380a893e725b95d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab03539711e3e6f86380a893e725b95d3">insert</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">ilist</a>)</td></tr>
<tr class="memdesc:ab03539711e3e6f86380a893e725b95d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:ab03539711e3e6f86380a893e725b95d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe7e8e7ea1b539e1b77cb2e67f3d56b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7e88bf6f5031a8e127a56adb37ec848d">insert_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1fe7e8e7ea1b539e1b77cb2e67f3d56b">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;nh)</td></tr>
<tr class="memdesc:a1fe7e8e7ea1b539e1b77cb2e67f3d56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a1fe7e8e7ea1b539e1b77cb2e67f3d56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c488877537c9281e341e04cc2836c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5c488877537c9281e341e04cc2836c4b">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;nh)</td></tr>
<tr class="memdesc:a5c488877537c9281e341e04cc2836c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a5c488877537c9281e341e04cc2836c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9003b85acdd5f58ba98601126fb7e5e"><td class="memTemplParams" colspan="2">template&lt;class type_t &gt; </td></tr>
<tr class="memitem:ad9003b85acdd5f58ba98601126fb7e5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad9003b85acdd5f58ba98601126fb7e5e">insert_or_assign</a> (const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:ad9003b85acdd5f58ba98601126fb7e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:ad9003b85acdd5f58ba98601126fb7e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="memTemplParams" colspan="2">template&lt;class type_t &gt; </td></tr>
<tr class="memitem:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#acc83f5a5d14fd0c9c164a3bffcffe128">insert_or_assign</a> (key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddd73ed7023f733638e9fda6246ed4"><td class="memTemplParams" colspan="2">template&lt;class type_t &gt; </td></tr>
<tr class="memitem:addddd73ed7023f733638e9fda6246ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#addddd73ed7023f733638e9fda6246ed4">insert_or_assign</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:addddd73ed7023f733638e9fda6246ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:addddd73ed7023f733638e9fda6246ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286f0cc1a6f5f3ea0e07728043b80038"><td class="memTemplParams" colspan="2">template&lt;class type_t &gt; </td></tr>
<tr class="memitem:a286f0cc1a6f5f3ea0e07728043b80038"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a286f0cc1a6f5f3ea0e07728043b80038">insert_or_assign</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:a286f0cc1a6f5f3ea0e07728043b80038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:a286f0cc1a6f5f3ea0e07728043b80038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f3e826724a20670a5b310e1eda5542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1d6112bd0a235323e439c6a230e3fb76">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a64f3e826724a20670a5b310e1eda5542">key_eq</a> () const</td></tr>
<tr class="memdesc:a64f3e826724a20670a5b310e1eda5542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function used to compare keys for equality.  <br /></td></tr>
<tr class="separator:a64f3e826724a20670a5b310e1eda5542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa575c136bf1a37de24a5a7ce7f552b6e"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t , class source_equator_t &gt; </td></tr>
<tr class="memitem:aa575c136bf1a37de24a5a7ce7f552b6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa575c136bf1a37de24a5a7ce7f552b6e">merge</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;source)</td></tr>
<tr class="memdesc:aa575c136bf1a37de24a5a7ce7f552b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:aa575c136bf1a37de24a5a7ce7f552b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5befc63a3053f4602f9440418e6e553b"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t , class source_equator_t &gt; </td></tr>
<tr class="memitem:a5befc63a3053f4602f9440418e6e553b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5befc63a3053f4602f9440418e6e553b">merge</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;source)</td></tr>
<tr class="memdesc:a5befc63a3053f4602f9440418e6e553b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:a5befc63a3053f4602f9440418e6e553b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e63cb0057bab0fe25d0b0496cebdab"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t , class source_equator_t &gt; </td></tr>
<tr class="memitem:ab4e63cb0057bab0fe25d0b0496cebdab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab4e63cb0057bab0fe25d0b0496cebdab">merge</a> (std::unordered_map&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;source)</td></tr>
<tr class="memdesc:ab4e63cb0057bab0fe25d0b0496cebdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:ab4e63cb0057bab0fe25d0b0496cebdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b3061b4dbf74c837b28315279242bf"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t , class source_equator_t &gt; </td></tr>
<tr class="memitem:a05b3061b4dbf74c837b28315279242bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a05b3061b4dbf74c837b28315279242bf">merge</a> (std::unordered_map&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;source)</td></tr>
<tr class="memdesc:a05b3061b4dbf74c837b28315279242bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:a05b3061b4dbf74c837b28315279242bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b8b13d8c3160f93641eaa1ccda8968"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t , class source_equator_t &gt; </td></tr>
<tr class="memitem:ac7b8b13d8c3160f93641eaa1ccda8968"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac7b8b13d8c3160f93641eaa1ccda8968">merge</a> (std::unordered_multimap&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;source)</td></tr>
<tr class="memdesc:ac7b8b13d8c3160f93641eaa1ccda8968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:ac7b8b13d8c3160f93641eaa1ccda8968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d725740942e0a175b87d23e8228dce"><td class="memTemplParams" colspan="2">template&lt;class source_hasher_t , class source_equator_t &gt; </td></tr>
<tr class="memitem:ad3d725740942e0a175b87d23e8228dce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad3d725740942e0a175b87d23e8228dce">merge</a> (std::unordered_multimap&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;source)</td></tr>
<tr class="memdesc:ad3d725740942e0a175b87d23e8228dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splices nodes from another container.  <br /></td></tr>
<tr class="separator:ad3d725740942e0a175b87d23e8228dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f150f182b8abc8caaf5914dbbba8eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a73f150f182b8abc8caaf5914dbbba8eb">rehash</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62">count</a>)</td></tr>
<tr class="memdesc:a73f150f182b8abc8caaf5914dbbba8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves at least the specified number of buckets and regenerates the hash table.  <br /></td></tr>
<tr class="separator:a73f150f182b8abc8caaf5914dbbba8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cb9a204619fd297fb77f09b86b4b29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a73cb9a204619fd297fb77f09b86b4b29">remove</a> (const key_t &amp;key) noexcept override</td></tr>
<tr class="memdesc:a73cb9a204619fd297fb77f09b86b4b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the value with the specified key from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a73cb9a204619fd297fb77f09b86b4b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b135339b414dd74f28dd0644fc255f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5b135339b414dd74f28dd0644fc255f3">remove</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;item) noexcept override</td></tr>
<tr class="memdesc:a5b135339b414dd74f28dd0644fc255f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first occurrence of a specific object from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a5b135339b414dd74f28dd0644fc255f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8a911620f4d683e1ddab2edb518310"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0a8a911620f4d683e1ddab2edb518310">remove</a> (const key_t &amp;key, value_t &amp;value) noexcept</td></tr>
<tr class="memdesc:a0a8a911620f4d683e1ddab2edb518310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the value with the specified key from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, and copies the element to the <code>value</code> parameter.  <br /></td></tr>
<tr class="separator:a0a8a911620f4d683e1ddab2edb518310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f59aa65bc93ff2771d7c1163e221368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3f59aa65bc93ff2771d7c1163e221368">reserve</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62">count</a>)</td></tr>
<tr class="memdesc:a3f59aa65bc93ff2771d7c1163e221368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for at least the specified number of elements and regenerates the hash table.  <br /></td></tr>
<tr class="separator:a3f59aa65bc93ff2771d7c1163e221368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4477fff561437e9a5487120b57055dd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4477fff561437e9a5487120b57055dd5">swap</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a4477fff561437e9a5487120b57055dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents.  <br /></td></tr>
<tr class="separator:a4477fff561437e9a5487120b57055dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae995c559f83b9915daf53430f2ccc95e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__strings.html#gacd1daef0757a14b1f957e10b32644f91">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae995c559f83b9915daf53430f2ccc95e">to_string</a> () const noexcept override</td></tr>
<tr class="memdesc:ae995c559f83b9915daf53430f2ccc95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string that represents the current object.  <br /></td></tr>
<tr class="separator:ae995c559f83b9915daf53430f2ccc95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039c4cc5a88a74481047772f8dc30980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a039c4cc5a88a74481047772f8dc30980">trim_excess</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3">capacity</a>)</td></tr>
<tr class="memdesc:a039c4cc5a88a74481047772f8dc30980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the capacity of this dictionary to hold up a specified number of entries without any further expansion of its backing storage.  <br /></td></tr>
<tr class="separator:a039c4cc5a88a74481047772f8dc30980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e33a4f0c0ff75219a24c4e17dd96798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7e33a4f0c0ff75219a24c4e17dd96798">trim_excess</a> ()</td></tr>
<tr class="memdesc:a7e33a4f0c0ff75219a24c4e17dd96798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries.  <br /></td></tr>
<tr class="separator:a7e33a4f0c0ff75219a24c4e17dd96798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5609a2b1e1555fe690d1b86368f36a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5609a2b1e1555fe690d1b86368f36a64">try_add</a> (const key_t &amp;key, const value_t value) noexcept</td></tr>
<tr class="memdesc:a5609a2b1e1555fe690d1b86368f36a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to add the specified key and value to the dictionary.  <br /></td></tr>
<tr class="separator:a5609a2b1e1555fe690d1b86368f36a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f68a0c5f67be81a1de0390a4f44ada"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:af3f68a0c5f67be81a1de0390a4f44ada"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af3f68a0c5f67be81a1de0390a4f44ada">try_emplace</a> (const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:af3f68a0c5f67be81a1de0390a4f44ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.  <br /></td></tr>
<tr class="separator:af3f68a0c5f67be81a1de0390a4f44ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2701181224b009ca6d91700273f56ab0"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:a2701181224b009ca6d91700273f56ab0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2701181224b009ca6d91700273f56ab0">try_emplace</a> (key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2701181224b009ca6d91700273f56ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.  <br /></td></tr>
<tr class="separator:a2701181224b009ca6d91700273f56ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6e71848f61306f161e00ef6abbcba1"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:a0a6e71848f61306f161e00ef6abbcba1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0a6e71848f61306f161e00ef6abbcba1">try_emplace</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0a6e71848f61306f161e00ef6abbcba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.  <br /></td></tr>
<tr class="separator:a0a6e71848f61306f161e00ef6abbcba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04620bd4ec2d7f3b5d0df030f5a1d9f"><td class="memTemplParams" colspan="2">template&lt;class ... args_t&gt; </td></tr>
<tr class="memitem:aa04620bd4ec2d7f3b5d0df030f5a1d9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa04620bd4ec2d7f3b5d0df030f5a1d9f">try_emplace</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, args_t &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa04620bd4ec2d7f3b5d0df030f5a1d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.  <br /></td></tr>
<tr class="separator:aa04620bd4ec2d7f3b5d0df030f5a1d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86c4dc2cfd6286bc7543d33f99a695d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac86c4dc2cfd6286bc7543d33f99a695d">try_get_value</a> (const key_t &amp;key, value_t &amp;value) const override</td></tr>
<tr class="memdesc:ac86c4dc2cfd6286bc7543d33f99a695d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value associated with the specified key.  <br /></td></tr>
<tr class="separator:ac86c4dc2cfd6286bc7543d33f99a695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:a82c683da2de29870afa991f4445dac29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a82c683da2de29870afa991f4445dac29">operator=</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a82c683da2de29870afa991f4445dac29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a82c683da2de29870afa991f4445dac29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f2116e984d8e567f334c97e84f4bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a34f2116e984d8e567f334c97e84f4bc8">operator=</a> (std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a34f2116e984d8e567f334c97e84f4bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a34f2116e984d8e567f334c97e84f4bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8af37e930bc671470277333004815c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa8af37e930bc671470277333004815c6">operator=</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:aa8af37e930bc671470277333004815c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:aa8af37e930bc671470277333004815c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93aa4cf42b1c7c83d3b01dafe6deac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa93aa4cf42b1c7c83d3b01dafe6deac1">operator=</a> (const std::unordered_map&lt; key_t, value_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aa93aa4cf42b1c7c83d3b01dafe6deac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:aa93aa4cf42b1c7c83d3b01dafe6deac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ceb0d680fe9a5d5d6c2f02e4bdcd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a14ceb0d680fe9a5d5d6c2f02e4bdcd60">operator=</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">ilist</a>)</td></tr>
<tr class="memdesc:a14ceb0d680fe9a5d5d6c2f02e4bdcd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a14ceb0d680fe9a5d5d6c2f02e4bdcd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d7bdef948dda8ae4029da1ea3b398a"><td class="memTemplParams" colspan="2">template&lt;class init_key_t , class init_value_t &gt; </td></tr>
<tr class="memitem:a14d7bdef948dda8ae4029da1ea3b398a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a14d7bdef948dda8ae4029da1ea3b398a">operator=</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">ilist</a>)</td></tr>
<tr class="memdesc:a14d7bdef948dda8ae4029da1ea3b398a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a14d7bdef948dda8ae4029da1ea3b398a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8d5edb392d4da50dfa18ff778b9aec"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0e8d5edb392d4da50dfa18ff778b9aec">operator[]</a> (const key_t &amp;key) const override</td></tr>
<tr class="memdesc:a0e8d5edb392d4da50dfa18ff778b9aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element with the specified key.  <br /></td></tr>
<tr class="separator:a0e8d5edb392d4da50dfa18ff778b9aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bf80a6988e9d62a6e57df4f12e00c2"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a03bf80a6988e9d62a6e57df4f12e00c2">operator[]</a> (const key_t &amp;key) override</td></tr>
<tr class="memdesc:a03bf80a6988e9d62a6e57df4f12e00c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element with the specified key.  <br /></td></tr>
<tr class="separator:a03bf80a6988e9d62a6e57df4f12e00c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b0f390c2eef3a3bc08a06c74134c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a04b0f390c2eef3a3bc08a06c74134c7b">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:a04b0f390c2eef3a3bc08a06c74134c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a04b0f390c2eef3a3bc08a06c74134c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2128516be272bac5e5a5561d1ad55eff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2128516be272bac5e5a5561d1ad55eff">operator base_type &amp;</a> () noexcept</td></tr>
<tr class="memdesc:a2128516be272bac5e5a5561d1ad55eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a2128516be272bac5e5a5561d1ad55eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1idictionary')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a></td></tr>
<tr class="memitem:a7d3fdc16ef498f8c7a4bc8e625ef8d92 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a7d3fdc16ef498f8c7a4bc8e625ef8d92">key_type</a> = key_t</td></tr>
<tr class="memdesc:a7d3fdc16ef498f8c7a4bc8e625ef8d92 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary key type.  <br /></td></tr>
<tr class="separator:a7d3fdc16ef498f8c7a4bc8e625ef8d92 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d8c36814a04e88a2c3765254402fea inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ab9d8c36814a04e88a2c3765254402fea">mapped_type</a> = value_t</td></tr>
<tr class="memdesc:ab9d8c36814a04e88a2c3765254402fea inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary mapped type.  <br /></td></tr>
<tr class="separator:ab9d8c36814a04e88a2c3765254402fea inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb74752fe514a28bebbd814114d869a inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a4cb74752fe514a28bebbd814114d869a">value_type</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &gt;::value_type</td></tr>
<tr class="memdesc:a4cb74752fe514a28bebbd814114d869a inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs.">xtd::collections::generic::idictionary</a> value type.  <br /></td></tr>
<tr class="separator:a4cb74752fe514a28bebbd814114d869a inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966d5c58830c823e37b4d2e227d989af inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a966d5c58830c823e37b4d2e227d989af">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a4cb74752fe514a28bebbd814114d869a">value_type</a> &gt;::iterator</td></tr>
<tr class="memdesc:a966d5c58830c823e37b4d2e227d989af inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a966d5c58830c823e37b4d2e227d989af inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445bda4f9b1bfde0cbb4f77b6b6b1ec9 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a445bda4f9b1bfde0cbb4f77b6b6b1ec9">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a4cb74752fe514a28bebbd814114d869a">value_type</a> &gt;::const_iterator</td></tr>
<tr class="memdesc:a445bda4f9b1bfde0cbb4f77b6b6b1ec9 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a445bda4f9b1bfde0cbb4f77b6b6b1ec9 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f7bfc73fd451652caf2f96af00442 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a348f7bfc73fd451652caf2f96af00442">key_collection</a> = <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a7d3fdc16ef498f8c7a4bc8e625ef8d92">key_type</a> &gt;</td></tr>
<tr class="memdesc:a348f7bfc73fd451652caf2f96af00442 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary key collection type.  <br /></td></tr>
<tr class="separator:a348f7bfc73fd451652caf2f96af00442 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0389edc8c5aa120ac731815b4cd96805 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a0389edc8c5aa120ac731815b4cd96805">value_collection</a> = <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ab9d8c36814a04e88a2c3765254402fea">mapped_type</a> &gt;</td></tr>
<tr class="memdesc:a0389edc8c5aa120ac731815b4cd96805 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary value collection type.  <br /></td></tr>
<tr class="separator:a0389edc8c5aa120ac731815b4cd96805 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1icollection')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a></td></tr>
<tr class="memitem:aabf331b843fac4f0cc1f5ac55e839e2c inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#aabf331b843fac4f0cc1f5ac55e839e2c">value_type</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &gt;::value_type</td></tr>
<tr class="memdesc:aabf331b843fac4f0cc1f5ac55e839e2c inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> value type.  <br /></td></tr>
<tr class="separator:aabf331b843fac4f0cc1f5ac55e839e2c inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1afc368593b46d649796b6b9034c90a inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#ae1afc368593b46d649796b6b9034c90a">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &gt;::iterator</td></tr>
<tr class="memdesc:ae1afc368593b46d649796b6b9034c90a inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:ae1afc368593b46d649796b6b9034c90a inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711d92da8c3c0b5d6f6f3c83154ed8d5 inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a711d92da8c3c0b5d6f6f3c83154ed8d5">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &gt;::const_iterator</td></tr>
<tr class="memdesc:a711d92da8c3c0b5d6f6f3c83154ed8d5 inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a711d92da8c3c0b5d6f6f3c83154ed8d5 inherit pub_types_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable&lt; type_t &gt;</a></td></tr>
<tr class="memitem:a1b6f4bbb7a3c18056332b28dae525927 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a1b6f4bbb7a3c18056332b28dae525927">value_type</a> = type_t</td></tr>
<tr class="memdesc:a1b6f4bbb7a3c18056332b28dae525927 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a1b6f4bbb7a3c18056332b28dae525927 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287e9c3dff72a406f2cf715de19afb11 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a287e9c3dff72a406f2cf715de19afb11">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators</a>&lt; type_t, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; type_t &gt; &gt;::iterator</td></tr>
<tr class="memdesc:a287e9c3dff72a406f2cf715de19afb11 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a287e9c3dff72a406f2cf715de19afb11 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a5659ab1d2d261e2a5d390685f6765 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#ac4a5659ab1d2d261e2a5d390685f6765">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators</a>&lt; type_t, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; type_t &gt; &gt;::const_iterator</td></tr>
<tr class="memdesc:ac4a5659ab1d2d261e2a5d390685f6765 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:ac4a5659ab1d2d261e2a5d390685f6765 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;</a></td></tr>
<tr class="memitem:a887f291bffea0f450760702ed2682590 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a887f291bffea0f450760702ed2682590">iterator</a> = enumerable_iterator</td></tr>
<tr class="memdesc:a887f291bffea0f450760702ed2682590 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of enumarable value type.  <br /></td></tr>
<tr class="separator:a887f291bffea0f450760702ed2682590 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75470cb0387e1459f1a87c300f097560 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a75470cb0387e1459f1a87c300f097560">const_iterator</a> = const enumerable_iterator</td></tr>
<tr class="memdesc:a75470cb0387e1459f1a87c300f097560 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of enumarable value type.  <br /></td></tr>
<tr class="separator:a75470cb0387e1459f1a87c300f097560 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable&lt; ienumerable&lt; type_t &gt;, type_t &gt;</a></td></tr>
<tr class="memitem:afa0428a5d439bb7fd6a75f0ca54751c5 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afa0428a5d439bb7fd6a75f0ca54751c5">enumerable_type</a> = <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt;</td></tr>
<tr class="memdesc:afa0428a5d439bb7fd6a75f0ca54751c5 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable enumerable type.  <br /></td></tr>
<tr class="separator:afa0428a5d439bb7fd6a75f0ca54751c5 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723aac49b8d3459b2caaff26c2ab90e0 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a723aac49b8d3459b2caaff26c2ab90e0">source_type</a> = type_t</td></tr>
<tr class="memdesc:a723aac49b8d3459b2caaff26c2ab90e0 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable source type.  <br /></td></tr>
<tr class="separator:a723aac49b8d3459b2caaff26c2ab90e0 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a> = typename <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">xtd::linq::enumerable::ienumerable</a>&lt; type_t &gt;</td></tr>
<tr class="memdesc:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a> = typename <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">xtd::linq::enumerable::list</a>&lt; type_t &gt;</td></tr>
<tr class="memdesc:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd11aa88ce86568b701b33fd1b3e508 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a6bd11aa88ce86568b701b33fd1b3e508 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a6bd11aa88ce86568b701b33fd1b3e508 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1idictionary"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1idictionary')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1icollection')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a></td></tr>
<tr class="memitem:a730d78dcfbf97aa94f662db6fbaee23d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a730d78dcfbf97aa94f662db6fbaee23d">add</a> (const <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &amp;item)=0</td></tr>
<tr class="memdesc:a730d78dcfbf97aa94f662db6fbaee23d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a730d78dcfbf97aa94f662db6fbaee23d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcee883f64746e43b1755f9f1b5d18c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a6bcee883f64746e43b1755f9f1b5d18c">contains</a> (const <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &amp;item) const noexcept=0</td></tr>
<tr class="memdesc:a6bcee883f64746e43b1755f9f1b5d18c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; contains a specific value.  <br /></td></tr>
<tr class="separator:a6bcee883f64746e43b1755f9f1b5d18c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5395bfa3efc35df844dc5c1d3197621c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a5395bfa3efc35df844dc5c1d3197621c">copy_to</a> (<a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &gt; &amp;<a class="el" href="classxtd_1_1array.html">array</a>, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> array_index) const=0</td></tr>
<tr class="memdesc:a5395bfa3efc35df844dc5c1d3197621c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; to an <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a>, starting at a particular <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> index.  <br /></td></tr>
<tr class="separator:a5395bfa3efc35df844dc5c1d3197621c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dc990732868e3e519a93f4d7f03112 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a86dc990732868e3e519a93f4d7f03112">remove</a> (const <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &amp;item)=0</td></tr>
<tr class="memdesc:a86dc990732868e3e519a93f4d7f03112 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first occurrence of a specific object from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a86dc990732868e3e519a93f4d7f03112 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1icollection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1ienumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1ienumerable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable&lt; type_t &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable&lt; ienumerable&lt; type_t &gt;, type_t &gt;</a></td></tr>
<tr class="memitem:a22f3540f62b3b6140ecf188faf509842 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a> (const std::function&lt; type_t(const type_t &amp;, const type_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>) const</td></tr>
<tr class="memdesc:a22f3540f62b3b6140ecf188faf509842 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a22f3540f62b3b6140ecf188faf509842 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bbfa7cff2e26dcf33e973a97d42316 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#af8bbfa7cff2e26dcf33e973a97d42316">aggregate</a> (const type_t &amp;seed, const std::function&lt; type_t(const type_t &amp;, const type_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>) const</td></tr>
<tr class="memdesc:af8bbfa7cff2e26dcf33e973a97d42316 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:af8bbfa7cff2e26dcf33e973a97d42316 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">accumulate_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2705732af439af4da98a7a28f0a02f5a">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const type_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>) const</td></tr>
<tr class="memdesc:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487db86dcfc03a261804db9288b917df inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a487db86dcfc03a261804db9288b917df">aggregate</a> (const type_t &amp;seed, const std::function&lt; type_t(const type_t &amp;, const type_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>, const std::function&lt; type_t(const type_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a487db86dcfc03a261804db9288b917df inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a487db86dcfc03a261804db9288b917df inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">result_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0b91578ce3ebc8da03751dfca700bf7d">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const type_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__delegates.html#ga972b9383c3235752ab971d9d6be04c88">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c344a4319826da54bae2611d78f7e41 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a> (const std::function&lt; bool(const type_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a8c344a4319826da54bae2611d78f7e41 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a8c344a4319826da54bae2611d78f7e41 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e647f592add925edc5682334fa2b29 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">any</a> () const noexcept</td></tr>
<tr class="memdesc:a25e647f592add925edc5682334fa2b29 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a25e647f592add925edc5682334fa2b29 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddaea79f05f3a1d7c83bdc64883ec44 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a7ddaea79f05f3a1d7c83bdc64883ec44">any</a> (const std::function&lt; bool(const type_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a7ddaea79f05f3a1d7c83bdc64883ec44 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a7ddaea79f05f3a1d7c83bdc64883ec44 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227fd05d7acfc24fe8805534fd706309 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a227fd05d7acfc24fe8805534fd706309">append</a> (const type_t &amp;element) const noexcept</td></tr>
<tr class="memdesc:a227fd05d7acfc24fe8805534fd706309 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a227fd05d7acfc24fe8805534fd706309 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184c35f6e8a0058a196b533394dbccd7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a184c35f6e8a0058a196b533394dbccd7">as_enumerable</a> () const noexcept</td></tr>
<tr class="memdesc:a184c35f6e8a0058a196b533394dbccd7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a184c35f6e8a0058a196b533394dbccd7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5669f1a9bf9da6303aa9ff29197b4799 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5669f1a9bf9da6303aa9ff29197b4799">average</a> () const noexcept</td></tr>
<tr class="memdesc:a5669f1a9bf9da6303aa9ff29197b4799 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of source_t values.  <br /></td></tr>
<tr class="separator:a5669f1a9bf9da6303aa9ff29197b4799 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ac8353f4d5daa13e1810b8aad661eb938">cast</a> () const noexcept</td></tr>
<tr class="memdesc:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> to the specified type.  <br /></td></tr>
<tr class="separator:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e97c665374affe07c6240f55db92a63 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; type_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8e97c665374affe07c6240f55db92a63">chunk</a> (size_t <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">size</a>) const</td></tr>
<tr class="memdesc:a8e97c665374affe07c6240f55db92a63 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the elements of a sequence into chunks of size at most size.  <br /></td></tr>
<tr class="separator:a8e97c665374affe07c6240f55db92a63 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28746d3222dc23090a710dd8548e77e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ad28746d3222dc23090a710dd8548e77e">concat</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;second) const noexcept</td></tr>
<tr class="memdesc:ad28746d3222dc23090a710dd8548e77e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two sequences.  <br /></td></tr>
<tr class="separator:ad28746d3222dc23090a710dd8548e77e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e29837254bb373971404eb103ba26 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ad77e29837254bb373971404eb103ba26">contains</a> (const type_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:ad77e29837254bb373971404eb103ba26 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using the default equality comparer.  <br /></td></tr>
<tr class="separator:ad77e29837254bb373971404eb103ba26 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4be2e1cde9d4316519230b03e0496 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a87d4be2e1cde9d4316519230b03e0496">contains</a> (const type_t &amp;value, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; type_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept</td></tr>
<tr class="memdesc:a87d4be2e1cde9d4316519230b03e0496 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using a specified equality comparer.  <br /></td></tr>
<tr class="separator:a87d4be2e1cde9d4316519230b03e0496 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0560a5c54fcf0e9786018f00e136c7fb inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a> () const noexcept</td></tr>
<tr class="memdesc:a0560a5c54fcf0e9786018f00e136c7fb inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in current sequence.  <br /></td></tr>
<tr class="separator:a0560a5c54fcf0e9786018f00e136c7fb inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef0abd344f629aef3c96e49d272b50c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aeef0abd344f629aef3c96e49d272b50c">count</a> (const std::function&lt; bool(const type_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:aeef0abd344f629aef3c96e49d272b50c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number that represents how many elements in the specified sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aeef0abd344f629aef3c96e49d272b50c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b65916d2ccf5f2e4d1eb3f4ef4850d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a45b65916d2ccf5f2e4d1eb3f4ef4850d">count</a> (const type_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:a45b65916d2ccf5f2e4d1eb3f4ef4850d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with the specified value.  <br /></td></tr>
<tr class="separator:a45b65916d2ccf5f2e4d1eb3f4ef4850d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; key_t, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0dba2660f845875cd5908be53e52bbc7">count_by</a> (const std::function&lt; key_t(const type_t &amp;)&gt; &amp;key_selector) const noexcept</td></tr>
<tr class="memdesc:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; key_t, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#acd274fa4579c9e02119888c7135d6c8e">count_by</a> (const std::function&lt; key_t(const type_t &amp;)&gt; &amp;key_selector, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;key_comparer) const noexcept</td></tr>
<tr class="memdesc:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb41413e817b71a549e3f99aaf743e1 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a3fb41413e817b71a549e3f99aaf743e1">default_if_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3fb41413e817b71a549e3f99aaf743e1 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a3fb41413e817b71a549e3f99aaf743e1 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5954e34075473c77cc41c979ed506fa3 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5954e34075473c77cc41c979ed506fa3">default_if_empty</a> (const type_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:a5954e34075473c77cc41c979ed506fa3 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the specified value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a5954e34075473c77cc41c979ed506fa3 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcddc251cf8f945686a5f77807e62dcd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afcddc251cf8f945686a5f77807e62dcd">first_or_default</a> (const std::function&lt; bool(const type_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>, const type_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:afcddc251cf8f945686a5f77807e62dcd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:afcddc251cf8f945686a5f77807e62dcd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52658d4876a5f7642288ef7cfd0be8 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2e52658d4876a5f7642288ef7cfd0be8">first_or_default</a> (const std::function&lt; bool(const type_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:a2e52658d4876a5f7642288ef7cfd0be8 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2e52658d4876a5f7642288ef7cfd0be8 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0a757b76c036ef644cec12662f887 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2ba0a757b76c036ef644cec12662f887">first_or_default</a> (const type_t default_value) const noexcept</td></tr>
<tr class="memdesc:a2ba0a757b76c036ef644cec12662f887 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2ba0a757b76c036ef644cec12662f887 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964948d137047014d18a7cc5db15f46f inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a964948d137047014d18a7cc5db15f46f">first_or_default</a> () const noexcept</td></tr>
<tr class="memdesc:a964948d137047014d18a7cc5db15f46f inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a964948d137047014d18a7cc5db15f46f inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a69ca739f420b3ddd4df01845ce9bd979">select</a> (const std::function&lt; result_t(const type_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58637f7cae0e9518f0b728d47f2dc8f9 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a58637f7cae0e9518f0b728d47f2dc8f9">select</a> (const std::function&lt; type_t(const type_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a58637f7cae0e9518f0b728d47f2dc8f9 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a58637f7cae0e9518f0b728d47f2dc8f9 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a74a6585ba5b3ff487437db47ade70486">select</a> (const std::function&lt; result_t(const type_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009c5250029162433b826be3a1a93efd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a009c5250029162433b826be3a1a93efd">select</a> (const std::function&lt; type_t(const type_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a009c5250029162433b826be3a1a93efd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a009c5250029162433b826be3a1a93efd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a910fbeb2bb448c779d761dd865063c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a6a910fbeb2bb448c779d761dd865063c">to_list</a> () const noexcept</td></tr>
<tr class="memdesc:a6a910fbeb2bb448c779d761dd865063c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a6a910fbeb2bb448c779d761dd865063c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669773bec96bcfe7a5b4f43068892620 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a> (const std::function&lt; bool(const type_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a669773bec96bcfe7a5b4f43068892620 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a669773bec96bcfe7a5b4f43068892620 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c236ea62904000f45e720b7a7dbf17 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; type_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a46c236ea62904000f45e720b7a7dbf17">where</a> (const std::function&lt; bool(const type_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a46c236ea62904000f45e720b7a7dbf17 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a46c236ea62904000f45e720b7a7dbf17 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators.html">xtd::collections::generic::extensions::collection_operators&lt; type_t, collection_t &gt;</a></td></tr>
<tr class="memitem:a9effa697b1081e4a878eb7cc80b7a587 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators"><td class="memItemLeft" align="right" valign="top">virtual collection_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators.html#a9effa697b1081e4a878eb7cc80b7a587">operator&lt;&lt;</a> (const type_t &amp;item)</td></tr>
<tr class="memdesc:a9effa697b1081e4a878eb7cc80b7a587 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shift left operator adds an item to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a9effa697b1081e4a878eb7cc80b7a587 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067707d4538f53c223e344511d03dd99 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators"><td class="memItemLeft" align="right" valign="top">virtual collection_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators.html#a067707d4538f53c223e344511d03dd99">operator&gt;&gt;</a> (const type_t &amp;item)</td></tr>
<tr class="memdesc:a067707d4538f53c223e344511d03dd99 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shift right operator removes tthe first occurrence of a specific object from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a067707d4538f53c223e344511d03dd99 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1collection__operators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t &gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t &gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;</a></td></tr>
<tr class="memitem:a448a5456acc01f4fba47c60de3e131fb inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a448a5456acc01f4fba47c60de3e131fb">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a448a5456acc01f4fba47c60de3e131fb inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a448a5456acc01f4fba47c60de3e131fb inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4290d992ac1a1c103d8da2b51e0a5b3 inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">static target_collection_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ae4290d992ac1a1c103d8da2b51e0a5b3">to_iterator</a> (typename source_collection_t::iterator &amp;value, const source_collection_t &amp;source_collection, const target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:ae4290d992ac1a1c103d8da2b51e0a5b3 inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:ae4290d992ac1a1c103d8da2b51e0a5b3 inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa952a17cd36abced37d4ff35733790cc inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">static target_collection_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#aa952a17cd36abced37d4ff35733790cc">to_iterator</a> (typename source_collection_t::const_iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:aa952a17cd36abced37d4ff35733790cc inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:aa952a17cd36abced37d4ff35733790cc inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f03a39012c080e229c4c3c5d1ad6df inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">static target_collection_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a42f03a39012c080e229c4c3c5d1ad6df">to_iterator</a> (typename source_collection_t::iterator &amp;value, source_collection_t &amp;source_collection, target_collection_t &amp;target_collection) noexcept</td></tr>
<tr class="memdesc:a42f03a39012c080e229c4c3c5d1ad6df inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts source iterator to target iterator.  <br /></td></tr>
<tr class="separator:a42f03a39012c080e229c4c3c5d1ad6df inherit pub_static_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac46665df3307e2ef72937349cbe9a043" name="ac46665df3307e2ef72937349cbe9a043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46665df3307e2ef72937349cbe9a043">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_type =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;key_t, value_t&gt;::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary key type. </p>

</div>
</div>
<a id="ab62f8fa8a47c2a7f0f4371ec0483086d" name="ab62f8fa8a47c2a7f0f4371ec0483086d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62f8fa8a47c2a7f0f4371ec0483086d">&#9670;&#160;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::mapped_type =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;key_t, value_t&gt;::mapped_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary mapped type. </p>

</div>
</div>
<a id="a1f951179b33766491339c34e62fcc98f" name="a1f951179b33766491339c34e62fcc98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f951179b33766491339c34e62fcc98f">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::value_type =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary value type. </p>

</div>
</div>
<a id="af564e40d9fd72f4ad84f8e5ae62f4610" name="af564e40d9fd72f4ad84f8e5ae62f4610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af564e40d9fd72f4ad84f8e5ae62f4610">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::size_type =  <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary size type. </p>

</div>
</div>
<a id="ad6f561b6c8f20e4e5f9c8cf73dfbbcc5" name="ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f561b6c8f20e4e5f9c8cf73dfbbcc5">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::difference_type =  <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca">xtd::ptrdiff</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary difference type. </p>

</div>
</div>
<a id="a1d6112bd0a235323e439c6a230e3fb76" name="a1d6112bd0a235323e439c6a230e3fb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6112bd0a235323e439c6a230e3fb76">&#9670;&#160;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_equal =  <a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1equator.html">equator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary key_equal type. </p>

</div>
</div>
<a id="ad1d7f951247c504df41d30e51f987394" name="ad1d7f951247c504df41d30e51f987394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d7f951247c504df41d30e51f987394">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::allocator_type =  allocator_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary allocator type. </p>

</div>
</div>
<a id="a6a69009b6f6be690dbfa2591d29b28c4" name="a6a69009b6f6be690dbfa2591d29b28c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a69009b6f6be690dbfa2591d29b28c4">&#9670;&#160;</a></span>base_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::base_value_type =  std::pair&lt;const key_t, value_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary base value type. </p>

</div>
</div>
<a id="a48eda53efea9ddfea79ad6f47b9f1eb8" name="a48eda53efea9ddfea79ad6f47b9f1eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48eda53efea9ddfea79ad6f47b9f1eb8">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::base_type =  std::unordered_map&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>, <a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html">hasher</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1d6112bd0a235323e439c6a230e3fb76">key_equal</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary base type. </p>

</div>
</div>
<a id="a1f55af09de680f0014615c3d4c4a2915" name="a1f55af09de680f0014615c3d4c4a2915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f55af09de680f0014615c3d4c4a2915">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::reference =  <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary reference type. </p>

</div>
</div>
<a id="ad8b6e59722145f09a8b59f06d94c9601" name="ad8b6e59722145f09a8b59f06d94c9601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b6e59722145f09a8b59f06d94c9601">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_reference =  const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary const reference type. </p>

</div>
</div>
<a id="a853042cc781b451b7e8c0522526c48e9" name="a853042cc781b451b7e8c0522526c48e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853042cc781b451b7e8c0522526c48e9">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::pointer =  typename std::allocator_traits&lt;allocator_t&gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary pointer type. </p>

</div>
</div>
<a id="af84e5f837cd6080080b886aa3378288b" name="af84e5f837cd6080080b886aa3378288b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84e5f837cd6080080b886aa3378288b">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_pointer =  typename std::allocator_traits&lt;allocator_t&gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary const pointer type. </p>

</div>
</div>
<a id="aec072eea57e68e1c6fad6aaee1a5a22e" name="aec072eea57e68e1c6fad6aaee1a5a22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec072eea57e68e1c6fad6aaee1a5a22e">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::iterator =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the iterator of dictionary value type. </p>

</div>
</div>
<a id="a7cadb73d74ba5ee36bafe1bc66810cb0" name="a7cadb73d74ba5ee36bafe1bc66810cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cadb73d74ba5ee36bafe1bc66810cb0">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_iterator =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const iterator of dictionary value type. </p>

</div>
</div>
<a id="adc966a9b4269ce145604c61eace7f57c" name="adc966a9b4269ce145604c61eace7f57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc966a9b4269ce145604c61eace7f57c">&#9670;&#160;</a></span>local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::local_iterator =  typename base_type::local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the local iterator of dictionary value type. </p>

</div>
</div>
<a id="a259c368e0dff747a4e4687d94d0ca8e0" name="a259c368e0dff747a4e4687d94d0ca8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259c368e0dff747a4e4687d94d0ca8e0">&#9670;&#160;</a></span>const_local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_local_iterator =  typename base_type::const_local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const local iterator of dictionary value type. </p>

</div>
</div>
<a id="a09ebfcd509b5c4d473ec9ab61bed6e85" name="a09ebfcd509b5c4d473ec9ab61bed6e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ebfcd509b5c4d473ec9ab61bed6e85">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::node_type =  typename base_type::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary node type. </p>

</div>
</div>
<a id="a7e88bf6f5031a8e127a56adb37ec848d" name="a7e88bf6f5031a8e127a56adb37ec848d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e88bf6f5031a8e127a56adb37ec848d">&#9670;&#160;</a></span>insert_return_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_return_type =  typename base_type::insert_return_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary insert return type. </p>

</div>
</div>
<a id="a4b86fcba0283b6ed1cb596b086e7d388" name="a4b86fcba0283b6ed1cb596b086e7d388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b86fcba0283b6ed1cb596b086e7d388">&#9670;&#160;</a></span>key_collection</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_collection =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::key_collection</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the idictionary key collection type. </p>

</div>
</div>
<a id="a5837e916ed3ecf5ad27d9c1287033f52" name="a5837e916ed3ecf5ad27d9c1287033f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5837e916ed3ecf5ad27d9c1287033f52">&#9670;&#160;</a></span>value_collection</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::value_collection =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::value_collection</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the idictionary value collection type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a50b15016f1b91a266a8beec12ab89584" name="a50b15016f1b91a266a8beec12ab89584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b15016f1b91a266a8beec12ab89584">&#9670;&#160;</a></span>dictionary() <span class="overload">[1/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the default equality comparer for the key type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the default equality comparer. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. This constructor uses the default generic equality comparer, equality_comparer::default. If type <code>key_t</code> implements the xtd::equatable &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. Alternatively, you can specify an implementation of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">iequality_comparer</a> &lt;typer_t&gt; generic interface by using a constructor that accepts a comparer parameter. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you can estimate the size of the collection, using a constructor that specifies the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd>
<dd>
This constructor is an O(1) operation. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example creates an empty <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; of strings with string keys and uses the Add method to add some elements. The example demonstrates that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">dictionary::add</a> method throws an <a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a> when attempting to add a duplicate key.</dd></dl>
<p>This code example is part of a larger example provided for the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class. </p><div class="fragment"><div class="line"><span class="comment">// Create a new dictionary of strings, with string keys.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">auto</span> open_with = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary&lt;string, string&gt;</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add some elements to the dictionary. There are no</span></div>
<div class="line"><span class="comment">// duplicate keys, but some of the values are duplicates.</span></div>
<div class="line">open_with.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522">add</a>(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;notepad.exe&quot;</span>);</div>
<div class="line">open_with.add(<span class="stringliteral">&quot;bmp&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">open_with.add(<span class="stringliteral">&quot;dib&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">open_with.add(<span class="stringliteral">&quot;rtf&quot;</span>, <span class="stringliteral">&quot;wordpad.exe&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The add method throws an exception if the new key is</span></div>
<div class="line"><span class="comment">// already in the dictionary.</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  open_with.add(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;winword.exe&quot;</span>);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1argument__exception.html">argument_exception</a>&amp;) {</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;An element with key = \&quot;txt\&quot; already exists.&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afd88350f974f41a0c131db83cbf72290" name="afd88350f974f41a0c131db83cbf72290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd88350f974f41a0c131db83cbf72290">&#9670;&#160;</a></span>dictionary() <span class="overload">[2/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">idictionary</a>&lt; key_t, value_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs.">xtd::collections::generic::idictionary</a> &lt;key_t, value_t&gt; and uses the default equality comparer for the key type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dictionary</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs.">xtd::collections::generic::idictionary</a> &lt;key_t, value_t&gt; whose elements are copied to the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the default equality comparer; likewise, every key in the source <code>dictionary</code> must also be unique according to the default equality comparer. </dd>
<dd>
The initial capacity of the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is large enough to contain all the elements in dictionary. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. This constructor uses the default generic equality comparer, <a class="el" href="classxtd_1_1collections_1_1generic_1_1equality__comparer.html#a5849423379f7c39750a1713ba8c44e35" title="Gets the default equality comparer for the type specified by the generic argument.">xtd::collections::generic::equality_comparer::default_equality_comparer</a>. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. Alternatively, you can specify an implementation of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; generic interface by using a constructor that accepts a comparer parameter. </dd>
<dd>
This constructor is an O(n) operation, where n is the number of elements in dictionary. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example shows how to use the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;(<a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;key_t&gt;) constructor to initialize a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; with sorted content from another dictionary. The code example creates a <a class="el" href="group__generic__collections.html#ga64bb7a14ab354aad70b9c8a839aca3d9" title="Represents a collection of key/value pairs that are sorted on the key.">xtd::collections::generic::sorted_dictionary</a> &lt;key_t, value_t&gt; and populates it with data in random order, then passes the <a class="el" href="group__generic__collections.html#ga64bb7a14ab354aad70b9c8a839aca3d9" title="Represents a collection of key/value pairs that are sorted on the key.">xtd::collections::generic::sorted_dictionary</a> &lt;key_t, value_t&gt; to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;(<a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;key_t&gt;) constructor, creating a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; that is sorted. This is useful if you need to build a sorted dictionary that at some point becomes static; copying the data from a <a class="el" href="group__generic__collections.html#ga64bb7a14ab354aad70b9c8a839aca3d9" title="Represents a collection of key/value pairs that are sorted on the key.">xtd::collections::generic::sorted_dictionary</a> &lt;key_t, value_t&gt; to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; improves retrieval speed. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/xtd&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd.html">xtd</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacextd_1_1collections_1_1generic.html">xtd::collections::generic</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>example {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> main() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="comment">// Create a new sorted dictionary of strings, with string keys.</span></div>
<div class="line">    <span class="keyword">auto</span> open_with = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">sorted_dictionary&lt;string, string&gt;</a> {};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add some elements to the dictionary.</span></div>
<div class="line">    open_with.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522">add</a>(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;notepad.exe&quot;</span>);</div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;bmp&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;dib&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">    open_with.add(<span class="stringliteral">&quot;rtf&quot;</span>, <span class="stringliteral">&quot;wordpad.exe&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create a dictionary of strings with string keys, and</span></div>
<div class="line">    <span class="comment">// initialize it with the contents of the sorted dictionary.</span></div>
<div class="line">    <span class="keyword">auto</span> copy = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary&lt;string, string&gt;</a>(open_with);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// List the contents of the copy.</span></div>
<div class="line">    console::write_line();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair&lt;string, string&gt;</a>&amp; kvp : copy)</div>
<div class="line">      <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;key = {0}, value = {1}&quot;</span>, kvp.key(), kvp.value());</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__keywords.html#ga44bd440a34d147923e428eacd1c8eedd">startup_</a>(example::main);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This code produces the following output :</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// key = txt, value = notepad.exe</span></div>
<div class="line"><span class="comment">// key = bmp, value = paint.exe</span></div>
<div class="line"><span class="comment">// key = dib, value = paint.exe</span></div>
<div class="line"><span class="comment">// key = rtf, value = wordpad.exe</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae7ddf7990763fbea30e0c6e38b5ae659" name="ae7ddf7990763fbea30e0c6e38b5ae659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ddf7990763fbea30e0c6e38b5ae659">&#9670;&#160;</a></span>dictionary() <span class="overload">[3/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are copied to the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd1d7beda0f8576d701cd22e9e3a12d8" name="acd1d7beda0f8576d701cd22e9e3a12d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1d7beda0f8576d701cd22e9e3a12d8">&#9670;&#160;</a></span>dictionary() <span class="overload">[4/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equality_comparer_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const equality_comparer_t &amp;&#160;</td>
          <td class="paramname"><em>comparer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the specified xtd::collections::generic::iequality_comparer&lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>The xtd::collections::generic::iequality_comparer&lt;type_t&gt; implementation to use when comparing keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use this constructor with the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga088b87511ab0bc2c8d8d37b0582f0c5f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class to create dictionaries with case-insensitive string keys. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd></dl>

</div>
</div>
<a id="ae43f677d6205a77520b4601206429243" name="ae43f677d6205a77520b4601206429243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43f677d6205a77520b4601206429243">&#9670;&#160;</a></span>dictionary() <span class="overload">[5/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>hasher_t&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equator_t &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>equator_t&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer. </dd>
<dd>
The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that can be added to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; before resizing is necessary. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a933f2c0b545c0485ecf052ec431db7a4" name="a933f2c0b545c0485ecf052ec431db7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933f2c0b545c0485ecf052ec431db7a4">&#9670;&#160;</a></span>dictionary() <span class="overload">[6/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer. </dd>
<dd>
The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that can be added to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; before resizing is necessary. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="ab609bca970bff889772b49d51f204487" name="ab609bca970bff889772b49d51f204487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab609bca970bff889772b49d51f204487">&#9670;&#160;</a></span>dictionary() <span class="overload">[7/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equality_comparer_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">idictionary</a>&lt; key_t, value_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equality_comparer_t &amp;&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dictionary</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; whose elements are copied to the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
    <tr><td class="paramname">comparer</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; implementation to use when comparing keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use this constructor with the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga088b87511ab0bc2c8d8d37b0582f0c5f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class to create dictionaries with case-insensitive string keys. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer; likewise, every key in the source <code>dictionary</code> must also be unique according to the specified comparer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For example, duplicate keys can occur if <code>comparer</code> is one of the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga088b87511ab0bc2c8d8d37b0582f0c5f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class and <code>dictionary</code> does not use a case-insensitive comparer key. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The initial capacity of the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is large enough to contain all the elements in <code>dictionary</code>. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd>
<dd>
This constructor is an O(n) operation, where n is the number of elements in dictionary. </dd></dl>

</div>
</div>
<a id="a2e18164c1d61bd817872588bd77c6789" name="a2e18164c1d61bd817872588bd77c6789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e18164c1d61bd817872588bd77c6789">&#9670;&#160;</a></span>dictionary() <span class="overload">[8/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equality_comparer_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">ienumerable</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equality_comparer_t &amp;&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that contains elements copied from the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt; whose elements are copied to the new <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
    <tr><td class="paramname">comparer</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; implementation to use when comparing keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a349de516d0b938124c175ce956b3ac28" name="a349de516d0b938124c175ce956b3ac28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349de516d0b938124c175ce956b3ac28">&#9670;&#160;</a></span>dictionary() <span class="overload">[9/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equality_comparer_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equality_comparer_t &amp;&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the specified initial capacity, and uses the specified <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The initial number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can contain. </td></tr>
    <tr><td class="paramname">comparer</td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; implementation to use when comparing keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use this constructor with the case-insensitive string comparers provided by the <a class="el" href="group__system.html#ga088b87511ab0bc2c8d8d37b0582f0c5f" title="Represents a string comparison operation that uses specific case and culture-based or ordinal compari...">xtd::string_comparer</a> class to create dictionaries with case-insensitive string keys. </dd>
<dd>
Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the specified comparer; likewise, every key in the source <code>dictionary</code> must also be unique according to the specified comparer. </dd>
<dd>
The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that can be added to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; before resizing is necessary. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. If type TKey implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd>
<dd>
This constructor is an O(1) operation. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a78fb45416d0a2a0b1d27082b7912878b" name="a78fb45416d0a2a0b1d27082b7912878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fb45416d0a2a0b1d27082b7912878b">&#9670;&#160;</a></span>dictionary() <span class="overload">[10/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>hasher_t&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equator_t &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>equator_t&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The fist iterator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>Thaae last itezrator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs the container with the contents of the range [first, last). Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a85a1e3057a72c385fc731c20b21e9606" name="a85a1e3057a72c385fc731c20b21e9606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a1e3057a72c385fc731c20b21e9606">&#9670;&#160;</a></span>dictionary() <span class="overload">[11/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The fist iterator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>Thaae last itezrator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs the container with the contents of the range [first, last). Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a45d7fe8271b0f7dd1776a8a99de3b1d0" name="a45d7fe8271b0f7dd1776a8a99de3b1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d7fe8271b0f7dd1776a8a99de3b1d0">&#9670;&#160;</a></span>dictionary() <span class="overload">[12/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The fist iterator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>Thaae last itezrator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs the container with the contents of the range [first, last). Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="aa953d39916161c5551072ee7685d48dc" name="aa953d39916161c5551072ee7685d48dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa953d39916161c5551072ee7685d48dc">&#9670;&#160;</a></span>dictionary() <span class="overload">[13/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
<div class="ttc" id="agroup__xtd__core_html_ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf"><div class="ttname"><a href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">xtd::platform_id::other</a></div><div class="ttdeci">@ other</div><div class="ttdoc">The operating system is other.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a27cea1264d53956ff616c99322bd744a" name="a27cea1264d53956ff616c99322bd744a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cea1264d53956ff616c99322bd744a">&#9670;&#160;</a></span>dictionary() <span class="overload">[14/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; key_t, value_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5202127b516af4f37f86d4a3f472ddc6" name="a5202127b516af4f37f86d4a3f472ddc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5202127b516af4f37f86d4a3f472ddc6">&#9670;&#160;</a></span>dictionary() <span class="overload">[15/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; key_t, value_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a07b758a73f04808f26eee3fa8ce363ef" name="a07b758a73f04808f26eee3fa8ce363ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b758a73f04808f26eee3fa8ce363ef">&#9670;&#160;</a></span>dictionary() <span class="overload">[16/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="ab1c24d7c8b5165f2e3814e21c8ad0231" name="ab1c24d7c8b5165f2e3814e21c8ad0231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c24d7c8b5165f2e3814e21c8ad0231">&#9670;&#160;</a></span>dictionary() <span class="overload">[17/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="a153be4b6329ddb7d86bfedd03db85ca8" name="a153be4b6329ddb7d86bfedd03db85ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153be4b6329ddb7d86bfedd03db85ca8">&#9670;&#160;</a></span>dictionary() <span class="overload">[18/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="a6260ac3aa16033a8c92bbb9a71c7ede0" name="a6260ac3aa16033a8c92bbb9a71c7ede0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6260ac3aa16033a8c92bbb9a71c7ede0">&#9670;&#160;</a></span>dictionary() <span class="overload">[19/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="a457a42aa23639faa8590bdb23f2d346a" name="a457a42aa23639faa8590bdb23f2d346a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457a42aa23639faa8590bdb23f2d346a">&#9670;&#160;</a></span>dictionary() <span class="overload">[20/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>hasher_t&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equator_t &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>equator_t&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html_a50b15016f1b91a266a8beec12ab89584"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">xtd::collections::generic::dictionary::dictionary</a></div><div class="ttdeci">dictionary() noexcept=default</div><div class="ttdoc">Initializes a new instance of the xtd::collections::generic::dictionary &lt;key_t, value_t&gt; class that i...</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acd1e2bddbc888c451b97e6cd2f760250" name="acd1e2bddbc888c451b97e6cd2f760250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1e2bddbc888c451b97e6cd2f760250">&#9670;&#160;</a></span>dictionary() <span class="overload">[21/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a0db2868740c4f2c5e70bb845654d31cf" name="a0db2868740c4f2c5e70bb845654d31cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db2868740c4f2c5e70bb845654d31cf">&#9670;&#160;</a></span>dictionary() <span class="overload">[22/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="af8f5f06c57ba2d50fffe837ff8dde852" name="af8f5f06c57ba2d50fffe837ff8dde852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f5f06c57ba2d50fffe837ff8dde852">&#9670;&#160;</a></span>dictionary() <span class="overload">[23/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t , class init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>hasher_t&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const equator_t &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>equator_t&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a8b272479748bbf823035dc716d9dad1d" name="a8b272479748bbf823035dc716d9dad1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b272479748bbf823035dc716d9dad1d">&#9670;&#160;</a></span>dictionary() <span class="overload">[24/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t , class init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a144ad7bfb943fd88490c08ae70251968" name="a144ad7bfb943fd88490c08ae70251968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144ad7bfb943fd88490c08ae70251968">&#9670;&#160;</a></span>dictionary() <span class="overload">[25/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t , class init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hasher_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>`dictionary` contains one or more duplicate keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5fb05a4d36ada3a05639760bbef1866f" name="a5fb05a4d36ada3a05639760bbef1866f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb05a4d36ada3a05639760bbef1866f">&#9670;&#160;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a7b9f8c15358cc78f7265ffe8f6480579">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="ad43461af42f40fafcba6c351b8915909" name="ad43461af42f40fafcba6c351b8915909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43461af42f40fafcba6c351b8915909">&#9670;&#160;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ad1e3a53b1e5c0e7769075bd28132d959">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="ad51c920c156b8cc6863e143972f5c11b" name="ad51c920c156b8cc6863e143972f5c11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51c920c156b8cc6863e143972f5c11b">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of buckets in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of buckets in the container. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="a24ebcb226f6bc8869c35bf9e1d634ff3" name="a24ebcb226f6bc8869c35bf9e1d634ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ebcb226f6bc8869c35bf9e1d634ff3">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total numbers of elements the internal data structure can hold without resizing. </p>
<dl class="section return"><dt>Returns</dt><dd>The total numbers of elements the internal data structure can hold without resizing. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3" title="Gets the total numbers of elements the internal data structure can hold without resizing.">xtd::collections::generic::dictionary::capacity</a> and <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> are equivalent properties. </dd></dl>

</div>
</div>
<a id="ac375db294d333e09891584e2a0956e1d" name="ac375db294d333e09891584e2a0956e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac375db294d333e09891584e2a0956e1d">&#9670;&#160;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a9c64ad67e8894d51bd1ee7da6f397e14">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="ad63291ea36f70c7ded93799d6890847e" name="ad63291ea36f70c7ded93799d6890847e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63291ea36f70c7ded93799d6890847e">&#9670;&#160;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ab461dd402e7464666ba6657864ea5f40">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="a2826f22b8d56568081a760c9f6d594da" name="a2826f22b8d56568081a760c9f6d594da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2826f22b8d56568081a760c9f6d594da">&#9670;&#160;</a></span>comparer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::comparer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the td::collections::generic::iequality_comparer &lt;type_t&gt; that is used to determine equality of keys for the dictionary. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; generic interface implementation that is used to determine equality of keys for the current <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; and to provide hash values for the keys. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. You can specify an implementation of the td::collections::generic::iequality_comparer &lt;type_t&gt; generic interface by using a constructor that accepts a comparer parameter; if you do not specify one, the default generic equality comparer td::collections::generic::equality_comparer::default_equality_comparer is used. </dd></dl>

</div>
</div>
<a id="af92f9b1f02bf864a69a46230f9b53c62" name="af92f9b1f02bf864a69a46230f9b53c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92f9b1f02bf864a69a46230f9b53c62">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can store. The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> property is the number of elements that are actually in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
The capacity is always greater than or equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a>. If <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> exceeds the capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#ab1b79f5d91774cc70b8a4e21d979e1ea">xtd::collections::generic::icollection&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="a55611e5c2304788bf7a281fc5b75e1cb" name="a55611e5c2304788bf7a281fc5b75e1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55611e5c2304788bf7a281fc5b75e1cb">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumarable.">begin()</a> == <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">end()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty; otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a84bcbef97b1acb696d8b444988530830" name="a84bcbef97b1acb696d8b444988530830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bcbef97b1acb696d8b444988530830">&#9670;&#160;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a5f943e5420e93551f9d764a055a8e50a">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="a8e062f26b355616dce3110a815645e7d" name="a8e062f26b355616dce3110a815645e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e062f26b355616dce3110a815645e7d">&#9670;&#160;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a1cc1239887628ed8028bdd1339af135a">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, xtd::collections::generic::ienumerable&lt; type_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="af2181745ec5b125827735336ea9ada43" name="af2181745ec5b125827735336ea9ada43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2181745ec5b125827735336ea9ada43">&#9670;&#160;</a></span>is_read_only()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::is_read_only </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating whether the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is read-only. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is read-only; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A collection that is read-only does not allow the addition or removal of elements after the collection is created. Note that read-only in this context does not indicate whether individual elements of the collection can be modified, since the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; interface only supports addition and removal operations. For example, the IsReadOnly property of an array that is cast or converted to an <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; object returns <code>true</code>, even though individual array elements can be modified. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a817ed0a0b5cdb551aac7512c52ed4c96">xtd::collections::generic::icollection&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="a9798bb3a3f89e6dd45d5783d42957550" name="a9798bb3a3f89e6dd45d5783d42957550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9798bb3a3f89e6dd45d5783d42957550">&#9670;&#160;</a></span>is_synchronized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::is_synchronized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a value indicating whether access to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is synchronized (thread safe). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if access to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is synchronized (thread safe); otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290" title="Gets an object that can be used to synchronize access to the the xtd::collections::generic::icollecti...">xtd::collections::generic::icollection::sync_root</a> returns an object, which can be used to synchronize access to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;. </dd>
<dd>
Most collection classes in the <a class="el" href="namespacextd_1_1collections.html" title="The xtd::collections namespace contains interfaces and classes that define various collections of obj...">xtd::collections</a> namespace also implement a <code>synchronized</code> method, which provides a synchronized wrapper around the underlying collection. </dd>
<dd>
Enumerating through a collection is intrinsically not a thread-safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads. </dd>
<dd>
The following code example shows how to lock the collection using the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290" title="Gets an object that can be used to synchronize access to the the xtd::collections::generic::icollecti...">xtd::collections::generic::icollection::sync_root</a> property during the entire enumeration. <div class="fragment"><div class="line"><a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1icollection.html">icollection</a>&amp; my_collection = some_collection;</div>
<div class="line"><a class="code hl_define" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a>(my_collection.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290">sync_root</a>()) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> item : my_collection) {</div>
<div class="line">    <span class="comment">// Insert your code here.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1icollection_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection</a></div><div class="ttdoc">Defines methods to manipulate generic collections.</div><div class="ttdef"><b>Definition</b> icollection.hpp:45</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1icollection_html_a2b277c3530daec2186daa89e213da290"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290">xtd::collections::generic::icollection::sync_root</a></div><div class="ttdeci">virtual const xtd::object &amp; sync_root() const noexcept=0</div><div class="ttdoc">Gets an object that can be used to synchronize access to the the xtd::collections::generic::icollecti...</div></div>
<div class="ttc" id="agroup__keywords_html_gacd9906b29d877eb1eb0a8c7bc4ab774a"><div class="ttname"><a href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a></div><div class="ttdeci">#define lock_(object)</div><div class="ttdoc">The lock_ keyword marks a statement block as a critical section by obtaining the mutual-exclusion loc...</div><div class="ttdef"><b>Definition</b> lock.hpp:85</div></div>
</div><!-- fragment --> </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a182c2916a22a16eba26db94e8e9c0423">xtd::collections::generic::icollection&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="ac5f9fa62ba008a290c60f795e768d74f" name="ac5f9fa62ba008a290c60f795e768d74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f9fa62ba008a290c60f795e768d74f">&#9670;&#160;</a></span>items() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="aeb58202461ac49407519756acca9ed12" name="aeb58202461ac49407519756acca9ed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb58202461ac49407519756acca9ed12">&#9670;&#160;</a></span>items() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="ac2a9b4d312798abd41548c6c97ee3312" name="ac2a9b4d312798abd41548c6c97ee3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a9b4d312798abd41548c6c97ee3312">&#9670;&#160;</a></span>keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388">key_collection</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a collection containing the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388" title="Represents the idictionary key collection type.">xtd::collections::generic::dictionary::key_collection</a> containing the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388" title="Represents the idictionary key collection type.">xtd::collections::generic::dictionary::key_collection</a> is unspecified, but it is the same order as the associated values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52" title="Represents the idictionary value collection type.">xtd::collections::generic::dictionary::value_collection</a> returned by the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa5519d6518ce9849e89b90fd573839f2" title="Gets a collection containing the values in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::values</a> property. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a6784f23fccd9a8021528e645b0d73e22">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="ad12fed9d70080e18e58e5f678ff8fce0" name="ad12fed9d70080e18e58e5f678ff8fce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fed9d70080e18e58e5f678ff8fce0">&#9670;&#160;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the average number of elements per bucket, that is, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a9b8a36cd363866ea458b74960e5d68eb" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::size</a> divided by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Average number of elements per bucket. </dd></dl>

</div>
</div>
<a id="ad9e4c1821576c7fba7fdd4dea0f2c512" name="ad9e4c1821576c7fba7fdd4dea0f2c512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e4c1821576c7fba7fdd4dea0f2c512">&#9670;&#160;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of buckets the container is able to hold due to system or library implementation limitations. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of buckets. </dd></dl>

</div>
</div>
<a id="af4ebdfacb702aad8221aa1b77817cdbd" name="af4ebdfacb702aad8221aa1b77817cdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ebdfacb702aad8221aa1b77817cdbd">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold. </p>
<dl class="section return"><dt>Returns</dt><dd>The current maximum load factor. </dd></dl>

</div>
</div>
<a id="ad7f7acfa0c36a187bd76efe62d87581c" name="ad7f7acfa0c36a187bd76efe62d87581c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f7acfa0c36a187bd76efe62d87581c">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new maximum load factor setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a070747ad0686a9136f66dfc5e3b19aa9" name="a070747ad0686a9136f66dfc5e3b19aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070747ad0686a9136f66dfc5e3b19aa9">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">end()</a>)</code> for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This value typically reflects the theoretical limit on the size of the container, at most <code><a class="el" href="classxtd_1_1box__integer.html#a21847edbb248c1b0d07a35e2a8c08232" title="Represents the largest possible value of type_t. This field is constant.">xtd::ptrdiff_object::max_value</a></code> or <code>std::numeric_limits&lt;difference_type&gt;::max()</code>. At runtime, the size of the container may be limited to a value smaller than <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a070747ad0686a9136f66dfc5e3b19aa9" title="Gets the maximum number of elements the container is able to hold due to system or library implementa...">max_size()</a> by the amount of RAM available. </dd></dl>

</div>
</div>
<a id="a9b8a36cd363866ea458b74960e5d68eb" name="a9b8a36cd363866ea458b74960e5d68eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8a36cd363866ea458b74960e5d68eb">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can store. The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> property is the number of elements that are actually in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
The capacity is always greater than or equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a>. If <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> exceeds the capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

</div>
</div>
<a id="a0784fa1eee73f0061df828986a5ae52d" name="a0784fa1eee73f0061df828986a5ae52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0784fa1eee73f0061df828986a5ae52d">&#9670;&#160;</a></span>sync_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxtd_1_1object.html">xtd::object</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::sync_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an object that can be used to synchronize access to the the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>An object that can be used to synchronize access to the the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For collections whose underlying store is not publicly available, the expected implementation is to return the current instance. Note that the pointer to the current instance might not be sufficient for collections that wrap other collections; those should return the underlying collection's <code>sync_root</code> property. </dd>
<dd>
Most collection classes in the xts::.collections namespace also implement a <code>synchronized</code> method, which provides a synchronized wrapper around the underlying collection. However, derived classes can provide their own synchronized version of the collection using the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290" title="Gets an object that can be used to synchronize access to the the xtd::collections::generic::icollecti...">xtd::collections::generic::icollection::sync_root</a> property. The synchronizing code must perform operations on the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290" title="Gets an object that can be used to synchronize access to the the xtd::collections::generic::icollecti...">xtd::collections::generic::icollection::sync_root</a> property of the collection, not directly on the collection. This ensures proper operation of collections that are derived from other objects. Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection instance. </dd>
<dd>
In the absence of a <code>synchronized</code> method on a collection, the expected usage for the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290" title="Gets an object that can be used to synchronize access to the the xtd::collections::generic::icollecti...">xtd::collections::generic::icollection::sync_root</a> looks as follows: <div class="fragment"><div class="line"><a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1icollection.html">icollection</a>&amp; my_collection = some_collection;</div>
<div class="line"><a class="code hl_define" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a>(my_collection.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290">sync_root</a>()) {</div>
<div class="line">  <span class="comment">// Some operation on the collection, which is now thread safe.</span></div>
<div class="line">}</div>
<div class="line">@encode</div>
<div class="line">@remarks Enumerating through <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a> collection <a class="code hl_function" href="group__xtd__core.html#ga8419620dc289ac0d790372a1616e993f">is</a> intrinsically not <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a> thread-safe procedure. Even when <a class="code hl_enumvalue" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">a</a> collection <a class="code hl_function" href="group__xtd__core.html#ga8419620dc289ac0d790372a1616e993f">is</a> <span class="keyword">synchronized</span>, <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a> threads can still modify the collection, which causes the <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">enumerator</a> to <span class="keywordflow">throw</span> an <a class="code hl_class" href="classxtd_1_1exception.html">exception</a>. To guarantee thread safety during enumeration, you can either <a class="code hl_class" href="classxtd_1_1threading_1_1lock__guard.html">lock</a> the collection during the entire enumeration or <span class="keywordflow">catch</span> the exceptions resulting from changes made by <a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a> threads.</div>
<div class="line">@remarks The following code example shows how to <a class="code hl_class" href="classxtd_1_1threading_1_1lock__guard.html">lock</a> the collection <span class="keyword">using </span>the <a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290">xtd::collections::generic::icollection::sync_root</a> <span class="keyword">property</span> during the entire enumeration.</div>
<div class="line">@code</div>
<div class="line"><a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1icollection.html">icollection</a>&amp; my_collection = some_collection;</div>
<div class="line"><a class="code hl_define" href="group__keywords.html#gacd9906b29d877eb1eb0a8c7bc4ab774a">lock_</a>(my_collection.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290">sync_root</a>()) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> item : my_collection) {</div>
<div class="line">    <span class="comment">// Insert your code here.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassxtd_1_1exception_html"><div class="ttname"><a href="classxtd_1_1exception.html">xtd::exception</a></div><div class="ttdoc">Defines the base class for predefined exceptions in the xtd namespace.</div><div class="ttdef"><b>Definition</b> exception.hpp:30</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1lock__guard_html"><div class="ttname"><a href="classxtd_1_1threading_1_1lock__guard.html">xtd::threading::lock_guard</a></div><div class="ttdoc">Provides a mechanism that synchronizes access to objects with xtd::threading::monitor.</div><div class="ttdef"><b>Definition</b> lock_guard.hpp:32</div></div>
<div class="ttc" id="agroup__xtd__core_html_ga8419620dc289ac0d790372a1616e993f"><div class="ttname"><a href="group__xtd__core.html#ga8419620dc289ac0d790372a1616e993f">xtd::is</a></div><div class="ttdeci">bool is(xtd::any value)</div><div class="ttdoc">Checks if the result of an expression is compatible with a given type.</div><div class="ttdef"><b>Definition</b> is.hpp:485</div></div>
<div class="ttc" id="agroup__xtd__core_html_ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661"><div class="ttname"><a href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a0cc175b9c0f1b6a831c399e269772661">xtd::console_key::a</a></div><div class="ttdeci">@ a</div><div class="ttdoc">The A key.</div></div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1enumerator_html"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1enumerator.html">xtd::collections::generic::enumerator</a></div><div class="ttdoc">Supports a simple iteration over a generic collection.</div><div class="ttdef"><b>Definition</b> enumerator.hpp:38</div></div>
</div><!-- fragment --> </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#a2b277c3530daec2186daa89e213da290">xtd::collections::generic::icollection&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="aa5519d6518ce9849e89b90fd573839f2" name="aa5519d6518ce9849e89b90fd573839f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5519d6518ce9849e89b90fd573839f2">&#9670;&#160;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52">value_collection</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a collection containing the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52" title="Represents the idictionary value collection type.">xtd::collections::generic::dictionary::value_collection</a> containing the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52" title="Represents the idictionary value collection type.">xtd::collections::generic::dictionary::value_collection</a> is unspecified, but it is the same order as the associated keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388" title="Represents the idictionary key collection type.">xtd::collections::generic::dictionary::key_collection</a> returned by the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac2a9b4d312798abd41548c6c97ee3312" title="Gets a collection containing the keys in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::keys</a> property. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ab9b17f2c004a86dc970ccb5a95e60151">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a8e4b572d70b69d4b688a2835a3258522" name="a8e4b572d70b69d4b688a2835a3258522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4b572d70b69d4b688a2835a3258522">&#9670;&#160;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element with the provided key and value to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The object to use as the key of the element to add. </td></tr>
    <tr><td class="paramname">value</td><td>The object to use as the value of the element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>An element with the same key already exists in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>You can also use the <code>operator []</code> to add new elements by setting the value of a key that does not exist in the dictionary; for example, <code>my_collection["my_nonexistent_key"] = my_value</code>. However, if the specified key already exists in the dictionary, setting the <code>operator []</code> overwrites the old value. In contrast, the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method does not modify existing elements. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ae5306bbad7df56d8b4ce4089b78befdc">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a22f323cd7289784e6380117b8bfadf8b" name="a22f323cd7289784e6380117b8bfadf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f323cd7289784e6380117b8bfadf8b">&#9670;&#160;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an item to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The object to add to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56664bbd826ba01e34ff35477064db2d" name="a56664bbd826ba01e34ff35477064db2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56664bbd826ba01e34ff35477064db2d">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a></td><td>The property is retrieved and key is not found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32980a15b7ef803c1ba5c8d69f1dbb84" name="a32980a15b7ef803c1ba5c8d69f1dbb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32980a15b7ef803c1ba5c8d69f1dbb84">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a></td><td>The property is retrieved and key is not found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d3e8fd61595d88e72199205dbf976b5" name="a8d3e8fd61595d88e72199205dbf976b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3e8fd61595d88e72199205dbf976b5">&#9670;&#160;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#adc966a9b4269ce145604c61eace7f57c">local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the first element of the bucket with index <code>n</code>. </dd></dl>

</div>
</div>
<a id="a772b3aff980ea2b05d5bf8ce5cbdd9f1" name="a772b3aff980ea2b05d5bf8ce5cbdd9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772b3aff980ea2b05d5bf8ce5cbdd9f1">&#9670;&#160;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the first element of the bucket with index <code>n</code>. </dd></dl>

</div>
</div>
<a id="a3b83cb5cb0fa23c7b4ff7c2c447419aa" name="a3b83cb5cb0fa23c7b4ff7c2c447419aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b83cb5cb0fa23c7b4ff7c2c447419aa">&#9670;&#160;</a></span>bucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The value of the key to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bucket index for the requested key. </dd></dl>

</div>
</div>
<a id="a8ce1e7684c03c73e9980372eceb779a2" name="a8ce1e7684c03c73e9980372eceb779a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce1e7684c03c73e9980372eceb779a2">&#9670;&#160;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the bucket with index <code>n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the bucket <code>n</code>. </dd></dl>

</div>
</div>
<a id="a325d0ef8dbeb149776a600386b13a9c6" name="a325d0ef8dbeb149776a600386b13a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325d0ef8dbeb149776a600386b13a9c6">&#9670;&#160;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the first element of the bucket with index <code>n</code>. </dd></dl>

</div>
</div>
<a id="ab38876c6b918c241ca74f597089606c1" name="ab38876c6b918c241ca74f597089606c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38876c6b918c241ca74f597089606c1">&#9670;&#160;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the element following the last element of the bucket with index <code>n</code>. This element acts as a placeholder, attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a50385c2da2442292164bc4f65c84ee76" name="a50385c2da2442292164bc4f65c84ee76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50385c2da2442292164bc4f65c84ee76">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all keys and values from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> property is set to 0, and references to other objects from elements of the collection are also released. The capacity remains unchanged. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html#af14af0908d5e7bde4a3e33ebca358852">xtd::collections::generic::icollection&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="a7db129cddf553ee484a09e6d39bb87a0" name="a7db129cddf553ee484a09e6d39bb87a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db129cddf553ee484a09e6d39bb87a0">&#9670;&#160;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container contains element with specific key. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Checks if there is an element with <code>key</code> equivalent to key in the container. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="hashtable_8cpp-example.html#a1">hashtable.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac19c1aca5cdab0045940d70246b37093" name="ac19c1aca5cdab0045940d70246b37093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19c1aca5cdab0045940d70246b37093">&#9670;&#160;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class contains_key_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const contains_key_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container contains element with specific key. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Checks if there is an element with key that compares equivalent to the value <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such <code>hasher_t</code> is callable with both <code>contains_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>key_t</code>. </dd></dl>

</div>
</div>
<a id="a90b87fe3db85b2c9f55ac59544070e20" name="a90b87fe3db85b2c9f55ac59544070e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b87fe3db85b2c9f55ac59544070e20">&#9670;&#160;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether an element is in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The object to be added to the end of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains an element with the specified <code>item</code> ; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="acf27b6ece343e1dd7450de296277f892" name="acf27b6ece343e1dd7450de296277f892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf27b6ece343e1dd7450de296277f892">&#9670;&#160;</a></span>contains_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::contains_key </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>key to locate in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains an element with the specified <code>key</code> ; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method approaches an O(1) operation. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#aad1ca9a4fd67aecfd518cf2a2df6f73d">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a3d231addcc65486d9ad0abee23ada3ac" name="a3d231addcc65486d9ad0abee23ada3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d231addcc65486d9ad0abee23ada3ac">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>array_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; to an <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a>, starting at a particular <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The one-dimensional <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> that is the destination of the elements copied from <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt;. The <a class="el" href="classxtd_1_1array.html" title="Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the ba...">xtd::array</a> must have zero-based indexing. </td></tr>
    <tr><td class="paramname">array_index</td><td>The zero-based index in <code>array</code> at which copying begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>The number of elements in the source <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html" title="Defines methods to manipulate generic collections.">xtd::collections::generic::icollection</a> &lt;type_t&gt; is greater than the available space from `array_index` to the end of the destination `array`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62388a5a93af71eb55d9f509420d1acb" name="a62388a5a93af71eb55d9f509420d1acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62388a5a93af71eb55d9f509420d1acb">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs element in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container. </dd>
<dd>
The constructor of the new element (i.e. <code>std::pair&lt;const key_t, value_t&gt;)</code> is called with exactly the same arguments as supplied to emplace, forwarded via <code>std::forward&lt;args_t&gt;(args)....</code> The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately (see <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af3f68a0c5f67be81a1de0390a4f44ada" title="Inserts in-place if the key does not exist, does nothing if the key exists.">xtd::collections::generic::dictionary::try_emplace</a> if this behavior is undesirable). </dd>
<dd>
Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a657fad4302a8e0c5a82892df5bef0504" name="a657fad4302a8e0c5a82892df5bef0504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657fad4302a8e0c5a82892df5bef0504">&#9670;&#160;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs elements in-place using a hint </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the new element. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts a new element into the container, using <code>hint</code> as a suggestion where the element should go. </dd>
<dd>
The constructor of the element type (value_type, that is, <code>std::pair&lt;const key_t, value_t&gt;</code>) is called with exactly the same arguments as supplied to the function, forwarded with <code>std::forward&lt;args_t&gt;(args)...</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a0cefc1b2c8027b4257647fccda518f71" name="a0cefc1b2c8027b4257647fccda518f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cefc1b2c8027b4257647fccda518f71">&#9670;&#160;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#adc966a9b4269ce145604c61eace7f57c">local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the element following the last element of the bucket with index <code>n</code>. This element acts as a placeholder, attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="aa26ad005233fb7741a285d791e56db19" name="aa26ad005233fb7741a285d791e56db19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26ad005233fb7741a285d791e56db19">&#9670;&#160;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the specified bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns an iterator to the element following the last element of the bucket with index <code>n</code>. This element acts as a placeholder, attempting to access it results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a460da2f9004cddf41f14d23d1fa09a25" name="a460da2f9004cddf41f14d23d1fa09a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460da2f9004cddf41f14d23d1fa09a25">&#9670;&#160;</a></span>ensure_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::ensure_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the dictionary can hold up to a specified number of entries without any further expansion of its backing storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The number of entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>

</div>
</div>
<a id="a7192082480f0412da88dfa004dca3c3b" name="a7192082480f0412da88dfa004dca3c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7192082480f0412da88dfa004dca3c3b">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range of elements matching a specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value to compare the elements to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a>) iterators are returned as both elements of the pair. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns a range containing all elements with key <code>key</code> in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range. </dd></dl>

</div>
</div>
<a id="a85e8a1a164d50122468d84a0d31c0724" name="a85e8a1a164d50122468d84a0d31c0724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e8a1a164d50122468d84a0d31c0724">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equal_range_key_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const equal_range_key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range of elements matching a specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value to compare the elements to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a>) iterators are returned as both elements of the pair. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns a range containing all elements with key <code>key</code> in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range. </dd></dl>

</div>
</div>
<a id="a94931223079f91ec84fd48de20d2c3e8" name="a94931223079f91ec84fd48de20d2c3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94931223079f91ec84fd48de20d2c3e8">&#9670;&#160;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class equal_range_key_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const equal_range_key_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range of elements matching a specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value of any type that can be transparently compared with a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a>) iterators are returned as both elements of the pair. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns a range containing all elements in the container with key equivalent to <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such Hash is callable with both <code>equal_range_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>equal_range_key_t</code>. </dd></dl>

</div>
</div>
<a id="a60a7786db2622f4e3c0cab7f64b6ff58" name="a60a7786db2622f4e3c0cab7f64b6ff58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a7786db2622f4e3c0cab7f64b6ff58">&#9670;&#160;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range of elements matching a specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value of any type that can be transparently compared with a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a>) iterators are returned as both elements of the pair. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns a range containing all elements in the container with key equivalent to <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such Hash is callable with both <code>equal_range_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>key_t</code>. </dd></dl>

</div>
</div>
<a id="a05eab79e42511efe5dd18c64f470a6bd" name="a05eab79e42511efe5dd18c64f470a6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eab79e42511efe5dd18c64f470a6bd">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator to the element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator following the last removed element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes specified elements from the container. The order of the remaining elements is preserved. (This makes it possible to erase individual elements while iterating through the container.) </dd>
<dd>
Removes the element at <code>pos</code>. </dd>
<dd>
References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated. </dd>
<dd>
The iterator <code>pos</code> must be valid and dereferenceable. Thus the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for <code>pos</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="hashtable_8cpp-example.html#a2">hashtable.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a51e499b3634ee1402b59a6742fc817e1" name="a51e499b3634ee1402b59a6742fc817e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e499b3634ee1402b59a6742fc817e1">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of the range of elements to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator of the range of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator following the last removed element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes specified elements from the container. The order of the remaining elements is preserved. (This makes it possible to erase individual elements while iterating through the container.) </dd>
<dd>
Removes the elements in the range [<code>first</code>, <code>last</code>), which must be a valid range in <code>*this</code>. </dd>
<dd>
References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated. </dd>
<dd>
The iterator <code>pos</code> must be valid and dereferenceable. Thus the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for <code>pos</code>. </dd></dl>

</div>
</div>
<a id="aa7a6184442c9b335e7984d655f722e0d" name="aa7a6184442c9b335e7984d655f722e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a6184442c9b335e7984d655f722e0d">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value of the elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements removed (0 or 1). </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removes specified elements from the container. The order of the remaining elements is preserved. (This makes it possible to erase individual elements while iterating through the container.) </dd>
<dd>
Removes the element (if one exists) with the key equivalent to <code>key</code>. </dd>
<dd>
References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated. </dd>
<dd>
The iterator <code>pos</code> must be valid and dereferenceable. Thus the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for <code>pos</code>. </dd></dl>

</div>
</div>
<a id="a7934e22726ecf3f3e3ddbe7ae6dbe4b5" name="a7934e22726ecf3f3e3ddbe7ae6dbe4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7934e22726ecf3f3e3ddbe7ae6dbe4b5">&#9670;&#160;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts nodes from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A valid iterator into this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a> that owns the extracted element, or empty node handle in case the element is not found in. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlinks the node that contains the element pointed to by position and returns a <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a> that owns it. </dd>
<dd>
In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed. </dd>
<dd>
Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container. </dd></dl>

</div>
</div>
<a id="a248ff4fbc36fb649ca0ef6a682b37c6c" name="a248ff4fbc36fb649ca0ef6a682b37c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248ff4fbc36fb649ca0ef6a682b37c6c">&#9670;&#160;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">const key_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts nodes from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>A key to identify the node to be extracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a> that owns the extracted element, or empty node handle in case the element is not found in. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the container has an element with key equivalent to k, unlinks the node that contains that element from the container and returns a <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a> that owns it. Otherwise, returns an empty node handle. </dd>
<dd>
In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed. </dd>
<dd>
Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container. </dd></dl>

</div>
</div>
<a id="a15b99ac9d6af11fda53cb838f611a0ec" name="a15b99ac9d6af11fda53cb838f611a0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b99ac9d6af11fda53cb838f611a0ec">&#9670;&#160;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds element with specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value of the element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the requested element. If no such element is found, past-the-end (see <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a>) iterator is returned. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds an element with key equivalent to <code>key</code>. </dd></dl>

</div>
</div>
<a id="ae3a5892c788e1c794aa49766438b79c1" name="ae3a5892c788e1c794aa49766438b79c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a5892c788e1c794aa49766438b79c1">&#9670;&#160;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds element with specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key value of the element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the requested element. If no such element is found, past-the-end (see <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a>) iterator is returned. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds an element with key equivalent to <code>key</code>. </dd></dl>

</div>
</div>
<a id="a4e712574f32c4ee5baf17502c9d89991" name="a4e712574f32c4ee5baf17502c9d89991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e712574f32c4ee5baf17502c9d89991">&#9670;&#160;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class find_key_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const find_key_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds element with specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value of any type that can be transparently compared with a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the requested element. If no such element is found, past-the-end (see <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a>) iterator is returned. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds an element with key that compares equivalent to the value <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such <code>hasher_t</code> is callable with both <code>find_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>key_t</code>. </dd></dl>

</div>
</div>
<a id="a6ba5c1ca5b7f05e3035ba70ca10c1ae0" name="a6ba5c1ca5b7f05e3035ba70ca10c1ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba5c1ca5b7f05e3035ba70ca10c1ae0">&#9670;&#160;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class find_key_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const find_key_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds element with specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value of any type that can be transparently compared with a key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Finds an element with key that compares equivalent to the value <code>x</code>. This overload participates in overload resolution only if <code>hasher_t::is_transparent</code> and <code>equator_t::is_transparent</code> are valid and each denotes a type. This assumes that such <code>hasher_t</code> is callable with both <code>find_key_t</code> and <code>key_t</code> type, and that the <code>equator_t</code> is transparent, which, together, allows calling this function without constructing an instance of <code>key_t</code>. </dd></dl>

</div>
</div>
<a id="ae3f30a82dc96ded7a4145c3d0533e3a7" name="ae3f30a82dc96ded7a4145c3d0533e3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f30a82dc96ded7a4145c3d0533e3a7">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="ab937a31d8ae4cb896ab25baf67330225" name="ab937a31d8ae4cb896ab25baf67330225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab937a31d8ae4cb896ab25baf67330225">&#9670;&#160;</a></span>get_enumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">enumerator</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::get_enumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerator that iterates through the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="group__collections.html#ga46ca5358d7207b976828dddad86adcf8" title="Supports a simple iteration over a non-generic collection.">xtd::collections::enumerator</a> structure for the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#aaa7f31bc15aecee93e381b36c71c3058">xtd::collections::generic::ienumerable&lt; type_t &gt;</a>.</p>

</div>
</div>
<a id="a14c1f0dd1e8ac7f753d0f56e05fa5a8c" name="a14c1f0dd1e8ac7f753d0f56e05fa5a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c1f0dd1e8ac7f753d0f56e05fa5a8c">&#9670;&#160;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1dictionary_1_1hasher.html">hasher</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns function used to hash the keys. </p>
<dl class="section return"><dt>Returns</dt><dd>The hash function. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the function that hashes the keys. </dd></dl>

</div>
</div>
<a id="a2536af020316364a5f3e053dbc02feb7" name="a2536af020316364a5f3e053dbc02feb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2536af020316364a5f3e053dbc02feb7">&#9670;&#160;</a></span>insert() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a4bbab4055f21c2b4f292408e2fe681e8" name="a4bbab4055f21c2b4f292408e2fe681e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbab4055f21c2b4f292408e2fe681e8">&#9670;&#160;</a></span>insert() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a18ad0f3139526c64cf06412b65feae9e" name="a18ad0f3139526c64cf06412b65feae9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ad0f3139526c64cf06412b65feae9e">&#9670;&#160;</a></span>insert() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>. </dd>
<dd>
Is equivalent to <code>emplace(std::forward&lt;P&gt;(value))</code> and only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value == true</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a380d38c18d0aa2a9d14309adfc143b53" name="a380d38c18d0aa2a9d14309adfc143b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380d38c18d0aa2a9d14309adfc143b53">&#9670;&#160;</a></span>insert() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a18df0c230fef405f5748b1bc0e499128" name="a18df0c230fef405f5748b1bc0e499128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18df0c230fef405f5748b1bc0e499128">&#9670;&#160;</a></span>insert() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a7128e65ca299ec54ac3141117d0a6215" name="a7128e65ca299ec54ac3141117d0a6215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7128e65ca299ec54ac3141117d0a6215">&#9670;&#160;</a></span>insert() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start. </dd>
<dd>
Is equivalent to <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code> and only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value == true</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a85007cea09c65235fd258adcc3a5a28d" name="a85007cea09c65235fd258adcc3a5a28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85007cea09c65235fd258adcc3a5a28d">&#9670;&#160;</a></span>insert() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of the range of elements to insert. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator of the range of elements to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from range [<code>first</code>, <code>last</code>). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>). </dd>
<dd>
If [<code>first</code>, <code>last</code>) is not a valid range, or <code>first</code> and/or <code>last</code> are iterators into <code>*this</code>, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a2f13f08d0a8068edeec540cd55b2656e" name="a2f13f08d0a8068edeec540cd55b2656e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f13f08d0a8068edeec540cd55b2656e">&#9670;&#160;</a></span>insert() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to insert the values from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>). </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="ab03539711e3e6f86380a893e725b95d3" name="ab03539711e3e6f86380a893e725b95d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03539711e3e6f86380a893e725b95d3">&#9670;&#160;</a></span>insert() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t , class init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to insert the values from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>). </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a1fe7e8e7ea1b539e1b77cb2e67f3d56b" name="a1fe7e8e7ea1b539e1b77cb2e67f3d56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe7e8e7ea1b539e1b77cb2e67f3d56b">&#9670;&#160;</a></span>insert() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7e88bf6f5031a8e127a56adb37ec848d">insert_return_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>nh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nh</td><td>A compatible <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object of <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7e88bf6f5031a8e127a56adb37ec848d" title="Represents the dictionary insert return type.">xtd::collections::generic::dictionary::insert_return_type</a> with the members initialized as follows:<ul>
<li>If <code>nh</code> is empty, inserted is <code>false</code>, position is <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a>, and node is empty.</li>
<li>Otherwise if the insertion took place, inserted is <code>true</code>, position points to the inserted element, and node is empty.</li>
<li>If the insertion failed, inserted is <code>false</code>, node has the previous value of <code>nh</code>, and position points to an element with a key equivalent to <code>nh.key()</code>. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>nh</code> is an empty <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>, does nothing. Otherwise, inserts the element owned by nh into the container , if the container doesn't already contain an element with a key equivalent to <code>nh.key()</code>. The behavior is undefined if <code>nh</code> is not empty and <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != nh.get_allocator()</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a5c488877537c9281e341e04cc2836c4b" name="a5c488877537c9281e341e04cc2836c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c488877537c9281e341e04cc2836c4b">&#9670;&#160;</a></span>insert() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>nh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">nh</td><td>A compatible <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator if <code>nh</code> was empty, iterator pointing to the inserted element if insertion took place, and iterator pointing to an element with a key equivalent to <code>nh.key()</code> if it failed. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>nh</code> is an empty <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>, does nothing and returns the end iterator. Otherwise, inserts the element owned by nh into the container, if the container doesn't already contain an element with a key equivalent to <code>nh.key()</code>, and returns the iterator pointing to the element with key equivalent to <code>nh.key()</code>(regardless of whether the insert succeeded or failed). If the insertion succeeds, <code>nh</code> is moved from, otherwise it retains ownership of the element. <code>hint</code> is used as a non-binding suggestion to where the search should start. The behavior is undefined if <code>nh</code> is not empty and <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != nh.get_allocator()</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="ad9003b85acdd5f58ba98601126fb7e5e" name="ad9003b85acdd5f58ba98601126fb7e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9003b85acdd5f58ba98601126fb7e5e">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code>value_type(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="acc83f5a5d14fd0c9c164a3bffcffe128" name="acc83f5a5d14fd0c9c164a3bffcffe128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc83f5a5d14fd0c9c164a3bffcffe128">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">key_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code>value_type(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="addddd73ed7023f733638e9fda6246ed4" name="addddd73ed7023f733638e9fda6246ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addddd73ed7023f733638e9fda6246ed4">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code>value_type(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a286f0cc1a6f5f3ea0e07728043b80038" name="a286f0cc1a6f5f3ea0e07728043b80038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286f0cc1a6f5f3ea0e07728043b80038">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code>value_type(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a64f3e826724a20670a5b310e1eda5542" name="a64f3e826724a20670a5b310e1eda5542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f3e826724a20670a5b310e1eda5542">&#9670;&#160;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1d6112bd0a235323e439c6a230e3fb76">key_equal</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function used to compare keys for equality. </p>
<dl class="section return"><dt>Returns</dt><dd>The key comparison function. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the function that compares keys for equality. </dd></dl>

</div>
</div>
<a id="aa575c136bf1a37de24a5a7ce7f552b6e" name="aa575c136bf1a37de24a5a7ce7f552b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa575c136bf1a37de24a5a7ce7f552b6e">&#9670;&#160;</a></span>merge() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t , class source_equator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="a5befc63a3053f4602f9440418e6e553b" name="a5befc63a3053f4602f9440418e6e553b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5befc63a3053f4602f9440418e6e553b">&#9670;&#160;</a></span>merge() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t , class source_equator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="ab4e63cb0057bab0fe25d0b0496cebdab" name="ab4e63cb0057bab0fe25d0b0496cebdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e63cb0057bab0fe25d0b0496cebdab">&#9670;&#160;</a></span>merge() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t , class source_equator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="a05b3061b4dbf74c837b28315279242bf" name="a05b3061b4dbf74c837b28315279242bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b3061b4dbf74c837b28315279242bf">&#9670;&#160;</a></span>merge() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t , class source_equator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="ac7b8b13d8c3160f93641eaa1ccda8968" name="ac7b8b13d8c3160f93641eaa1ccda8968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b8b13d8c3160f93641eaa1ccda8968">&#9670;&#160;</a></span>merge() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t , class source_equator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">std::unordered_multimap&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="ad3d725740942e0a175b87d23e8228dce" name="ad3d725740942e0a175b87d23e8228dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d725740942e0a175b87d23e8228dce">&#9670;&#160;</a></span>merge() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class source_hasher_t , class source_equator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">std::unordered_multimap&lt; key_t, value_t, source_hasher_t, source_equator_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splices nodes from another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A compatible container to transfer the nodes from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Attempts to extract ("splice") each element in <code>source</code> and insert it into <code>*this</code> using the hash function and key equality predicate of <code>*this</code>. If there is an element in <code>*this</code> with key equivalent to the key of an element from <code>source</code>, then that element is not extracted from <code>source</code>. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into <code>*this</code>, not into <code>source</code>. Iterators referring to the transferred elements and all iterators referring to <code>*this</code> are invalidated. Iterators to elements remaining in <code>source</code> remain valid. </dd>
<dd>
The behavior is undefined if <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != source.get_allocator()</code>. </dd></dl>

</div>
</div>
<a id="a73f150f182b8abc8caaf5914dbbba8eb" name="a73f150f182b8abc8caaf5914dbbba8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f150f182b8abc8caaf5914dbbba8eb">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves at least the specified number of buckets and regenerates the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The lower bound for the new number of buckets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Changes the number of buckets to a value n that is not less than <code>count</code> and satisfies <code>n &gt;= <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d" title="Represents a size of any object in bytes.">size()</a> / <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">max_load_factor()</a></code>, then rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>rehash(0)</code> may be used to force an unconditional rehash, such as after suspension of automatic rehashing by temporarily increasing <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">max_load_factor()</a></code>. </dd></dl>

</div>
</div>
<a id="a73cb9a204619fd297fb77f09b86b4b29" name="a73cb9a204619fd297fb77f09b86b4b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cb9a204619fd297fb77f09b86b4b29">&#9670;&#160;</a></span>remove() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the value with the specified key from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the element is successfully found and removed; otherwise, <code>false</code>. This method returns <code>false</code> if key is not found in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; does not contain an element with the specified key, the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; remains unchanged. No exception is thrown. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a350ca7a421a2515680c138c2a093b7bc">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a5b135339b414dd74f28dd0644fc255f3" name="a5b135339b414dd74f28dd0644fc255f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b135339b414dd74f28dd0644fc255f3">&#9670;&#160;</a></span>remove() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first occurrence of a specific object from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The object to remove from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item is successfully removed; otherwise, <code>false</code>. This method also returns <code>false</code> if item value was not found in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>

</div>
</div>
<a id="a0a8a911620f4d683e1ddab2edb518310" name="a0a8a911620f4d683e1ddab2edb518310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8a911620f4d683e1ddab2edb518310">&#9670;&#160;</a></span>remove() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the value with the specified key from the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, and copies the element to the <code>value</code> parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to remove. </td></tr>
    <tr><td class="paramname">value</td><td>The removed element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f59aa65bc93ff2771d7c1163e221368" name="a3f59aa65bc93ff2771d7c1163e221368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f59aa65bc93ff2771d7c1163e221368">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space for at least the specified number of elements and regenerates the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new capacity of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Sets the number of buckets to the number needed to accommodate at least <code>count</code> elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls <code>rehash(std::ceil(count / <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">max_load_factor()</a>))</code>. </dd></dl>

</div>
</div>
<a id="a4477fff561437e9a5487120b57055dd5" name="a4477fff561437e9a5487120b57055dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4477fff561437e9a5487120b57055dd5">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>container to exchange the contents with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. </dd>
<dd>
All iterators and references remain valid. The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end</a> iterator is invalidated. The <code>hasher_t</code> and <code>equator_t</code> objects must be <a href="https://en.cppreference.com/w/cpp/named_req/Swappable">Swappable</a>, and they are exchanged using unqualified calls to non-member swap. </dd></dl>

</div>
</div>
<a id="ae995c559f83b9915daf53430f2ccc95e" name="ae995c559f83b9915daf53430f2ccc95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae995c559f83b9915daf53430f2ccc95e">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__strings.html#gacd1daef0757a14b1f957e10b32644f91">xtd::string</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a string that represents the current object. </p>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the current object. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">xtd::object</a>.</p>

</div>
</div>
<a id="a039c4cc5a88a74481047772f8dc30980" name="a039c4cc5a88a74481047772f8dc30980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039c4cc5a88a74481047772f8dc30980">&#9670;&#160;</a></span>trim_excess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::trim_excess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the capacity of this dictionary to hold up a specified number of entries without any further expansion of its backing storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The new capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__out__of__range__exception.html" title="The exception that is thrown when one of the arguments provided to a method is out of range.">xtd::argument_out_of_range_exception</a></td><td>`capacity` is less than <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af92f9b1f02bf864a69a46230f9b53c62" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method can be used to minimize the memory overhead once it is known that no new elements will be added. </dd></dl>

</div>
</div>
<a id="a7e33a4f0c0ff75219a24c4e17dd96798" name="a7e33a4f0c0ff75219a24c4e17dd96798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e33a4f0c0ff75219a24c4e17dd96798">&#9670;&#160;</a></span>trim_excess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::trim_excess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method can be used to minimize memory overhead once it is known that no new elements will be added to the dictionary. To allocate a minimum size storage array, execute the following statements: <div class="fragment"><div class="line"><a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50385c2da2442292164bc4f65c84ee76">clear</a>();</div>
<div class="line"><a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a039c4cc5a88a74481047772f8dc30980">trim_excess</a>();</div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html_a039c4cc5a88a74481047772f8dc30980"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a039c4cc5a88a74481047772f8dc30980">xtd::collections::generic::dictionary::trim_excess</a></div><div class="ttdeci">void trim_excess(size_type capacity)</div><div class="ttdoc">Sets the capacity of this dictionary to hold up a specified number of entries without any further exp...</div><div class="ttdef"><b>Definition</b> dictionary.hpp:1380</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html_a50385c2da2442292164bc4f65c84ee76"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50385c2da2442292164bc4f65c84ee76">xtd::collections::generic::dictionary::clear</a></div><div class="ttdeci">void clear() noexcept override</div><div class="ttdoc">Removes all keys and values from the xtd::collections::generic::dictionary &lt;key_t,...</div><div class="ttdef"><b>Definition</b> dictionary.hpp:788</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5609a2b1e1555fe690d1b86368f36a64" name="a5609a2b1e1555fe690d1b86368f36a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5609a2b1e1555fe690d1b86368f36a64">&#9670;&#160;</a></span>try_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_add </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to add the specified key and value to the dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to add. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the key/value pair was added to the dictionary successfully; otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method, this method doesn't throw an exception if the element with the given key exists in the dictionary. Unlike the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> indexer (operator []), <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5609a2b1e1555fe690d1b86368f36a64" title="Attempts to add the specified key and value to the dictionary.">xtd::collections::generic::dictionary::try_add</a> doesn't override the element if the element with the given key exists in the dictionary. If the key already exists, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5609a2b1e1555fe690d1b86368f36a64" title="Attempts to add the specified key and value to the dictionary.">xtd::collections::generic::dictionary::try_add</a> does nothing and returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="af3f68a0c5f67be81a1de0390a4f44ada" name="af3f68a0c5f67be81a1de0390a4f44ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f68a0c5f67be81a1de0390a4f44ada">&#9670;&#160;</a></span>try_emplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If value_type is not <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible">EmplaceConstructible</a> into unordered_map from the corresponding expression, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a2701181224b009ca6d91700273f56ab0" name="a2701181224b009ca6d91700273f56ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2701181224b009ca6d91700273f56ab0">&#9670;&#160;</a></span>try_emplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">key_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If value_type is not <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible">EmplaceConstructible</a> into unordered_map from the corresponding expression, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a0a6e71848f61306f161e00ef6abbcba1" name="a0a6e71848f61306f161e00ef6abbcba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6e71848f61306f161e00ef6abbcba1">&#9670;&#160;</a></span>try_emplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If value_type is not <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible">EmplaceConstructible</a> into unordered_map from the corresponding expression, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="aa04620bd4ec2d7f3b5d0df030f5a1d9f" name="aa04620bd4ec2d7f3b5d0df030f5a1d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04620bd4ec2d7f3b5d0df030f5a1d9f">&#9670;&#160;</a></span>try_emplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If value_type is not <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible">EmplaceConstructible</a> into unordered_map from the corresponding expression, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="ac86c4dc2cfd6286bc7543d33f99a695d" name="ac86c4dc2cfd6286bc7543d33f99a695d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86c4dc2cfd6286bc7543d33f99a695d">&#9670;&#160;</a></span>try_get_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::try_get_value </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value associated with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the value to get. </td></tr>
    <tr><td class="paramname">value</td><td>When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; contains an element with the specified key; otherwise, <code>false</code>. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a4126d8c6dd5d5dbc84926aaf5198770e">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a82c683da2de29870afa991f4445dac29" name="a82c683da2de29870afa991f4445dac29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c683da2de29870afa991f4445dac29">&#9670;&#160;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a34f2116e984d8e567f334c97e84f4bc8" name="a34f2116e984d8e567f334c97e84f4bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f2116e984d8e567f334c97e84f4bc8">&#9670;&#160;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa8af37e930bc671470277333004815c6" name="aa8af37e930bc671470277333004815c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8af37e930bc671470277333004815c6">&#9670;&#160;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa93aa4cf42b1c7c83d3b01dafe6deac1" name="aa93aa4cf42b1c7c83d3b01dafe6deac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93aa4cf42b1c7c83d3b01dafe6deac1">&#9670;&#160;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; key_t, value_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a14ceb0d680fe9a5d5d6c2f02e4bdcd60" name="a14ceb0d680fe9a5d5d6c2f02e4bdcd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ceb0d680fe9a5d5d6c2f02e4bdcd60">&#9670;&#160;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a14d7bdef948dda8ae4029da1ea3b398a" name="a14d7bdef948dda8ae4029da1ea3b398a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d7bdef948dda8ae4029da1ea3b398a">&#9670;&#160;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class init_key_t , class init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a0e8d5edb392d4da50dfa18ff778b9aec" name="a0e8d5edb392d4da50dfa18ff778b9aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8d5edb392d4da50dfa18ff778b9aec">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a></td><td>The property is retrieved and key is not found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property provides the ability to access a specific element in the collection by using the following syntax: <code>my_collection[key]</code>. </dd>
<dd>
You can also use the <code>operator []</code> to add new elements by setting the value of a key that does not exist in the dictionary; for example, <code>my_collection["my_nonexistent_key"] = my_value</code>. However, if the specified key already exists in the dictionary, setting the <code>operator []</code> overwrites the old value. In contrast, the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method does not modify existing elements. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#abbd9d09bab50fce4e72deaa00985e3b2">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a03bf80a6988e9d62a6e57df4f12e00c2" name="a03bf80a6988e9d62a6e57df4f12e00c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bf80a6988e9d62a6e57df4f12e00c2">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property provides the ability to access a specific element in the collection by using the following syntax: <code>my_collection[key]</code>. </dd>
<dd>
You can also use the <code>operator []</code> to add new elements by setting the value of a key that does not exist in the dictionary; for example, <code>my_collection["my_nonexistent_key"] = my_value</code>. However, if the specified key already exists in the dictionary, setting the <code>operator []</code> overwrites the old value. In contrast, the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method does not modify existing elements. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a1428322c2f912bd597f667bd1aec0bdc">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a04b0f390c2eef3a3bc08a06c74134c7b" name="a04b0f390c2eef3a3bc08a06c74134c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b0f390c2eef3a3bc08a06c74134c7b">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a2128516be272bac5e5a5561d1ad55eff" name="a2128516be272bac5e5a5561d1ad55eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2128516be272bac5e5a5561d1ad55eff">&#9670;&#160;</a></span>operator base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key_t , class value_t , class hasher_t  = helpers::hasher&lt;key_t&gt;, class equator_t  = helpers::equator&lt;key_t&gt;, class allocator_t  = helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/collections/generic/<a class="el" href="dictionary_8hpp_source.html">dictionary.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 16 2025 12:18:51 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
