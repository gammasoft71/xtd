<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; Class Template Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections.html">collections</a></li><li class="navelem"><a class="el" href="namespacextd_1_1collections_1_1generic.html">generic</a></li><li class="navelem"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classxtd_1_1collections_1_1generic_1_1dictionary-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__collections.html">collections</a> &raquo; <a class="el" href="group__generic__collections.html">generic</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1collections_1_1generic_1_1dictionary.png" usemap="#xtd::collections::generic::dictionary_3C_20key_5Ft_2C_20value_5Ft_2C_20hasher_5Ft_2C_20equator_5Ft_2C_20allocator_5Ft_20_3E_map" alt=""/>
  <map id="xtd::collections::generic::dictionary_3C_20key_5Ft_2C_20value_5Ft_2C_20hasher_5Ft_2C_20equator_5Ft_2C_20allocator_5Ft_20_3E_map" name="xtd::collections::generic::dictionary_3C_20key_5Ft_2C_20value_5Ft_2C_20hasher_5Ft_2C_20equator_5Ft_2C_20allocator_5Ft_20_3E_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,112,1252,136"/>
<area href="classxtd_1_1collections_1_1generic_1_1idictionary.html" title="Represents a generic collection of key/value pairs." alt="xtd::collections::generic::idictionary&lt; key_t, value_t &gt;" shape="rect" coords="1262,112,2514,136"/>
<area href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" alt="xtd::collections::generic::ienumerable&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;" shape="rect" coords="1262,56,2514,80"/>
<area href="classxtd_1_1interface.html" title="Represent an interface class." alt="xtd::interface" shape="rect" coords="0,0,1252,24"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html" title="Internal enumarable iterators definition." alt="xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t &gt;" shape="rect" coords="1262,0,2514,24"/>
<area href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html" title="Provides a set of static methods for querying objects that implement ienumerable &lt;type_t&gt;." alt="xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt;" shape="rect" coords="2524,0,3776,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename key_t, typename value_t, typename hasher_t = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt;<br />
class xtd::collections::generic::dictionary&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;</div><p>Represents a collection of keys and values. </p>
<dl class="section user"><dt>Definition</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> key_t, <span class="keyword">typename</span> value_t, <span class="keyword">typename</span> hasher_t = xtd::collections::<span class="keyword">generic</span>::helpers::hasher&lt;key_t&gt;, <span class="keyword">typename</span> equator_t = <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1helpers_1_1equator.html">xtd::collections::generic::helpers::equator&lt;key_t&gt;</a>, <span class="keyword">typename</span> allocator_t = <a class="code hl_typedef" href="group__helpers__generic__collections.html#gac7dc24539787a344466014161f2d39af">xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;</a>&gt;&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a>, <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;key_t, value_t&gt;;</div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a></div><div class="ttdoc">Represents a collection of keys and values.</div><div class="ttdef"><b>Definition</b> dictionary.hpp:57</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1idictionary_html"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a></div><div class="ttdoc">Represents a generic collection of key/value pairs.</div><div class="ttdef"><b>Definition</b> idictionary.hpp:35</div></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:42</div></div>
<div class="ttc" id="agroup__helpers__generic__collections_html_gac7dc24539787a344466014161f2d39af"><div class="ttname"><a href="group__helpers__generic__collections.html#gac7dc24539787a344466014161f2d39af">xtd::collections::generic::helpers::allocator</a></div><div class="ttdeci">std::allocator&lt; type_t &gt; allocator</div><div class="ttdoc">Represent an allocator alias.</div><div class="ttdef"><b>Definition</b> allocator.hpp:35</div></div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1helpers_1_1equator_html"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1helpers_1_1equator.html">xtd::collections::generic::helpers::equator</a></div><div class="ttdoc">Implements a function object for performing comparisons. Unless specialised, invokes operator== on ty...</div><div class="ttdef"><b>Definition</b> equator.hpp:37</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/collections/dictionary</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1collections_1_1generic.html" title="The xtd::collections::generic namespace contains interfaces and classes that define generic collectio...">xtd::collections::generic</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> class is same as <a href="https://en.cppreference.com/w/cpp/container/unordered_map">std::unordered_map</a>. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following shows how to use <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a>. <div class="fragment"></div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; generic class provides a mapping from a set of keys to a set of values. Each addition to the dictionary consists of a value and its associated key. Retrieving a value by using its key is very fast, close to O(1), because the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class is implemented as a hash table. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The speed of retrieval depends on the quality of the hashing algorithm of the type specified for <code>key_t</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>As long as an object is used as a key in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, it must not change in any way that affects its hash value. Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the dictionary's equality comparer. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. You can specify an implementation of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">xtd::collections::generic::iequality_comparer</a> &lt;type_t&gt; generic interface by using a constructor that accepts a comparer parameter; if you do not specify an implementation, the default generic equality comparer <a class="el" href="classxtd_1_1collections_1_1generic_1_1equality__comparer.html#a5587032e4b47a24f81e3ed4cb23f813c" title="Gets the default equality comparer for the type specified by the generic argument.">xtd::collections::generic::equality_comparer&lt;type_t&gt;::default_equality_comparer</a> is used. If type <code>key_t</code> implements the <a class="el" href="classxtd_1_1iequatable.html" title="Defines a generalized method that a value type or class implements to create a type-specific method f...">xtd::iequatable</a> &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For example, you can use the case-insensitive string comparers provided by the xtd::string_comparer class to create dictionaries with case-insensitive string keys. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can hold. As elements are added to a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;, the capacity is automatically increased as required by reallocating the internal array. </dd>
<dd>
For purposes of enumeration, each item in the dictionary is treated as a <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> &lt;key_t, value_t&gt; structure representing a value and its key. The order in which the items are returned is undefined. </dd>
<dd>
The for each statement returns an object of the type of the elements in the collection. Since the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is a collection of keys and values, the element type is not the type of the key or the type of the value. Instead, the element type is a <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html" title="Defines a key/value pair that can be set or retrieved.">xtd::collections::generic::key_value_pair</a> &lt;key_t, value_t&gt; of the key type and the value type. For example: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_struct" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair&lt;string, string&gt;</a>&amp; kvp : my_dictionary)</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;key = {}, value = {}&quot;</span>, kvp.key(), kvp.value());</div>
<div class="ttc" id="aclassxtd_1_1console_html"><div class="ttname"><a href="classxtd_1_1console.html">xtd::console</a></div><div class="ttdoc">Represents the standard input, output, and error streams for console applications.</div><div class="ttdef"><b>Definition</b> console.hpp:36</div></div>
<div class="ttc" id="astructxtd_1_1collections_1_1generic_1_1key__value__pair_html"><div class="ttname"><a href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a></div><div class="ttdoc">Defines a key/value pair that can be set or retrieved.</div><div class="ttdef"><b>Definition</b> key_value_pair.hpp:36</div></div>
</div><!-- fragment --> </dd>
<dd>
Or with <code>auto</code> key type and the value type. For example: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [key, value] : my_dictionary)</div>
<div class="line">  <a class="code hl_class" href="classxtd_1_1console.html">console</a>::write_line(<span class="stringliteral">&quot;key = {}, value = {}&quot;</span>, key, value);</div>
</div><!-- fragment --> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Aliases</h2></td></tr>
<tr class="memitem:ac46665df3307e2ef72937349cbe9a043"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; key_t, value_t &gt;::key_type</td></tr>
<tr class="memdesc:ac46665df3307e2ef72937349cbe9a043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary key type.  <br /></td></tr>
<tr class="separator:ac46665df3307e2ef72937349cbe9a043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62f8fa8a47c2a7f0f4371ec0483086d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; key_t, value_t &gt;::mapped_type</td></tr>
<tr class="memdesc:ab62f8fa8a47c2a7f0f4371ec0483086d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary mapped type.  <br /></td></tr>
<tr class="separator:ab62f8fa8a47c2a7f0f4371ec0483086d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f951179b33766491339c34e62fcc98f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::value_type</td></tr>
<tr class="memdesc:a1f951179b33766491339c34e62fcc98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary value type.  <br /></td></tr>
<tr class="separator:a1f951179b33766491339c34e62fcc98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af564e40d9fd72f4ad84f8e5ae62f4610"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> = <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a></td></tr>
<tr class="memdesc:af564e40d9fd72f4ad84f8e5ae62f4610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary size type.  <br /></td></tr>
<tr class="separator:af564e40d9fd72f4ad84f8e5ae62f4610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad6f561b6c8f20e4e5f9c8cf73dfbbcc5">difference_type</a> = <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca">xtd::ptrdiff</a></td></tr>
<tr class="memdesc:ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary difference type.  <br /></td></tr>
<tr class="separator:ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a23e2ca9e1ae6169e1e66a617bafad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> = hasher_t</td></tr>
<tr class="memdesc:a55a23e2ca9e1ae6169e1e66a617bafad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary hasher type.  <br /></td></tr>
<tr class="separator:a55a23e2ca9e1ae6169e1e66a617bafad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3117536e7eb45cdf75f69073e37126b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> = equator_t</td></tr>
<tr class="memdesc:a3117536e7eb45cdf75f69073e37126b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary equator type.  <br /></td></tr>
<tr class="separator:a3117536e7eb45cdf75f69073e37126b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3875535b1af051b47b4c4be60ca9cb86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3875535b1af051b47b4c4be60ca9cb86">key_equal</a> = equator_t</td></tr>
<tr class="memdesc:a3875535b1af051b47b4c4be60ca9cb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary equator type.  <br /></td></tr>
<tr class="separator:a3875535b1af051b47b4c4be60ca9cb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d7f951247c504df41d30e51f987394"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> = allocator_t</td></tr>
<tr class="memdesc:ad1d7f951247c504df41d30e51f987394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary allocator type.  <br /></td></tr>
<tr class="separator:ad1d7f951247c504df41d30e51f987394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69009b6f6be690dbfa2591d29b28c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> = std::pair&lt; const key_t, value_t &gt;</td></tr>
<tr class="memdesc:a6a69009b6f6be690dbfa2591d29b28c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary base value type.  <br /></td></tr>
<tr class="separator:a6a69009b6f6be690dbfa2591d29b28c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eda53efea9ddfea79ad6f47b9f1eb8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> = std::unordered_map&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3875535b1af051b47b4c4be60ca9cb86">key_equal</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &gt;</td></tr>
<tr class="memdesc:a48eda53efea9ddfea79ad6f47b9f1eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary base type.  <br /></td></tr>
<tr class="separator:a48eda53efea9ddfea79ad6f47b9f1eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f55af09de680f0014615c3d4c4a2915"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f55af09de680f0014615c3d4c4a2915">reference</a> = <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;</td></tr>
<tr class="memdesc:a1f55af09de680f0014615c3d4c4a2915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary reference type.  <br /></td></tr>
<tr class="separator:a1f55af09de680f0014615c3d4c4a2915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b6e59722145f09a8b59f06d94c9601"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad8b6e59722145f09a8b59f06d94c9601">const_reference</a> = const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;</td></tr>
<tr class="memdesc:ad8b6e59722145f09a8b59f06d94c9601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary const reference type.  <br /></td></tr>
<tr class="separator:ad8b6e59722145f09a8b59f06d94c9601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853042cc781b451b7e8c0522526c48e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a853042cc781b451b7e8c0522526c48e9">pointer</a> = typename std::allocator_traits&lt; allocator_t &gt;::pointer</td></tr>
<tr class="memdesc:a853042cc781b451b7e8c0522526c48e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary pointer type.  <br /></td></tr>
<tr class="separator:a853042cc781b451b7e8c0522526c48e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84e5f837cd6080080b886aa3378288b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af84e5f837cd6080080b886aa3378288b">const_pointer</a> = typename std::allocator_traits&lt; allocator_t &gt;::const_pointer</td></tr>
<tr class="memdesc:af84e5f837cd6080080b886aa3378288b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary const pointer type.  <br /></td></tr>
<tr class="separator:af84e5f837cd6080080b886aa3378288b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec072eea57e68e1c6fad6aaee1a5a22e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::iterator</td></tr>
<tr class="memdesc:aec072eea57e68e1c6fad6aaee1a5a22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:aec072eea57e68e1c6fad6aaee1a5a22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cadb73d74ba5ee36bafe1bc66810cb0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::const_iterator</td></tr>
<tr class="memdesc:a7cadb73d74ba5ee36bafe1bc66810cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:a7cadb73d74ba5ee36bafe1bc66810cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc966a9b4269ce145604c61eace7f57c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#adc966a9b4269ce145604c61eace7f57c">local_iterator</a> = typename base_type::local_iterator</td></tr>
<tr class="memdesc:adc966a9b4269ce145604c61eace7f57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the local iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:adc966a9b4269ce145604c61eace7f57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259c368e0dff747a4e4687d94d0ca8e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a259c368e0dff747a4e4687d94d0ca8e0">const_local_iterator</a> = typename base_type::const_local_iterator</td></tr>
<tr class="memdesc:a259c368e0dff747a4e4687d94d0ca8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const local iterator of dictionary value type.  <br /></td></tr>
<tr class="separator:a259c368e0dff747a4e4687d94d0ca8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ebfcd509b5c4d473ec9ab61bed6e85"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> = typename base_type::node_type</td></tr>
<tr class="memdesc:a09ebfcd509b5c4d473ec9ab61bed6e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary node type.  <br /></td></tr>
<tr class="separator:a09ebfcd509b5c4d473ec9ab61bed6e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e88bf6f5031a8e127a56adb37ec848d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7e88bf6f5031a8e127a56adb37ec848d">insert_return_type</a> = typename base_type::insert_return_type</td></tr>
<tr class="memdesc:a7e88bf6f5031a8e127a56adb37ec848d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary insert return type.  <br /></td></tr>
<tr class="separator:a7e88bf6f5031a8e127a56adb37ec848d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b86fcba0283b6ed1cb596b086e7d388"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388">key_collection</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::key_collection</td></tr>
<tr class="memdesc:a4b86fcba0283b6ed1cb596b086e7d388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary key collection type.  <br /></td></tr>
<tr class="separator:a4b86fcba0283b6ed1cb596b086e7d388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5837e916ed3ecf5ad27d9c1287033f52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52">value_collection</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a> &gt;::value_collection</td></tr>
<tr class="memdesc:a5837e916ed3ecf5ad27d9c1287033f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary value collection type.  <br /></td></tr>
<tr class="separator:a5837e916ed3ecf5ad27d9c1287033f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:a50b15016f1b91a266a8beec12ab89584"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a> () noexcept=default</td></tr>
<tr class="memdesc:a50b15016f1b91a266a8beec12ab89584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the default equality comparer for the key type.  <br /></td></tr>
<tr class="separator:a50b15016f1b91a266a8beec12ab89584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0560bd5c164940e101c379af9ef8f65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad0560bd5c164940e101c379af9ef8f65">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;hash=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> &amp;equal=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {}) noexcept</td></tr>
<tr class="memdesc:ad0560bd5c164940e101c379af9ef8f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:ad0560bd5c164940e101c379af9ef8f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a05a50c5843077f4e3fa29a3119790c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4a05a50c5843077f4e3fa29a3119790c">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a4a05a50c5843077f4e3fa29a3119790c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a4a05a50c5843077f4e3fa29a3119790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e9590be6d1f2dee9cf2ee5e1981f34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a32e9590be6d1f2dee9cf2ee5e1981f34">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;hash, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a32e9590be6d1f2dee9cf2ee5e1981f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a32e9590be6d1f2dee9cf2ee5e1981f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a32c1d1e03ae4b0d6e504a78ea55e56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3a32c1d1e03ae4b0d6e504a78ea55e56">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a3a32c1d1e03ae4b0d6e504a78ea55e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a3a32c1d1e03ae4b0d6e504a78ea55e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a39e00fab008316a1539307ef953668"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5a39e00fab008316a1539307ef953668"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5a39e00fab008316a1539307ef953668">dictionary</a> (input_iterator_t first, input_iterator_t last, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>=0, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;hash=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> &amp;equal=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {}) noexcept</td></tr>
<tr class="memdesc:a5a39e00fab008316a1539307ef953668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a5a39e00fab008316a1539307ef953668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2ecbbabe9824db7185cf18c1e81a14"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:aca2ecbbabe9824db7185cf18c1e81a14"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aca2ecbbabe9824db7185cf18c1e81a14">dictionary</a> (input_iterator_t first, input_iterator_t last, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:aca2ecbbabe9824db7185cf18c1e81a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:aca2ecbbabe9824db7185cf18c1e81a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d462bfcece7a5829901f48a313ac035"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a5d462bfcece7a5829901f48a313ac035"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5d462bfcece7a5829901f48a313ac035">dictionary</a> (input_iterator_t first, input_iterator_t last, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;hash, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a5d462bfcece7a5829901f48a313ac035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a5d462bfcece7a5829901f48a313ac035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa953d39916161c5551072ee7685d48dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa953d39916161c5551072ee7685d48dc">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aa953d39916161c5551072ee7685d48dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:aa953d39916161c5551072ee7685d48dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdced64621e8ed1a148df1709ce185e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5cdced64621e8ed1a148df1709ce185e">dictionary</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a5cdced64621e8ed1a148df1709ce185e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a5cdced64621e8ed1a148df1709ce185e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9956d405104fcc34db6c56f3103c52f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa9956d405104fcc34db6c56f3103c52f">dictionary</a> (const std::unordered_map&lt; key_t, value_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aa9956d405104fcc34db6c56f3103c52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:aa9956d405104fcc34db6c56f3103c52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557c19d6693d48bfd48f2c757210ba60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a557c19d6693d48bfd48f2c757210ba60">dictionary</a> (const std::unordered_map&lt; key_t, value_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a557c19d6693d48bfd48f2c757210ba60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a557c19d6693d48bfd48f2c757210ba60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b758a73f04808f26eee3fa8ce363ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a07b758a73f04808f26eee3fa8ce363ef">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:a07b758a73f04808f26eee3fa8ce363ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a07b758a73f04808f26eee3fa8ce363ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c24d7c8b5165f2e3814e21c8ad0231"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab1c24d7c8b5165f2e3814e21c8ad0231">dictionary</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:ab1c24d7c8b5165f2e3814e21c8ad0231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:ab1c24d7c8b5165f2e3814e21c8ad0231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153be4b6329ddb7d86bfedd03db85ca8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a153be4b6329ddb7d86bfedd03db85ca8">dictionary</a> (std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a153be4b6329ddb7d86bfedd03db85ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a153be4b6329ddb7d86bfedd03db85ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260ac3aa16033a8c92bbb9a71c7ede0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6260ac3aa16033a8c92bbb9a71c7ede0">dictionary</a> (std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a6260ac3aa16033a8c92bbb9a71c7ede0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a6260ac3aa16033a8c92bbb9a71c7ede0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54d35d73259f1c4bb63b98779a18d7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac54d35d73259f1c4bb63b98779a18d7e">dictionary</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>=0, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;hash=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> &amp;equal=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {})</td></tr>
<tr class="memdesc:ac54d35d73259f1c4bb63b98779a18d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:ac54d35d73259f1c4bb63b98779a18d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1e2bddbc888c451b97e6cd2f760250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#acd1e2bddbc888c451b97e6cd2f760250">dictionary</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:acd1e2bddbc888c451b97e6cd2f760250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:acd1e2bddbc888c451b97e6cd2f760250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0437ef2f75e99d1392ce07f5040f7237"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0437ef2f75e99d1392ce07f5040f7237">dictionary</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;hash, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a0437ef2f75e99d1392ce07f5040f7237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a0437ef2f75e99d1392ce07f5040f7237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94db56e7e5c29681f68d93cfab4e4b4a"><td class="memTemplParams" colspan="2">template&lt;typename init_key_t , typename init_value_t &gt; </td></tr>
<tr class="memitem:a94db56e7e5c29681f68d93cfab4e4b4a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a94db56e7e5c29681f68d93cfab4e4b4a">dictionary</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>=0, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;hash=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> &amp;equal=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> {}, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc=<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> {})</td></tr>
<tr class="memdesc:a94db56e7e5c29681f68d93cfab4e4b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a94db56e7e5c29681f68d93cfab4e4b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b272479748bbf823035dc716d9dad1d"><td class="memTemplParams" colspan="2">template&lt;typename init_key_t , typename init_value_t &gt; </td></tr>
<tr class="memitem:a8b272479748bbf823035dc716d9dad1d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8b272479748bbf823035dc716d9dad1d">dictionary</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a8b272479748bbf823035dc716d9dad1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a8b272479748bbf823035dc716d9dad1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814b0e672622c6defc0b5482d9121e47"><td class="memTemplParams" colspan="2">template&lt;typename init_key_t , typename init_value_t &gt; </td></tr>
<tr class="memitem:a814b0e672622c6defc0b5482d9121e47"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a814b0e672622c6defc0b5482d9121e47">dictionary</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; init, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a>, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;hash, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a814b0e672622c6defc0b5482d9121e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator.  <br /></td></tr>
<tr class="separator:a814b0e672622c6defc0b5482d9121e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:a5fb05a4d36ada3a05639760bbef1866f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5fb05a4d36ada3a05639760bbef1866f">begin</a> () const noexcept override</td></tr>
<tr class="memdesc:a5fb05a4d36ada3a05639760bbef1866f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:a5fb05a4d36ada3a05639760bbef1866f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43461af42f40fafcba6c351b8915909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909">begin</a> () noexcept override</td></tr>
<tr class="memdesc:ad43461af42f40fafcba6c351b8915909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:ad43461af42f40fafcba6c351b8915909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51c920c156b8cc6863e143972f5c11b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b">bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:ad51c920c156b8cc6863e143972f5c11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of buckets in the container.  <br /></td></tr>
<tr class="separator:ad51c920c156b8cc6863e143972f5c11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ebcb226f6bc8869c35bf9e1d634ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a24ebcb226f6bc8869c35bf9e1d634ff3">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a24ebcb226f6bc8869c35bf9e1d634ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total numbers of elements the internal data structure can hold without resizing.  <br /></td></tr>
<tr class="separator:a24ebcb226f6bc8869c35bf9e1d634ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375db294d333e09891584e2a0956e1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac375db294d333e09891584e2a0956e1d">cbegin</a> () const noexcept override</td></tr>
<tr class="memdesc:ac375db294d333e09891584e2a0956e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the enumarable.  <br /></td></tr>
<tr class="separator:ac375db294d333e09891584e2a0956e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63291ea36f70c7ded93799d6890847e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad63291ea36f70c7ded93799d6890847e">cend</a> () const noexcept override</td></tr>
<tr class="memdesc:ad63291ea36f70c7ded93799d6890847e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:ad63291ea36f70c7ded93799d6890847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f122cc0e5b14e4a6c66414d84c5c990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0f122cc0e5b14e4a6c66414d84c5c990">count</a> () const noexcept</td></tr>
<tr class="memdesc:a0f122cc0e5b14e4a6c66414d84c5c990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a0f122cc0e5b14e4a6c66414d84c5c990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55611e5c2304788bf7a281fc5b75e1cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55611e5c2304788bf7a281fc5b75e1cb">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a55611e5c2304788bf7a281fc5b75e1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumarable.">begin()</a> == <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">end()</a></code>.  <br /></td></tr>
<tr class="separator:a55611e5c2304788bf7a281fc5b75e1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bcbef97b1acb696d8b444988530830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a84bcbef97b1acb696d8b444988530830">end</a> () const noexcept override</td></tr>
<tr class="memdesc:a84bcbef97b1acb696d8b444988530830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a84bcbef97b1acb696d8b444988530830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e062f26b355616dce3110a815645e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d">end</a> () noexcept override</td></tr>
<tr class="memdesc:a8e062f26b355616dce3110a815645e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the enumarable.  <br /></td></tr>
<tr class="separator:a8e062f26b355616dce3110a815645e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f9fa62ba008a290c60f795e768d74f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac5f9fa62ba008a290c60f795e768d74f">items</a> () const noexcept</td></tr>
<tr class="memdesc:ac5f9fa62ba008a290c60f795e768d74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:ac5f9fa62ba008a290c60f795e768d74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb58202461ac49407519756acca9ed12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aeb58202461ac49407519756acca9ed12">items</a> () noexcept</td></tr>
<tr class="memdesc:aeb58202461ac49407519756acca9ed12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying base type items.  <br /></td></tr>
<tr class="separator:aeb58202461ac49407519756acca9ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a9b4d312798abd41548c6c97ee3312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388">key_collection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac2a9b4d312798abd41548c6c97ee3312">keys</a> () const noexcept override</td></tr>
<tr class="memdesc:ac2a9b4d312798abd41548c6c97ee3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a collection containing the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:ac2a9b4d312798abd41548c6c97ee3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fed9d70080e18e58e5f678ff8fce0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad12fed9d70080e18e58e5f678ff8fce0">load_factor</a> () const</td></tr>
<tr class="memdesc:ad12fed9d70080e18e58e5f678ff8fce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the average number of elements per bucket, that is, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a9b8a36cd363866ea458b74960e5d68eb" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::size</a> divided by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a>.  <br /></td></tr>
<tr class="separator:ad12fed9d70080e18e58e5f678ff8fce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4c1821576c7fba7fdd4dea0f2c512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad9e4c1821576c7fba7fdd4dea0f2c512">max_bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:ad9e4c1821576c7fba7fdd4dea0f2c512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of buckets the container is able to hold due to system or library implementation limitations.  <br /></td></tr>
<tr class="separator:ad9e4c1821576c7fba7fdd4dea0f2c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ebdfacb702aad8221aa1b77817cdbd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd">max_load_factor</a> () const</td></tr>
<tr class="memdesc:af4ebdfacb702aad8221aa1b77817cdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.  <br /></td></tr>
<tr class="separator:af4ebdfacb702aad8221aa1b77817cdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f7acfa0c36a187bd76efe62d87581c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad7f7acfa0c36a187bd76efe62d87581c">max_load_factor</a> (float value) const</td></tr>
<tr class="memdesc:ad7f7acfa0c36a187bd76efe62d87581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.  <br /></td></tr>
<tr class="separator:ad7f7acfa0c36a187bd76efe62d87581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070747ad0686a9136f66dfc5e3b19aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a070747ad0686a9136f66dfc5e3b19aa9">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a070747ad0686a9136f66dfc5e3b19aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">end()</a>)</code> for the largest container.  <br /></td></tr>
<tr class="separator:a070747ad0686a9136f66dfc5e3b19aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8a36cd363866ea458b74960e5d68eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a9b8a36cd363866ea458b74960e5d68eb">size</a> () const noexcept</td></tr>
<tr class="memdesc:a9b8a36cd363866ea458b74960e5d68eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a9b8a36cd363866ea458b74960e5d68eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5519d6518ce9849e89b90fd573839f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52">value_collection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa5519d6518ce9849e89b90fd573839f2">values</a> () const noexcept override</td></tr>
<tr class="memdesc:aa5519d6518ce9849e89b90fd573839f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a collection containing the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:aa5519d6518ce9849e89b90fd573839f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a8e4b572d70b69d4b688a2835a3258522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522">add</a> (const key_t &amp;key, const value_t value) override</td></tr>
<tr class="memdesc:a8e4b572d70b69d4b688a2835a3258522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element with the provided key and value to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:a8e4b572d70b69d4b688a2835a3258522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56664bbd826ba01e34ff35477064db2d"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a56664bbd826ba01e34ff35477064db2d">at</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a56664bbd826ba01e34ff35477064db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element with the specified key.  <br /></td></tr>
<tr class="separator:a56664bbd826ba01e34ff35477064db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32980a15b7ef803c1ba5c8d69f1dbb84"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a32980a15b7ef803c1ba5c8d69f1dbb84">at</a> (const key_t &amp;key)</td></tr>
<tr class="memdesc:a32980a15b7ef803c1ba5c8d69f1dbb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element with the specified key.  <br /></td></tr>
<tr class="separator:a32980a15b7ef803c1ba5c8d69f1dbb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b83cb5cb0fa23c7b4ff7c2c447419aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3b83cb5cb0fa23c7b4ff7c2c447419aa">bucket</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a3b83cb5cb0fa23c7b4ff7c2c447419aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket.  <br /></td></tr>
<tr class="separator:a3b83cb5cb0fa23c7b4ff7c2c447419aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce1e7684c03c73e9980372eceb779a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8ce1e7684c03c73e9980372eceb779a2">bucket_size</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a7b8b965ad4bca0e41ab51de7b31363a1">n</a>) const noexcept</td></tr>
<tr class="memdesc:a8ce1e7684c03c73e9980372eceb779a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the bucket with index <code>n</code>.  <br /></td></tr>
<tr class="separator:a8ce1e7684c03c73e9980372eceb779a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad052549a4ee1f409ef0d343e3379ba10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad052549a4ee1f409ef0d343e3379ba10">clear</a> () noexcept</td></tr>
<tr class="memdesc:ad052549a4ee1f409ef0d343e3379ba10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a9b8a36cd363866ea458b74960e5d68eb" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::size</a> returns zero.  <br /></td></tr>
<tr class="separator:ad052549a4ee1f409ef0d343e3379ba10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62388a5a93af71eb55d9f509420d1acb"><td class="memTemplParams" colspan="2">template&lt;typename ... args_t&gt; </td></tr>
<tr class="memitem:a62388a5a93af71eb55d9f509420d1acb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a62388a5a93af71eb55d9f509420d1acb">emplace</a> (args_t &amp;&amp;...args)</td></tr>
<tr class="memdesc:a62388a5a93af71eb55d9f509420d1acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container.  <br /></td></tr>
<tr class="separator:a62388a5a93af71eb55d9f509420d1acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f30a82dc96ded7a4145c3d0533e3a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:ae3f30a82dc96ded7a4145c3d0533e3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <br /></td></tr>
<tr class="separator:ae3f30a82dc96ded7a4145c3d0533e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab937a31d8ae4cb896ab25baf67330225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">enumerator</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab937a31d8ae4cb896ab25baf67330225">get_enumerator</a> () const noexcept override</td></tr>
<tr class="memdesc:ab937a31d8ae4cb896ab25baf67330225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that iterates through the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;.  <br /></td></tr>
<tr class="separator:ab937a31d8ae4cb896ab25baf67330225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2536af020316364a5f3e053dbc02feb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7">insert</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a2536af020316364a5f3e053dbc02feb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a2536af020316364a5f3e053dbc02feb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbab4055f21c2b4f292408e2fe681e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4bbab4055f21c2b4f292408e2fe681e8">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a4bbab4055f21c2b4f292408e2fe681e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a4bbab4055f21c2b4f292408e2fe681e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ad0f3139526c64cf06412b65feae9e"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:a18ad0f3139526c64cf06412b65feae9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a18ad0f3139526c64cf06412b65feae9e">insert</a> (type_t &amp;&amp;value)</td></tr>
<tr class="memdesc:a18ad0f3139526c64cf06412b65feae9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a18ad0f3139526c64cf06412b65feae9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380d38c18d0aa2a9d14309adfc143b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a380d38c18d0aa2a9d14309adfc143b53">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a380d38c18d0aa2a9d14309adfc143b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a380d38c18d0aa2a9d14309adfc143b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18df0c230fef405f5748b1bc0e499128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a18df0c230fef405f5748b1bc0e499128">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a18df0c230fef405f5748b1bc0e499128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a18df0c230fef405f5748b1bc0e499128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7128e65ca299ec54ac3141117d0a6215"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:a7128e65ca299ec54ac3141117d0a6215"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7128e65ca299ec54ac3141117d0a6215">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, type_t &amp;&amp;value)</td></tr>
<tr class="memdesc:a7128e65ca299ec54ac3141117d0a6215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a7128e65ca299ec54ac3141117d0a6215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85007cea09c65235fd258adcc3a5a28d"><td class="memTemplParams" colspan="2">template&lt;typename input_iterator_t &gt; </td></tr>
<tr class="memitem:a85007cea09c65235fd258adcc3a5a28d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a85007cea09c65235fd258adcc3a5a28d">insert</a> (input_iterator_t first, input_iterator_t last)</td></tr>
<tr class="memdesc:a85007cea09c65235fd258adcc3a5a28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a85007cea09c65235fd258adcc3a5a28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f13f08d0a8068edeec540cd55b2656e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2f13f08d0a8068edeec540cd55b2656e">insert</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">ilist</a>)</td></tr>
<tr class="memdesc:a2f13f08d0a8068edeec540cd55b2656e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a2f13f08d0a8068edeec540cd55b2656e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03539711e3e6f86380a893e725b95d3"><td class="memTemplParams" colspan="2">template&lt;typename init_key_t , typename init_value_t &gt; </td></tr>
<tr class="memitem:ab03539711e3e6f86380a893e725b95d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab03539711e3e6f86380a893e725b95d3">insert</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">ilist</a>)</td></tr>
<tr class="memdesc:ab03539711e3e6f86380a893e725b95d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:ab03539711e3e6f86380a893e725b95d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe7e8e7ea1b539e1b77cb2e67f3d56b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7e88bf6f5031a8e127a56adb37ec848d">insert_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1fe7e8e7ea1b539e1b77cb2e67f3d56b">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;nh)</td></tr>
<tr class="memdesc:a1fe7e8e7ea1b539e1b77cb2e67f3d56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a1fe7e8e7ea1b539e1b77cb2e67f3d56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c488877537c9281e341e04cc2836c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5c488877537c9281e341e04cc2836c4b">insert</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;nh)</td></tr>
<tr class="memdesc:a5c488877537c9281e341e04cc2836c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a5c488877537c9281e341e04cc2836c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9003b85acdd5f58ba98601126fb7e5e"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:ad9003b85acdd5f58ba98601126fb7e5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad9003b85acdd5f58ba98601126fb7e5e">insert_or_assign</a> (const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:ad9003b85acdd5f58ba98601126fb7e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:ad9003b85acdd5f58ba98601126fb7e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#acc83f5a5d14fd0c9c164a3bffcffe128">insert_or_assign</a> (key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:acc83f5a5d14fd0c9c164a3bffcffe128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddd73ed7023f733638e9fda6246ed4"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:addddd73ed7023f733638e9fda6246ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#addddd73ed7023f733638e9fda6246ed4">insert_or_assign</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, const key_t &amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:addddd73ed7023f733638e9fda6246ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:addddd73ed7023f733638e9fda6246ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286f0cc1a6f5f3ea0e07728043b80038"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:a286f0cc1a6f5f3ea0e07728043b80038"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a286f0cc1a6f5f3ea0e07728043b80038">insert_or_assign</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> hint, key_t &amp;&amp;<a class="el" href="group__xtd__core.html#ggad94b2f43c7550180321e0ac4b02a4ff2a8ce4b16b22b58894aa86c421e8759df3">k</a>, type_t &amp;&amp;obj)</td></tr>
<tr class="memdesc:a286f0cc1a6f5f3ea0e07728043b80038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:a286f0cc1a6f5f3ea0e07728043b80038"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Operators</h2></td></tr>
<tr class="memitem:a82c683da2de29870afa991f4445dac29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a82c683da2de29870afa991f4445dac29">operator=</a> (<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a82c683da2de29870afa991f4445dac29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a82c683da2de29870afa991f4445dac29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f2116e984d8e567f334c97e84f4bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a34f2116e984d8e567f334c97e84f4bc8">operator=</a> (std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a34f2116e984d8e567f334c97e84f4bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a34f2116e984d8e567f334c97e84f4bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8af37e930bc671470277333004815c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa8af37e930bc671470277333004815c6">operator=</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept=default</td></tr>
<tr class="memdesc:aa8af37e930bc671470277333004815c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:aa8af37e930bc671470277333004815c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93aa4cf42b1c7c83d3b01dafe6deac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa93aa4cf42b1c7c83d3b01dafe6deac1">operator=</a> (const std::unordered_map&lt; key_t, value_t &gt; &amp;<a class="el" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aa93aa4cf42b1c7c83d3b01dafe6deac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:aa93aa4cf42b1c7c83d3b01dafe6deac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ceb0d680fe9a5d5d6c2f02e4bdcd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a14ceb0d680fe9a5d5d6c2f02e4bdcd60">operator=</a> (std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">ilist</a>)</td></tr>
<tr class="memdesc:a14ceb0d680fe9a5d5d6c2f02e4bdcd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a14ceb0d680fe9a5d5d6c2f02e4bdcd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d7bdef948dda8ae4029da1ea3b398a"><td class="memTemplParams" colspan="2">template&lt;typename init_key_t , typename init_value_t &gt; </td></tr>
<tr class="memitem:a14d7bdef948dda8ae4029da1ea3b398a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a14d7bdef948dda8ae4029da1ea3b398a">operator=</a> (std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1ilist.html">ilist</a>)</td></tr>
<tr class="memdesc:a14d7bdef948dda8ae4029da1ea3b398a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.  <br /></td></tr>
<tr class="separator:a14d7bdef948dda8ae4029da1ea3b398a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8d5edb392d4da50dfa18ff778b9aec"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0e8d5edb392d4da50dfa18ff778b9aec">operator[]</a> (const key_t &amp;key) const override</td></tr>
<tr class="memdesc:a0e8d5edb392d4da50dfa18ff778b9aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element with the specified key.  <br /></td></tr>
<tr class="separator:a0e8d5edb392d4da50dfa18ff778b9aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bf80a6988e9d62a6e57df4f12e00c2"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a03bf80a6988e9d62a6e57df4f12e00c2">operator[]</a> (const key_t &amp;key) override</td></tr>
<tr class="memdesc:a03bf80a6988e9d62a6e57df4f12e00c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element with the specified key.  <br /></td></tr>
<tr class="separator:a03bf80a6988e9d62a6e57df4f12e00c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b0f390c2eef3a3bc08a06c74134c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a04b0f390c2eef3a3bc08a06c74134c7b">operator const base_type &amp;</a> () const noexcept</td></tr>
<tr class="memdesc:a04b0f390c2eef3a3bc08a06c74134c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a04b0f390c2eef3a3bc08a06c74134c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2128516be272bac5e5a5561d1ad55eff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2128516be272bac5e5a5561d1ad55eff">operator base_type &amp;</a> () noexcept</td></tr>
<tr class="memdesc:a2128516be272bac5e5a5561d1ad55eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying base type.  <br /></td></tr>
<tr class="separator:a2128516be272bac5e5a5561d1ad55eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1idictionary')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a></td></tr>
<tr class="memitem:a7d3fdc16ef498f8c7a4bc8e625ef8d92 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a7d3fdc16ef498f8c7a4bc8e625ef8d92">key_type</a> = key_t</td></tr>
<tr class="memdesc:a7d3fdc16ef498f8c7a4bc8e625ef8d92 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary key type.  <br /></td></tr>
<tr class="separator:a7d3fdc16ef498f8c7a4bc8e625ef8d92 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d8c36814a04e88a2c3765254402fea inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ab9d8c36814a04e88a2c3765254402fea">mapped_type</a> = value_t</td></tr>
<tr class="memdesc:ab9d8c36814a04e88a2c3765254402fea inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary mapped type.  <br /></td></tr>
<tr class="separator:ab9d8c36814a04e88a2c3765254402fea inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331886116daca4bb8ff6a2ce211b3f9e inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a331886116daca4bb8ff6a2ce211b3f9e">value_type</a> = <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a7d3fdc16ef498f8c7a4bc8e625ef8d92">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ab9d8c36814a04e88a2c3765254402fea">mapped_type</a> &gt;</td></tr>
<tr class="memdesc:a331886116daca4bb8ff6a2ce211b3f9e inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dictionary value type.  <br /></td></tr>
<tr class="separator:a331886116daca4bb8ff6a2ce211b3f9e inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966d5c58830c823e37b4d2e227d989af inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a966d5c58830c823e37b4d2e227d989af">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a331886116daca4bb8ff6a2ce211b3f9e">value_type</a> &gt;::iterator</td></tr>
<tr class="memdesc:a966d5c58830c823e37b4d2e227d989af inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a966d5c58830c823e37b4d2e227d989af inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445bda4f9b1bfde0cbb4f77b6b6b1ec9 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a445bda4f9b1bfde0cbb4f77b6b6b1ec9">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1icollection.html">xtd::collections::generic::icollection</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a331886116daca4bb8ff6a2ce211b3f9e">value_type</a> &gt;::const_iterator</td></tr>
<tr class="memdesc:a445bda4f9b1bfde0cbb4f77b6b6b1ec9 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a445bda4f9b1bfde0cbb4f77b6b6b1ec9 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f7bfc73fd451652caf2f96af00442 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a348f7bfc73fd451652caf2f96af00442">key_collection</a> = <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a7d3fdc16ef498f8c7a4bc8e625ef8d92">key_type</a> &gt;</td></tr>
<tr class="memdesc:a348f7bfc73fd451652caf2f96af00442 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary key collection type.  <br /></td></tr>
<tr class="separator:a348f7bfc73fd451652caf2f96af00442 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0389edc8c5aa120ac731815b4cd96805 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a0389edc8c5aa120ac731815b4cd96805">value_collection</a> = <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html">xtd::collections::generic::list</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ab9d8c36814a04e88a2c3765254402fea">mapped_type</a> &gt;</td></tr>
<tr class="memdesc:a0389edc8c5aa120ac731815b4cd96805 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the idictionary value collection type.  <br /></td></tr>
<tr class="separator:a0389edc8c5aa120ac731815b4cd96805 inherit pub_types_classxtd_1_1collections_1_1generic_1_1idictionary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a></td></tr>
<tr class="memitem:a287e9c3dff72a406f2cf715de19afb11 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#a287e9c3dff72a406f2cf715de19afb11">iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt;, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &gt; &gt;::iterator</td></tr>
<tr class="memdesc:a287e9c3dff72a406f2cf715de19afb11 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:a287e9c3dff72a406f2cf715de19afb11 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a5659ab1d2d261e2a5d390685f6765 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#ac4a5659ab1d2d261e2a5d390685f6765">const_iterator</a> = typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt;, <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">xtd::collections::generic::key_value_pair</a>&lt; key_t, value_t &gt; &gt; &gt;::const_iterator</td></tr>
<tr class="memdesc:ac4a5659ab1d2d261e2a5d390685f6765 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> value type.  <br /></td></tr>
<tr class="separator:ac4a5659ab1d2d261e2a5d390685f6765 inherit pub_types_classxtd_1_1collections_1_1generic_1_1ienumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t &gt;</a></td></tr>
<tr class="memitem:a38c7595da1248eb6a6fefc117a185916 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a38c7595da1248eb6a6fefc117a185916">const_iterator</a> = const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:a38c7595da1248eb6a6fefc117a185916 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the const iterator of enumarable value type.  <br /></td></tr>
<tr class="separator:a38c7595da1248eb6a6fefc117a185916 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt;</a></td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a> = typename <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a2bd1889dc1967c50ef692411dc2c4b92">xtd::linq::enumerable::ienumerable</a>&lt; type_t &gt;</td></tr>
<tr class="memdesc:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the ienumerable value type.  <br /></td></tr>
<tr class="separator:aec4cd2ae6b5b4fde97fef8e2f160336f inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;typename type_t &gt; </td></tr>
<tr class="memitem:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a> = typename <a class="el" href="classxtd_1_1linq_1_1enumerable.html#a4ff59be55b7be66d275f28741e2f1f0a">xtd::linq::enumerable::list</a>&lt; type_t &gt;</td></tr>
<tr class="memdesc:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the list value type.  <br /></td></tr>
<tr class="separator:a417e4adb1792949e9a54516bee2ca3d2 inherit pub_types_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a1fea096f8a49ac5eef1f2431806109ca">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a1fea096f8a49ac5eef1f2431806109ca inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_t &gt; </td></tr>
<tr class="memitem:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga4ac188feb2d52b21e188417441519bb2">xtd::uptr</a>&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#abb9700deaba669584080178e391d97c4">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:abb9700deaba669584080178e391d97c4 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d19ef177db62351b58a42f22138dbe inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:af2d19ef177db62351b58a42f22138dbe inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#ga9fe47a4b2c6dc7d7eeaf5d2fb218d4d1" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:af2d19ef177db62351b58a42f22138dbe inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1idictionary"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1idictionary')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1ienumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1ienumerable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html">xtd::collections::generic::ienumerable&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t &gt;</a></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html">xtd::collections::generic::extensions::enumerable&lt; enumerable_t, source_t &gt;</a></td></tr>
<tr class="memitem:a22f3540f62b3b6140ecf188faf509842 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a22f3540f62b3b6140ecf188faf509842">aggregate</a> (const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>) const</td></tr>
<tr class="memdesc:a22f3540f62b3b6140ecf188faf509842 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence.  <br /></td></tr>
<tr class="separator:a22f3540f62b3b6140ecf188faf509842 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bbfa7cff2e26dcf33e973a97d42316 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#af8bbfa7cff2e26dcf33e973a97d42316">aggregate</a> (const source_t &amp;seed, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>) const</td></tr>
<tr class="memdesc:af8bbfa7cff2e26dcf33e973a97d42316 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:af8bbfa7cff2e26dcf33e973a97d42316 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;typename accumulate_t &gt; </td></tr>
<tr class="memitem:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">accumulate_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2705732af439af4da98a7a28f0a02f5a">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>) const</td></tr>
<tr class="memdesc:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.  <br /></td></tr>
<tr class="separator:a2705732af439af4da98a7a28f0a02f5a inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487db86dcfc03a261804db9288b917df inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a487db86dcfc03a261804db9288b917df">aggregate</a> (const source_t &amp;seed, const std::function&lt; source_t(const source_t &amp;, const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; source_t(const source_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a487db86dcfc03a261804db9288b917df inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a487db86dcfc03a261804db9288b917df inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;typename result_t , typename accumulate_t &gt; </td></tr>
<tr class="memitem:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0b91578ce3ebc8da03751dfca700bf7d">aggregate</a> (const accumulate_t &amp;seed, const std::function&lt; accumulate_t(const source_t &amp;, const accumulate_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga655ac2d710f5daaa327ac82c8c235de9">func</a>, const std::function&lt; result_t(const accumulate_t &amp;)&gt; &amp;result_selector) const</td></tr>
<tr class="memdesc:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.  <br /></td></tr>
<tr class="separator:a0b91578ce3ebc8da03751dfca700bf7d inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c344a4319826da54bae2611d78f7e41 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8c344a4319826da54bae2611d78f7e41">all</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a8c344a4319826da54bae2611d78f7e41 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all elements of a sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:a8c344a4319826da54bae2611d78f7e41 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e647f592add925edc5682334fa2b29 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a25e647f592add925edc5682334fa2b29">any</a> () const noexcept</td></tr>
<tr class="memdesc:a25e647f592add925edc5682334fa2b29 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains any elements.  <br /></td></tr>
<tr class="separator:a25e647f592add925edc5682334fa2b29 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddaea79f05f3a1d7c83bdc64883ec44 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a7ddaea79f05f3a1d7c83bdc64883ec44">any</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a7ddaea79f05f3a1d7c83bdc64883ec44 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any element of a sequence satisfies a condition.  <br /></td></tr>
<tr class="separator:a7ddaea79f05f3a1d7c83bdc64883ec44 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227fd05d7acfc24fe8805534fd706309 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a227fd05d7acfc24fe8805534fd706309">append</a> (const source_t &amp;element) const noexcept</td></tr>
<tr class="memdesc:a227fd05d7acfc24fe8805534fd706309 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of the sequence.  <br /></td></tr>
<tr class="separator:a227fd05d7acfc24fe8805534fd706309 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184c35f6e8a0058a196b533394dbccd7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a184c35f6e8a0058a196b533394dbccd7">as_enumerable</a> () const noexcept</td></tr>
<tr class="memdesc:a184c35f6e8a0058a196b533394dbccd7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input typed as xtd::collection::generic::ienumerable &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a184c35f6e8a0058a196b533394dbccd7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5669f1a9bf9da6303aa9ff29197b4799 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5669f1a9bf9da6303aa9ff29197b4799">average</a> () const noexcept</td></tr>
<tr class="memdesc:a5669f1a9bf9da6303aa9ff29197b4799 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of a sequence of source_t values.  <br /></td></tr>
<tr class="separator:a5669f1a9bf9da6303aa9ff29197b4799 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;typename result_t &gt; </td></tr>
<tr class="memitem:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ac8353f4d5daa13e1810b8aad661eb938">cast</a> () const noexcept</td></tr>
<tr class="memdesc:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the elements of an xtd::collection::generic::ienumerable to the specified type.  <br /></td></tr>
<tr class="separator:ac8353f4d5daa13e1810b8aad661eb938 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e97c665374affe07c6240f55db92a63 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="classxtd_1_1array.html">xtd::array</a>&lt; source_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a8e97c665374affe07c6240f55db92a63">chunk</a> (size_t <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">size</a>) const</td></tr>
<tr class="memdesc:a8e97c665374affe07c6240f55db92a63 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the elements of a sequence into chunks of size at most size.  <br /></td></tr>
<tr class="separator:a8e97c665374affe07c6240f55db92a63 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28746d3222dc23090a710dd8548e77e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ad28746d3222dc23090a710dd8548e77e">concat</a> (const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;second) const noexcept</td></tr>
<tr class="memdesc:ad28746d3222dc23090a710dd8548e77e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two sequences.  <br /></td></tr>
<tr class="separator:ad28746d3222dc23090a710dd8548e77e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e29837254bb373971404eb103ba26 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#ad77e29837254bb373971404eb103ba26">contains</a> (const source_t &amp;value) const noexcept</td></tr>
<tr class="memdesc:ad77e29837254bb373971404eb103ba26 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using the default equality comparer.  <br /></td></tr>
<tr class="separator:ad77e29837254bb373971404eb103ba26 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4be2e1cde9d4316519230b03e0496 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a87d4be2e1cde9d4316519230b03e0496">contains</a> (const source_t &amp;value, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">xtd::collections::generic::iequality_comparer</a>&lt; source_t &gt; &amp;<a class="el" href="classxtd_1_1collections_1_1generic_1_1comparer.html">comparer</a>) const noexcept</td></tr>
<tr class="memdesc:a87d4be2e1cde9d4316519230b03e0496 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a sequence contains a specified element by using a specified equality comparer.  <br /></td></tr>
<tr class="separator:a87d4be2e1cde9d4316519230b03e0496 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0560a5c54fcf0e9786018f00e136c7fb inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0560a5c54fcf0e9786018f00e136c7fb">count</a> () const noexcept</td></tr>
<tr class="memdesc:a0560a5c54fcf0e9786018f00e136c7fb inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in current sequence.  <br /></td></tr>
<tr class="separator:a0560a5c54fcf0e9786018f00e136c7fb inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef0abd344f629aef3c96e49d272b50c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aeef0abd344f629aef3c96e49d272b50c">count</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:aeef0abd344f629aef3c96e49d272b50c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number that represents how many elements in the specified sequence satisfy a condition.  <br /></td></tr>
<tr class="separator:aeef0abd344f629aef3c96e49d272b50c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;typename key_t &gt; </td></tr>
<tr class="memitem:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; key_t, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a0dba2660f845875cd5908be53e52bbc7">count_by</a> (const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector) const noexcept</td></tr>
<tr class="memdesc:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:a0dba2660f845875cd5908be53e52bbc7 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;typename key_t &gt; </td></tr>
<tr class="memitem:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; key_t, <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a> &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#acd274fa4579c9e02119888c7135d6c8e">count_by</a> (const std::function&lt; key_t(const source_t &amp;)&gt; &amp;key_selector, const <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html">iequality_comparer</a>&lt; key_t &gt; &amp;key_comparer) const noexcept</td></tr>
<tr class="memdesc:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of elements in the current sequence grouped by key.  <br /></td></tr>
<tr class="separator:acd274fa4579c9e02119888c7135d6c8e inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb41413e817b71a549e3f99aaf743e1 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a3fb41413e817b71a549e3f99aaf743e1">default_if_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3fb41413e817b71a549e3f99aaf743e1 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a3fb41413e817b71a549e3f99aaf743e1 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5954e34075473c77cc41c979ed506fa3 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a5954e34075473c77cc41c979ed506fa3">default_if_empty</a> (const source_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:a5954e34075473c77cc41c979ed506fa3 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of the specified sequence or the specified value in a singleton collection if the current sequence is empty.  <br /></td></tr>
<tr class="separator:a5954e34075473c77cc41c979ed506fa3 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcddc251cf8f945686a5f77807e62dcd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#afcddc251cf8f945686a5f77807e62dcd">first_or_default</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>, const source_t &amp;default_value) const noexcept</td></tr>
<tr class="memdesc:afcddc251cf8f945686a5f77807e62dcd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition, or a specified default value if no such element is found.  <br /></td></tr>
<tr class="separator:afcddc251cf8f945686a5f77807e62dcd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52658d4876a5f7642288ef7cfd0be8 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2e52658d4876a5f7642288ef7cfd0be8">first_or_default</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const noexcept</td></tr>
<tr class="memdesc:a2e52658d4876a5f7642288ef7cfd0be8 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2e52658d4876a5f7642288ef7cfd0be8 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0a757b76c036ef644cec12662f887 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a2ba0a757b76c036ef644cec12662f887">first_or_default</a> (const source_t default_value) const noexcept</td></tr>
<tr class="memdesc:a2ba0a757b76c036ef644cec12662f887 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a2ba0a757b76c036ef644cec12662f887 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964948d137047014d18a7cc5db15f46f inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">source_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a964948d137047014d18a7cc5db15f46f">first_or_default</a> () const noexcept</td></tr>
<tr class="memdesc:a964948d137047014d18a7cc5db15f46f inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.  <br /></td></tr>
<tr class="separator:a964948d137047014d18a7cc5db15f46f inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;typename result_t &gt; </td></tr>
<tr class="memitem:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a69ca739f420b3ddd4df01845ce9bd979">select</a> (const std::function&lt; result_t(const source_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a69ca739f420b3ddd4df01845ce9bd979 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58637f7cae0e9518f0b728d47f2dc8f9 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a58637f7cae0e9518f0b728d47f2dc8f9">select</a> (const std::function&lt; source_t(const source_t &amp;)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a58637f7cae0e9518f0b728d47f2dc8f9 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form.  <br /></td></tr>
<tr class="separator:a58637f7cae0e9518f0b728d47f2dc8f9 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplParams" colspan="2">template&lt;typename result_t &gt; </td></tr>
<tr class="memitem:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; result_t &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a74a6585ba5b3ff487437db47ade70486">select</a> (const std::function&lt; result_t(const source_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a74a6585ba5b3ff487437db47ade70486 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009c5250029162433b826be3a1a93efd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a009c5250029162433b826be3a1a93efd">select</a> (const std::function&lt; source_t(const source_t &amp;, size_t index)&gt; &amp;selector) const</td></tr>
<tr class="memdesc:a009c5250029162433b826be3a1a93efd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects each element of a sequence into a new form by incorporating the element's index.  <br /></td></tr>
<tr class="separator:a009c5250029162433b826be3a1a93efd inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a910fbeb2bb448c779d761dd865063c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a417e4adb1792949e9a54516bee2ca3d2">list</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a6a910fbeb2bb448c779d761dd865063c">to_list</a> () const noexcept</td></tr>
<tr class="memdesc:a6a910fbeb2bb448c779d761dd865063c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classxtd_1_1collections_1_1generic_1_1list.html" title="Represents a strongly typed list of objects that can be accessed by index. Provides methods to search...">xtd::collections::generic::list</a> &lt;type_t&gt; from an <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html" title="Exposes the enumerator, which supports a simple iteration over a collection of a specified type.">xtd::collections::generic::ienumerable</a> &lt;type_t&gt;.  <br /></td></tr>
<tr class="separator:a6a910fbeb2bb448c779d761dd865063c inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669773bec96bcfe7a5b4f43068892620 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a669773bec96bcfe7a5b4f43068892620">where</a> (const std::function&lt; bool(const source_t &amp;)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a669773bec96bcfe7a5b4f43068892620 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate.  <br /></td></tr>
<tr class="separator:a669773bec96bcfe7a5b4f43068892620 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c236ea62904000f45e720b7a7dbf17 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#aec4cd2ae6b5b4fde97fef8e2f160336f">ienumerable</a>&lt; source_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable.html#a46c236ea62904000f45e720b7a7dbf17">where</a> (const std::function&lt; bool(const source_t &amp;, size_t)&gt; &amp;<a class="el" href="group__xtd__core.html#ga535b9ce590888fa8d367c010a725fe20">predicate</a>) const</td></tr>
<tr class="memdesc:a46c236ea62904000f45e720b7a7dbf17 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.  <br /></td></tr>
<tr class="separator:a46c236ea62904000f45e720b7a7dbf17 inherit pub_methods_classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t &gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;typename object_a_t , typename object_b_t &gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac46665df3307e2ef72937349cbe9a043" name="ac46665df3307e2ef72937349cbe9a043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46665df3307e2ef72937349cbe9a043">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_type =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;key_t, value_t&gt;::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary key type. </p>

</div>
</div>
<a id="ab62f8fa8a47c2a7f0f4371ec0483086d" name="ab62f8fa8a47c2a7f0f4371ec0483086d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62f8fa8a47c2a7f0f4371ec0483086d">&#9670;&#160;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::mapped_type =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;key_t, value_t&gt;::mapped_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary mapped type. </p>

</div>
</div>
<a id="a1f951179b33766491339c34e62fcc98f" name="a1f951179b33766491339c34e62fcc98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f951179b33766491339c34e62fcc98f">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::value_type =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary value type. </p>

</div>
</div>
<a id="af564e40d9fd72f4ad84f8e5ae62f4610" name="af564e40d9fd72f4ad84f8e5ae62f4610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af564e40d9fd72f4ad84f8e5ae62f4610">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::size_type =  <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary size type. </p>

</div>
</div>
<a id="ad6f561b6c8f20e4e5f9c8cf73dfbbcc5" name="ad6f561b6c8f20e4e5f9c8cf73dfbbcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f561b6c8f20e4e5f9c8cf73dfbbcc5">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::difference_type =  <a class="el" href="group__types.html#gac047942a62f03ba75e1b4f0bde7401ca">xtd::ptrdiff</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary difference type. </p>

</div>
</div>
<a id="a55a23e2ca9e1ae6169e1e66a617bafad" name="a55a23e2ca9e1ae6169e1e66a617bafad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a23e2ca9e1ae6169e1e66a617bafad">&#9670;&#160;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::hasher =  hasher_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary hasher type. </p>

</div>
</div>
<a id="a3117536e7eb45cdf75f69073e37126b8" name="a3117536e7eb45cdf75f69073e37126b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3117536e7eb45cdf75f69073e37126b8">&#9670;&#160;</a></span>equator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::equator =  equator_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary equator type. </p>

</div>
</div>
<a id="a3875535b1af051b47b4c4be60ca9cb86" name="a3875535b1af051b47b4c4be60ca9cb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3875535b1af051b47b4c4be60ca9cb86">&#9670;&#160;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_equal =  equator_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary equator type. </p>

</div>
</div>
<a id="ad1d7f951247c504df41d30e51f987394" name="ad1d7f951247c504df41d30e51f987394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d7f951247c504df41d30e51f987394">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::allocator_type =  allocator_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary allocator type. </p>

</div>
</div>
<a id="a6a69009b6f6be690dbfa2591d29b28c4" name="a6a69009b6f6be690dbfa2591d29b28c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a69009b6f6be690dbfa2591d29b28c4">&#9670;&#160;</a></span>base_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::base_value_type =  std::pair&lt;const key_t, value_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary base value type. </p>

</div>
</div>
<a id="a48eda53efea9ddfea79ad6f47b9f1eb8" name="a48eda53efea9ddfea79ad6f47b9f1eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48eda53efea9ddfea79ad6f47b9f1eb8">&#9670;&#160;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::base_type =  std::unordered_map&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3875535b1af051b47b4c4be60ca9cb86">key_equal</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary base type. </p>

</div>
</div>
<a id="a1f55af09de680f0014615c3d4c4a2915" name="a1f55af09de680f0014615c3d4c4a2915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f55af09de680f0014615c3d4c4a2915">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::reference =  <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary reference type. </p>

</div>
</div>
<a id="ad8b6e59722145f09a8b59f06d94c9601" name="ad8b6e59722145f09a8b59f06d94c9601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b6e59722145f09a8b59f06d94c9601">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_reference =  const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary const reference type. </p>

</div>
</div>
<a id="a853042cc781b451b7e8c0522526c48e9" name="a853042cc781b451b7e8c0522526c48e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853042cc781b451b7e8c0522526c48e9">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::pointer =  typename std::allocator_traits&lt;allocator_t&gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary pointer type. </p>

</div>
</div>
<a id="af84e5f837cd6080080b886aa3378288b" name="af84e5f837cd6080080b886aa3378288b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84e5f837cd6080080b886aa3378288b">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_pointer =  typename std::allocator_traits&lt;allocator_t&gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary const pointer type. </p>

</div>
</div>
<a id="aec072eea57e68e1c6fad6aaee1a5a22e" name="aec072eea57e68e1c6fad6aaee1a5a22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec072eea57e68e1c6fad6aaee1a5a22e">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::iterator =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the iterator of dictionary value type. </p>

</div>
</div>
<a id="a7cadb73d74ba5ee36bafe1bc66810cb0" name="a7cadb73d74ba5ee36bafe1bc66810cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cadb73d74ba5ee36bafe1bc66810cb0">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_iterator =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const iterator of dictionary value type. </p>

</div>
</div>
<a id="adc966a9b4269ce145604c61eace7f57c" name="adc966a9b4269ce145604c61eace7f57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc966a9b4269ce145604c61eace7f57c">&#9670;&#160;</a></span>local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::local_iterator =  typename base_type::local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the local iterator of dictionary value type. </p>

</div>
</div>
<a id="a259c368e0dff747a4e4687d94d0ca8e0" name="a259c368e0dff747a4e4687d94d0ca8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259c368e0dff747a4e4687d94d0ca8e0">&#9670;&#160;</a></span>const_local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::const_local_iterator =  typename base_type::const_local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the const local iterator of dictionary value type. </p>

</div>
</div>
<a id="a09ebfcd509b5c4d473ec9ab61bed6e85" name="a09ebfcd509b5c4d473ec9ab61bed6e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ebfcd509b5c4d473ec9ab61bed6e85">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::node_type =  typename base_type::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary node type. </p>

</div>
</div>
<a id="a7e88bf6f5031a8e127a56adb37ec848d" name="a7e88bf6f5031a8e127a56adb37ec848d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e88bf6f5031a8e127a56adb37ec848d">&#9670;&#160;</a></span>insert_return_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_return_type =  typename base_type::insert_return_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the dictionary insert return type. </p>

</div>
</div>
<a id="a4b86fcba0283b6ed1cb596b086e7d388" name="a4b86fcba0283b6ed1cb596b086e7d388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b86fcba0283b6ed1cb596b086e7d388">&#9670;&#160;</a></span>key_collection</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::key_collection =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::key_collection</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the idictionary key collection type. </p>

</div>
</div>
<a id="a5837e916ed3ecf5ad27d9c1287033f52" name="a5837e916ed3ecf5ad27d9c1287033f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5837e916ed3ecf5ad27d9c1287033f52">&#9670;&#160;</a></span>value_collection</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::value_collection =  typename <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html">xtd::collections::generic::idictionary</a>&lt;<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac46665df3307e2ef72937349cbe9a043">key_type</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d">mapped_type</a>&gt;::value_collection</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the idictionary value collection type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a50b15016f1b91a266a8beec12ab89584" name="a50b15016f1b91a266a8beec12ab89584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b15016f1b91a266a8beec12ab89584">&#9670;&#160;</a></span>dictionary() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class that is empty, has the default initial capacity, and uses the default equality comparer for the key type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Every key in a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; must be unique according to the default equality comparer. </dd>
<dd>
<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; requires an equality implementation to determine whether keys are equal. This constructor uses the default generic equality comparer, equality_comparer::default. If type <code>key_t</code> implements the xtd::equatable &lt;type_t&gt; generic interface, the default equality comparer uses that implementation. Alternatively, you can specify an implementation of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1iequality__comparer.html" title="Defines methods to support the comparison of objects for equality.">iequality_comparer</a> &lt;typer_t&gt; generic interface by using a constructor that accepts a comparer parameter. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you can estimate the size of the collection, using a constructor that specifies the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd>
<dd>
This constructor is an O(1) operation. </dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following code example creates an empty <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; of strings with string keys and uses the Add method to add some elements. The example demonstrates that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">dictionary::add</a> method throws an <a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a> when attempting to add a duplicate key.</dd></dl>
<p>This code example is part of a larger example provided for the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class. </p><div class="fragment"><div class="line"><span class="comment">// Create a new dictionary of strings, with string keys.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">auto</span> open_with = <a class="code hl_class" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary&lt;string, string&gt;</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add some elements to the dictionary. There are no</span></div>
<div class="line"><span class="comment">// duplicate keys, but some of the values are duplicates.</span></div>
<div class="line">open_with.<a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522">add</a>(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;notepad.exe&quot;</span>);</div>
<div class="line">open_with.add(<span class="stringliteral">&quot;bmp&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">open_with.add(<span class="stringliteral">&quot;dib&quot;</span>, <span class="stringliteral">&quot;paint.exe&quot;</span>);</div>
<div class="line">open_with.add(<span class="stringliteral">&quot;rtf&quot;</span>, <span class="stringliteral">&quot;wordpad.exe&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The add method throws an exception if the new key is</span></div>
<div class="line"><span class="comment">// already in the dictionary.</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  open_with.add(<span class="stringliteral">&quot;txt&quot;</span>, <span class="stringliteral">&quot;winword.exe&quot;</span>);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classxtd_1_1argument__exception.html">argument_exception</a>&amp;) {</div>
<div class="line">  <a class="code hl_function" href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">console::write_line</a>(<span class="stringliteral">&quot;An element with Key = \&quot;txt\&quot; already exists.&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassxtd_1_1argument__exception_html"><div class="ttname"><a href="classxtd_1_1argument__exception.html">xtd::argument_exception</a></div><div class="ttdoc">The exception that is thrown when one of the arguments provided to a method is not valid.</div><div class="ttdef"><b>Definition</b> argument_exception.hpp:24</div></div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html_a8e4b572d70b69d4b688a2835a3258522"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522">xtd::collections::generic::dictionary::add</a></div><div class="ttdeci">void add(const key_t &amp;key, const value_t value) override</div><div class="ttdoc">Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...</div><div class="ttdef"><b>Definition</b> dictionary.hpp:460</div></div>
<div class="ttc" id="aclassxtd_1_1console_html_ae0ccd7fef284ccda33a88576c8a35a37"><div class="ttname"><a href="classxtd_1_1console.html#ae0ccd7fef284ccda33a88576c8a35a37">xtd::console::write_line</a></div><div class="ttdeci">static void write_line()</div><div class="ttdoc">Writes the current line terminator to the standard output stream using the specified format informati...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad0560bd5c164940e101c379af9ef8f65" name="ad0560bd5c164940e101c379af9ef8f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0560bd5c164940e101c379af9ef8f65">&#9670;&#160;</a></span>dictionary() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a>&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a>&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd></dl>

</div>
</div>
<a id="a4a05a50c5843077f4e3fa29a3119790c" name="a4a05a50c5843077f4e3fa29a3119790c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a05a50c5843077f4e3fa29a3119790c">&#9670;&#160;</a></span>dictionary() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd></dl>

</div>
</div>
<a id="a32e9590be6d1f2dee9cf2ee5e1981f34" name="a32e9590be6d1f2dee9cf2ee5e1981f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e9590be6d1f2dee9cf2ee5e1981f34">&#9670;&#160;</a></span>dictionary() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to 1.0. For the default constructor, the number of buckets is implementation-defined. </dd></dl>

</div>
</div>
<a id="a3a32c1d1e03ae4b0d6e504a78ea55e56" name="a3a32c1d1e03ae4b0d6e504a78ea55e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a32c1d1e03ae4b0d6e504a78ea55e56">&#9670;&#160;</a></span>dictionary() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs empty container. Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. For the default constructor, the number of buckets is implementation-defined. </dd></dl>

</div>
</div>
<a id="a5a39e00fab008316a1539307ef953668" name="a5a39e00fab008316a1539307ef953668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a39e00fab008316a1539307ef953668">&#9670;&#160;</a></span>dictionary() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a>&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a>&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The fist iterator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>Thaae last itezrator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs the container with the contents of the range [first, last). Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>. </dd></dl>

</div>
</div>
<a id="aca2ecbbabe9824db7185cf18c1e81a14" name="aca2ecbbabe9824db7185cf18c1e81a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2ecbbabe9824db7185cf18c1e81a14">&#9670;&#160;</a></span>dictionary() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The fist iterator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>Thaae last itezrator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs the container with the contents of the range [first, last). Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>. </dd></dl>

</div>
</div>
<a id="a5d462bfcece7a5829901f48a313ac035" name="a5d462bfcece7a5829901f48a313ac035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d462bfcece7a5829901f48a313ac035">&#9670;&#160;</a></span>dictionary() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The fist iterator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">last</td><td>Thaae last itezrator of the range [first, last) to copy the elements from. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constructs the container with the contents of the range [first, last). Sets <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor()</a> to <code>1.0</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>. </dd></dl>

</div>
</div>
<a id="aa953d39916161c5551072ee7685d48dc" name="aa953d39916161c5551072ee7685d48dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa953d39916161c5551072ee7685d48dc">&#9670;&#160;</a></span>dictionary() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
<div class="ttc" id="agroup__xtd__core_html_ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf"><div class="ttname"><a href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">xtd::platform_id::other</a></div><div class="ttdeci">@ other</div><div class="ttdoc">The operating system is other.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5cdced64621e8ed1a148df1709ce185e" name="a5cdced64621e8ed1a148df1709ce185e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdced64621e8ed1a148df1709ce185e">&#9670;&#160;</a></span>dictionary() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa9956d405104fcc34db6c56f3103c52f" name="aa9956d405104fcc34db6c56f3103c52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9956d405104fcc34db6c56f3103c52f">&#9670;&#160;</a></span>dictionary() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; key_t, value_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a557c19d6693d48bfd48f2c757210ba60" name="a557c19d6693d48bfd48f2c757210ba60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557c19d6693d48bfd48f2c757210ba60">&#9670;&#160;</a></span>dictionary() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; key_t, value_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Copy constructor. Constructs the container with the copy of the contents of <code>other</code>, copies the load factor, the predicate, and the hash function as well. If <code>alloc</code> is not provided, allocator is obtained by calling <div class="fragment"><div class="line">std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(<a class="code hl_enumvalue" href="group__xtd__core.html#ggac34b9e6b6738a27b73c2f5ffeaa2ecf2a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>.get_allocator())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a07b758a73f04808f26eee3fa8ce363ef" name="a07b758a73f04808f26eee3fa8ce363ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b758a73f04808f26eee3fa8ce363ef">&#9670;&#160;</a></span>dictionary() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="ab1c24d7c8b5165f2e3814e21c8ad0231" name="ab1c24d7c8b5165f2e3814e21c8ad0231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c24d7c8b5165f2e3814e21c8ad0231">&#9670;&#160;</a></span>dictionary() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="a153be4b6329ddb7d86bfedd03db85ca8" name="a153be4b6329ddb7d86bfedd03db85ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153be4b6329ddb7d86bfedd03db85ca8">&#9670;&#160;</a></span>dictionary() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="a6260ac3aa16033a8c92bbb9a71c7ede0" name="a6260ac3aa16033a8c92bbb9a71c7ede0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6260ac3aa16033a8c92bbb9a71c7ede0">&#9670;&#160;</a></span>dictionary() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a>. Constructs the container with the contents of <code>other</code> using move semantics. If <code>alloc</code> is not provided, allocator is obtained by move-construction from the allocator belonging to other. </dd></dl>

</div>
</div>
<a id="ac54d35d73259f1c4bb63b98779a18d7e" name="ac54d35d73259f1c4bb63b98779a18d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54d35d73259f1c4bb63b98779a18d7e">&#9670;&#160;</a></span>dictionary() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a>&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a>&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
<div class="ttc" id="aclassxtd_1_1collections_1_1generic_1_1dictionary_html_a50b15016f1b91a266a8beec12ab89584"><div class="ttname"><a href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">xtd::collections::generic::dictionary::dictionary</a></div><div class="ttdeci">dictionary() noexcept=default</div><div class="ttdoc">Initializes a new instance of the xtd::collections::generic::dictionary &lt;key_t, value_t&gt; class that i...</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acd1e2bddbc888c451b97e6cd2f760250" name="acd1e2bddbc888c451b97e6cd2f760250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1e2bddbc888c451b97e6cd2f760250">&#9670;&#160;</a></span>dictionary() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0437ef2f75e99d1392ce07f5040f7237" name="a0437ef2f75e99d1392ce07f5040f7237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0437ef2f75e99d1392ce07f5040f7237">&#9670;&#160;</a></span>dictionary() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a94db56e7e5c29681f68d93cfab4e4b4a" name="a94db56e7e5c29681f68d93cfab4e4b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94db56e7e5c29681f68d93cfab4e4b4a">&#9670;&#160;</a></span>dictionary() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename init_key_t , typename init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a>&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a> &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a3117536e7eb45cdf75f69073e37126b8">equator</a>&#160;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Comparison function to use for all key comparisons of this container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8b272479748bbf823035dc716d9dad1d" name="a8b272479748bbf823035dc716d9dad1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b272479748bbf823035dc716d9dad1d">&#9670;&#160;</a></span>dictionary() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename init_key_t , typename init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a814b0e672622c6defc0b5482d9121e47" name="a814b0e672622c6defc0b5482d9121e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814b0e672622c6defc0b5482d9121e47">&#9670;&#160;</a></span>dictionary() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename init_key_t , typename init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::dictionary </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a55a23e2ca9e1ae6169e1e66a617bafad">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes instance of the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; class from a variety of data sources. Optionally uses user supplied <code>bucket_count</code> as a minimal number of buckets to create, <code>hash</code> as the hash function, <code>equal</code> as the function to compare keys and <code>alloc</code> as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>Minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a href="https://en.cppreference.com/w/cpp/language/list_initialization">Initializer-list</a> constructor. Constructs the container with the contents of the initializer list init, same as <div class="fragment"><div class="line"><a class="code hl_function" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a50b15016f1b91a266a8beec12ab89584">dictionary</a>(init.begin(), init.end())</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5fb05a4d36ada3a05639760bbef1866f" name="a5fb05a4d36ada3a05639760bbef1866f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb05a4d36ada3a05639760bbef1866f">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a436d1607f6b62c831e84221b6c196b37">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t &gt;</a>.</p>

</div>
</div>
<a id="ad43461af42f40fafcba6c351b8915909" name="ad43461af42f40fafcba6c351b8915909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43461af42f40fafcba6c351b8915909">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#ac8fbecfad24d9e7a1bc54529c86e2c7f">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t &gt;</a>.</p>

</div>
</div>
<a id="ad51c920c156b8cc6863e143972f5c11b" name="ad51c920c156b8cc6863e143972f5c11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51c920c156b8cc6863e143972f5c11b">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of buckets in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of buckets in the container. </dd></dl>

</div>
</div>
<a id="a24ebcb226f6bc8869c35bf9e1d634ff3" name="a24ebcb226f6bc8869c35bf9e1d634ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ebcb226f6bc8869c35bf9e1d634ff3">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the total numbers of elements the internal data structure can hold without resizing. </p>
<dl class="section return"><dt>Returns</dt><dd>The total numbers of elements the internal data structure can hold without resizing. </dd></dl>

</div>
</div>
<a id="ac375db294d333e09891584e2a0956e1d" name="ac375db294d333e09891584e2a0956e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac375db294d333e09891584e2a0956e1d">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a3244c6835d9103844098ceee00dd929c">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t &gt;</a>.</p>

</div>
</div>
<a id="ad63291ea36f70c7ded93799d6890847e" name="ad63291ea36f70c7ded93799d6890847e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63291ea36f70c7ded93799d6890847e">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a549d04adc2cad4650f5f81273cf94eb1">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t &gt;</a>.</p>

</div>
</div>
<a id="a0f122cc0e5b14e4a6c66414d84c5c990" name="a0f122cc0e5b14e4a6c66414d84c5c990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f122cc0e5b14e4a6c66414d84c5c990">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can store. The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0f122cc0e5b14e4a6c66414d84c5c990" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> property is the number of elements that are actually in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
The capacity is always greater than or equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0f122cc0e5b14e4a6c66414d84c5c990" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a>. If <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0f122cc0e5b14e4a6c66414d84c5c990" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> exceeds the capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

</div>
</div>
<a id="a55611e5c2304788bf7a281fc5b75e1cb" name="a55611e5c2304788bf7a281fc5b75e1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55611e5c2304788bf7a281fc5b75e1cb">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumarable.">begin()</a> == <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">end()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty; otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a84bcbef97b1acb696d8b444988530830" name="a84bcbef97b1acb696d8b444988530830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bcbef97b1acb696d8b444988530830">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a6170ebbcc1ed30723db0d8f695a88477">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t &gt;</a>.</p>

</div>
</div>
<a id="a8e062f26b355616dce3110a815645e7d" name="a8e062f26b355616dce3110a815645e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e062f26b355616dce3110a815645e7d">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the enumarable. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Reimplemented from <a class="el" href="classxtd_1_1collections_1_1generic_1_1extensions_1_1enumerable__iterators.html#a7158d69d20933e2f4216cbbdb82c6591">xtd::collections::generic::extensions::enumerable_iterators&lt; type_t, enumerable_t &gt;</a>.</p>

</div>
</div>
<a id="ac5f9fa62ba008a290c60f795e768d74f" name="ac5f9fa62ba008a290c60f795e768d74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f9fa62ba008a290c60f795e768d74f">&#9670;&#160;</a></span>items() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="aeb58202461ac49407519756acca9ed12" name="aeb58202461ac49407519756acca9ed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb58202461ac49407519756acca9ed12">&#9670;&#160;</a></span>items() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying base type items. </p>
<dl class="section return"><dt>Returns</dt><dd>The underlying base type items. </dd></dl>

</div>
</div>
<a id="ac2a9b4d312798abd41548c6c97ee3312" name="ac2a9b4d312798abd41548c6c97ee3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a9b4d312798abd41548c6c97ee3312">&#9670;&#160;</a></span>keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388">key_collection</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a collection containing the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388" title="Represents the idictionary key collection type.">xtd::collections::generic::dictionary::key_collection</a> containing the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388" title="Represents the idictionary key collection type.">xtd::collections::generic::dictionary::key_collection</a> is unspecified, but it is the same order as the associated values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52" title="Represents the idictionary value collection type.">xtd::collections::generic::dictionary::value_collection</a> returned by the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aa5519d6518ce9849e89b90fd573839f2" title="Gets a collection containing the values in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::values</a> property. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a6784f23fccd9a8021528e645b0d73e22">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="ad12fed9d70080e18e58e5f678ff8fce0" name="ad12fed9d70080e18e58e5f678ff8fce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fed9d70080e18e58e5f678ff8fce0">&#9670;&#160;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the average number of elements per bucket, that is, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a9b8a36cd363866ea458b74960e5d68eb" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::size</a> divided by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Average number of elements per bucket. </dd></dl>

</div>
</div>
<a id="ad9e4c1821576c7fba7fdd4dea0f2c512" name="ad9e4c1821576c7fba7fdd4dea0f2c512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e4c1821576c7fba7fdd4dea0f2c512">&#9670;&#160;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of buckets the container is able to hold due to system or library implementation limitations. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of buckets. </dd></dl>

</div>
</div>
<a id="af4ebdfacb702aad8221aa1b77817cdbd" name="af4ebdfacb702aad8221aa1b77817cdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ebdfacb702aad8221aa1b77817cdbd">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold. </p>
<dl class="section return"><dt>Returns</dt><dd>The current maximum load factor. </dd></dl>

</div>
</div>
<a id="ad7f7acfa0c36a187bd76efe62d87581c" name="ad7f7acfa0c36a187bd76efe62d87581c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f7acfa0c36a187bd76efe62d87581c">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new maximum load factor setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a070747ad0686a9136f66dfc5e3b19aa9" name="a070747ad0686a9136f66dfc5e3b19aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070747ad0686a9136f66dfc5e3b19aa9">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad43461af42f40fafcba6c351b8915909" title="Returns an iterator to the first element of the enumarable.">begin()</a>, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">end()</a>)</code> for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This value typically reflects the theoretical limit on the size of the container, at most <code><a class="el" href="classxtd_1_1box__integer.html#a21847edbb248c1b0d07a35e2a8c08232" title="Represents the largest possible value of type_t. This field is constant.">xtd::ptrdiff_object::max_value</a></code> or <code>std::numeric_limits&lt;difference_type&gt;::max()</code>. At runtime, the size of the container may be limited to a value smaller than <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a070747ad0686a9136f66dfc5e3b19aa9" title="Gets the maximum number of elements the container is able to hold due to system or library implementa...">max_size()</a> by the amount of RAM available. </dd></dl>

</div>
</div>
<a id="a9b8a36cd363866ea458b74960e5d68eb" name="a9b8a36cd363866ea458b74960e5d68eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8a36cd363866ea458b74960e5d68eb">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of key/value pairs contained in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The capacity of a <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is the number of elements that the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; can store. The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0f122cc0e5b14e4a6c66414d84c5c990" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> property is the number of elements that are actually in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd>
<dd>
The capacity is always greater than or equal to <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0f122cc0e5b14e4a6c66414d84c5c990" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a>. If <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a0f122cc0e5b14e4a6c66414d84c5c990" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::count</a> exceeds the capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

</div>
</div>
<a id="aa5519d6518ce9849e89b90fd573839f2" name="aa5519d6518ce9849e89b90fd573839f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5519d6518ce9849e89b90fd573839f2">&#9670;&#160;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52">value_collection</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a collection containing the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52" title="Represents the idictionary value collection type.">xtd::collections::generic::dictionary::value_collection</a> containing the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the values in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a5837e916ed3ecf5ad27d9c1287033f52" title="Represents the idictionary value collection type.">xtd::collections::generic::dictionary::value_collection</a> is unspecified, but it is the same order as the associated keys in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a4b86fcba0283b6ed1cb596b086e7d388" title="Represents the idictionary key collection type.">xtd::collections::generic::dictionary::key_collection</a> returned by the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ac2a9b4d312798abd41548c6c97ee3312" title="Gets a collection containing the keys in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::keys</a> property. </dd>
<dd>
Getting the value of this property is an O(1) operation. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ab9b17f2c004a86dc970ccb5a95e60151">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a8e4b572d70b69d4b688a2835a3258522" name="a8e4b572d70b69d4b688a2835a3258522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4b572d70b69d4b688a2835a3258522">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element with the provided key and value to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The object to use as the key of the element to add. </td></tr>
    <tr><td class="paramname">value</td><td>The object to use as the value of the element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1argument__exception.html" title="The exception that is thrown when one of the arguments provided to a method is not valid.">xtd::argument_exception</a></td><td>An element with the same key already exists in the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>You can also use the <code>operator []</code> to add new elements by setting the value of a key that does not exist in the dictionary; for example, <code>my_collection["my_nonexistent_key"] = my_value</code>. However, if the specified key already exists in the dictionary, setting the <code>operator []</code> overwrites the old value. In contrast, the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method does not modify existing elements. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#ae5306bbad7df56d8b4ce4089b78befdc">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a56664bbd826ba01e34ff35477064db2d" name="a56664bbd826ba01e34ff35477064db2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56664bbd826ba01e34ff35477064db2d">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a></td><td>The property is retrieved and key is not found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32980a15b7ef803c1ba5c8d69f1dbb84" name="a32980a15b7ef803c1ba5c8d69f1dbb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32980a15b7ef803c1ba5c8d69f1dbb84">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a></td><td>The property is retrieved and key is not found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b83cb5cb0fa23c7b4ff7c2c447419aa" name="a3b83cb5cb0fa23c7b4ff7c2c447419aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b83cb5cb0fa23c7b4ff7c2c447419aa">&#9670;&#160;</a></span>bucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The value of the key to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bucket index for the requested key. </dd></dl>

</div>
</div>
<a id="a8ce1e7684c03c73e9980372eceb779a2" name="a8ce1e7684c03c73e9980372eceb779a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce1e7684c03c73e9980372eceb779a2">&#9670;&#160;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af564e40d9fd72f4ad84f8e5ae62f4610">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the bucket with index <code>n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the bucket to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the bucket <code>n</code>. </dd></dl>

</div>
</div>
<a id="ad052549a4ee1f409ef0d343e3379ba10" name="ad052549a4ee1f409ef0d343e3379ba10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad052549a4ee1f409ef0d343e3379ba10">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container. After this call, <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a9b8a36cd363866ea458b74960e5d68eb" title="Gets the number of key/value pairs contained in the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::size</a> returns zero. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Invalidates any references, pointers, and iterators referring to contained elements. May also invalidate past-the-end iterators. </dd></dl>

</div>
</div>
<a id="a62388a5a93af71eb55d9f509420d1acb" name="a62388a5a93af71eb55d9f509420d1acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62388a5a93af71eb55d9f509420d1acb">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">args_t &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to <code>true</code> if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The constructor of the new element (i.e. <code>std::pair&lt;const key_t, value_t&gt;)</code> is called with exactly the same arguments as supplied to emplace, forwarded via <code>std::forward&lt;args_t&gt;(args)....</code> The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately (see xtd::collections::generic::dictionary::try_emplace if this behavior is undesirable). </dd>
<dd>
Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="ae3f30a82dc96ded7a4145c3d0533e3a7" name="ae3f30a82dc96ded7a4145c3d0533e3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f30a82dc96ded7a4145c3d0533e3a7">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad1d7f951247c504df41d30e51f987394">allocator_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="ab937a31d8ae4cb896ab25baf67330225" name="ab937a31d8ae4cb896ab25baf67330225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab937a31d8ae4cb896ab25baf67330225">&#9670;&#160;</a></span>get_enumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1enumerator.html">enumerator</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::get_enumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerator that iterates through the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="group__collections.html#ga46ca5358d7207b976828dddad86adcf8" title="Supports a simple iteration over a non-generic collection.">xtd::collections::enumerator</a> structure for the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt;. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1ienumerable.html#aaa7f31bc15aecee93e381b36c71c3058">xtd::collections::generic::ienumerable&lt; xtd::collections::generic::key_value_pair&lt; key_t, value_t &gt; &gt;</a>.</p>

</div>
</div>
<a id="a2536af020316364a5f3e053dbc02feb7" name="a2536af020316364a5f3e053dbc02feb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2536af020316364a5f3e053dbc02feb7">&#9670;&#160;</a></span>insert() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to true if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a4bbab4055f21c2b4f292408e2fe681e8" name="a4bbab4055f21c2b4f292408e2fe681e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbab4055f21c2b4f292408e2fe681e8">&#9670;&#160;</a></span>insert() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to true if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a18ad0f3139526c64cf06412b65feae9e" name="a18ad0f3139526c64cf06412b65feae9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ad0f3139526c64cf06412b65feae9e">&#9670;&#160;</a></span>insert() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool value set to true if and only if the insertion took place. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>. </dd>
<dd>
Is equivalent to <code>emplace(std::forward&lt;P&gt;(value))</code> and only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value == true</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a380d38c18d0aa2a9d14309adfc143b53" name="a380d38c18d0aa2a9d14309adfc143b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380d38c18d0aa2a9d14309adfc143b53">&#9670;&#160;</a></span>insert() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a18df0c230fef405f5748b1bc0e499128" name="a18df0c230fef405f5748b1bc0e499128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18df0c230fef405f5748b1bc0e499128">&#9670;&#160;</a></span>insert() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a1f951179b33766491339c34e62fcc98f">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a7128e65ca299ec54ac3141117d0a6215" name="a7128e65ca299ec54ac3141117d0a6215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7128e65ca299ec54ac3141117d0a6215">&#9670;&#160;</a></span>insert() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">value</td><td>The element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start. </dd>
<dd>
Is equivalent to <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code> and only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value == true</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a85007cea09c65235fd258adcc3a5a28d" name="a85007cea09c65235fd258adcc3a5a28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85007cea09c65235fd258adcc3a5a28d">&#9670;&#160;</a></span>insert() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename input_iterator_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_iterator_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first iterator of the range of elements to insert. </td></tr>
    <tr><td class="paramname">last</td><td>The last iterator of the range of elements to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from range [<code>first</code>, <code>last</code>). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>). </dd>
<dd>
If [<code>first</code>, <code>last</code>) is not a valid range, or <code>first</code> and/or <code>last</code> are iterators into <code>*this</code>, the behavior is undefined. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a2f13f08d0a8068edeec540cd55b2656e" name="a2f13f08d0a8068edeec540cd55b2656e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f13f08d0a8068edeec540cd55b2656e">&#9670;&#160;</a></span>insert() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to insert the values from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>). </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="ab03539711e3e6f86380a893e725b95d3" name="ab03539711e3e6f86380a893e725b95d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03539711e3e6f86380a893e725b95d3">&#9670;&#160;</a></span>insert() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename init_key_t , typename init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to insert the values from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>). </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a1fe7e8e7ea1b539e1b77cb2e67f3d56b" name="a1fe7e8e7ea1b539e1b77cb2e67f3d56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe7e8e7ea1b539e1b77cb2e67f3d56b">&#9670;&#160;</a></span>insert() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7e88bf6f5031a8e127a56adb37ec848d">insert_return_type</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>nh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nh</td><td>A compatible <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object of <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7e88bf6f5031a8e127a56adb37ec848d" title="Represents the dictionary insert return type.">xtd::collections::generic::dictionary::insert_return_type</a> with the members initialized as follows:<ul>
<li>If <code>nh</code> is empty, inserted is <code>false</code>, position is <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e062f26b355616dce3110a815645e7d" title="Returns an iterator to the element following the last element of the enumarable.">xtd::collections::generic::dictionary::end()</a>, and node is empty.</li>
<li>Otherwise if the insertion took place, inserted is <code>true</code>, position points to the inserted element, and node is empty.</li>
<li>If the insertion failed, inserted is <code>false</code>, node has the previous value of <code>nh</code>, and position points to an element with a key equivalent to <code>nh.key()</code>. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>nh</code> is an empty <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>, does nothing. Otherwise, inserts the element owned by nh into the container , if the container doesn't already contain an element with a key equivalent to <code>nh.key()</code>. The behavior is undefined if <code>nh</code> is not empty and <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != nh.get_allocator()</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd></dl>

</div>
</div>
<a id="a5c488877537c9281e341e04cc2836c4b" name="a5c488877537c9281e341e04cc2836c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c488877537c9281e341e04cc2836c4b">&#9670;&#160;</a></span>insert() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a09ebfcd509b5c4d473ec9ab61bed6e85">node_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>nh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator, used as a suggestion as to where to insert the content. </td></tr>
    <tr><td class="paramname">nh</td><td>A compatible <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator if <code>nh</code> was empty, iterator pointing to the inserted element if insertion took place, and iterator pointing to an element with a key equivalent to <code>nh.key()</code> if it failed. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>nh</code> is an empty <a href="https://en.cppreference.com/w/cpp/container/node_handle">node handle</a>, does nothing and returns the end iterator. Otherwise, inserts the element owned by nh into the container, if the container doesn't already contain an element with a key equivalent to <code>nh.key()</code>, and returns the iterator pointing to the element with key equivalent to <code>nh.key()</code>(regardless of whether the insert succeeded or failed). If the insertion succeeds, <code>nh</code> is moved from, otherwise it retains ownership of the element. <code>hint</code> is used as a non-binding suggestion to where the search should start. The behavior is undefined if <code>nh</code> is not empty and <code><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ae3f30a82dc96ded7a4145c3d0533e3a7" title="Returns the allocator associated with the container.">get_allocator()</a> != nh.get_allocator()</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="ad9003b85acdd5f58ba98601126fb7e5e" name="ad9003b85acdd5f58ba98601126fb7e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9003b85acdd5f58ba98601126fb7e5e">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code>value_type(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="acc83f5a5d14fd0c9c164a3bffcffe128" name="acc83f5a5d14fd0c9c164a3bffcffe128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc83f5a5d14fd0c9c164a3bffcffe128">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a>, bool &gt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">key_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code>value_type(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="addddd73ed7023f733638e9fda6246ed4" name="addddd73ed7023f733638e9fda6246ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addddd73ed7023f733638e9fda6246ed4">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code>value_type(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a286f0cc1a6f5f3ea0e07728043b80038" name="a286f0cc1a6f5f3ea0e07728043b80038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286f0cc1a6f5f3ea0e07728043b80038">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename type_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#aec072eea57e68e1c6fad6aaee1a5a22e">iterator</a> <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a7cadb73d74ba5ee36bafe1bc66810cb0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element or assigns to the current element if the key already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>The iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramname">k</td><td>The key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">obj</td><td>The value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a key equivalent to <code>k</code> already exists in the container, assigns <code>std::forward&lt;type_t&gt;(obj)</code> to the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ab62f8fa8a47c2a7f0f4371ec0483086d" title="Represents the dictionary mapped type.">xtd::collections::generic::dictionary::mapped_type</a> corresponding to the key <code>k</code>. If the key does not exist, inserts the new value as if by <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a2536af020316364a5f3e053dbc02feb7" title="Inserts element(s) into the container, if the container doesn&#39;t already contain an element with an eq...">xtd::collections::generic::dictionary::insert</a>, constructing it from <code>value_type(k, std::forward&lt;type_t&gt;(obj))</code>. </dd>
<dd>
If after the operation the new number of elements is greater than old <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#af4ebdfacb702aad8221aa1b77817cdbd" title="Gets the maximum load factor (number of elements per bucket). The container automatically increases t...">xtd::collections::generic::dictionary::max_load_factor</a> * <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#ad51c920c156b8cc6863e143972f5c11b" title="Gets the number of buckets in the container.">xtd::collections::generic::dictionary::bucket_count</a> a rehashing takes place. </dd>
<dd>
If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. </dd></dl>

</div>
</div>
<a id="a82c683da2de29870afa991f4445dac29" name="a82c683da2de29870afa991f4445dac29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c683da2de29870afa991f4445dac29">&#9670;&#160;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a34f2116e984d8e567f334c97e84f4bc8" name="a34f2116e984d8e567f334c97e84f4bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f2116e984d8e567f334c97e84f4bc8">&#9670;&#160;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; key_t, value_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa8af37e930bc671470277333004815c6" name="aa8af37e930bc671470277333004815c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8af37e930bc671470277333004815c6">&#9670;&#160;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="aa93aa4cf42b1c7c83d3b01dafe6deac1" name="aa93aa4cf42b1c7c83d3b01dafe6deac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93aa4cf42b1c7c83d3b01dafe6deac1">&#9670;&#160;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; key_t, value_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a14ceb0d680fe9a5d5d6c2f02e4bdcd60" name="a14ceb0d680fe9a5d5d6c2f02e4bdcd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ceb0d680fe9a5d5d6c2f02e4bdcd60">&#9670;&#160;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a6a69009b6f6be690dbfa2591d29b28c4">base_value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a14d7bdef948dda8ae4029da1ea3b398a" name="a14d7bdef948dda8ae4029da1ea3b398a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d7bdef948dda8ae4029da1ea3b398a">&#9670;&#160;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename init_key_t , typename init_value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">dictionary</a> &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structxtd_1_1collections_1_1generic_1_1key__value__pair.html">key_value_pair</a>&lt; init_key_t, init_value_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list to use as data source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This current instance. </dd></dl>

</div>
</div>
<a id="a0e8d5edb392d4da50dfa18ff778b9aec" name="a0e8d5edb392d4da50dfa18ff778b9aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8d5edb392d4da50dfa18ff778b9aec">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1key__not__found__exception.html" title="The exception that is thrown when the key specified for accessing an element in a collection does not...">xtd::collections::generic::key_not_found_exception</a></td><td>The property is retrieved and key is not found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property provides the ability to access a specific element in the collection by using the following syntax: <code>my_collection[key]</code>. </dd>
<dd>
You can also use the <code>operator []</code> to add new elements by setting the value of a key that does not exist in the dictionary; for example, <code>my_collection["my_nonexistent_key"] = my_value</code>. However, if the specified key already exists in the dictionary, setting the <code>operator []</code> overwrites the old value. In contrast, the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method does not modify existing elements. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#abbd9d09bab50fce4e72deaa00985e3b2">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a03bf80a6988e9d62a6e57df4f12e00c2" name="a03bf80a6988e9d62a6e57df4f12e00c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bf80a6988e9d62a6e57df4f12e00c2">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t &amp; <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the element with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element with the specified key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1not__supported__exception.html" title="The exception that is thrown when an invoked method is not supported, or when there is an attempt to ...">xtd::not_supported_exception</a></td><td>The property is set and the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html" title="Represents a collection of keys and values.">xtd::collections::generic::dictionary</a> &lt;key_t, value_t&gt; is read-only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This property provides the ability to access a specific element in the collection by using the following syntax: <code>my_collection[key]</code>. </dd>
<dd>
You can also use the <code>operator []</code> to add new elements by setting the value of a key that does not exist in the dictionary; for example, <code>my_collection["my_nonexistent_key"] = my_value</code>. However, if the specified key already exists in the dictionary, setting the <code>operator []</code> overwrites the old value. In contrast, the <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a8e4b572d70b69d4b688a2835a3258522" title="Adds an element with the provided key and value to the xtd::collections::generic::dictionary &lt;key_t,...">xtd::collections::generic::dictionary::add</a> method does not modify existing elements. </dd></dl>

<p>Implements <a class="el" href="classxtd_1_1collections_1_1generic_1_1idictionary.html#a1428322c2f912bd597f667bd1aec0bdc">xtd::collections::generic::idictionary&lt; key_t, value_t &gt;</a>.</p>

</div>
</div>
<a id="a04b0f390c2eef3a3bc08a06c74134c7b" name="a04b0f390c2eef3a3bc08a06c74134c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b0f390c2eef3a3bc08a06c74134c7b">&#9670;&#160;</a></span>operator const base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator const <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<a id="a2128516be272bac5e5a5561d1ad55eff" name="a2128516be272bac5e5a5561d1ad55eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2128516be272bac5e5a5561d1ad55eff">&#9670;&#160;</a></span>operator base_type &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t , typename value_t , typename hasher_t  = xtd::collections::generic::helpers::hasher&lt;key_t&gt;, typename equator_t  = xtd::collections::generic::helpers::equator&lt;key_t&gt;, typename allocator_t  = xtd::collections::generic::helpers::allocator&lt;std::pair&lt;const key_t, value_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html">xtd::collections::generic::dictionary</a>&lt; key_t, value_t, hasher_t, equator_t, allocator_t &gt;::operator <a class="el" href="classxtd_1_1collections_1_1generic_1_1dictionary.html#a48eda53efea9ddfea79ad6f47b9f1eb8">base_type</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying base type. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying base type. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/collections/generic/<a class="el" href="dictionary_8hpp_source.html">dictionary.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 10 2025 14:45:20 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
