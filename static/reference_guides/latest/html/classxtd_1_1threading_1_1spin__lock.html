<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>xtd: xtd::threading::spin_lock Class Reference</title>
    <link href="favicon.png" rel="shortcut icon" type="image/png"/>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom_images.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
	</head>
	<body>
  <div id="page_container">
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%;">
				<tbody>
					<tr>
						<td id="projectlogo">
						  <a href="https://gammasoft71.github.io/xtd/" target="_new">
						    <img alt="Logo" src="xtd_doxygen.png"/>
						  </a>
						</td>
						<td id="projectalign" style="padding-left: 0.5em; text-align: right;">
							<div id="projectname">xtd
								<span id="projectnumber">0.2.0</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacextd.html">xtd</a></li><li class="navelem"><a class="el" href="namespacextd_1_1threading.html">threading</a></li><li class="navelem"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html">spin_lock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classxtd_1_1threading_1_1spin__lock-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xtd::threading::spin_lock Class Reference<div class="ingroups"><a class="el" href="group__libraries.html">ï¹¡ libraries</a> &raquo; <a class="el" href="group__xtd__core.html">xtd.core</a> &#124; <a class="el" href="group__system.html">system</a> &raquo; <a class="el" href="group__threading.html">threading</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for xtd::threading::spin_lock:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxtd_1_1threading_1_1spin__lock.png" usemap="#xtd::threading::spin_5Flock_map" alt=""/>
  <map id="xtd::threading::spin_5Flock_map" name="xtd::threading::spin_5Flock_map">
<area href="classxtd_1_1object.html" title="Supports all classes in the xtd class hierarchy and provides low-level services to derived classes...." alt="xtd::object" shape="rect" coords="0,0,146,24"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><p>Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classxtd_1_1threading_1_1spin__lock.html">spin_lock</a> : <span class="keyword">public</span> <a class="code hl_class" href="classxtd_1_1object.html">xtd::object</a></div>
<div class="ttc" id="aclassxtd_1_1object_html"><div class="ttname"><a href="classxtd_1_1object.html">xtd::object</a></div><div class="ttdoc">Supports all classes in the xtd class hierarchy and provides low-level services to derived classes....</div><div class="ttdef"><b>Definition</b> object.hpp:44</div></div>
<div class="ttc" id="aclassxtd_1_1threading_1_1spin__lock_html"><div class="ttname"><a href="classxtd_1_1threading_1_1spin__lock.html">xtd::threading::spin_lock</a></div><div class="ttdoc">Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...</div><div class="ttdef"><b>Definition</b> spin_lock.hpp:36</div></div>
</div><!-- fragment --> <dl class="section user"><dt>Header</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;xtd/threading/spin_lock&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Namespace</dt><dd><a class="el" href="namespacextd_1_1threading.html" title="The xtd::threading namespace provides classes and interfaces that enable multithreaded programming....">xtd::threading</a> </dd></dl>
<dl class="section user"><dt>Library</dt><dd>xtd.core</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example shows how to use a <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a>: <div class="fragment"></div><!-- fragment --> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Spin locks can be used for leaf-level locks where the object allocation implied by using a <a class="el" href="classxtd_1_1threading_1_1monitor.html" title="Provides a mechanism that synchronizes access to objects.">xtd::threading::monitor</a>, in size, is overly expensive. A spin lock can be useful to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning. Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short. In general, while holding a spin lock, one should avoid any of these actions:<ul>
<li>blocking,</li>
<li>calling anything that itself may block,</li>
<li>holding more than one spin lock at once,</li>
<li>making dynamically dispatched calls (interface and virtuals),</li>
<li>making statically dispatched calls into any code one doesn't own, or</li>
<li>allocating memory. </li>
</ul>
</dd>
<dd>
<a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> should only be used after you have been determined that doing so will improve an application's performance. It is also important to note that <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> is a value type, for performance reasons. For this reason, you must be very careful not to accidentally copy a <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application. If a <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> instance must be passed around, it should be passed by reference rather than by value. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Constructors</h2></td></tr>
<tr class="memitem:a58fa5007bcd2bf8644d8dc8ce9b30823"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a58fa5007bcd2bf8644d8dc8ce9b30823">spin_lock</a> ()</td></tr>
<tr class="memdesc:a58fa5007bcd2bf8644d8dc8ce9b30823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> structure.  <br /></td></tr>
<tr class="separator:a58fa5007bcd2bf8644d8dc8ce9b30823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1564fffb6c9f3ee5ea802e7c8a689323"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a1564fffb6c9f3ee5ea802e7c8a689323">spin_lock</a> (bool enable_thread_owner_tracking)</td></tr>
<tr class="memdesc:a1564fffb6c9f3ee5ea802e7c8a689323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> structure with the option to track thread IDs to improve debugging.  <br /></td></tr>
<tr class="separator:a1564fffb6c9f3ee5ea802e7c8a689323"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Properties</h2></td></tr>
<tr class="memitem:acdc54498e82b31d71af62424ffbc2cb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#acdc54498e82b31d71af62424ffbc2cb8">is_held</a> () const noexcept</td></tr>
<tr class="memdesc:acdc54498e82b31d71af62424ffbc2cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the lock is currently held by any thread.  <br /></td></tr>
<tr class="separator:acdc54498e82b31d71af62424ffbc2cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fa245a6e054558dd7d4272602c93d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a92fa245a6e054558dd7d4272602c93d0">is_held_by_current_thread</a> () const noexcept</td></tr>
<tr class="memdesc:a92fa245a6e054558dd7d4272602c93d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the lock is held by the current thread.  <br /></td></tr>
<tr class="separator:a92fa245a6e054558dd7d4272602c93d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531972816dbf8084244030140a9db621"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a531972816dbf8084244030140a9db621">is_thread_owner_tracking_enabled</a> () const noexcept</td></tr>
<tr class="memdesc:a531972816dbf8084244030140a9db621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether thread ownership tracking is enabled for this instance.  <br /></td></tr>
<tr class="separator:a531972816dbf8084244030140a9db621"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Methods</h2></td></tr>
<tr class="memitem:a24e13fcd4189869a3d23e187b42c792a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a">enter</a> (bool &amp;lock_taken)</td></tr>
<tr class="memdesc:a24e13fcd4189869a3d23e187b42c792a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired.  <br /></td></tr>
<tr class="separator:a24e13fcd4189869a3d23e187b42c792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ee56319b6e02c8c404321d04f6347e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a61ee56319b6e02c8c404321d04f6347e">exit</a> ()</td></tr>
<tr class="memdesc:a61ee56319b6e02c8c404321d04f6347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock.  <br /></td></tr>
<tr class="separator:a61ee56319b6e02c8c404321d04f6347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b66f6109eea3da0fe54e44886419782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a1b66f6109eea3da0fe54e44886419782">exit</a> (bool use_memory_barrier)</td></tr>
<tr class="memdesc:a1b66f6109eea3da0fe54e44886419782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock.  <br /></td></tr>
<tr class="separator:a1b66f6109eea3da0fe54e44886419782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e1ebdce78eacbba641ca8cb0d36ada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada">try_enter</a> (bool &amp;lock_taken)</td></tr>
<tr class="memdesc:a18e1ebdce78eacbba641ca8cb0d36ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired.  <br /></td></tr>
<tr class="separator:a18e1ebdce78eacbba641ca8cb0d36ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef47de7e0dec014b37778a0a6558433d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#aef47de7e0dec014b37778a0a6558433d">try_enter</a> (<a class="el" href="group__types.html#ga4d9a4a89e8f5fb16669589e26d866e09">int32</a> milliseconds_timeout, bool &amp;lock_taken)</td></tr>
<tr class="memdesc:aef47de7e0dec014b37778a0a6558433d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired.  <br /></td></tr>
<tr class="separator:aef47de7e0dec014b37778a0a6558433d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80299f8d1b5945954a087b17c3213e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1threading_1_1spin__lock.html#ac80299f8d1b5945954a087b17c3213e6">try_enter</a> (const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;<a class="el" href="classxtd_1_1threading_1_1timeout.html">timeout</a>, bool &amp;lock_taken)</td></tr>
<tr class="memdesc:ac80299f8d1b5945954a087b17c3213e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired.  <br /></td></tr>
<tr class="separator:ac80299f8d1b5945954a087b17c3213e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ad2cab851376bb6ca085b567bf5da0f5f">object</a> ()=default</td></tr>
<tr class="memdesc:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the ultimate base class object.  <br /></td></tr>
<tr class="separator:ad2cab851376bb6ca085b567bf5da0f5f inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a2743b6f75405882c28eebe2456f3837b">equals</a> (const <a class="el" href="classxtd_1_1object.html">object</a> &amp;obj) const noexcept</td></tr>
<tr class="memdesc:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object is equal to the current object.  <br /></td></tr>
<tr class="separator:a2743b6f75405882c28eebe2456f3837b inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd11aa88ce86568b701b33fd1b3e508 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__types.html#ga92c4f59ae39104d31ce9c0c20810001d">xtd::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a6bd11aa88ce86568b701b33fd1b3e508">get_hash_code</a> () const noexcept</td></tr>
<tr class="memdesc:a6bd11aa88ce86568b701b33fd1b3e508 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serves as a hash function for a particular type.  <br /></td></tr>
<tr class="separator:a6bd11aa88ce86568b701b33fd1b3e508 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classxtd_1_1type__object.html">type_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a322144840e8ad539c039538997b0fe40">get_type</a> () const noexcept</td></tr>
<tr class="memdesc:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the current instance.  <br /></td></tr>
<tr class="separator:a322144840e8ad539c039538997b0fe40 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35 inherit pub_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_t &gt; </td></tr>
<tr class="memitem:ac24dbacb9a6e23a1ebd63ad403141a35 inherit pub_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">xtd::unique_ptr_object&lt; object_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#ac24dbacb9a6e23a1ebd63ad403141a35">memberwise_clone</a> () const</td></tr>
<tr class="memdesc:ac24dbacb9a6e23a1ebd63ad403141a35 inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of the current object.  <br /></td></tr>
<tr class="separator:ac24dbacb9a6e23a1ebd63ad403141a35 inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d19ef177db62351b58a42f22138dbe inherit pub_methods_classxtd_1_1object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__strings.html#gacd1daef0757a14b1f957e10b32644f91">xtd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#af2d19ef177db62351b58a42f22138dbe">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:af2d19ef177db62351b58a42f22138dbe inherit pub_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="group__strings.html#gacd1daef0757a14b1f957e10b32644f91" title="Represents text as a sequence of UTF-8 code units.">xtd::string</a> that represents the current object.  <br /></td></tr>
<tr class="separator:af2d19ef177db62351b58a42f22138dbe inherit pub_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxtd_1_1object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxtd_1_1object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxtd_1_1object.html">xtd::object</a></td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t &gt; </td></tr>
<tr class="memitem:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a7fa6fd860800fb1dd1caac338e2355e6">equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are considered equal.  <br /></td></tr>
<tr class="separator:a7fa6fd860800fb1dd1caac338e2355e6 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplParams" colspan="2">template&lt;class object_a_t , class object_b_t &gt; </td></tr>
<tr class="memitem:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxtd_1_1object.html#a772d50f4da23b418b7e3a523f52564b5">reference_equals</a> (const object_a_t &amp;object_a, const object_b_t &amp;object_b) noexcept</td></tr>
<tr class="memdesc:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified object instances are the same instance.  <br /></td></tr>
<tr class="separator:a772d50f4da23b418b7e3a523f52564b5 inherit pub_static_methods_classxtd_1_1object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a58fa5007bcd2bf8644d8dc8ce9b30823" name="a58fa5007bcd2bf8644d8dc8ce9b30823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fa5007bcd2bf8644d8dc8ce9b30823">&#9670;&#160;</a></span>spin_lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::spin_lock::spin_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> structure. </p>

</div>
</div>
<a id="a1564fffb6c9f3ee5ea802e7c8a689323" name="a1564fffb6c9f3ee5ea802e7c8a689323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1564fffb6c9f3ee5ea802e7c8a689323">&#9670;&#160;</a></span>spin_lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xtd::threading::spin_lock::spin_lock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_thread_owner_tracking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> structure with the option to track thread IDs to improve debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_thread_owner_tracking</td><td>Whether to capture and use thread IDs for debugging purposes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The parameterless constructor for <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> tracks thread ownership. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acdc54498e82b31d71af62424ffbc2cb8" name="acdc54498e82b31d71af62424ffbc2cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc54498e82b31d71af62424ffbc2cb8">&#9670;&#160;</a></span>is_held()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::spin_lock::is_held </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the lock is currently held by any thread. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock is currently held by any thread; otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a92fa245a6e054558dd7d4272602c93d0" name="a92fa245a6e054558dd7d4272602c93d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fa245a6e054558dd7d4272602c93d0">&#9670;&#160;</a></span>is_held_by_current_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::spin_lock::is_held_by_current_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the lock is held by the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock is held by the current thread; otherwise <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread. It is invalid to use this property when the lock was initialized to not track thread ownership. </dd></dl>

</div>
</div>
<a id="a531972816dbf8084244030140a9db621" name="a531972816dbf8084244030140a9db621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531972816dbf8084244030140a9db621">&#9670;&#160;</a></span>is_thread_owner_tracking_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xtd::threading::spin_lock::is_thread_owner_tracking_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether thread ownership tracking is enabled for this instance. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if thread ownership tracking is enabled for this instance; otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a24e13fcd4189869a3d23e187b42c792a" name="a24e13fcd4189869a3d23e187b42c792a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e13fcd4189869a3d23e187b42c792a">&#9670;&#160;</a></span>enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::enter </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_taken</td><td>True if the lock is acquired; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1lock__recursion__exception.html" title="The exception that is thrown when recursive entry into a lock is not compatible with the recursion po...">xtd::threading::lock_recursion_exception</a></td><td>Thread ownership tracking is enabled, and the current thread has already acquired this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's enabled is available through <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a531972816dbf8084244030140a9db621" title="Gets whether thread ownership tracking is enabled for this instance.">xtd::threading::spin_lock::is_thread_owner_tracking_enabled</a>), an exception will be thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock. </dd></dl>

</div>
</div>
<a id="a61ee56319b6e02c8c404321d04f6347e" name="a61ee56319b6e02c8c404321d04f6347e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ee56319b6e02c8c404321d04f6347e">&#9670;&#160;</a></span>exit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td>Thread ownership tracking is enabled, and the current thread is not the owner of this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The default overload of Exit provides the same behavior as if calling Exit using <code>true</code> as the argument. </dd>
<dd>
If you call <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a61ee56319b6e02c8c404321d04f6347e" title="Releases the lock.">xtd::threading::spin_lock::exit</a> without having first called <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a> the internal state of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> can become corrupted. </dd></dl>

</div>
</div>
<a id="a1b66f6109eea3da0fe54e44886419782" name="a1b66f6109eea3da0fe54e44886419782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b66f6109eea3da0fe54e44886419782">&#9670;&#160;</a></span>exit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::exit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_memory_barrier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_memory_barrier</td><td>A bool value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1synchronization__lock__exception.html" title="The exception that is thrown when a method requires the caller to own the lock on a given Monitor,...">xtd::threading::synchronization_lock_exception</a></td><td>Thread ownership tracking is enabled, and the current thread is not the owner of this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Calling Exit with the use_memory_barrier argument set to <code>true</code> will improve the fairness of the lock at the expense of some performance. The default <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a61ee56319b6e02c8c404321d04f6347e" title="Releases the lock.">xtd::threading::spin_lock::exit</a> overload behaves as if specifying <code>true</code> for use_memory_barrier. </dd>
<dd>
If you call <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a61ee56319b6e02c8c404321d04f6347e" title="Releases the lock.">xtd::threading::spin_lock::exit</a> without having first called <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a> the internal state of the <a class="el" href="classxtd_1_1threading_1_1spin__lock.html" title="Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop ...">xtd::threading::spin_lock</a> can become corrupted. </dd></dl>

</div>
</div>
<a id="a18e1ebdce78eacbba641ca8cb0d36ada" name="a18e1ebdce78eacbba641ca8cb0d36ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e1ebdce78eacbba641ca8cb0d36ada">&#9670;&#160;</a></span>try_enter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::try_enter </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_taken</td><td>True if the lock is acquired; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1lock__recursion__exception.html" title="The exception that is thrown when recursive entry into a lock is not compatible with the recursion po...">xtd::threading::lock_recursion_exception</a></td><td>Thread ownership tracking is enabled, and the current thread has already acquired this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a>, <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada" title="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the m...">xtd::threading::spin_lock::try_enter</a> will not block waiting for the lock to be available. If the lock is not available when <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada" title="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the m...">xtd::threading::spin_lock::try_enter</a> is called, it will return immediately without any further spinning. </dd></dl>

</div>
</div>
<a id="aef47de7e0dec014b37778a0a6558433d" name="aef47de7e0dec014b37778a0a6558433d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef47de7e0dec014b37778a0a6558433d">&#9670;&#160;</a></span>try_enter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::try_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga4d9a4a89e8f5fb16669589e26d866e09">int32</a>&#160;</td>
          <td class="paramname"><em>milliseconds_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds_timeout</td><td>The number of milliseconds to wait, or <a class="el" href="classxtd_1_1threading_1_1timeout.html#af4059e4ae0d201f7382742e6a7dfd1b2" title="A constant used to specify an infinite waiting period. This field is constant.">xtd::threading::timeout::infinite</a> (-1) to wait indefinitely. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>True if the lock is acquired; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1lock__recursion__exception.html" title="The exception that is thrown when recursive entry into a lock is not compatible with the recursion po...">xtd::threading::lock_recursion_exception</a></td><td>Thread ownership tracking is enabled, and the current thread has already acquired this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a>, <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada" title="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the m...">xtd::threading::spin_lock::try_enter</a> will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the milliseconds_timeout has expired. </dd></dl>

</div>
</div>
<a id="ac80299f8d1b5945954a087b17c3213e6" name="ac80299f8d1b5945954a087b17c3213e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80299f8d1b5945954a087b17c3213e6">&#9670;&#160;</a></span>try_enter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xtd::threading::spin_lock::try_enter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxtd_1_1time__span.html">time_span</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lock_taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, lock_taken can be examined reliably to determine whether the lock was acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>A <a class="el" href="classxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> that represents the number of milliseconds to wait, or a <a class="el" href="classxtd_1_1time__span.html" title="Represents a time interval.">xtd::time_span</a> that represents -1 milliseconds to wait indefinitely. </td></tr>
    <tr><td class="paramname">lock_taken</td><td>True if the lock is acquired; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxtd_1_1threading_1_1lock__recursion__exception.html" title="The exception that is thrown when recursive entry into a lock is not compatible with the recursion po...">xtd::threading::lock_recursion_exception</a></td><td>Thread ownership tracking is enabled, and the current thread has already acquired this lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a24e13fcd4189869a3d23e187b42c792a" title="Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,...">xtd::threading::spin_lock::enter</a>, <a class="el" href="classxtd_1_1threading_1_1spin__lock.html#a18e1ebdce78eacbba641ca8cb0d36ada" title="Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the m...">xtd::threading::spin_lock::try_enter</a> will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the timeout has expired. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xtd.core/include/xtd/threading/<a class="el" href="spin__lock_8hpp_source.html">spin_lock.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 6 2025 18:11:23 for xtd by <a href="https://gammasoft71.wixsite.com/gammasoft">Gammasoft</a>. All rights reserved.
</small></address>
</body>
</html>
